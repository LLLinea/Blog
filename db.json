{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/yelee/source/js/pc.js","path":"js/pc.js","modified":1},{"_id":"themes/yelee/source/js/mobile.js","path":"js/mobile.js","modified":1},{"_id":"themes/yelee/source/js/main.js","path":"js/main.js","modified":1},{"_id":"themes/yelee/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":1},{"_id":"themes/yelee/source/js/instagram.js","path":"js/instagram.js","modified":1},{"_id":"themes/yelee/source/js/clipboard.min.js","path":"js/clipboard.min.js","modified":1},{"_id":"themes/yelee/source/js/GithubRepoWidget.js","path":"js/GithubRepoWidget.js","modified":1},{"_id":"themes/yelee/source/img/豆瓣.png","path":"img/豆瓣.png","modified":1},{"_id":"themes/yelee/source/img/虾米音乐.png","path":"img/虾米音乐.png","modified":1},{"_id":"themes/yelee/source/img/网易云音乐.png","path":"img/网易云音乐.png","modified":1},{"_id":"themes/yelee/source/img/简书.png","path":"img/简书.png","modified":1},{"_id":"themes/yelee/source/img/知乎.png","path":"img/知乎.png","modified":1},{"_id":"themes/yelee/source/img/新浪微博.png","path":"img/新浪微博.png","modified":1},{"_id":"themes/yelee/source/img/twitter.png","path":"img/twitter.png","modified":1},{"_id":"themes/yelee/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":1},{"_id":"themes/yelee/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1},{"_id":"themes/yelee/source/img/rss.png","path":"img/rss.png","modified":1},{"_id":"themes/yelee/source/img/pinterest.png","path":"img/pinterest.png","modified":1},{"_id":"themes/yelee/source/img/pinboard.png","path":"img/pinboard.png","modified":1},{"_id":"themes/yelee/source/img/mail.png","path":"img/mail.png","modified":1},{"_id":"themes/yelee/source/img/linkedin.png","path":"img/linkedin.png","modified":1},{"_id":"themes/yelee/source/img/img-loading.png","path":"img/img-loading.png","modified":1},{"_id":"themes/yelee/source/img/img-err.png","path":"img/img-err.png","modified":1},{"_id":"themes/yelee/source/img/google.png","path":"img/google.png","modified":1},{"_id":"themes/yelee/source/img/favicon.png","path":"img/favicon.png","modified":1},{"_id":"themes/yelee/source/img/facebook.png","path":"img/facebook.png","modified":1},{"_id":"themes/yelee/source/img/delicious.png","path":"img/delicious.png","modified":1},{"_id":"themes/yelee/source/img/coderwall.png","path":"img/coderwall.png","modified":1},{"_id":"themes/yelee/source/img/avatar.png","path":"img/avatar.png","modified":1},{"_id":"themes/yelee/source/img/V2EX.png","path":"img/V2EX.png","modified":1},{"_id":"themes/yelee/source/img/TiddlyWiki.png","path":"img/TiddlyWiki.png","modified":1},{"_id":"themes/yelee/source/img/SegmentFault.png","path":"img/SegmentFault.png","modified":1},{"_id":"themes/yelee/source/img/GitHub.png","path":"img/GitHub.png","modified":1},{"_id":"themes/yelee/source/font-awesome/fonts/fontawesome-webfont.woff2","path":"font-awesome/fonts/fontawesome-webfont.woff2","modified":1},{"_id":"themes/yelee/source/font-awesome/fonts/fontawesome-webfont.woff","path":"font-awesome/fonts/fontawesome-webfont.woff","modified":1},{"_id":"themes/yelee/source/font-awesome/fonts/fontawesome-webfont.ttf","path":"font-awesome/fonts/fontawesome-webfont.ttf","modified":1},{"_id":"themes/yelee/source/font-awesome/fonts/fontawesome-webfont.svg","path":"font-awesome/fonts/fontawesome-webfont.svg","modified":1},{"_id":"themes/yelee/source/font-awesome/fonts/fontawesome-webfont.eot","path":"font-awesome/fonts/fontawesome-webfont.eot","modified":1},{"_id":"themes/yelee/source/font-awesome/fonts/FontAwesome.otf","path":"font-awesome/fonts/FontAwesome.otf","modified":1},{"_id":"themes/yelee/source/font-awesome/css/font-awesome.min.css","path":"font-awesome/css/font-awesome.min.css","modified":1},{"_id":"themes/yelee/source/font-awesome/css/font-awesome.css","path":"font-awesome/css/font-awesome.css","modified":1},{"_id":"themes/yelee/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/yelee/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1},{"_id":"themes/yelee/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/yelee/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/yelee/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/yelee/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/yelee/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/yelee/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/yelee/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/yelee/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/yelee/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/yelee/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/yelee/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/yelee/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/yelee/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/yelee/source/css/style.styl","path":"css/style.styl","modified":1},{"_id":"themes/yelee/source/background/bg-528.jpg","path":"background/bg-528.jpg","modified":1},{"_id":"themes/yelee/source/background/bg-0.jpg","path":"background/bg-0.jpg","modified":1},{"_id":"themes/yelee/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":1}],"Cache":[{"_id":"source/_posts/20160318-color.md","shasum":"a18c64e4cf6e232a943bedb3b0539bb2e6471216","modified":1458640230000},{"_id":"source/_posts/20160319-candy.md","shasum":"a8e44b7e64ac90ffe42178737d82a1b8cdd3a433","modified":1458640268000},{"_id":"source/_posts/20160319-set.md","shasum":"d103ece1f5688025e3aeb64d98b83450a468ee78","modified":1458640286000},{"_id":"source/_posts/ahoi2008-meet.md","shasum":"f0b90f3145a22269f536672815d48a74442a737f","modified":1458003954000},{"_id":"source/_posts/apio2009-atm.md","shasum":"5d4307e5eea665c30887244d586f2db77d9acbaf","modified":1458003954000},{"_id":"source/_posts/bigint-template.md","shasum":"934fda5bea22b36e0606b10d33bc5df2f37d2487","modified":1458003954000},{"_id":"source/_posts/bzoj-1251.md","shasum":"ad84ee02428319c058a532256b73ad33917148b7","modified":1458003954000},{"_id":"source/_posts/bzoj-1477.md","shasum":"c2116b666823e57f8e15df281f7ebf28870b475d","modified":1458006627000},{"_id":"source/_posts/bzoj-1756.md","shasum":"509da3a07727bf23b9e041bf6f054b73d51b1feb","modified":1458003954000},{"_id":"source/_posts/bzoj-2143.md","shasum":"d7bb81b4973726e7854a3cab33d3fb99ac13a75b","modified":1458647602000},{"_id":"source/_posts/bzoj-2442.md","shasum":"b881b2a39934c273cdf8adbf13d7217d1828a133","modified":1458003954000},{"_id":"source/_posts/bzoj-2683/cdq.png","shasum":"a95d0b02b915f092df6656298add0f0fc9662341","modified":1458003954000},{"_id":"source/_posts/bzoj-2683.md","shasum":"0492ca4c21f2426610b50f7b1f779a6d4b7f56a9","modified":1458382779000},{"_id":"source/_posts/codevs-1345.md","shasum":"35a63f86d492797be009f5f2021e155abab33438","modified":1458003954000},{"_id":"source/_posts/codevs-1563.md","shasum":"2e3b4f933efc86ac55bb314a5e81bab8ec3e0ae0","modified":1458003954000},{"_id":"source/_posts/codevs-2598.md","shasum":"43cea9c145daae8ec694d68be8448e9501ee6641","modified":1458003954000},{"_id":"source/_posts/codevs-2822.md","shasum":"eccf7d5e907409bd0c5289f23d681f3143ba1ae6","modified":1458003954000},{"_id":"source/_posts/codevs-3168-3162.md","shasum":"1e6ea3cce65f34e2adb25355c033822e36ab4f75","modified":1458003954000},{"_id":"source/_posts/codevs-3269-monotone-queue.md","shasum":"8b65485135f6dfb76a25e40c31e87b4ea8996952","modified":1458003954000},{"_id":"source/_posts/codevs-3269.md","shasum":"f149c7d49dd29762775770c88c21c0fc24367ad1","modified":1458003954000},{"_id":"source/_posts/cogs-14.md","shasum":"1815e43f2fa053587c1a7fd8cf1dbe49cb1dd6ec","modified":1458003954000},{"_id":"source/_posts/cogs-396.md","shasum":"f09aeb892396bcd011436d9dab0d95b642f80858","modified":1458003954000},{"_id":"source/_posts/cogs-439.md","shasum":"a1f2386e650be344ffcf3c6bd9f758c635e43610","modified":1458003954000},{"_id":"source/_posts/cogs-727.md","shasum":"161177dd266ab294f4f8aec1ac540896aa8d3994","modified":1458003954000},{"_id":"source/_posts/cogs-728.md","shasum":"df4085140dc76c1c12746838489045d941bd5934","modified":1458003954000},{"_id":"source/_posts/cogs-729.md","shasum":"fabb285fe6ff84c3e08e2583cf39121e910a0f35","modified":1458003954000},{"_id":"source/_posts/cogs-731.md","shasum":"781ea52e8b8d0459d16b44ea557ae0ba8c99c7b8","modified":1458003954000},{"_id":"source/_posts/cogs-734.md","shasum":"7691921e57b0d56b1027379f0bf6c74280ce56d9","modified":1458003954000},{"_id":"source/_posts/cogs-738.md","shasum":"d49ed353decc1f879f20260e2fbdbd994bf2bc80","modified":1458003954000},{"_id":"source/_posts/cogs-739.md","shasum":"6424379f94d41c0606bb190f62da16333b7c3d3e","modified":1458003954000},{"_id":"source/_posts/cogs-740.md","shasum":"a4da170a464f8f054136586b4a2aa306a00229fd","modified":1458003954000},{"_id":"source/_posts/cogs-741.md","shasum":"7097431c59b83b5879fc654359fbc520e9625390","modified":1458003954000},{"_id":"source/_posts/cogs-742.md","shasum":"b8e4e12bbf7a1be4cdf32d6252de75bedd4a5640","modified":1458003954000},{"_id":"source/_posts/cogs-746.md","shasum":"3cc0fb454e2cba5b6ef5d6ce3638f2c7c36abcfb","modified":1458003954000},{"_id":"source/_posts/combinatorics-notes.md","shasum":"f3e5e1bf1d06c126032426103df6f1990368ad07","modified":1458033641000},{"_id":"source/_posts/ctsc1997-course.md","shasum":"1bc44c199676b54b44a87dfb489a768f4c2831a5","modified":1458003954000},{"_id":"source/_posts/ctsc1999-home.md","shasum":"e7c40f399440f4e268e836f02a4b01423f177c7d","modified":1458003954000},{"_id":"source/_posts/cut-tree-notes/cutTree.png","shasum":"12de28c1f402f876a3826dcd7bfc8525d555ce1e","modified":1458003954000},{"_id":"source/_posts/cut-tree-notes.md","shasum":"e16fa699ed487724d2d7aa58d90088af35c1770a","modified":1458006411000},{"_id":"source/_posts/dinic-notes.md","shasum":"0378294542c3e68fff50acce4071552b870f0468","modified":1458006378000},{"_id":"source/_posts/edmonds-karp-notes.md","shasum":"6c145828e387d262d0b9fd5cb1c529201815e265","modified":1458006388000},{"_id":"source/_posts/gnu-debugger.md","shasum":"a39a3556d1965b8fc4ce3404e23c4aa5587ceca1","modified":1458003954000},{"_id":"source/_posts/haoi2006-cow.md","shasum":"fb01210fd048525414b685904c1be9297115de8e","modified":1458003954000},{"_id":"source/_posts/hnoi2004-pet.md","shasum":"c7003d07eddf8a9ad982a9d0555658b92b20c9e0","modified":1458003954000},{"_id":"source/_posts/jsoi2008-maxnumber.md","shasum":"41da0000e6e44f6851ce462f98a7c0bd02021152","modified":1458003954000},{"_id":"source/_posts/kmp-notes.md","shasum":"716f23d1fb6ac763134dfd9a570a9ce7cc88f3f5","modified":1458006457000},{"_id":"source/_posts/link-cut-tree-notes.md","shasum":"d0dd589310e783f3cc72f2d4a558396dde355f78","modified":1458043807000},{"_id":"source/_posts/markdown-latex-helper.md","shasum":"9646c40f411c104088af99b554ea34af8fb61e3d","modified":1458003954000},{"_id":"source/_posts/minimum-spanning-tree-notes.md","shasum":"8dc289c57c0f5deebdf831c730d1298bec918254","modified":1458006421000},{"_id":"source/_posts/monotone-queue-notes.md","shasum":"fc7a11f33c6b9f425dde2c3b3c901e7018aca151","modified":1458006445000},{"_id":"source/_posts/noi2002-galaxy.md","shasum":"8d2fbdeac0dbc1a5161deb6f810f6fa4effcaf72","modified":1458003954000},{"_id":"source/_posts/noi2003-editor.md","shasum":"316ad2a1c484941802caf23c8273e8ed003b6e93","modified":1458003954000},{"_id":"source/_posts/noi2004-cashier.md","shasum":"ecf35f2c34f6bd25e87029f1fd630a8e9d827ef5","modified":1458003954000},{"_id":"source/_posts/noi2006-profit.md","shasum":"d6b9cd171e4df5df17b9500138081fb468fba9f5","modified":1458003954000},{"_id":"source/_posts/noi2015-manager.md","shasum":"777c7ab467f7f2ccaf7aa494e30eb4f94ab5000e","modified":1458003954000},{"_id":"source/_posts/noi2015-prog.md","shasum":"08f98e733eb308d48657d2331aa097cf6da636a2","modified":1458003954000},{"_id":"source/_posts/noip2000-cheng-ji-zui-da.md","shasum":"030bb9ca1f7165d025de920e73e2a91c60f66aee","modified":1458003954000},{"_id":"source/_posts/noip2003-game.md","shasum":"9f8439789c62c835ae1b77f50cafda43c3f1cc9f","modified":1458003954000},{"_id":"source/_posts/noip2006-budget.md","shasum":"221887a8c70fdcb11c2907bd20be874bbdfa3532","modified":1458003954000},{"_id":"source/_posts/noip2006-energy.md","shasum":"580cb66a590a62f0c1baed062d13b82e0d6640de","modified":1458003954000},{"_id":"source/_posts/noip2010-prison.md","shasum":"1448e3bd6d6b3bbc2e514429c0cac4233e8ee63f","modified":1458003954000},{"_id":"source/_posts/noip2012-mod.md","shasum":"e6fbd0a6b633fa6ed5d8c1751d075de6dc79f6e2","modified":1458006606000},{"_id":"source/_posts/number-theory-notes-1.md","shasum":"06a1c30f28a21e76f65bc5afc0d9766231d8af32","modified":1458033453000},{"_id":"source/_posts/osx-enable-retina.md","shasum":"ce107893ed50fd33bad30317e10e2237a8ea118d","modified":1458096628000},{"_id":"source/_posts/osx-softwares.md","shasum":"1889f0fdb89578e89f6c34a0a16dfbdd7a2e9c23","modified":1458003954000},{"_id":"source/_posts/poj-2728.md","shasum":"eb54e9ae5aa2f5f25c740ffb7d087c6fa6b60c4b","modified":1458003954000},{"_id":"source/_posts/poj-1737.md","shasum":"639cc82ec54c8d913c4354f65214da58c898c4be","modified":1458033091000},{"_id":"source/_posts/scoi2007-repair.md","shasum":"d0a3f9f9bde613da02b04df7a49960c0d3e71e16","modified":1458003954000},{"_id":"source/_posts/scoi2010-game.md","shasum":"4769fc7c0577e5ae3e6ac6eb378c324a36957ec9","modified":1458003954000},{"_id":"source/_posts/scoi2011-candy.md","shasum":"846835c789a8e42c0eff000167ea950b1560ee95","modified":1458003954000},{"_id":"source/_posts/scoi2015-flag.md","shasum":"0c2fc4f4a94f4467c7ec03e9123e2397653c9f3f","modified":1458642346000},{"_id":"source/_posts/scoi2015-matrix.md","shasum":"d8b9f91054ad6e107fab5bf68abe542cbd9a6533","modified":1458642401000},{"_id":"source/_posts/scoi2015-message.md","shasum":"10c74a2bf0b7277bfb5c77fc12c7965592ba98e9","modified":1458641403000},{"_id":"source/_posts/sdoi2008-cave.md","shasum":"7bdfd72842631766d2d08ab7b8f3a27d2b6b0913","modified":1458043614000},{"_id":"source/_posts/sdoi2010-starrace.md","shasum":"8c36c9fd0d86ef4818edfb91eddda25a0fcaf9de","modified":1458003954000},{"_id":"source/_posts/sdoi2015-war.md","shasum":"64600d2ef83f31e38c656f7768e76909707f9e2f","modified":1458003954000},{"_id":"source/_posts/splay-notes-1.md","shasum":"74b118e9cca1b32c32298fcabf90192aa194e1a8","modified":1458003954000},{"_id":"source/_posts/splay-notes-2.md","shasum":"b7c1615a96dfff66ea8c6337d06c966a9223f69e","modified":1458003954000},{"_id":"source/_posts/splay-notes-3.md","shasum":"77f025b32786a71ce628095d27642fbe230e764a","modified":1458006308000},{"_id":"source/_posts/stl-in-oi.md","shasum":"c3e0ecfbc635868a47b686a6ea7a992183fa9d96","modified":1458003954000},{"_id":"source/_posts/system-of-difference-constraints-notes.md","shasum":"cda796649d3175c93146609b99ba4e753d04c995","modified":1458006336000},{"_id":"source/_posts/tarjan-scc-notes.md","shasum":"78f4744865c553f80815c07f1de3e94270e45733","modified":1458006345000},{"_id":"source/_posts/uva-10253.md","shasum":"a7ce29631cd01ba892d722a7c195a63deb2a9bce","modified":1458033172000},{"_id":"source/_posts/tyvj-3317.md","shasum":"0b0bcc0bfc54473c1545b105cd26ebbcf6ced6fb","modified":1458003954000},{"_id":"source/_posts/uva-11137.md","shasum":"35a252e75a295ef4b03461c89fceba4b071a1bae","modified":1458003954000},{"_id":"source/_posts/uva-11174.md","shasum":"f5d1909b95556fe7d9d6fa700cf79df9aaff6f15","modified":1458003954000},{"_id":"source/_posts/uva-11361.md","shasum":"d83c49375c1d79de668152151c4b00b62209bef0","modified":1458003954000},{"_id":"source/_posts/uva-11375.md","shasum":"00bc972f94fd8ad0bf0e1aec091b28fe2fe71319","modified":1458003954000},{"_id":"source/_posts/uva-11538.md","shasum":"3a49e51f774c735977b321180e6cc85061369096","modified":1458003954000},{"_id":"source/_posts/uva-11538/cells.png","shasum":"3a162829c312a17639950c3620cd70799ed94a49","modified":1458003954000},{"_id":"source/_posts/uva-11806.md","shasum":"147f46b315401cc166d1c7ff9b4b931714fe46a8","modified":1458003954000},{"_id":"source/_posts/uva-1362.md","shasum":"a5847010ccb13138b27aa43ba7b568e402cf6785","modified":1458003954000},{"_id":"source/_posts/virtualbox-archlinux.md","shasum":"920b51fe7f50d524a368c55db06a84cba0f3df1e","modified":1458003954000},{"_id":"source/about-me.md","shasum":"b7044084ee719baa66574b4d1291a322c60973fc","modified":1458571589000},{"_id":"source/friends.md","shasum":"3b783dae3e96abca46f5fc49c53eb5e5d459619e","modified":1458298467000},{"_id":"source/_posts/osx-enable-retina/plist-edit.png","shasum":"94dd75a8fba5775cd97fcc5cc9f917f5bba40061","modified":1458095214000},{"_id":"source/_posts/osx-softwares/dropbox.png","shasum":"c57885f99a5af62b94eb53a510edbc2faab47e7b","modified":1458003954000},{"_id":"source/_posts/osx-softwares/go2shell.png","shasum":"538be85641e7b95ec18bf577ac1353d757637817","modified":1458003954000},{"_id":"source/_posts/osx-softwares/shadowsocksx.png","shasum":"e4d6e7dac5744d19d5303ba13b3f8411953a0427","modified":1458003954000},{"_id":"source/_posts/virtualbox-archlinux/port.png","shasum":"bb684dd8b616413e3e0e27c5efce118249a54113","modified":1458003954000},{"_id":"source/_posts/osx-softwares/vlc.png","shasum":"395a973310d204c78cdefb9da9929c3892479b73","modified":1458003954000},{"_id":"source/_posts/osx-softwares/fileroller.png","shasum":"9bf831aec4309e525791f286c346a447c6605acd","modified":1458003954000},{"_id":"source/_posts/osx-softwares/karabiner.png","shasum":"0b24e2252a00f402e681a6dd84a679a4be9706be","modified":1458003954000},{"_id":"source/_posts/osx-softwares/teamviewer.png","shasum":"c9c00c296ccdc4c234cc945bc6b3653e9742797f","modified":1458003954000},{"_id":"source/_posts/osx-softwares/virtualbox.png","shasum":"7401b6a6f6543356234d9ecbaa5fd8026455ead4","modified":1458003954000},{"_id":"source/_posts/virtualbox-archlinux/share.png","shasum":"8f7c7dcf96cf750b6e0098b07fe257cfd65d22f8","modified":1458003954000},{"_id":"source/_posts/osx-softwares/flashlight.png","shasum":"c251a90415340d44655c18461ed5b186167cd03a","modified":1458003954000},{"_id":"source/_posts/splay-notes-1/splay.png","shasum":"ee64a4a43e084b0011003b743a680eb2ec2b9a13","modified":1458003954000},{"_id":"source/_posts/virtualbox-archlinux/hotkey.png","shasum":"aca0dac1c68edb971a77b72a0db588f3c034c426","modified":1458003954000},{"_id":"source/_posts/virtualbox-archlinux/network.png","shasum":"23bd9c4bd71642cd4176ae1737e545bc121724f2","modified":1458003954000},{"_id":"source/_posts/virtualbox-archlinux/terminal.png","shasum":"8960a9c80feac7fefd5894684fdd6d0a174ba426","modified":1458003954000},{"_id":"source/_posts/osx-softwares/feeluown.png","shasum":"70c4a0b923c3d8688d64f0036ec09d34d214a7eb","modified":1458003954000},{"_id":"source/_posts/osx-softwares/libreoffice-writer.png","shasum":"f0e740eef5a31433f798a9ab689bca320b3ec05f","modified":1458003954000},{"_id":"source/_posts/osx-softwares/macdown.png","shasum":"f655bf9258ec412c856078653aadac847f69bd08","modified":1458003954000},{"_id":"source/_posts/virtualbox-archlinux/screenfetch.png","shasum":"edd38d6098ab0cb8d1c6bf35578379f4fd0de96d","modified":1458003954000},{"_id":"source/_posts/osx-softwares/gimp.png","shasum":"8d1f18af30cbe2639375bc13d993d81894d916ab","modified":1458003954000},{"_id":"source/_posts/osx-softwares/macvim.png","shasum":"550e044c4af938acbd373649bacff7dd4f020f8c","modified":1458003954000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/test/modules/ignore.txt","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1441988248000},{"_id":"themes/yelee/node_modules/hoek/test/modules/ignore.txt","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1441988248000},{"_id":"themes/yelee/node_modules/readdirp/test/bed/root_dir1/root_dir1_file1.ext1","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/test/bed/root_dir1/root_dir1_file2.ext2","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/test/bed/root_dir1/root_dir1_file3.ext3","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/test/bed/root_dir1/root_dir1_subdir1/root1_dir1_subdir1_file1.ext1","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/test/bed/root_dir2/root_dir2_file1.ext1","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/test/bed/root_dir2/root_dir2_file2.ext2","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/test/bed/root_file1.ext1","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/test/bed/root_file2.ext2","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/test/bed/root_file3.ext3","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1418419137000},{"_id":"themes/yelee/README.md","shasum":"099145f13a1b5bc6c05c1191d97c5f3141a0d065","modified":1456461572000},{"_id":"themes/yelee/_config.yml","shasum":"3989d6d0ff586c2e497eefb0a46067fedaf37030","modified":1457843972000},{"_id":"themes/yelee/layout/_partial/after-footer.ejs","shasum":"c6cfbf438076d306185c0fe1561bac6c4b621ace","modified":1458034075000},{"_id":"themes/yelee/layout/_partial/archive-post.ejs","shasum":"0ecc2ad07b4abad80f564ac1858c50bcbdff34f8","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/archive.ejs","shasum":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/article.ejs","shasum":"f74f702b5c52abb75b443d39a8584a276335f79f","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/background.ejs","shasum":"f28a2ddf873bfae6410103b5c04ebc791c92b092","modified":1456632368000},{"_id":"themes/yelee/layout/_partial/comments/disqus.ejs","shasum":"2e5cad68bc59190b4158f4ab1879a222ca49a0d2","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/comments/duoshuo.ejs","shasum":"1f9ac8182fe0b867a8f1988888336c40c25894cd","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/comments/youyan.ejs","shasum":"a6853b59ee60e775de1ed90b242084f83774d195","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/footer.ejs","shasum":"9b82f9df1c362d9f753471a1b762ae9dec541a41","modified":1456473992000},{"_id":"themes/yelee/layout/_partial/google-analytics.ejs","shasum":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/head.ejs","shasum":"03834e314b0cbba1848419379468eb96957d20d6","modified":1458034185000},{"_id":"themes/yelee/layout/_partial/header.ejs","shasum":"b69855e07b65117769adc515cb64b803932068c9","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/hide-labels.ejs","shasum":"85efb11ec87453274e9fcec1aba9fe0ff943e40c","modified":1456636113000},{"_id":"themes/yelee/layout/_partial/left-col.ejs","shasum":"eef030e8c70f17cbeec5257610ddca533af74814","modified":1456631866000},{"_id":"themes/yelee/layout/_partial/mathjax.ejs","shasum":"23bb102f7eea9b0919c82b6372750a034b88d071","modified":1456484747000},{"_id":"themes/yelee/layout/_partial/mobile-nav.ejs","shasum":"3965642143865e07e83a886480d03a77135bf830","modified":1456633591000},{"_id":"themes/yelee/layout/_partial/page.ejs","shasum":"1744af0843e6805ca7140327c6a9be2301204221","modified":1456636152000},{"_id":"themes/yelee/layout/_partial/post/category.ejs","shasum":"08c8d98bc6a73d3f72a3b0b30521ff28e1b657a7","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/post/date.ejs","shasum":"a9fc6bac9e1b90c1c17c0d0ffd97f9b108072fbe","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/post/nav.ejs","shasum":"e1b8d9bf1951aa621d6dffc1a4944da42571d064","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/post/share.ejs","shasum":"bfac451ed8d632dbba84673691cc5ea3315c1469","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/post/tag.ejs","shasum":"7d2693a1162bf26e4b1ae9b789e0b2a2637ddbd5","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/post/title.ejs","shasum":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/post-nav-button.ejs","shasum":"1c233f308a35b3aaca0f4a4158cc3dd24a9dc3f8","modified":1456636126000},{"_id":"themes/yelee/layout/_partial/scrolling-button.ejs","shasum":"aad58483a5d6d4627fce9bbc367784d57e93c544","modified":1456461572000},{"_id":"themes/yelee/layout/_partial/toc.ejs","shasum":"2dd741fc718c67e9dfe8e7c7e04bb18dfe04416a","modified":1456636136000},{"_id":"themes/yelee/layout/archive.ejs","shasum":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1456461572000},{"_id":"themes/yelee/layout/category.ejs","shasum":"765426a9c8236828dc34759e604cc2c52292835a","modified":1456461572000},{"_id":"themes/yelee/layout/index.ejs","shasum":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1456461572000},{"_id":"themes/yelee/layout/layout.ejs","shasum":"0dc82852411f536d87580a56c427c2b1ee2d82f8","modified":1457932096000},{"_id":"themes/yelee/layout/page.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1456461572000},{"_id":"themes/yelee/layout/post.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1456461572000},{"_id":"themes/yelee/layout/tag.ejs","shasum":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1456461572000},{"_id":"themes/yelee/node_modules/ansi-regex/index.js","shasum":"03d6a4cc534cbb9a855b01b372a17bfa2b830442","modified":1435679868000},{"_id":"themes/yelee/node_modules/ansi-regex/license","shasum":"0c94f137f6e0536db8cb2622a9dc84253b91b90c","modified":1396798991000},{"_id":"themes/yelee/node_modules/ansi-regex/package.json","shasum":"348b89f9ce5248f9551751fa61fab43ed217fbe7","modified":1456469176000},{"_id":"themes/yelee/node_modules/ansi-regex/readme.md","shasum":"76c119f1cf0605a0409f9c2756de3e55a1398fc2","modified":1435679915000},{"_id":"themes/yelee/node_modules/ansi-styles/index.js","shasum":"87fbeeb30899102acf006a96eb12dfc24bcc01b5","modified":1456056918000},{"_id":"themes/yelee/node_modules/ansi-styles/license","shasum":"0c94f137f6e0536db8cb2622a9dc84253b91b90c","modified":1405288555000},{"_id":"themes/yelee/node_modules/ansi-styles/package.json","shasum":"451cd978d9d63d9579e37266d42baeb1c492869f","modified":1456469176000},{"_id":"themes/yelee/node_modules/ansi-styles/readme.md","shasum":"8613831018b4ce9805fadf6de8bcbf6ef16bcae3","modified":1456056918000},{"_id":"themes/yelee/node_modules/anymatch/LICENSE","shasum":"2faff6eb900a1f252dd5628fa007d8df033d9717","modified":1426989009000},{"_id":"themes/yelee/node_modules/anymatch/README.md","shasum":"6abfe77bff90bcf1c9adde01eab4a5eb609eda7b","modified":1429740109000},{"_id":"themes/yelee/node_modules/anymatch/index.js","shasum":"21e942db79cdd8c863a7c1d4c619de728a3f4277","modified":1429713941000},{"_id":"themes/yelee/node_modules/anymatch/package.json","shasum":"75ca62b32f5233a01233b0558a30008c5f5a17c2","modified":1456469176000},{"_id":"themes/yelee/node_modules/arr-diff/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1440300569000},{"_id":"themes/yelee/node_modules/arr-diff/README.md","shasum":"aea1c9d09e3e4836b20459900490582a913ba318","modified":1449375940000},{"_id":"themes/yelee/node_modules/arr-diff/index.js","shasum":"b0af4d581bd0e4f370526dfaee3d2a8daf45880c","modified":1449375115000},{"_id":"themes/yelee/node_modules/arr-diff/package.json","shasum":"6fd028ead99b9a701052735f165a0862f7f4e044","modified":1456469176000},{"_id":"themes/yelee/node_modules/arr-flatten/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1426048064000},{"_id":"themes/yelee/node_modules/arr-flatten/README.md","shasum":"3f5ac995fae4c1ac9372779114b7b683e3b21a85","modified":1426048068000},{"_id":"themes/yelee/node_modules/arr-flatten/index.js","shasum":"f520001d7bfbf978f6b90448fc2dc51f5bdf6ca4","modified":1426048064000},{"_id":"themes/yelee/node_modules/arr-flatten/package.json","shasum":"b4a87c85dd069d2d5bf2506934588fb1401466ce","modified":1456469176000},{"_id":"themes/yelee/node_modules/array-unique/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1427255160000},{"_id":"themes/yelee/node_modules/array-unique/README.md","shasum":"c469edac074366095833e9e37da13d111df44bd7","modified":1427255211000},{"_id":"themes/yelee/node_modules/array-unique/index.js","shasum":"1826adc4c19e8d8bcf421d342ae7e2db52f69bb6","modified":1427255160000},{"_id":"themes/yelee/node_modules/array-unique/package.json","shasum":"faad20d4985d2579ca067318a51b60730fb18268","modified":1456469176000},{"_id":"themes/yelee/node_modules/arrify/index.js","shasum":"d91a789bdf6d6e7ea9014b0b1bacfef0d7621f47","modified":1449683153000},{"_id":"themes/yelee/node_modules/arrify/license","shasum":"0c94f137f6e0536db8cb2622a9dc84253b91b90c","modified":1396798991000},{"_id":"themes/yelee/node_modules/arrify/package.json","shasum":"0f7f5368f5c6bb47e84dd23c59d9050a2c73c82b","modified":1456469176000},{"_id":"themes/yelee/node_modules/arrify/readme.md","shasum":"6354f6960ff472c330f75421ac9a81d3709599ad","modified":1449683163000},{"_id":"themes/yelee/node_modules/asn1/LICENSE","shasum":"724e48cfc739674999ff82b4e49d76d5376818e9","modified":1401981220000},{"_id":"themes/yelee/node_modules/asn1/README.md","shasum":"71e6a47944ebaefe5d5357a7b6f46df9c389316f","modified":1401981220000},{"_id":"themes/yelee/node_modules/asn1/lib/ber/errors.js","shasum":"556bbb1b810ede9292493a70ad9a8644e5c4fb7a","modified":1401981220000},{"_id":"themes/yelee/node_modules/asn1/lib/ber/index.js","shasum":"1ab39535ed24903d0f9e2a4bf74333702842080b","modified":1401981220000},{"_id":"themes/yelee/node_modules/asn1/lib/ber/types.js","shasum":"8a41886747dc1f7cde7e4e5cb60e1a3b8a4c813c","modified":1401981220000},{"_id":"themes/yelee/node_modules/asn1/lib/ber/reader.js","shasum":"3cfcdc9225bb43dd8413dc3f1f05d4fcd32d0b30","modified":1443646115000},{"_id":"themes/yelee/node_modules/asn1/lib/ber/writer.js","shasum":"bdad4a0bb12fb5f91b789329fc4e4a45ecf87e64","modified":1443646115000},{"_id":"themes/yelee/node_modules/asn1/lib/index.js","shasum":"cbff145d47fb41eb1262f012a7024e7b0e527d6c","modified":1401981220000},{"_id":"themes/yelee/node_modules/asn1/package.json","shasum":"d8a5922f5468e54ed1547dbf87460f454bd00e41","modified":1456469177000},{"_id":"themes/yelee/node_modules/asn1/tst/ber/reader.test.js","shasum":"de84b2d7317393c6e6a0cdef04bfbff82ba78237","modified":1401981220000},{"_id":"themes/yelee/node_modules/asn1/tst/ber/writer.test.js","shasum":"59892680384339812688163b346d12cc05e979fd","modified":1401981220000},{"_id":"themes/yelee/node_modules/assert-plus/AUTHORS","shasum":"d1d14de8fc8c21f9f86c2231df2531381f6a9194","modified":1446952976000},{"_id":"themes/yelee/node_modules/assert-plus/CHANGES.md","shasum":"b64b8d16f3858a1c3d55538c5bfee934437af75b","modified":1447141659000},{"_id":"themes/yelee/node_modules/assert-plus/README.md","shasum":"79988e7cb3bb80b7cc20dc420ee2a7f86ab3d3e0","modified":1446952976000},{"_id":"themes/yelee/node_modules/assert-plus/assert.js","shasum":"8f3f85bae8edd30db24882766a5c8c4df8357462","modified":1447140668000},{"_id":"themes/yelee/node_modules/assert-plus/package.json","shasum":"7f2b96a2e7aef656e776ba30a8e37c44f8111364","modified":1456469176000},{"_id":"themes/yelee/node_modules/async/CHANGELOG.md","shasum":"f6dbdbec1d4babb8661eae69a9d35700ca89bfb1","modified":1452211409000},{"_id":"themes/yelee/node_modules/async/LICENSE","shasum":"e452de6c5360ba269a3bda17cca33f0bf51035f5","modified":1432069407000},{"_id":"themes/yelee/node_modules/async/README.md","shasum":"1e5c0380861222c007090d0c0a1d8ca4f5272dc5","modified":1452208687000},{"_id":"themes/yelee/node_modules/async/dist/async.js","shasum":"a410bed1e8c6a19be68101c293ff66c4961076ae","modified":1452211451000},{"_id":"themes/yelee/node_modules/async/dist/async.min.js","shasum":"487f1a1adb0bf6b00233edb64e64f2fb305ce5a3","modified":1452211452000},{"_id":"themes/yelee/node_modules/async/lib/async.js","shasum":"a410bed1e8c6a19be68101c293ff66c4961076ae","modified":1452207555000},{"_id":"themes/yelee/node_modules/async/package.json","shasum":"b9680461f372a533849ffb06ab7e158f4cb32d89","modified":1456469177000},{"_id":"themes/yelee/node_modules/async-each/CHANGELOG.md","shasum":"1102ca4765f9168b80496cefa91817ac39bb30a1","modified":1415225746000},{"_id":"themes/yelee/node_modules/async-each/README.md","shasum":"dfc8f7a521e3b419521df634fd9ea5f9932104c7","modified":1414004479000},{"_id":"themes/yelee/node_modules/async-each/bower.json","shasum":"36d0d507aa0d7aa6d06170dd73969b17c1dfaa2f","modified":1415225763000},{"_id":"themes/yelee/node_modules/async-each/component.json","shasum":"1da329193224221f15946abc68712721acd9040a","modified":1415225758000},{"_id":"themes/yelee/node_modules/async-each/index.js","shasum":"c329e80e544646b7f83d52d3428687b19e6d7119","modified":1414004479000},{"_id":"themes/yelee/node_modules/async-each/package.json","shasum":"3f272365a8b531881ef2e9de609cf8673bad5726","modified":1456469176000},{"_id":"themes/yelee/node_modules/aws-sign2/README.md","shasum":"5e8e0e7c811b1f319c0e94ff08f38ecf4896e3c9","modified":1366607619000},{"_id":"themes/yelee/node_modules/aws-sign2/LICENSE","shasum":"05979f0750cf5c2a17bd3aa12450849c151d8b7c","modified":1366607619000},{"_id":"themes/yelee/node_modules/aws-sign2/index.js","shasum":"b380be041c204108febb8f32b19431a54aaed4a6","modified":1444584231000},{"_id":"themes/yelee/node_modules/aws-sign2/package.json","shasum":"d06c8cde76acc2e86f3ace0fbf412d07e9ca37e0","modified":1456469176000},{"_id":"themes/yelee/node_modules/aws4/LICENSE","shasum":"9ba903f14c37d0ab0250a8e6920e7269bdc5b294","modified":1384232184000},{"_id":"themes/yelee/node_modules/aws4/aws4.js","shasum":"4155d86150b56a456a7b90fb55a82b8e9e3fc666","modified":1451426937000},{"_id":"themes/yelee/node_modules/aws4/README.md","shasum":"8b02542186fe300b27acd3aba5c65b77a3d822e3","modified":1426551080000},{"_id":"themes/yelee/node_modules/aws4/package.json","shasum":"16a640a56c5f9f9ac310df89189e49c33290aebc","modified":1456469177000},{"_id":"themes/yelee/node_modules/aws4/example.js","shasum":"4da6b34b39625ad7b9c788f6c2ebac1f80531520","modified":1426551098000},{"_id":"themes/yelee/node_modules/balanced-match/LICENSE.md","shasum":"09013c002fbdd686da2ec13c5a6d014f0a294ba9","modified":1445519600000},{"_id":"themes/yelee/node_modules/balanced-match/Makefile","shasum":"98cb6ef36a74f052f3bad15c72f01d78e2d0ba8e","modified":1445519548000},{"_id":"themes/yelee/node_modules/balanced-match/README.md","shasum":"261a929745508f56c655d4ec306123bbfabdaa16","modified":1448714230000},{"_id":"themes/yelee/node_modules/balanced-match/example.js","shasum":"27792bf4ffe9ce453c5d6896611d7647fd8f0e6b","modified":1445519548000},{"_id":"themes/yelee/node_modules/balanced-match/index.js","shasum":"8c1cf0e709f8668e14b11c9086a50c70a0b0434e","modified":1448714230000},{"_id":"themes/yelee/node_modules/balanced-match/package.json","shasum":"08939dbde000855efbadc72e6d987378748e24dc","modified":1456469177000},{"_id":"themes/yelee/node_modules/balanced-match/test/balanced.js","shasum":"706b6e79b2c13f0fed4d25706b63bbeec17c3600","modified":1448714230000},{"_id":"themes/yelee/node_modules/binary-extensions/binary-extensions.json","shasum":"02c5fbd9d5f15c24536fac478a79dca0eecfcc0f","modified":1447865992000},{"_id":"themes/yelee/node_modules/binary-extensions/license","shasum":"0c94f137f6e0536db8cb2622a9dc84253b91b90c","modified":1396798991000},{"_id":"themes/yelee/node_modules/binary-extensions/package.json","shasum":"ab77bfd76d4ec25eede9b5bc4c7c5641c3761a97","modified":1456469176000},{"_id":"themes/yelee/node_modules/binary-extensions/readme.md","shasum":"df2c147fdca66c819adb5e7e7709ba1d4167a37b","modified":1431905669000},{"_id":"themes/yelee/node_modules/bl/LICENSE.md","shasum":"d068ae801f9277b4b248f0c2aad7f50181dacaad","modified":1453181857000},{"_id":"themes/yelee/node_modules/bl/README.md","shasum":"4308d9ba8f28872911d3e4f8b3de6b56b47be042","modified":1453181864000},{"_id":"themes/yelee/node_modules/bl/bl.js","shasum":"4ff984b4b3c546295b51e71787ff8a99b159007d","modified":1455187025000},{"_id":"themes/yelee/node_modules/bl/package.json","shasum":"da25e044a1f9844c8be0cced38c56a31b08b3710","modified":1456469177000},{"_id":"themes/yelee/node_modules/bluebird/LICENSE","shasum":"914158dfad0452ceb55ea5e1822605ca05984bd9","modified":1441756221000},{"_id":"themes/yelee/node_modules/bl/test/test.js","shasum":"94102bab86dc65abd7f8a762fd2b03489527ab77","modified":1455187143000},{"_id":"themes/yelee/node_modules/bluebird/README.md","shasum":"7301370c8dcfec15e81690573e67cec9098722b6","modified":1443731831000},{"_id":"themes/yelee/node_modules/bluebird/changelog.md","shasum":"379c89dae1fe9a27f88326e51bee47a69d6d166f","modified":1443731919000},{"_id":"themes/yelee/node_modules/bluebird/js/main/any.js","shasum":"424dfe2a1afeaad729ca2be5ccfd443311716c41","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/assert.js","shasum":"913ec7a809e56b5958cbcec9636261ef8678f039","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/async.js","shasum":"59886110bb7c636f009738204e1b741e5a392901","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/bind.js","shasum":"33588c68d7f07021a8bc39e9aa0d152c9b8bb36c","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/bluebird.js","shasum":"ff935d6b554c445b4a1ff63828a883a922e8adfe","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/call_get.js","shasum":"58d857432929fcec4290920561d078ae14b37fd3","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/cancel.js","shasum":"5af48d3225ea7d186307b5e40068df50029fb51d","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/captured_trace.js","shasum":"c2366ef310186f3c0f724d609ab5182430bda350","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/catch_filter.js","shasum":"a82102f6dda6254edc559e3f0fca18386cbf7704","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/context.js","shasum":"00f52d27fe05ad386ebc5a0c3145055a8239b717","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/debuggability.js","shasum":"cd4e51109686fa6ef6393580e4ce1b2fb8857708","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/direct_resolve.js","shasum":"09460167ef03306534e2a5b4955aaf6cd2928816","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/each.js","shasum":"22c435d2bf35fa9d4e49845b051a19ed915ae033","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/errors.js","shasum":"12a0cb75135f2e21233e7a86ba75a87d2bcaae90","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/es5.js","shasum":"019c4e8b62031ea49aedc86dedd20318c6122698","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/filter.js","shasum":"a5f3aee4afbc67d372e5b4fbaeac047d0d9c779b","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/finally.js","shasum":"b965777471de69b0dd8d4954ea4eadda259b47da","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/generators.js","shasum":"a1dd036d2ba0b8e5fa5f1c9eeb782e40e6e1d446","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/join.js","shasum":"3343313085a4c70419b9480fbe3aadc8999f2c61","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/map.js","shasum":"a31b919a76b2e49cbe2b9af6a55d895a15721361","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/method.js","shasum":"241c83511b11611db4f93379ecb52cc956524f08","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/nodeify.js","shasum":"bed107c219728c53f8b2ca98fbf152cf17f38b37","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/progress.js","shasum":"520f17a7b4a9e60cc9c81c97432a0cca8d95bec6","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/promise_array.js","shasum":"20440af825405966bf371340b28f71050e511356","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/promise.js","shasum":"8e4ad2c061036b6076e93ca161aef773aad638c5","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/promise_resolver.js","shasum":"0724c0b49798dd9e052a0b647a0f8eca2eee2085","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/promisify.js","shasum":"76a80de1f074b815af8d0c5eb7b00c77ec776ccf","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/props.js","shasum":"c0cefcfd25e02e258867fd6b04e05c703dc32848","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/queue.js","shasum":"6c24c68f716db1a6c18b5cad2a951f0df6ee76ec","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/race.js","shasum":"3fdee03445a36d1ba8c1c25c7f1cbd2048dcf8c8","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/schedule.js","shasum":"fc5702823d7db29090fc00782e4830be98f5d868","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/reduce.js","shasum":"ae62bdfa766e869d635dae6907a2ae7661248770","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/settle.js","shasum":"5c2b5afa5c58f73d7d180aea5f4aac740d592fb4","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/some.js","shasum":"9520efd87fd7e846435bdd30be5599f22936c923","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/synchronous_inspection.js","shasum":"9585e3b56fb8b0fab358782dea3310b640853ecf","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/thenables.js","shasum":"d1b36cd6d1e1e8db91e7f947a6434bb5197cce98","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/timers.js","shasum":"b7462244ff2349386d8c9319d7b795fe0fe57c13","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/using.js","shasum":"6691ef4555e191df6369224449d15919ba98fc4f","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/js/main/util.js","shasum":"1b59d56271df184c21ff649a5cf63b7881bb6249","modified":1443731942000},{"_id":"themes/yelee/node_modules/bluebird/package.json","shasum":"4fbf358f772f23bc9d0257b6034dbdf70d84f072","modified":1456469177000},{"_id":"themes/yelee/node_modules/boom/CONTRIBUTING.md","shasum":"61998267d75f17fdd423c1c742edc20a1561c1e2","modified":1411478104000},{"_id":"themes/yelee/node_modules/boom/LICENSE","shasum":"53ded9fedb90236c92321a45d1ab00fa35f282d8","modified":1407506005000},{"_id":"themes/yelee/node_modules/boom/README.md","shasum":"2d7368cd181df38d42b300f04f7323cc16f9b7d2","modified":1446232305000},{"_id":"themes/yelee/node_modules/boom/images/boom.png","shasum":"126fe71d237c4939338507417d5f5e172773be3e","modified":1407506005000},{"_id":"themes/yelee/node_modules/boom/lib/index.js","shasum":"a894f6f39fc0bf0f8a82a420d8a2a5018e9dcdbe","modified":1446232305000},{"_id":"themes/yelee/node_modules/boom/package.json","shasum":"b1f86f88ecbaf27e12e63cfb972694c7b3dc1a36","modified":1456469177000},{"_id":"themes/yelee/node_modules/boom/test/index.js","shasum":"62d76a920212e160acf6894f1ee3e981e6aaa8b1","modified":1446232305000},{"_id":"themes/yelee/node_modules/brace-expansion/README.md","shasum":"3ed262742cc9e8e0db93c5f1d729127af1ffbe82","modified":1446204351000},{"_id":"themes/yelee/node_modules/brace-expansion/example.js","shasum":"8a259435e31e75ac76d3abcbefd225af7f41c185","modified":1446204351000},{"_id":"themes/yelee/node_modules/braces/LICENSE","shasum":"d99d5158898474f25efb4c8790f9fcc4cf55b350","modified":1450565981000},{"_id":"themes/yelee/node_modules/brace-expansion/index.js","shasum":"acd1637cc605d2aff5f9da27ff9f7df5a9f79840","modified":1455216657000},{"_id":"themes/yelee/node_modules/brace-expansion/package.json","shasum":"4061400587900da9701d3365d7b37e2ca9675097","modified":1456469176000},{"_id":"themes/yelee/node_modules/braces/README.md","shasum":"cba67f4f8b1b30f75187913d8817c80af6755b7b","modified":1450565981000},{"_id":"themes/yelee/node_modules/braces/index.js","shasum":"e13bca7cef9140534c7726fbf78b74796b41c949","modified":1450566164000},{"_id":"themes/yelee/node_modules/braces/package.json","shasum":"239eccd5df7cc847bda3adcacd588e995b79e324","modified":1456469176000},{"_id":"themes/yelee/node_modules/caseless/LICENSE","shasum":"48f9e0a4c07f36c07d47962212fe022d0417c90f","modified":1435268329000},{"_id":"themes/yelee/node_modules/caseless/README.md","shasum":"5770b9496fb480f7c403b6c38759a27d6170e882","modified":1414608769000},{"_id":"themes/yelee/node_modules/caseless/index.js","shasum":"326fc25f6edec25f7d239314ed6e75259147088a","modified":1424972076000},{"_id":"themes/yelee/node_modules/caseless/package.json","shasum":"7e72c84e774921b717928812f61d6ba4adf18305","modified":1456469176000},{"_id":"themes/yelee/node_modules/caseless/test.js","shasum":"73948ff77c144352fb9d9615079ee35cab781912","modified":1414609010000},{"_id":"themes/yelee/node_modules/chalk/index.js","shasum":"08315806beaa18a4eb58052e8e7182b2d8bddf8f","modified":1440014707000},{"_id":"themes/yelee/node_modules/chalk/license","shasum":"0c94f137f6e0536db8cb2622a9dc84253b91b90c","modified":1396798991000},{"_id":"themes/yelee/node_modules/chalk/package.json","shasum":"2810cf074114281d965ca3698a09d62092a284e2","modified":1456469176000},{"_id":"themes/yelee/node_modules/chalk/readme.md","shasum":"a10251893e1a61957a4c7238001e682d20d46d47","modified":1440014506000},{"_id":"themes/yelee/node_modules/chokidar/CHANGELOG.md","shasum":"85f505f3e1a49969effaa5aeecf4589ed9e6cbfe","modified":1451487551000},{"_id":"themes/yelee/node_modules/chokidar/README.md","shasum":"548672a8bfbaa03a8f667ddf23540e55b6b2cf4d","modified":1451487515000},{"_id":"themes/yelee/node_modules/chokidar/index.js","shasum":"73d55f784b04a68118142e3990545076c088d5c9","modified":1451487515000},{"_id":"themes/yelee/node_modules/chokidar/lib/fsevents-handler.js","shasum":"34dbf4382b9abe8557225200f67d14ce4acecce4","modified":1447810431000},{"_id":"themes/yelee/node_modules/chokidar/package.json","shasum":"42dfd6857b527de60e8423355d7aedde0f1d8ef8","modified":1456469176000},{"_id":"themes/yelee/node_modules/chokidar/lib/nodefs-handler.js","shasum":"2bb20459d65f97b270774f64af9ec021bed83222","modified":1449237717000},{"_id":"themes/yelee/node_modules/color-convert/CHANGELOG.md","shasum":"888f63060f1f4e78696f49f97d2c7bbe59f6a1bd","modified":1452208038000},{"_id":"themes/yelee/node_modules/color-convert/README.md","shasum":"bc54b7505917008b59fb44c1c1510496b7e10c64","modified":1452208022000},{"_id":"themes/yelee/node_modules/color-convert/LICENSE","shasum":"213184abbe8fc3ea5e46b468252a8169976ec023","modified":1452140295000},{"_id":"themes/yelee/node_modules/color-convert/conversions.js","shasum":"50fbbafede5e11cbf00f774274d82d7c642ae4ee","modified":1452208022000},{"_id":"themes/yelee/node_modules/color-convert/css-keywords.js","shasum":"1cc46ce6700efa9f1e28658f7711f66be4d05849","modified":1452208022000},{"_id":"themes/yelee/node_modules/color-convert/index.js","shasum":"21aa2caa71a73a374ee8eb218a384bacc5c1a60c","modified":1452208022000},{"_id":"themes/yelee/node_modules/color-convert/package.json","shasum":"e30a256ecee34136cda2e3d0fe4bddfa3ebe59ea","modified":1456469177000},{"_id":"themes/yelee/node_modules/color-convert/route.js","shasum":"9b51ec58ff46f37687d76e7e77139c7567ed1483","modified":1452208022000},{"_id":"themes/yelee/node_modules/colors/LICENSE","shasum":"341480159e4c6e291a492a441fe69081d671e85d","modified":1430290937000},{"_id":"themes/yelee/node_modules/colors/ReadMe.md","shasum":"3e22ae665134396b6dcd45ec5c2c750ad98c00d9","modified":1434545826000},{"_id":"themes/yelee/node_modules/colors/examples/normal-usage.js","shasum":"8da0b32e0ce469a8fbadf4d3fe93c259447368e4","modified":1434545263000},{"_id":"themes/yelee/node_modules/colors/examples/safe-string.js","shasum":"60552d817643905fde3839ae9d93f7c933f8af89","modified":1416873262000},{"_id":"themes/yelee/node_modules/colors/lib/colors.js","shasum":"856e1a49d90ba1d9a53bbff307e27ecb677ecff9","modified":1434545520000},{"_id":"themes/yelee/node_modules/colors/lib/custom/zalgo.js","shasum":"73b50e3646fb82e15b321067d3e0353529fbcc6c","modified":1434545520000},{"_id":"themes/yelee/node_modules/colors/lib/custom/trap.js","shasum":"391f769b8dd1a77b7c8ea1a76817b4e265cc6f38","modified":1416873262000},{"_id":"themes/yelee/node_modules/colors/lib/extendStringPrototype.js","shasum":"cbb6181b5cbccd38a97457cf58716781fa9f32d8","modified":1434545843000},{"_id":"themes/yelee/node_modules/colors/lib/index.js","shasum":"55f38c877985406790f063965cb600ae2a6f1492","modified":1434545520000},{"_id":"themes/yelee/node_modules/colors/lib/maps/america.js","shasum":"45f3d39d744cc14040d4d62757b412b169cf2efc","modified":1416873262000},{"_id":"themes/yelee/node_modules/colors/lib/maps/rainbow.js","shasum":"014697741d559ea1dce3a5a27b9ba27b7241355c","modified":1416873262000},{"_id":"themes/yelee/node_modules/colors/lib/maps/random.js","shasum":"50ac05ea88379162110f19cf3c441fa282956e73","modified":1416873262000},{"_id":"themes/yelee/node_modules/colors/lib/maps/zebra.js","shasum":"5f6caffb4012ae13e8f36302a03cf27a7e593d89","modified":1416873262000},{"_id":"themes/yelee/node_modules/colors/lib/styles.js","shasum":"a06697bab0a191e7961b855e767bbafacb25737a","modified":1416873262000},{"_id":"themes/yelee/node_modules/colors/lib/system/supports-colors.js","shasum":"65ce27a33eccf3e698c49de9c94b6ffef349ca97","modified":1416873262000},{"_id":"themes/yelee/node_modules/colors/package.json","shasum":"00254d8912edcc7ec9322204c2e68b6e326cebf8","modified":1456469177000},{"_id":"themes/yelee/node_modules/colors/safe.js","shasum":"65698ffe95c229962bb1c212eb971401eaeb0b62","modified":1416873262000},{"_id":"themes/yelee/node_modules/colors/themes/generic-logging.js","shasum":"ea9fb8f704581e751d85767563a3dcd826ead0e6","modified":1416873262000},{"_id":"themes/yelee/node_modules/combined-stream/License","shasum":"04e7b761eee5270ea8914303516852faf990394b","modified":1403594961000},{"_id":"themes/yelee/node_modules/combined-stream/Readme.md","shasum":"9a4115c7973388087b21e93e1c538371e5f94ce9","modified":1434294512000},{"_id":"themes/yelee/node_modules/combined-stream/lib/combined_stream.js","shasum":"5d3a85a28a463dc2949fbb974919598e00183d24","modified":1434294512000},{"_id":"themes/yelee/node_modules/combined-stream/package.json","shasum":"30db86ea52fc01a0307759304df880cb92b88cb5","modified":1456469176000},{"_id":"themes/yelee/node_modules/commander/History.md","shasum":"386cc2f8d7b3b54307b7056a57fc4516402aa894","modified":1444749720000},{"_id":"themes/yelee/node_modules/commander/LICENSE","shasum":"63513188251d15fcdc716703fbee89be4a3a20e6","modified":1444531073000},{"_id":"themes/yelee/node_modules/commander/Readme.md","shasum":"af810334e87894faf80bd73d9e207c9d5f2b3c90","modified":1444531073000},{"_id":"themes/yelee/node_modules/commander/package.json","shasum":"400fe91af9ab6c100c8a5b3e50fea3dfe7b28953","modified":1456469176000},{"_id":"themes/yelee/node_modules/commander/index.js","shasum":"5adc820ea125a479f7fa597cfe2083eeede0dd2b","modified":1444748408000},{"_id":"themes/yelee/node_modules/concat-map/LICENSE","shasum":"b2e68ce937c1f851926f7e10280cc93221d4f53c","modified":1391050985000},{"_id":"themes/yelee/node_modules/concat-map/README.markdown","shasum":"132e6e8fd1d19ec2422fdcde00840d8237e44094","modified":1354099276000},{"_id":"themes/yelee/node_modules/concat-map/example/map.js","shasum":"022a614b8d9f5ccb67b6ce1f478b1efd7aff298e","modified":1339124034000},{"_id":"themes/yelee/node_modules/concat-map/index.js","shasum":"a3063f014cc693b320dbd64de3243a79247c1e05","modified":1354939769000},{"_id":"themes/yelee/node_modules/concat-map/package.json","shasum":"ddb8574b39d495063d244adc399cf16b768662d5","modified":1456469176000},{"_id":"themes/yelee/node_modules/concat-map/test/map.js","shasum":"162cce32c23628192cef64924a1ce768af399a4b","modified":1354099176000},{"_id":"themes/yelee/node_modules/core-util-is/README.md","shasum":"d4987293f1078d937454a14a5ca6f386d227679d","modified":1447978999000},{"_id":"themes/yelee/node_modules/core-util-is/LICENSE","shasum":"a95471326a84657b0e164f84e1285685f63011e0","modified":1447979068000},{"_id":"themes/yelee/node_modules/core-util-is/float.patch","shasum":"d7f073ceb05c6f6dd1bb852fc00f5379a3e41301","modified":1447978999000},{"_id":"themes/yelee/node_modules/core-util-is/lib/util.js","shasum":"7d34435928ee9228995c04eaa7bdcef875c41e65","modified":1447979840000},{"_id":"themes/yelee/node_modules/core-util-is/test.js","shasum":"2837ee1d57f385943ba5ccc7fd0ec4ed1cb8cfdd","modified":1447979358000},{"_id":"themes/yelee/node_modules/core-util-is/package.json","shasum":"1606eb5e25b8f94ceaf82b5deaeb4fcbe8a4d6bd","modified":1456469176000},{"_id":"themes/yelee/node_modules/cryptiles/LICENSE","shasum":"2d1840f1b4088e3a370317c82e7b443321f2b2eb","modified":1441778892000},{"_id":"themes/yelee/node_modules/cryptiles/README.md","shasum":"52c9561e75f66870d194d12ac07c05bc0484df18","modified":1441778892000},{"_id":"themes/yelee/node_modules/cryptiles/lib/index.js","shasum":"e5c479d1d0966b82298d86669aaa5ed4bcee4fb7","modified":1441778892000},{"_id":"themes/yelee/node_modules/cryptiles/package.json","shasum":"49a3fbd3e688fdf5519bbfa0da492444718ff742","modified":1456469176000},{"_id":"themes/yelee/node_modules/cryptiles/test/index.js","shasum":"c4d4151097d486ade0ee21bfd91297dafda16e88","modified":1441778892000},{"_id":"themes/yelee/node_modules/dashdash/README.md","shasum":"e40739349732594d5d96438bd27aa444915d3f79","modified":1453144686000},{"_id":"themes/yelee/node_modules/dashdash/etc/dashdash.bash_completion.in","shasum":"cbb2d2c1c856735b5555384080853f896aac9c61","modified":1453144686000},{"_id":"themes/yelee/node_modules/dashdash/node_modules/assert-plus/AUTHORS","shasum":"d1d14de8fc8c21f9f86c2231df2531381f6a9194","modified":1453918488000},{"_id":"themes/yelee/node_modules/dashdash/lib/dashdash.js","shasum":"0398a1a799416107c41d667c3d397a60e740fada","modified":1455248872000},{"_id":"themes/yelee/node_modules/dashdash/node_modules/assert-plus/CHANGES.md","shasum":"b27cef2253f8ff8a83584bf1a55cec9d4dfbf517","modified":1453920717000},{"_id":"themes/yelee/node_modules/dashdash/node_modules/assert-plus/README.md","shasum":"d6771de291034391f0ec79175fff3428ed6d82b8","modified":1453920717000},{"_id":"themes/yelee/node_modules/dashdash/node_modules/assert-plus/assert.js","shasum":"8103ced007b61b3e45a420607de576faf7e1e0e4","modified":1453920717000},{"_id":"themes/yelee/node_modules/dashdash/node_modules/assert-plus/package.json","shasum":"950532164194e2d5255d0db67bdbdf79e6933dc8","modified":1456469176000},{"_id":"themes/yelee/node_modules/dashdash/package.json","shasum":"2d642c650936610061d0c171c56047732c23d802","modified":1456469176000},{"_id":"themes/yelee/node_modules/delayed-stream/License","shasum":"04e7b761eee5270ea8914303516852faf990394b","modified":1430160212000},{"_id":"themes/yelee/node_modules/delayed-stream/Makefile","shasum":"1d88cf18c0fef56e91425a086590e31271a7c4d5","modified":1430160212000},{"_id":"themes/yelee/node_modules/delayed-stream/Readme.md","shasum":"21db9b7ec97b7028a031a18867aab00575b09850","modified":1430160212000},{"_id":"themes/yelee/node_modules/delayed-stream/lib/delayed_stream.js","shasum":"097ab12e3837896d11d3f1d2c7a891d177b493c4","modified":1430160544000},{"_id":"themes/yelee/node_modules/delayed-stream/package.json","shasum":"bd88f3d64fc3f22960faa7e0519c99af96631a08","modified":1456469176000},{"_id":"themes/yelee/node_modules/ecc-jsbn/LICENSE","shasum":"d9dddd103d636dbaa178cd222de612fd923f62da","modified":1393978405000},{"_id":"themes/yelee/node_modules/ecc-jsbn/README.md","shasum":"97cb1bdec48ebb5e46e64fc5441c79d3d38a3c82","modified":1408853444000},{"_id":"themes/yelee/node_modules/ecc-jsbn/index.js","shasum":"13c052ad0b0507a4203d5d1274fdfa049a6c1339","modified":1448288282000},{"_id":"themes/yelee/node_modules/ecc-jsbn/lib/LICENSE-jsbn","shasum":"4f94910918b5e57f3e55c7387f43b0d6293a4319","modified":1394075812000},{"_id":"themes/yelee/node_modules/ecc-jsbn/lib/sec.js","shasum":"b1632526290dfddc063f05ac6ed29cc40bd9e221","modified":1448288300000},{"_id":"themes/yelee/node_modules/ecc-jsbn/lib/ec.js","shasum":"d9a60c831fe91bd2c62ff3e3c9675b0379ef504c","modified":1448288163000},{"_id":"themes/yelee/node_modules/ecc-jsbn/package.json","shasum":"ce1de4515ffd719e5fa24a30ad1324f7d643482a","modified":1456469177000},{"_id":"themes/yelee/node_modules/ecc-jsbn/test.js","shasum":"9709f584f556ceb8acaa0fd746029dcb58390eb4","modified":1408853485000},{"_id":"themes/yelee/node_modules/ent/LICENSE","shasum":"b2e68ce937c1f851926f7e10280cc93221d4f53c","modified":1420933654000},{"_id":"themes/yelee/node_modules/ent/decode.js","shasum":"c5f610c056660b0219923f8389bd7527e4207c2e","modified":1421263455000},{"_id":"themes/yelee/node_modules/ent/encode.js","shasum":"e325db89d085cb99dc98cf35dd539b3dfd9476e8","modified":1421374712000},{"_id":"themes/yelee/node_modules/ent/examples/simple.js","shasum":"4b87242731b0e84c67602f3c0d029039018e4065","modified":1420933654000},{"_id":"themes/yelee/node_modules/ent/index.js","shasum":"84ae412e9c6729bf7b397740ca981037cd80258f","modified":1420933988000},{"_id":"themes/yelee/node_modules/ent/entities.json","shasum":"9d9bd43412b55eaf2eb9126d77f9a5c8aec62ee1","modified":1421443100000},{"_id":"themes/yelee/node_modules/ent/package.json","shasum":"5fe5b02303562ff6a44e688e6ae13afac428dcfe","modified":1456469177000},{"_id":"themes/yelee/node_modules/ent/readme.markdown","shasum":"a9bf022f1841c566e8ec8a17e3e324ae41038612","modified":1421374877000},{"_id":"themes/yelee/node_modules/ent/test/codes.js","shasum":"969271fbb8fc79b57e0543cc7663cc98cf4618d2","modified":1421374306000},{"_id":"themes/yelee/node_modules/ent/reversed.json","shasum":"55ad9b99021eef02691e15bb0bb78f0969a86ca9","modified":1421443100000},{"_id":"themes/yelee/node_modules/ent/test/hex.js","shasum":"af471bdcc663c60e1d010428f9c525893d48ed82","modified":1420933654000},{"_id":"themes/yelee/node_modules/ent/test/num.js","shasum":"65311e12e302cae8b891727701f7709adc6a0745","modified":1420933654000},{"_id":"themes/yelee/node_modules/escape-string-regexp/index.js","shasum":"17b40cc4dc8a455277994ab351c0650215394042","modified":1456057032000},{"_id":"themes/yelee/node_modules/escape-string-regexp/license","shasum":"0c94f137f6e0536db8cb2622a9dc84253b91b90c","modified":1403645654000},{"_id":"themes/yelee/node_modules/escape-string-regexp/readme.md","shasum":"b693d3ddaf0a2edac02f8dc9b60382f7a818083e","modified":1456057032000},{"_id":"themes/yelee/node_modules/escape-string-regexp/package.json","shasum":"4340bee90cbc410b6ce7a5d18434210f0cc48e52","modified":1456469176000},{"_id":"themes/yelee/node_modules/expand-brackets/LICENSE","shasum":"7e21c9f5aa0a1be61e943a935506095ea40bbafc","modified":1423173787000},{"_id":"themes/yelee/node_modules/expand-brackets/README.md","shasum":"6480b9a4aea618ca0008d55c604c8747db80589b","modified":1438464589000},{"_id":"themes/yelee/node_modules/expand-brackets/index.js","shasum":"d30cf1aa96d67d4b1d52a9234e04cdc7b2718980","modified":1440148604000},{"_id":"themes/yelee/node_modules/expand-brackets/package.json","shasum":"c7959e77e754fe6af212768bdfc72352f466b462","modified":1456469176000},{"_id":"themes/yelee/node_modules/expand-range/LICENSE","shasum":"d99d5158898474f25efb4c8790f9fcc4cf55b350","modified":1421022684000},{"_id":"themes/yelee/node_modules/expand-range/README.md","shasum":"ca34ffedbd376b5fa552f6e1778f357e073779f9","modified":1422624444000},{"_id":"themes/yelee/node_modules/expand-range/index.js","shasum":"c1b5fe07de2d7fbc35440eccba98d542eea988e1","modified":1424034813000},{"_id":"themes/yelee/node_modules/expand-range/package.json","shasum":"005bcab4cb0ef8198273f6120e4e2637dacec750","modified":1456469176000},{"_id":"themes/yelee/node_modules/extend/CHANGELOG.md","shasum":"782aabec0278f6500fbedf61e29a5a0d748c78fb","modified":1435783518000},{"_id":"themes/yelee/node_modules/extend/LICENSE","shasum":"bed93ae1abcd71e5d1c9c363595dd24bb1b9016c","modified":1435780828000},{"_id":"themes/yelee/node_modules/extend/README.md","shasum":"4bce70a4b2e7dda8a760418301a4622c0557bae9","modified":1435780828000},{"_id":"themes/yelee/node_modules/extend/component.json","shasum":"07af5d609ee23647ce3238a0e1322c35b385fc45","modified":1435783532000},{"_id":"themes/yelee/node_modules/extend/index.js","shasum":"9154a195afa931672ff49f30d5fdf0c5a10614bc","modified":1435780828000},{"_id":"themes/yelee/node_modules/extend/package.json","shasum":"8e2f886a2b4b751deeebc1f99bb63257160731e9","modified":1456469177000},{"_id":"themes/yelee/node_modules/extglob/LICENSE","shasum":"f6794e2167dc92e7ab5f2b00a15f0af45639a5a1","modified":1429345875000},{"_id":"themes/yelee/node_modules/extglob/README.md","shasum":"ac4514f62a9bbf39090ca79839a0cc9a95d8e810","modified":1438459882000},{"_id":"themes/yelee/node_modules/extglob/index.js","shasum":"c330dc0091d0f58e6a22455c1dc1ad5796013bbd","modified":1453279404000},{"_id":"themes/yelee/node_modules/extglob/package.json","shasum":"f56a678bfb92ff0177dc866c312d975fd89d9eb0","modified":1456469176000},{"_id":"themes/yelee/node_modules/extsprintf/LICENSE","shasum":"772b18147b3bf826978f984f8e01562a9e3cc254","modified":1360175237000},{"_id":"themes/yelee/node_modules/extsprintf/Makefile","shasum":"88eff1bf9d8152cf847e0720e384a4a84418082f","modified":1360175237000},{"_id":"themes/yelee/node_modules/extsprintf/Makefile.deps","shasum":"f27b6650501f14e21f8ce186476537d0e2f3e026","modified":1360175237000},{"_id":"themes/yelee/node_modules/extsprintf/Makefile.targ","shasum":"f66e38899fc918aac830c478ae402c66d8793bc7","modified":1360175237000},{"_id":"themes/yelee/node_modules/extsprintf/README.md","shasum":"e06a0c86165e03cf3170be3f4e5b7dfd5c7eca5f","modified":1360175237000},{"_id":"themes/yelee/node_modules/extsprintf/examples/simple.js","shasum":"5e7b4892b3625f689d9dcb5fd2e43140f21d66a4","modified":1360175237000},{"_id":"themes/yelee/node_modules/extsprintf/jsl.node.conf","shasum":"7197578b829d6c93d8356bf114c7f3d26722ec0b","modified":1360175237000},{"_id":"themes/yelee/node_modules/extsprintf/lib/extsprintf.js","shasum":"cfe80b99a5d428a0f357ae11e0a067c46ebdbb2c","modified":1360175237000},{"_id":"themes/yelee/node_modules/extsprintf/package.json","shasum":"db62245d197bd87344c951442fcb70ba5a765298","modified":1456469177000},{"_id":"themes/yelee/node_modules/filename-regex/README.md","shasum":"6f7b2600f371413b90ac67824993d73f8e209664","modified":1422107084000},{"_id":"themes/yelee/node_modules/filename-regex/index.js","shasum":"0c901dd7fd6cedfd15f2c1fea2cbf3efb3837aaf","modified":1422106871000},{"_id":"themes/yelee/node_modules/filename-regex/package.json","shasum":"596e9c72d78eaffc1408a728196e7d3016d62420","modified":1456469176000},{"_id":"themes/yelee/node_modules/fill-range/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1428396142000},{"_id":"themes/yelee/node_modules/fill-range/README.md","shasum":"846adfe3de4ed18174b00fd079e3704daab075e9","modified":1428396632000},{"_id":"themes/yelee/node_modules/fill-range/index.js","shasum":"5ddcbe607a51a43d05eecfc9fe333a96005e91e1","modified":1449439890000},{"_id":"themes/yelee/node_modules/fill-range/package.json","shasum":"cca77ad2c3d70614d529cc9af6ff1cbbb9b31570","modified":1456469176000},{"_id":"themes/yelee/node_modules/for-in/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1427178221000},{"_id":"themes/yelee/node_modules/for-in/README.md","shasum":"12359b5563a9d991e3b8a6a379cbba30a23a37fb","modified":1427178003000},{"_id":"themes/yelee/node_modules/for-in/index.js","shasum":"691db06522e53f8d10f7c2c147bebe4addd16f32","modified":1427178221000},{"_id":"themes/yelee/node_modules/for-in/package.json","shasum":"4a7534e3f366d3226aef81234697146dca403cad","modified":1456469176000},{"_id":"themes/yelee/node_modules/for-own/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1427178102000},{"_id":"themes/yelee/node_modules/for-own/README.md","shasum":"7f75457c2e068515e4f3f46458fb490333f27568","modified":1427178013000},{"_id":"themes/yelee/node_modules/for-own/index.js","shasum":"a015403a1ef9e5270327e876f852930b66c25ac3","modified":1427178102000},{"_id":"themes/yelee/node_modules/for-own/package.json","shasum":"ad2a88e6e9af65fba7215e05985ff0932723ecbc","modified":1456469176000},{"_id":"themes/yelee/node_modules/forever-agent/LICENSE","shasum":"05979f0750cf5c2a17bd3aa12450849c151d8b7c","modified":1426938522000},{"_id":"themes/yelee/node_modules/forever-agent/README.md","shasum":"fd2b1d08b55284aa2abc72d199e3c487744a0c31","modified":1426938522000},{"_id":"themes/yelee/node_modules/forever-agent/package.json","shasum":"b1a47ec08823dc7a71451992aaa69e6a114522a8","modified":1456469176000},{"_id":"themes/yelee/node_modules/forever-agent/index.js","shasum":"a96917d5912eef5a8ed12a4b1f3a41400eac80d1","modified":1428426146000},{"_id":"themes/yelee/node_modules/form-data/Readme.md","shasum":"6af9e2006617a38c1f5ce1186ca9069cacbe2bf1","modified":1438228280000},{"_id":"themes/yelee/node_modules/form-data/License","shasum":"1d11381521bdc7e7df9bb1d7bf85341ffca266d9","modified":1438228280000},{"_id":"themes/yelee/node_modules/form-data/lib/browser.js","shasum":"79f01a7616f6247aa3e55a73602e477cbe15a7a5","modified":1438228280000},{"_id":"themes/yelee/node_modules/form-data/package.json","shasum":"1712d72478bde15199f65b56577a6bb008a6d3e5","modified":1456469176000},{"_id":"themes/yelee/node_modules/form-data/lib/form_data.js","shasum":"a7aca54a95311cd44da040f8c5429fd649c06b2a","modified":1438228280000},{"_id":"themes/yelee/node_modules/fsevents/LICENSE","shasum":"aff99c3b222af6dc2cc4d713ee6f46de6febcb4e","modified":1426989723000},{"_id":"themes/yelee/node_modules/fsevents/Readme.md","shasum":"58a6326efbb8b6403f97e535abff0c305d8a2bbb","modified":1449701320000},{"_id":"themes/yelee/node_modules/fsevents/binding.gyp","shasum":"f1bf70a0822fc2b333fc4b9202dd1c3bbb7052b8","modified":1441767349000},{"_id":"themes/yelee/node_modules/fsevents/fsevents.cc","shasum":"50afb7dd154c23daefef0b5432d85c90e0bc75fd","modified":1441032660000},{"_id":"themes/yelee/node_modules/fsevents/fsevents.js","shasum":"db803a36632d843d8cc5dc5a73f19df73d5d4b17","modified":1446645410000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi/History.md","shasum":"e08a586cfeff13f78415131ab12dc59047625b8f","modified":1452816446000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi/LICENSE","shasum":"29e2ec2d24a38c009dfb6f3c1b8d1b57e3ec492b","modified":1452816251000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi/README.md","shasum":"95d1873583f32730c8ffa1ff463b2cadf08f2667","modified":1442006415000},{"_id":"themes/yelee/node_modules/fsevents/lib/binding/Release/node-v47-darwin-x64/fse.node","shasum":"e225f2763b760583692ccfdfc87788af7b334b65","modified":1456188282000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi/examples/beep/index.js","shasum":"aab8b4f5c513d02b3be10dfc4c73c93e16c042e3","modified":1426184022000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi/examples/clear/index.js","shasum":"7b00443efe706b7ac20e843515087b4b379d5e16","modified":1426184022000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi/examples/cursorPosition.js","shasum":"e4d4c5f329672a2b8e58047f56765a59502699c4","modified":1442006415000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi/examples/progress/index.js","shasum":"24cdce431211efc73ae6cc61aba05a6c3e8c29f7","modified":1426184022000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi/lib/ansi.js","shasum":"eac25e4f75b684ce56d7091d60fe4fb7bf26e8b2","modified":1442006415000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi/lib/newlines.js","shasum":"9bfaff398370f329734fb275c5f0d7733d76918b","modified":1426184022000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi/package.json","shasum":"1c3a2ead959a5437de677020b072bcc2ef05c112","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi-regex/index.js","shasum":"03d6a4cc534cbb9a855b01b372a17bfa2b830442","modified":1435679868000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi-regex/package.json","shasum":"e37a019fd02f5c738100e01ccc319c8dc068efe4","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi-regex/readme.md","shasum":"76c119f1cf0605a0409f9c2756de3e55a1398fc2","modified":1435679915000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi-styles/index.js","shasum":"7e89eee4c6711e897597268d129348b685cc6548","modified":1435756896000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi-styles/package.json","shasum":"92995f73cfd26108fa2a01fbc78ddb71529e6630","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ansi-styles/readme.md","shasum":"b12348b9ea14a18112719b1aad4cdf7e52f4b35f","modified":1435756896000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/are-we-there-yet/LICENSE","shasum":"13b22b5c5f89edc3f31e092b7298cd65687e7250","modified":1449362748000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/are-we-there-yet/README.md","shasum":"904b624ad7c2b8695b03e06701437b8913081c8b","modified":1449362911000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/are-we-there-yet/index.js","shasum":"06a843e3f97d2de36d147082ef3b5a1fdc7b741a","modified":1453935680000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/are-we-there-yet/package.json","shasum":"c322dcdf2d099577a77acd772485cb60d26dfd97","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/are-we-there-yet/test/tracker.js","shasum":"6c1682be5b99645e4910a304a048b4ca1b783f01","modified":1417811068000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/are-we-there-yet/test/trackergroup.js","shasum":"487907a04231f9792f01fa576421e3a8819e9b36","modified":1418025000000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/are-we-there-yet/test/trackerstream.js","shasum":"687a590ad8880527b812df27430542c5cdd8a64b","modified":1428037437000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/asn1/LICENSE","shasum":"724e48cfc739674999ff82b4e49d76d5376818e9","modified":1401981220000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/asn1/README.md","shasum":"71e6a47944ebaefe5d5357a7b6f46df9c389316f","modified":1401981220000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/asn1/lib/ber/errors.js","shasum":"556bbb1b810ede9292493a70ad9a8644e5c4fb7a","modified":1401981220000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/asn1/lib/ber/index.js","shasum":"1ab39535ed24903d0f9e2a4bf74333702842080b","modified":1401981220000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/asn1/lib/ber/reader.js","shasum":"3cfcdc9225bb43dd8413dc3f1f05d4fcd32d0b30","modified":1443646115000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/asn1/lib/ber/types.js","shasum":"8a41886747dc1f7cde7e4e5cb60e1a3b8a4c813c","modified":1401981220000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/asn1/lib/ber/writer.js","shasum":"bdad4a0bb12fb5f91b789329fc4e4a45ecf87e64","modified":1443646115000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/asn1/lib/index.js","shasum":"cbff145d47fb41eb1262f012a7024e7b0e527d6c","modified":1401981220000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/asn1/package.json","shasum":"fcde168b164423805f164103716f7f1469f8a601","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/asn1/tst/ber/reader.test.js","shasum":"de84b2d7317393c6e6a0cdef04bfbff82ba78237","modified":1401981220000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/asn1/tst/ber/writer.test.js","shasum":"59892680384339812688163b346d12cc05e979fd","modified":1401981220000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/assert-plus/AUTHORS","shasum":"d1d14de8fc8c21f9f86c2231df2531381f6a9194","modified":1446952976000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/assert-plus/CHANGES.md","shasum":"b64b8d16f3858a1c3d55538c5bfee934437af75b","modified":1447141659000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/assert-plus/README.md","shasum":"79988e7cb3bb80b7cc20dc420ee2a7f86ab3d3e0","modified":1446952976000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/assert-plus/assert.js","shasum":"8f3f85bae8edd30db24882766a5c8c4df8357462","modified":1447140668000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/assert-plus/package.json","shasum":"db88399340e0921559c2b2ce1c055da38f49bef5","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/async/dist/async.min.js","shasum":"487f1a1adb0bf6b00233edb64e64f2fb305ce5a3","modified":1452211452000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/async/dist/async.js","shasum":"a410bed1e8c6a19be68101c293ff66c4961076ae","modified":1452211451000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/async/README.md","shasum":"1e5c0380861222c007090d0c0a1d8ca4f5272dc5","modified":1452208687000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/async/package.json","shasum":"0b83cf81e68d8e876a12c0fe95f538e4a1b18461","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/async/lib/async.js","shasum":"a410bed1e8c6a19be68101c293ff66c4961076ae","modified":1452207555000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws-sign2/README.md","shasum":"5e8e0e7c811b1f319c0e94ff08f38ecf4896e3c9","modified":1366607619000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws-sign2/LICENSE","shasum":"05979f0750cf5c2a17bd3aa12450849c151d8b7c","modified":1366607619000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws-sign2/index.js","shasum":"b380be041c204108febb8f32b19431a54aaed4a6","modified":1444584231000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws-sign2/package.json","shasum":"db83c21a1138b3d557a0213d11b0f3b1e61aadf1","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/LICENSE","shasum":"9ba903f14c37d0ab0250a8e6920e7269bdc5b294","modified":1384232184000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/aws4.js","shasum":"4155d86150b56a456a7b90fb55a82b8e9e3fc666","modified":1451426937000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/README.md","shasum":"8b02542186fe300b27acd3aba5c65b77a3d822e3","modified":1426551080000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/example.js","shasum":"4da6b34b39625ad7b9c788f6c2ebac1f80531520","modified":1426551098000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/node_modules/lru-cache/CONTRIBUTORS","shasum":"6a6e5148568ff15b4756ee478f0da581ea97fc01","modified":1385053079000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/node_modules/lru-cache/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1431999527000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/node_modules/lru-cache/README.md","shasum":"129fd032ba2ac7580e57e0d9988a4d06f1b344fd","modified":1448474798000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/node_modules/lru-cache/lib/lru-cache.js","shasum":"d4091806568fef3089f4522f09d5976d91912dd4","modified":1448475000000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/node_modules/lru-cache/package.json","shasum":"05bfe76c8a7f6ec3ac09a087013436dac514a32e","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/node_modules/lru-cache/test/basic.js","shasum":"caffd5539b398fb1f369ed259c14dc4d00eda244","modified":1448474452000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/node_modules/lru-cache/test/foreach.js","shasum":"5493ce987892f9c740837c36acd5240d9cf93644","modified":1448413217000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/node_modules/lru-cache/test/memory-leak.js","shasum":"5b5690f4e32c4d2fc501e7f408fdcfd25f8b4e3a","modified":1435688444000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/node_modules/lru-cache/test/serialize.js","shasum":"6383a06c3f56cce6eb364b66f2301eea00db5828","modified":1448474452000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/bl/LICENSE.md","shasum":"d068ae801f9277b4b248f0c2aad7f50181dacaad","modified":1453181857000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/aws4/package.json","shasum":"b1935d934d7f07bc6757ad70c477060c3673004c","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/bl/README.md","shasum":"4308d9ba8f28872911d3e4f8b3de6b56b47be042","modified":1453181864000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/bl/bl.js","shasum":"640a8dd3791d6962ef2d968a5f89fb06adf01314","modified":1453181857000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/bl/package.json","shasum":"11622a3a326df275982b0e19b2f8b4a216c623e1","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/LICENCE","shasum":"fbc159c463d7717ec1acff3d8b6524d0ce74f2a7","modified":1331939706000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/bl/test/test.js","shasum":"809ed5ce6857e95b00d1247de5d98d2fc31e9da6","modified":1453182317000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1432105388000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/README.md","shasum":"165520dbb78c0d401c0cbc3efc33753b9737d2f0","modified":1317956974000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/bench/block-stream-pause.js","shasum":"67df5f7f0f8ad86ee6fdddbe6bea1aa28c6ac6eb","modified":1318903909000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/bench/block-stream.js","shasum":"42821f2fe9db3e4d0f9c51f5a9f7b20423a418fd","modified":1318896987000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/bench/dropper-pause.js","shasum":"982774d6076efbbd7b20cd8ae1adbe84223da254","modified":1318903105000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/bench/dropper.js","shasum":"dd1925e4c2ace4e86d1d1f2c9bff66b425b7e0b7","modified":1318897004000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/block-stream.js","shasum":"60770fccf771c6d03441efebf62fb257473c163a","modified":1366232220000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/package.json","shasum":"50530cbb5162ec6d06ff5f0c6c05f5767dc6db42","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/test/basic.js","shasum":"278c9b462db9ef2c6f9815ffc97764cf3be7ab48","modified":1317959661000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/test/nopad-thorough.js","shasum":"ff5f326b21707010825647d3ff6f0f28efbaa308","modified":1320791299000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/test/nopad.js","shasum":"353fea96f0c506e06114d9480a4feb5d5b397d07","modified":1318891657000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/test/pause-resume.js","shasum":"dc1f099b749cf4c0e93b55ea6f378d8d89012977","modified":1320791299000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/test/thorough.js","shasum":"e1b1f164bcdb11255e32d11a8a80cc7f60d27edf","modified":1320791299000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/boom/CONTRIBUTING.md","shasum":"61998267d75f17fdd423c1c742edc20a1561c1e2","modified":1411478104000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/block-stream/test/two-stream.js","shasum":"2d8e79865c92715133159a698d36b57176d6eb2b","modified":1340227457000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/boom/LICENSE","shasum":"53ded9fedb90236c92321a45d1ab00fa35f282d8","modified":1407506005000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/boom/README.md","shasum":"2d7368cd181df38d42b300f04f7323cc16f9b7d2","modified":1446232305000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/boom/lib/index.js","shasum":"a894f6f39fc0bf0f8a82a420d8a2a5018e9dcdbe","modified":1446232305000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/boom/images/boom.png","shasum":"126fe71d237c4939338507417d5f5e172773be3e","modified":1407506005000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/boom/package.json","shasum":"388f74028d643724aea014611f94543163009684","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/caseless/LICENSE","shasum":"48f9e0a4c07f36c07d47962212fe022d0417c90f","modified":1435268329000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/caseless/README.md","shasum":"5770b9496fb480f7c403b6c38759a27d6170e882","modified":1414608769000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/boom/test/index.js","shasum":"62d76a920212e160acf6894f1ee3e981e6aaa8b1","modified":1446232305000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/caseless/index.js","shasum":"326fc25f6edec25f7d239314ed6e75259147088a","modified":1424972076000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/caseless/package.json","shasum":"164a637829712e1e9db74fc3ef2a6fd1e389f304","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/caseless/test.js","shasum":"73948ff77c144352fb9d9615079ee35cab781912","modified":1414609010000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/chalk/index.js","shasum":"08315806beaa18a4eb58052e8e7182b2d8bddf8f","modified":1440014707000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/chalk/package.json","shasum":"c799d83da65131ce275f4fa4812fae791c1d26da","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/chalk/readme.md","shasum":"a10251893e1a61957a4c7238001e682d20d46d47","modified":1440014506000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/combined-stream/License","shasum":"04e7b761eee5270ea8914303516852faf990394b","modified":1403594961000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/combined-stream/Readme.md","shasum":"9a4115c7973388087b21e93e1c538371e5f94ce9","modified":1434294512000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/combined-stream/package.json","shasum":"7f1aeae32ba6f1686a2309d30c54fe15827d203d","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/combined-stream/lib/combined_stream.js","shasum":"5d3a85a28a463dc2949fbb974919598e00183d24","modified":1434294512000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/commander/Readme.md","shasum":"af810334e87894faf80bd73d9e207c9d5f2b3c90","modified":1444531073000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/commander/index.js","shasum":"5adc820ea125a479f7fa597cfe2083eeede0dd2b","modified":1444748408000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/commander/package.json","shasum":"f5f6f74806957cad71b97fc05868ceab32b058eb","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/core-util-is/LICENSE","shasum":"a95471326a84657b0e164f84e1285685f63011e0","modified":1447979068000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/core-util-is/README.md","shasum":"d4987293f1078d937454a14a5ca6f386d227679d","modified":1447978999000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/core-util-is/float.patch","shasum":"d7f073ceb05c6f6dd1bb852fc00f5379a3e41301","modified":1447978999000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/core-util-is/lib/util.js","shasum":"7d34435928ee9228995c04eaa7bdcef875c41e65","modified":1447979840000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/core-util-is/package.json","shasum":"134308c1ab5eef494b32a215bf6465211e44bb9a","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/core-util-is/test.js","shasum":"2837ee1d57f385943ba5ccc7fd0ec4ed1cb8cfdd","modified":1447979358000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/cryptiles/LICENSE","shasum":"2d1840f1b4088e3a370317c82e7b443321f2b2eb","modified":1441778892000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/cryptiles/README.md","shasum":"52c9561e75f66870d194d12ac07c05bc0484df18","modified":1441778892000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/cryptiles/lib/index.js","shasum":"e5c479d1d0966b82298d86669aaa5ed4bcee4fb7","modified":1441778892000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/cryptiles/package.json","shasum":"039277bac5be9d7a8b335d77f74e185fc437ca10","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/cryptiles/test/index.js","shasum":"c4d4151097d486ade0ee21bfd91297dafda16e88","modified":1441778892000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/dashdash/README.md","shasum":"e40739349732594d5d96438bd27aa444915d3f79","modified":1453144686000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/dashdash/etc/dashdash.bash_completion.in","shasum":"cbb2d2c1c856735b5555384080853f896aac9c61","modified":1453144686000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/dashdash/lib/dashdash.js","shasum":"ee9836b6bb5625fd29fb95483214d7e679f96c8c","modified":1453144686000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/dashdash/package.json","shasum":"96d3541187b96ec4a1352fc22881bd893b576deb","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/debug/History.md","shasum":"b468a2f1d58147ab41c4b817d4aa627ad13c7018","modified":1431199973000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/debug/Makefile","shasum":"6521581191ac9a04ee418c5f2e3b05042421eed7","modified":1431199632000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/debug/Readme.md","shasum":"a5c1b396924aa2101e501543bfe9750bdf2f9480","modified":1431199632000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/debug/bower.json","shasum":"d66ecb3b7d22df8fcc8936a18f1e3b9261808cb8","modified":1431242465000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/debug/browser.js","shasum":"36202f55a9cbc03b8d10bc9b14748eb00a79a419","modified":1431199632000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/debug/component.json","shasum":"b31ef70de11fdd63030cb49b2c8e50bbf54f1ae2","modified":1431242465000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/debug/debug.js","shasum":"bb692db9f1b4e06986755b168fa71c1bd360edb8","modified":1408510177000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/debug/node.js","shasum":"30354b578cac8fc83d13d2f8b42f19c579255e3d","modified":1426272474000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/debug/package.json","shasum":"7c00c1413992981e9bef2576de1259a44239b221","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/deep-extend/README.md","shasum":"eac1c3118d5a56e9145539d97cb87403b6a98844","modified":1452985878000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/deep-extend/index.js","shasum":"b88a0d6a70660e804a88f0cf89b6bfd978f900f5","modified":1452973894000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/deep-extend/lib/deep-extend.js","shasum":"204a94059923c358d83e93aa2c76a41b39de2cc0","modified":1452973894000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/deep-extend/package.json","shasum":"2cad90311832d6109eb8d6fc09014e521b9c3e0a","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delayed-stream/License","shasum":"04e7b761eee5270ea8914303516852faf990394b","modified":1430160212000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delayed-stream/Makefile","shasum":"1d88cf18c0fef56e91425a086590e31271a7c4d5","modified":1430160212000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delayed-stream/Readme.md","shasum":"21db9b7ec97b7028a031a18867aab00575b09850","modified":1430160212000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delayed-stream/lib/delayed_stream.js","shasum":"097ab12e3837896d11d3f1d2c7a891d177b493c4","modified":1430160544000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delegates/History.md","shasum":"37e8641729544115b9d3a566ead3480e47d44a9b","modified":1450122948000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delayed-stream/package.json","shasum":"ffe71c0e5c4f995792df4ae3cf65958e82e5c379","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delegates/License","shasum":"9d414bd96ce8326fadc2f959781154de49af5b00","modified":1450122923000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delegates/Makefile","shasum":"abd4a7cd4a519df349900dd853a307f58a5cd4a5","modified":1450122923000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delegates/Readme.md","shasum":"b0afdd75170fd52fc87f9d0bbaa713054fdf42c7","modified":1450122923000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delegates/package.json","shasum":"41e8eb97cd53ffe0fe97625f438434a81171554b","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delegates/test/index.js","shasum":"f1c8ec4cfea947c03d8dd7c2ce43e7e878794284","modified":1450122923000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/delegates/index.js","shasum":"694697be68fb102fb7e9f70d9f35a8827c6d6943","modified":1450122923000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ecc-jsbn/LICENSE","shasum":"d9dddd103d636dbaa178cd222de612fd923f62da","modified":1393978405000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ecc-jsbn/README.md","shasum":"97cb1bdec48ebb5e46e64fc5441c79d3d38a3c82","modified":1408853444000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ecc-jsbn/index.js","shasum":"13c052ad0b0507a4203d5d1274fdfa049a6c1339","modified":1448288282000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ecc-jsbn/lib/LICENSE-jsbn","shasum":"4f94910918b5e57f3e55c7387f43b0d6293a4319","modified":1394075812000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ecc-jsbn/lib/ec.js","shasum":"d9a60c831fe91bd2c62ff3e3c9675b0379ef504c","modified":1448288163000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ecc-jsbn/lib/sec.js","shasum":"b1632526290dfddc063f05ac6ed29cc40bd9e221","modified":1448288300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ecc-jsbn/package.json","shasum":"0211eedff85b26c72e3751f14ee3f9c9d4f421cd","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ecc-jsbn/test.js","shasum":"9709f584f556ceb8acaa0fd746029dcb58390eb4","modified":1408853485000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/escape-string-regexp/index.js","shasum":"17b40cc4dc8a455277994ab351c0650215394042","modified":1450563101000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/escape-string-regexp/package.json","shasum":"b3e030d5d5a781ba125c170de34aaac319fee165","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/escape-string-regexp/readme.md","shasum":"b693d3ddaf0a2edac02f8dc9b60382f7a818083e","modified":1444058838000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extend/CHANGELOG.md","shasum":"782aabec0278f6500fbedf61e29a5a0d748c78fb","modified":1435783518000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extend/LICENSE","shasum":"bed93ae1abcd71e5d1c9c363595dd24bb1b9016c","modified":1435780828000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extend/README.md","shasum":"4bce70a4b2e7dda8a760418301a4622c0557bae9","modified":1435780828000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extend/component.json","shasum":"07af5d609ee23647ce3238a0e1322c35b385fc45","modified":1435783532000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extend/index.js","shasum":"9154a195afa931672ff49f30d5fdf0c5a10614bc","modified":1435780828000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extend/package.json","shasum":"86c05639729e15106cb7c820771e7a0c127ead75","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extsprintf/LICENSE","shasum":"772b18147b3bf826978f984f8e01562a9e3cc254","modified":1360175237000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extsprintf/Makefile","shasum":"88eff1bf9d8152cf847e0720e384a4a84418082f","modified":1360175237000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extsprintf/Makefile.deps","shasum":"f27b6650501f14e21f8ce186476537d0e2f3e026","modified":1360175237000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extsprintf/README.md","shasum":"e06a0c86165e03cf3170be3f4e5b7dfd5c7eca5f","modified":1360175237000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extsprintf/Makefile.targ","shasum":"f66e38899fc918aac830c478ae402c66d8793bc7","modified":1360175237000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extsprintf/examples/simple.js","shasum":"5e7b4892b3625f689d9dcb5fd2e43140f21d66a4","modified":1360175237000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extsprintf/lib/extsprintf.js","shasum":"cfe80b99a5d428a0f357ae11e0a067c46ebdbb2c","modified":1360175237000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extsprintf/jsl.node.conf","shasum":"7197578b829d6c93d8356bf114c7f3d26722ec0b","modified":1360175237000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/extsprintf/package.json","shasum":"457e74665edd417492d9e9b437146d749180be75","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/forever-agent/LICENSE","shasum":"05979f0750cf5c2a17bd3aa12450849c151d8b7c","modified":1426938522000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/forever-agent/README.md","shasum":"fd2b1d08b55284aa2abc72d199e3c487744a0c31","modified":1426938522000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/forever-agent/index.js","shasum":"a96917d5912eef5a8ed12a4b1f3a41400eac80d1","modified":1428426146000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/forever-agent/package.json","shasum":"0c946ced2200f0d59b072ff02ec5a71d58040e72","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/form-data/License","shasum":"1d11381521bdc7e7df9bb1d7bf85341ffca266d9","modified":1438228280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/form-data/lib/browser.js","shasum":"79f01a7616f6247aa3e55a73602e477cbe15a7a5","modified":1438228280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/form-data/Readme.md","shasum":"6af9e2006617a38c1f5ce1186ca9069cacbe2bf1","modified":1438228280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/form-data/lib/form_data.js","shasum":"a7aca54a95311cd44da040f8c5429fd649c06b2a","modified":1438228280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/form-data/package.json","shasum":"7bd310625b6c5fbc920bcc850eacaac4dfd78ae0","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/README.md","shasum":"ed7e0a5f1120d22e425ac6c5f08c3ed611f93baa","modified":1441842040000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/examples/filter-pipe.js","shasum":"a5b494a4fe5738f5b2c7a3df3d3e7c9685e8cafb","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/examples/pipe.js","shasum":"ff0ea1e9b09953cd0e96420f419e65a9fe3f598b","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/examples/reader.js","shasum":"9d828670e866e34dc8212c564403f78c98558c80","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/examples/symlink-write.js","shasum":"a795df07387ef7c89d4d5afb33722f11b68dcdfd","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/fstream.js","shasum":"cde00245f823e368a96b0bf0aa7749fbf94021bd","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/abstract.js","shasum":"237e8d46b8a6087e7b9b46fd14537cf6f26b79ce","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/collect.js","shasum":"c0841dcb15eb7f67ad9699e8db89e5241e892bcb","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/dir-reader.js","shasum":"72161bd3e3576549f5f9dc7970aaaa09bc764737","modified":1441845533000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/dir-writer.js","shasum":"3746846974dbbdf325f8d15ea8ca0d012fa5dcc2","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/file-reader.js","shasum":"2b6f5039d467b080fb92abb57a673ec97877e9c7","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/get-type.js","shasum":"ef95fa07f3c5af2226d74feb0f66fb87df5e288c","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/file-writer.js","shasum":"f4e66be6242777e3c38564125ab626edbca1f3a3","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/link-reader.js","shasum":"e9f6cc283c032c5c21768d76ff48651f8169b530","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/link-writer.js","shasum":"74b0816529379a9ffa93c1ab866d7399c63eb136","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/proxy-reader.js","shasum":"1b24a353bd457db6a84dfde4feecf0a9367f15d9","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/proxy-writer.js","shasum":"ba51acb8e3b5277c510cf9f97fb3d07f0567f3a4","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/reader.js","shasum":"323979daecbf47fba50278e908c2f77c3eef52bc","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/socket-reader.js","shasum":"11296e436392e54d4b2018c524c580f794b00486","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/lib/writer.js","shasum":"580eff911f66640c7caed30bcfa224ac91c9496d","modified":1441844311000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream/package.json","shasum":"c7d5c78973b2c12c18f4dcd44df9b65fad7340b3","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1406507496000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/README.md","shasum":"ba3ea6ed0e20d4e115bc428bdb3c6ac46db73fd5","modified":1406507496000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/example/basic.js","shasum":"d7a8e1617b33ee936f4976922269b0608309f678","modified":1406507496000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/ignore.js","shasum":"050a85cd5ce874c41c1e5bd510c2208bcbc0f85b","modified":1406507496000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/README.md","shasum":"fb5bec4ab02467cdb76cdb552613ff0547402439","modified":1407793656000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/README.md","shasum":"3ed262742cc9e8e0db93c5f1d729127af1ffbe82","modified":1446204351000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/minimatch.js","shasum":"16b28bcabd1eca778c2176d6c49330396907411e","modified":1437616284000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/example.js","shasum":"8a259435e31e75ac76d3abcbefd225af7f41c185","modified":1446204351000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/index.js","shasum":"6d8c3796c04fb513fd0a1d1d66e59ef73f075f76","modified":1446204351000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/LICENSE.md","shasum":"09013c002fbdd686da2ec13c5a6d014f0a294ba9","modified":1445519600000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/Makefile","shasum":"98cb6ef36a74f052f3bad15c72f01d78e2d0ba8e","modified":1445519548000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/README.md","shasum":"261a929745508f56c655d4ec306123bbfabdaa16","modified":1448714230000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/index.js","shasum":"8c1cf0e709f8668e14b11c9086a50c70a0b0434e","modified":1448714230000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/example.js","shasum":"27792bf4ffe9ce453c5d6896611d7647fd8f0e6b","modified":1445519548000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/package.json","shasum":"4247d02ff3eba0a962adf44734d0b574e9aff1bf","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/test/balanced.js","shasum":"706b6e79b2c13f0fed4d25706b63bbeec17c3600","modified":1448714230000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/README.markdown","shasum":"132e6e8fd1d19ec2422fdcde00840d8237e44094","modified":1354099276000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/LICENSE","shasum":"b2e68ce937c1f851926f7e10280cc93221d4f53c","modified":1391050985000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/example/map.js","shasum":"022a614b8d9f5ccb67b6ce1f478b1efd7aff298e","modified":1339124034000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/index.js","shasum":"a3063f014cc693b320dbd64de3243a79247c1e05","modified":1354939769000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/package.json","shasum":"ffa4caf6c5ea7bef6c191b9f12f7fc76aeb90db6","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/package.json","shasum":"fd1eef529b6782424aa5c44b819c6faaa24d63df","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/test/map.js","shasum":"162cce32c23628192cef64924a1ce768af399a4b","modified":1354099176000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/node_modules/minimatch/package.json","shasum":"8b6dc33ca4310ac9867632043a5911e72ce0f6ee","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/package.json","shasum":"498de8f3b3816bd44805f66037cc62d2788d62ba","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/test/00-setup.js","shasum":"f0fd8188b27143153d0c519bc034fbb3639f4312","modified":1406507496000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/test/basic.js","shasum":"71bb54d431a1121dc08f2b212cb89dd3e42e5713","modified":1406507496000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/test/common.js","shasum":"0668403c695d97759db32f06b59a5e35934f7e37","modified":1433889073000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/test/ignore-most.js","shasum":"9c1519c559e5f71283269ce38ebd76489d7e5b8d","modified":1406507496000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/test/nested-ignores.js","shasum":"77038e94e3b6b72a935df479d113d3f5f5397e1d","modified":1406507496000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/test/unignore-child.js","shasum":"96da57e0eda3ca25ded1989b98ffca651860c6a3","modified":1406507496000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/test/read-file-order.js","shasum":"918110c9f5222640bf4abd7024c5cb117ff5664a","modified":1406507496000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/fstream-ignore/test/zz-cleanup.js","shasum":"36805caeb3799434bb3c2d0f94e75dda54840d73","modified":1406507496000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/gauge/LICENSE","shasum":"ce0c4782bdbd720baf4d2484e5b71728d3a943af","modified":1453847625000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/gauge/README.md","shasum":"698270efddb3f6ce884112d51b9d813d9c06f52f","modified":1453847625000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/gauge/example.png","shasum":"7fb19a54b7521b6a7b08c52ef70f311751fa800f","modified":1453847625000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/gauge/package.json","shasum":"767141cd2873bafc2b6ade420ccd15e827e915c1","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/gauge/progress-bar.js","shasum":"35f4f50c6e852f6d5dd38c8741c434496172512c","modified":1453847625000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/gauge/test/progress-bar.js","shasum":"a1feb803ea2772dd73d37aaf3f1cf0432eac0447","modified":1453847625000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/generate-function/README.md","shasum":"d9255d9f65aeed364e61715ce43392b237dd10a7","modified":1406741356000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/generate-function/example.js","shasum":"677d763dc7b82f9d69585388ff04094107481e4d","modified":1406741329000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/generate-function/index.js","shasum":"2942e1c63f5a2013a70196110b4859029d09c48d","modified":1408639884000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/generate-function/package.json","shasum":"8179b5abf0baa5b2837444bc62c4cb9f267c6829","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/generate-function/test.js","shasum":"9bb3d8f4f20a97f1af0ef033d8dbe32693f9fb3a","modified":1406740670000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/generate-object-property/LICENSE","shasum":"a95ab3a4b0e4bd978897f09b3b430a449da20a08","modified":1427465395000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/generate-object-property/README.md","shasum":"e300730218d5bbf519653e5d19cfbd5857b78796","modified":1427465395000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/generate-object-property/index.js","shasum":"47eacac5534f58609e9f3ccc3a1c5879c20f9add","modified":1431893671000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/generate-object-property/package.json","shasum":"3d6bcf30a482e537c2de52af3f329fca7d74e885","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/generate-object-property/test.js","shasum":"b738cbfd474028baa30f5b003e228356d61c6a58","modified":1427465395000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/graceful-fs/fs.js","shasum":"8b8116f2fc0e6393cfed3b1076810ce5d02e0f01","modified":1435436586000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/graceful-fs/README.md","shasum":"3ca4000bd861d5d95e8f861fc35d30a31b48677d","modified":1435601369000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/graceful-fs/graceful-fs.js","shasum":"48c86f6a8c193aa2ee2969f4b8fbf3c722ab97d8","modified":1454449073000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/graceful-fs/legacy-streams.js","shasum":"f4a3583d4c3e8b0c407ab8406bdafb02b4055b7f","modified":1435436586000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/graceful-fs/package.json","shasum":"3b001b25dcf3146afa98b080dc1de4cd24c839bf","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/graceful-readlink/LICENSE","shasum":"e9f4a5c36ecaa401588e457af96e7a85d53a98f0","modified":1423665419000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/graceful-fs/polyfills.js","shasum":"57619610164625aeff0f6bbefc4008ac2d909b43","modified":1435436586000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/graceful-readlink/README.md","shasum":"a3e9fe045614e9dc2473a75cd9a7e9a6315043c9","modified":1423714083000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/graceful-readlink/index.js","shasum":"3ecfe7f28912aa64161b8a6e4129c2b4fbcf50a0","modified":1423714095000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/graceful-readlink/package.json","shasum":"2e7fa57502651c40a8d2a0f8893ca9a4240af5da","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/bin/har-validator","shasum":"702b45900cba1bd2ee74c4df1a5b51db0aeab0d7","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/README.md","shasum":"43ef10fa75b3eb5369012ac32654ab907a79fb14","modified":1453244556000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/async.js","shasum":"864f1787c6e6521d6495d337d7894d844dba24b6","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/error.js","shasum":"e08730fe6ce867fea7b32e8e7c6f9266b7fce592","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/index.js","shasum":"099021ac86914964d97afb35a9594e29c136bd0e","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/runner.js","shasum":"c0c49bddac013682d52bfff6065cceae67474fb2","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/cache.json","shasum":"24dd76d544e1c3c4be343e1a88e9ffad19705021","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/cacheEntry.json","shasum":"abb6d0b052b7f624f2e9efd5508c0614c4831b36","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/content.json","shasum":"896c9f34e3f38c5687255edcec798bedc98221a0","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/cookie.json","shasum":"fc6b61b7f65667ebd270e2daadfc21e6b6aec452","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/creator.json","shasum":"b0096cca448769435a9a1dfc8835bc560957fa97","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/entry.json","shasum":"161d6c3ab62b4fc423c5aa1d3ee1f67d98c008ca","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/har.json","shasum":"9b5debe33b9aa8c6055bb950ca5f19b1a1d82a42","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/index.js","shasum":"1bab9e9eb0c54be915c5303ee23cba4faaff0194","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/log.json","shasum":"9c72f7600e6fad2818459e76de0140ed9cb67422","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/page.json","shasum":"d3ca0cf8dbcc30f33b91b8e8db85982b01cc5986","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/pageTimings.json","shasum":"2661f2488c8bfaec68b30b4e9dee25089277e448","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/postData.json","shasum":"123d9c6853b0e1a33147e2c04404aa33cf53a1ff","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/record.json","shasum":"23a2f8245bfef93b6b87696af51c1e9d4a0302df","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/request.json","shasum":"ecdaba295ca01aeaa9f3f9779d1c94a051af5578","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/response.json","shasum":"e01a380eeb0b3c87c37f936ebf4888eae55dc3b1","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/lib/schemas/timings.json","shasum":"4879ffeb448af68307aa46910bd2d3ac2fde9246","modified":1448373288000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/har-validator/package.json","shasum":"bccf834aaa4187f1c61ce1153716f15042e0c11f","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/has-ansi/index.js","shasum":"e7305f641b51be9dc463cdfc1e6b7afb8d03576e","modified":1402774137000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/has-ansi/package.json","shasum":"b22270a86ae1c29b45db05cd37168668f058ac39","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/has-ansi/readme.md","shasum":"8f5dd99e33b07d2f4abaff2410728acca335ebfc","modified":1435680789000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/has-unicode/LICENSE","shasum":"0478d8708f5ff5e49c150412201cb066a9b2006d","modified":1419955664000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/has-unicode/README.md","shasum":"ace56f38c5b7a359fa99a9338a7d93a85a1d24ab","modified":1448499284000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/has-unicode/index.js","shasum":"35b9e9a4011608fd14ea1d7f158654d7eda8fd0b","modified":1448499183000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/has-unicode/package.json","shasum":"8789309532231c5042924549121a4eeace5aa584","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/has-unicode/test/index.js","shasum":"454a09bb55fe15de1bc72daa3bd91d5e13a169ce","modified":1448499521000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/LICENSE","shasum":"23dc309f4a3614d359884bbc4a64d0ca20e41d68","modified":1453233148000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/bower.json","shasum":"0394736479292c80f177ca8d29263d9162d489b3","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/README.md","shasum":"332080064c5f554a1ad68a43ab48a68d2b49a1a4","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/component.json","shasum":"004be58031f7d1cbdbff8ca684b464df449cde8c","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/dist/client.js","shasum":"78e967c19bffde7606b06c595c41e83cde6c0d53","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/example/usage.js","shasum":"9c61ce5a46828c4c26b93e06141dbee8679c33a2","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/images/hawk.png","shasum":"756c85c7133e66dc5c119c47081f7f890d046f77","modified":1447968927000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/lib/client.js","shasum":"781eb260241b46515df2f2f009969a772aa9dbcc","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/lib/browser.js","shasum":"d4f08ffcfa0012fdb1a304d0fdda5586cf959af3","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/lib/crypto.js","shasum":"06d65d9f325d49f11a0bf223dc683648f6fac977","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/lib/index.js","shasum":"64f1cfdf834d8d679d020071124865b83a6cae72","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/lib/server.js","shasum":"ecde371bb849aa221cd138ba993f5fb19fff160e","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/lib/utils.js","shasum":"befb760ea6a14654fcce187b2b790f8292b404b2","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/package.json","shasum":"e904bd9a77e7f3e29eaabda2f839db58821cf129","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/test/client.js","shasum":"fabb1388ee6f94ffe25870f2152d1a46c480dde3","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/test/crypto.js","shasum":"222fe636eb910e343a0dd0db76224fac92a47647","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/test/index.js","shasum":"9e790c1104e148298687c0ed87fd48ee14a943a4","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/test/readme.js","shasum":"e8743507f0a6c8d261e1d037e8aadc11cda3ac82","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/test/browser.js","shasum":"fda1c8242cc48078540c30464da1d36a64d223a6","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/CONTRIBUTING.md","shasum":"61998267d75f17fdd423c1c742edc20a1561c1e2","modified":1441988248000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/LICENSE","shasum":"8798f9342afed7351f4aa459b96e4d1062c1dd89","modified":1441988248000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/test/utils.js","shasum":"042ec97613b298b257e409d54eeca7a84ef3f84b","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/README.md","shasum":"fa10590d10b5c14546e9124bf634621583235285","modified":1442428161000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/test/uri.js","shasum":"a7037450a234ee97c7bce23dc5c2f295fcddbd47","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/lib/escape.js","shasum":"5ccf43b55ca0fbbc307a91235127af5601bd1187","modified":1441988248000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/package.json","shasum":"da1d39cc6474b93a303b3226c66a32aeb14df821","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/test/escaper.js","shasum":"206886beb62a1d9d907b3838b20eb2037826167a","modified":1441988248000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/test/server.js","shasum":"45a0a16ecee59114ad2765a73af25443125278ba","modified":1453400406000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/lib/index.js","shasum":"cfd3b556015082fc786d83c3e85ade81f448aafb","modified":1442857232000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/images/hoek.png","shasum":"61fce871b635b32957b3c8c4e3c523eb2b2ac58f","modified":1441988248000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/test/modules/test1.js","shasum":"32aceae0ba03e9116b108f41d74bea7d163bb56f","modified":1441988248000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/test/modules/test2.js","shasum":"31071671a8bdb854825c1cd90e29c30e9203b9fc","modified":1441988248000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/test/modules/test3.js","shasum":"4b695a807655475e7d89966828af28b7dee15ec5","modified":1441988248000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/http-signature/CHANGES.md","shasum":"59a2ab5cc1ac7f7691560038beb2349e628eeacc","modified":1453759387000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/http-signature/LICENSE","shasum":"10b8ac49ffb8f7cc8bdca9303209a1b3b2f3587d","modified":1442600921000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/http-signature/README.md","shasum":"5847fa2ec86a2ca744776acd5528fdfd6c3377fc","modified":1444857627000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/http-signature/lib/index.js","shasum":"996c8efa1d7896034c980e498bec866824662d52","modified":1444858648000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/http-signature/http_signing.md","shasum":"945eb22661d1c43e547371ac8d354a4b761eab09","modified":1453759268000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/http-signature/lib/parser.js","shasum":"c47fbe5cb6f1be3c5a5d62f9085273f3403ff401","modified":1444858648000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/http-signature/lib/signer.js","shasum":"5e312acbe0c57117dad754fa369a36dca4569bbd","modified":1453759272000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/http-signature/lib/utils.js","shasum":"dce96d033869c424854178ae71991fe39b7c58b5","modified":1444858648000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/http-signature/lib/verify.js","shasum":"f0603457d003b72d484d608b266566e771644438","modified":1447890069000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/http-signature/package.json","shasum":"f30349078562246c05bbd21814aba1f5ef9b9d48","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/inherits/LICENSE","shasum":"3b0e8d58a362b1787ef3504fba4f593b22f3cee4","modified":1376950172000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/inherits/README.md","shasum":"f2f8d26f1cf5fb1e3a68aa225221b064f999fefb","modified":1368714278000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/inherits/inherits.js","shasum":"3146ed5f0e6053ad30398afdbd5a0d6a4133a4cb","modified":1368714177000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/inherits/inherits_browser.js","shasum":"7c13eacf36e79e5e7dd257d80ec25846e4df7eb3","modified":1368715198000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/inherits/package.json","shasum":"a53398e37716ea017f5b6bb1e43fe24ac801c638","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/inherits/test.js","shasum":"ba3f458c9b47c1bcd3fdf5dd9289b7aa0ae90b1c","modified":1368715388000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ini/README.md","shasum":"1997c778eb616617ba9d369f6a27828bf83af8b8","modified":1410851261000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ini/ini.js","shasum":"361f1811be8059fe1e009db0b8805fb17046d4fb","modified":1423612669000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ini/package.json","shasum":"7788edf20b3012169c84ce86eda534d0fc3e961b","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/LICENSE","shasum":"a95ab3a4b0e4bd978897f09b3b430a449da20a08","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/README.md","shasum":"7579af584be527b613516d1b4146bb23e45c17a6","modified":1440789245000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/example.js","shasum":"cee9de4194e0c4ba372b5678983d6d701385d355","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/formats.js","shasum":"2d511859d3d654f3bf604a47e13f98e9b1bc305c","modified":1453067668000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/index.js","shasum":"bb2c1a15eb553a2dd948ebfe09b3b95312df173f","modified":1446823818000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/package.json","shasum":"efc83f85c6bfc6e139cf43ca8d8225d66a2ddbd7","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/require.js","shasum":"24081d202d91cdd0b4910b57dfd434ab41543b07","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/fixtures/cosmic.js","shasum":"94a2af635cae7d0491fce9767a67d06f651e0244","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/additionalItems.json","shasum":"75644b309367675ce21d8b35b9baee049a58e159","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/additionalProperties.json","shasum":"34478026a586b1ff8b96dbe54efdf7515099da7d","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/allOf.json","shasum":"e98aea1d36d932870561f0c32c32fc5858f251f9","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/anyOf.json","shasum":"8081feb305d328878b37a7cc3b296eb5544c239d","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/bignum.json","shasum":"32b70fb2c2156c979702eec5c18a86c1fe6d0bd7","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/default.json","shasum":"17c051cc94a9fb40ad627b04a41d7dce9150e3b5","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/definitions.json","shasum":"0963ac4f014a0faf6ad37554c9af03f63dad9b02","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/dependencies.json","shasum":"d239f1bb8cfffb7487335c73e02c6cda10d4ef5b","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/enum.json","shasum":"4b96cc24245950f9fad0916113a5056d9f51c2e5","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/format.json","shasum":"3d60bdb3fbb2d47da991e99e51bb9ab241703c44","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/items.json","shasum":"873828cf8ad5d2701022650e99367cb0a89624b0","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/maxItems.json","shasum":"580cdb7c89cd07b45f3fdadb2279bb13108b79b4","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/maxLength.json","shasum":"3f6273e86c31605607384559df5ee9c92201c5bc","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/maxProperties.json","shasum":"1703d6ef976a74eae8ea6cd21c131853c6ca5f6c","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/maximum.json","shasum":"c205edb4c5bd171c9e1f4955f5cc3b94ca78cb0c","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/minItems.json","shasum":"176fedc074768c6ec5c7ceb979f23a6a4bd0be58","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/minLength.json","shasum":"99eb79755bf43df641900a01e8ac9ff5becec8d5","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/minProperties.json","shasum":"b61b2829899d8a5f6bbc8bde2b694b69bb35d38a","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/minimum.json","shasum":"1a849968c80db05a9ad0a92481edd93dee567804","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/multipleOf.json","shasum":"9e70c593b1cc3a3572a0d389b5b7a171bf292ddd","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/not.json","shasum":"5b9567e8409e28b256f3704ca83447f0d0abb707","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/nullAndFormat.json","shasum":"8682b818844ecab9f69642d3f121eea59877f6e0","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/nullAndObject.json","shasum":"dc0ff1a9b5740271c3e92436a697a50ee8168046","modified":1437940209000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/oneOf.json","shasum":"6772cacb066e5458a7fca9a47cfee27b56110d6b","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/pattern.json","shasum":"5b09d287b8d5170ba4442429bf5309eae1f3cec8","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/patternProperties.json","shasum":"e0080348b213f1d004af7d5c43c2f3f29375224b","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/properties.json","shasum":"1aacdf890a9b844c7275f6ad2f3acc2f9100219c","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/ref.json","shasum":"a9dd881b0a9d5272897be0cc8550c5a64841fc8c","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/refRemote.json","shasum":"ef0c43623cad9a3ceb7b407272062ca55c1c9c7e","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/required.json","shasum":"35b980ec46ea56c7c7c38afc63c84a863d4b3132","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/type.json","shasum":"e2e4371fb68d01ecbc7a5022348c0ffd05d1fd9b","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema-draft4/uniqueItems.json","shasum":"8c9909ffd2abf8f625f81c18a43c789efa369e34","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/json-schema.js","shasum":"c5ef8e3da495a6ca1c7cc9dd0cb8d8c415dcc245","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-my-json-valid/test/misc.js","shasum":"748b6ed6ae2678830339a94e6b0291fa2563545e","modified":1434031383000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-property/README.md","shasum":"dc4d53b5d6c1d1387fd41fb6bf3597d9642540a4","modified":1374156267000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-property/LICENSE","shasum":"50fe55ab192fa4860c14bd57bcec5d090904eb97","modified":1374156563000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-property/is-property.js","shasum":"d09cd64e2bcead412c4d3be1d95f76fe1e315794","modified":1419518893000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-property/package.json","shasum":"49eee5e4b84a24ede4b71f24d62d41eb405b4a88","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-typedarray/LICENSE.md","shasum":"b2e68ce937c1f851926f7e10280cc93221d4f53c","modified":1401649683000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-typedarray/README.md","shasum":"8f33b0dd445cfa2ab6712dee34df082f480a5a76","modified":1401649785000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-typedarray/index.js","shasum":"b7ff45ac41fdcb4bb75dd771d6cb9bfbd129e56d","modified":1431824601000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-typedarray/package.json","shasum":"894c25e54ecabf49ad72b06c641707f6e6c5726e","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/is-typedarray/test.js","shasum":"c3aa563061f8d086aaf066b389b0e811444e3913","modified":1401649839000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/isarray/README.md","shasum":"34470c173ddf6ddfbf9683cf343e83cea1629049","modified":1369676403000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/isarray/build/build.js","shasum":"711567b86256a86ed22bd637c35786d13e0f73b3","modified":1369676297000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/isarray/component.json","shasum":"88615028e91d7872104932a02b78a75f04df8465","modified":1369676355000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/isarray/index.js","shasum":"eec5f3c0d16211678cfc7c2d9c18bc4718adf700","modified":1369249661000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/isarray/package.json","shasum":"153f08e27474c7213ec22be16a4b8635a7fccfab","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/isstream/LICENSE.md","shasum":"3fc5bd6825a9d8fd53c0cd8de0bd16d1c1a7f37a","modified":1425687271000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/isstream/README.md","shasum":"0563c8dd8178c335de8d882a14c0408ba179789b","modified":1425687291000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/isstream/isstream.js","shasum":"db3d8708d100bdb66fd33e1eeb6d2b232016934b","modified":1396827239000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/isstream/package.json","shasum":"49a832abdc377a43f99030aad18f20d76b7f2cb0","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/isstream/test.js","shasum":"3c3c171729a3738bd73b12d311265c7fcfb2a9fa","modified":1396831146000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/AUTHORS.md","shasum":"cc3f12565134b1da757450b40b5f3fa80c7fc132","modified":1445881497000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/LICENSE","shasum":"4fe6ded38ad123523792104dcf60f28badd905f2","modified":1445881497000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/README.md","shasum":"3a28ce7b2aa6b6343508cfe28eadec9733fd14e7","modified":1445881497000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/almond.0","shasum":"216d893df0f002babc23e63d4c98005db5e8104e","modified":1445881497000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/almond.1","shasum":"157b7bc54f90865debe5b1f817a8c1155b580dd8","modified":1445881497000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/index.js","shasum":"29e0b96fa095b35ecac9be6c2afde6c9b769e73b","modified":1445885964000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/jsdoc.json","shasum":"5a3782a2b7072783e0e5aa3b74d9c87c423818dc","modified":1445881497000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/lib/core.js","shasum":"55894ff0a71a08de470029f7689b3967c2ce9233","modified":1446502968000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/lib/curve255.js","shasum":"fdc3f9501dbda3945b6478cecaab0b0e1ecd2d63","modified":1446502968000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/lib/dh.js","shasum":"e9a0561e419e956f953570d7121e65c84fa72488","modified":1446502968000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/lib/utils.js","shasum":"5b4e9a60c9f4758bf714e52f9064df0d33fd019a","modified":1446502968000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/lib/eddsa.js","shasum":"bacec5f12e7d5303cee9b0493e22b3743a19ef1e","modified":1446502968000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jodid25519/package.json","shasum":"57fef6e07ebedf58b42179d9645dbb7d6ddb8ce0","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsbn/LICENSE","shasum":"d9b1b910dfea689402ffdb75f5467ec263f8480d","modified":1446141666000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsbn/README.md","shasum":"6db673c03e15b4e75f95e25ba87177799511ad0c","modified":1446141602000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsbn/example.html","shasum":"ec1f94b093e0f1457642f8647294be35d4af033f","modified":1446141602000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsbn/example.js","shasum":"ba7f33b1196eca41a007177372fe237ac7a85c1b","modified":1446141602000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsbn/package.json","shasum":"c38816f871f1a7d5b17d7918f9b0682d7b50c582","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsbn/index.js","shasum":"f53a89111c54f03ab39eab110c924b560b877051","modified":1446141602000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/README.md","shasum":"9065e9ab354ce910706716a42584222674fe1470","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-00/hyper-schema","shasum":"a5972bcc99abc4936ff350f116a69390f8ac99e8","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-00/json-ref","shasum":"b5f7e93c3edc2eb501e913441ddfdeef0c04386a","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-00/links","shasum":"490c91fb104a16a76290377797a5411d21379614","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-00/schema","shasum":"253c4fcfccaf49023c10a1a92d81cc3d21344e8a","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-01/hyper-schema","shasum":"51802f7884c813fe2a002776aa97a440c7442d9a","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-01/json-ref","shasum":"2132a5a9319f8bf190040b49150e005e0916ed22","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-01/links","shasum":"09b2131c15d754a61a1baf1158a8e6c73644287f","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-01/schema","shasum":"10942d74811e1e16425e6219b0ba808b493321ab","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-02/hyper-schema","shasum":"117eb70efaa120edeb97caa6ca7e53eae8f761e2","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-02/json-ref","shasum":"31b76b211e24e56b0ff5ae3ba739835039cd96b8","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-02/links","shasum":"f8a835ea08959ceca9682cf1c30df6d5cf9ff033","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-02/schema","shasum":"ba84a3e7e9332328db986a1123084f2a6dba57f7","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-03/examples/address","shasum":"b6e70440f5faf725b978da4e92f6f39100377674","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-03/examples/calendar","shasum":"3e53cb296ba1799f39c5a00bc4627fa10e26e165","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-03/examples/card","shasum":"c1405e471f81bbb4eea94c2ef85fa07195a8ad80","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-03/examples/interfaces","shasum":"9666b12a3d05e526886aa2650f0439d32b25f0dd","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-03/examples/geo","shasum":"74d8c66f1ba74c6cd330b8acd5948efb5f2879e4","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-03/hyper-schema","shasum":"552aaa9921cbeb19c2c9b485e64965f7a98e22fc","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-03/json-ref","shasum":"9f121cedcda14cbdd55e2fd80a96e289d9a1f2f9","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-03/links","shasum":"5f1601142843a6028beb35cef8b851413a4dfa91","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-03/schema","shasum":"4b500e66b7c4a36bc4d3ff6da089d6228c54f94c","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-04/hyper-schema","shasum":"362194bf4c6690db17b848c1a796ef747bf7a6c1","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-04/links","shasum":"92cd269ccdfe3f3bc673205133cb9940afa465c4","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-04/schema","shasum":"7a6839ef21cf49fd6bdc687be7dbfbb92c97ac7c","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/lib/links.js","shasum":"9d0d0289e4dd2840778b88834f17bad854b013b5","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-zyp-json-schema-03.xml","shasum":"da15453583b019a448fae4b857fe29a583bc1a38","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/draft-zyp-json-schema-04.xml","shasum":"02845f4b0406bffb06ff5cb01eca43f492db6901","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/lib/validate.js","shasum":"97195ad80d4a217293a8bc240ee44c0c89a7fe79","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/package.json","shasum":"fa5f2db6ced4bc174783e16af4599c2607be9a08","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-schema/test/tests.js","shasum":"f3f322d2cec777f57df41b071818a05e97d35f2a","modified":1345750810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-stringify-safe/CHANGELOG.md","shasum":"d9b3407ce2eef8d2dadc6b2839a8b16b783eef47","modified":1431999690000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-stringify-safe/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1431999719000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-stringify-safe/Makefile","shasum":"589819e00a30573f50fa4a11ddb22fb45b372a65","modified":1431999690000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-stringify-safe/README.md","shasum":"a2972dd72d8ec7c8b1f229f7732f911ed721dbca","modified":1431999690000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-stringify-safe/package.json","shasum":"6883e12536091d528a074ee3cec552237a651c0f","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-stringify-safe/stringify.js","shasum":"b36a3a8d0f794fae13dc8e1c93bd4a8cae311bf2","modified":1431999708000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-stringify-safe/test/mocha.opts","shasum":"98216b4fbc2e0c1c17ee946b02272a26fcc1f4c1","modified":1431999690000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/json-stringify-safe/test/stringify_test.js","shasum":"4760401b04513ae7eb79fff0e1239a9947a8af78","modified":1431999690000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsonpointer/README.md","shasum":"7b05e3bfb84beb3a5e7607912fc47ccc8d2b1e33","modified":1430458330000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsonpointer/jsonpointer.js","shasum":"cd510cab1d95a07efc733965dd2533a3fad50e51","modified":1432622187000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsonpointer/package.json","shasum":"e27c7cf73b0405cc138b8f74cfc582d727783434","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsonpointer/test.js","shasum":"ac5befd353f47b170e2efececbf1ef6d82bc6ade","modified":1432622760000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsprim/CHANGES.md","shasum":"56da97f41e22a449194235ad13ee30a2f4758956","modified":1444953672000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsprim/LICENSE","shasum":"772b18147b3bf826978f984f8e01562a9e3cc254","modified":1416249172000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsprim/README.md","shasum":"78fa58f9e0acaee38db00e4ff234394308cef93d","modified":1444856653000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsprim/lib/jsprim.js","shasum":"b6fb3f70d3ba7ce276c625e0dd5cb7dfb0af67d1","modified":1444953536000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/jsprim/package.json","shasum":"02f389d4c4058d297e1e5fc305ef9f646c0b184f","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._basetostring/LICENSE","shasum":"36c3ff463d0890f895498124f6ef3295fbb4a616","modified":1435677344000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._basetostring/README.md","shasum":"e075950489d6d73eeeacb4906e37b09e4f6cfe78","modified":1435677344000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._basetostring/index.js","shasum":"835c23c6a3642d720f0ee0618c0e8861d8cb3134","modified":1435677344000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._basetostring/package.json","shasum":"2a653805082aeccbb39e207b5c53372006d9a141","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._createpadding/LICENSE","shasum":"36c3ff463d0890f895498124f6ef3295fbb4a616","modified":1435677344000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._createpadding/README.md","shasum":"bda43e247ff533c8eaf26c45e47736e58fe1d373","modified":1435677344000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._createpadding/index.js","shasum":"b19e0107063ae114288a10dbbe839af1ab3e9a5b","modified":1435677344000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._createpadding/package.json","shasum":"d5d6dc9c8f33ac9b9ad8e1b5dba7833d6629bd30","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._root/LICENSE","shasum":"3a1d08be6b4b07a0ec877adc0a9d2e238ff711f5","modified":1454898280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._root/README.md","shasum":"91c4c36c5a2bf927c710d573732f55a0c0ad6095","modified":1454898280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._root/index.js","shasum":"545616dd71d349344faab75f29b340e7ce77b361","modified":1454898280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash._root/package.json","shasum":"f5dcf3bd6fdac87986d40eca82de2af6e710c59c","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.pad/LICENSE","shasum":"3a1d08be6b4b07a0ec877adc0a9d2e238ff711f5","modified":1454898280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.pad/README.md","shasum":"4c459dabb74826d06acce0c922929bceef5c5513","modified":1454898280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.pad/index.js","shasum":"4871fb052f40df95397e45de54174cca6ed4099a","modified":1454898280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.pad/package.json","shasum":"1f5d2b3215963a04bfb91e71f0b6fd142f6bc3c4","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.padleft/README.md","shasum":"0e6843f638d533a73ef1b21caacf96d571bd8ef0","modified":1430495270000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.padleft/LICENSE.txt","shasum":"36c3ff463d0890f895498124f6ef3295fbb4a616","modified":1430495270000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.padleft/index.js","shasum":"4faeb94e9ffaa3b1b30636bb8dfe6e45e0e02cdb","modified":1430495270000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.padright/LICENSE.txt","shasum":"36c3ff463d0890f895498124f6ef3295fbb4a616","modified":1430495270000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.padleft/package.json","shasum":"e93bcd1bb99cc1f9246a1dc16eed71d03e3b2b8d","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.padright/README.md","shasum":"c9ed091410ba5c18a1e0d504a8cce14546b2b2c5","modified":1430495270000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.padright/index.js","shasum":"f212732a54455ce07d042150faef7a0229d04a1b","modified":1430495270000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.padright/package.json","shasum":"b47d855f23933c96e403a1f1cb93a39fca121a9b","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.repeat/LICENSE","shasum":"3a1d08be6b4b07a0ec877adc0a9d2e238ff711f5","modified":1454898280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.repeat/README.md","shasum":"536792bb622d08ea03919eb41037b1a5c70a42f7","modified":1454898280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.repeat/index.js","shasum":"5d3846daaed514f752445f94632c96aac6338f83","modified":1454898280000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/lodash.repeat/package.json","shasum":"716e39bc2503a38e3ee7e27a9f1c091241539355","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mime-db/HISTORY.md","shasum":"118acc07d6743b47568717a7fcb42f5a4e1aaf59","modified":1452100935000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mime-db/LICENSE","shasum":"b559c45c8d07f2679620d9771e68696ee3d5964b","modified":1423439849000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mime-db/README.md","shasum":"1018078c0d9fd0331ca23ac5d97ace15596bf46c","modified":1452022838000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mime-db/index.js","shasum":"31180f8d0ae079b1bee7ee03e77ea5323583eb06","modified":1423439849000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mime-db/package.json","shasum":"40c77135b96e22a603ee46554053a2d409e83cf2","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mime-types/HISTORY.md","shasum":"d2ab51246e8865a74bc6f27b8b4182ea72bab920","modified":1452102507000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mime-types/LICENSE","shasum":"f027af3e61af3880fd7f7b8ba9452a85dd215738","modified":1433741526000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mime-types/README.md","shasum":"904567c440d9be49c0e52cbff36fb16d08e624ea","modified":1433741526000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mime-types/index.js","shasum":"d1983bb9d10cc678f693be62ef05e1b8c2638ef0","modified":1439520766000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mime-types/package.json","shasum":"df8866b598e35c1d8d3f9eb78ebad84baf803ff8","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/LICENSE","shasum":"b2e68ce937c1f851926f7e10280cc93221d4f53c","modified":1372145420000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/example/parse.js","shasum":"7684d952ceaa32a8c9e3cd21ba26a62e7ee14387","modified":1372147306000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/index.js","shasum":"c69b3860fa8b40337db188fdfb201077df93ef5b","modified":1392957961000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/package.json","shasum":"6d2e0eef3859ccf658d63c5dca30c202446c734a","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/test/dash.js","shasum":"27fa6e19e26916edd7fd46ccc2d0b2301b3042a3","modified":1389378397000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/readme.markdown","shasum":"b037b8453fa008383cf7495b3736aa7cc217deb1","modified":1372148196000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/test/default_bool.js","shasum":"ecdb759c4275fb23bd5d072c3c6a7baa74b407c7","modified":1372147071000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/test/dotted.js","shasum":"51664f4efb36d519b2e439f1156e05e917c08bda","modified":1377730679000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/test/long.js","shasum":"f0ccd5d55358f78efbc928753264e4a32f7724fc","modified":1372143145000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/test/parse.js","shasum":"e240ae50a049d7b4b4b625467df34bcfaef7dceb","modified":1392957961000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/test/parse_modified.js","shasum":"5c3cf170e2a2476e0f5bfee9af78556a1958d503","modified":1372145355000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/test/short.js","shasum":"2ce00fdfe4906fc504286974c143c4ced6a11b12","modified":1391917546000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/minimist/test/whitespace.js","shasum":"ea3a87137fa34c00a7d84a4d0350770e8d85ed9c","modified":1372148159000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/LICENSE","shasum":"35d8442a9599f876c805b2c7d31178ecfa18c829","modified":1419626841000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/bin/cmd.js","shasum":"0dbed17e23d62e8dc9893f9459768531b300c95c","modified":1419626841000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/bin/usage.txt","shasum":"682ca66d4def0ba4af814be4e6363eff5fcede0d","modified":1419626841000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/index.js","shasum":"e4aca996fb54ff20c3dad61f1fa7807fcb44409f","modified":1431570694000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/examples/pow.js","shasum":"6d34dfc0f5f17a971dee0f5ba40eba5219bdd803","modified":1419626841000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/package.json","shasum":"c76b7c6d2681fef5e5ae3ec6855c1401f40afc68","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/readme.markdown","shasum":"e4ffd1099773d1e612dc9ecea76dbb791ef355f5","modified":1419626841000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/chmod.js","shasum":"ee02690748279a5bad6179dd3feeb66a48d330c8","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/clobber.js","shasum":"4d00dc55c23f21600adbceb6760587b3ca861626","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/mkdirp.js","shasum":"628f2dbd4137f64e69454708ba513870b85af4c8","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/opts_fs.js","shasum":"8dd756971f7443eb340b846acee0c17cbadbcb87","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/opts_fs_sync.js","shasum":"0f949a29099c6206e617d6e9e39cb3a41d0daab4","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/perm.js","shasum":"11382491d90f70fce17e9d183765c343c7870c3c","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/perm_sync.js","shasum":"1759536f89220a608a3987a3038cbaaa0e7458ac","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/rel.js","shasum":"2488c0b77bc0419a4646c7d0bcfaaef5651995a5","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/race.js","shasum":"237f49a5262bc2c668653897e8cc1af8eaa5bd89","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/return.js","shasum":"dc2bf5dd5eff2e6a914fc1f731f50ac887ef9d31","modified":1419626841000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/return_sync.js","shasum":"ef9a789aeb65bafbbb7bceb048dc33ec24a41e3b","modified":1419626841000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/root.js","shasum":"b034b5fdf0da3932263437d9d52b53642a2b40ad","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/sync.js","shasum":"22a3775a59d8994c368e5574ba8ffbe19c8b8648","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/umask.js","shasum":"d08a2f100ddc37e563e548fd9f7730599009824c","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mkdirp/test/umask_sync.js","shasum":"917a95e95427eecd9a0cb7807e0ab6ab3c653fcc","modified":1431568795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ms/LICENSE","shasum":"06c5a8e25add90a402138ff3d78eb6524f2cc710","modified":1429572836000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ms/README.md","shasum":"5c2f58a77f80869b968e1450639fb2ae64439f1b","modified":1429572836000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ms/index.js","shasum":"21867f756553abdaede5397a39c6d55931b353e3","modified":1429572968000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/ms/package.json","shasum":"6f30a5162512053713203f6f69590c0babf69102","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/CHANGELOG.md","shasum":"19b9c208f46e999b40deb66f012f8836db6c5c33","modified":1455047528000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/LICENSE","shasum":"0917a1370f9878d391966436c6029f7b84b0cefb","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/README.md","shasum":"04ffce5c71fbe6c8a0a7528e81d4032b4f8e55fe","modified":1446679217000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/appveyor.yml","shasum":"a16195eb4558ed7290fe5bee741369584d69d362","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/bin/node-pre-gyp","shasum":"14a04775e8c6a8ad81d809331b3e9a205f7a6295","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/bin/node-pre-gyp.cmd","shasum":"b12c5e56438c650e4062bea15e6d00a07435b4ca","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/build.js","shasum":"60da785242154a5d4edf83b36b2286a3072df265","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/clean.js","shasum":"64d4a2e0d250775aaa813da7aecd336af0ec357b","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/configure.js","shasum":"4800e9525f634d866a57ed87aa016b921c1e3e55","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/info.js","shasum":"5d625595e04cf4547122def865fa775c0dd646ba","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/install.js","shasum":"de6d5234d2430b27ee7edf4526d7ab35b37c6979","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/node-pre-gyp.js","shasum":"e73bb230546414362ab58e30bda731dd7fe256aa","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/package.js","shasum":"e39486542432242ce871526629c41075f0952098","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/pre-binding.js","shasum":"71f81e4b2714e28b98709279bb5474dd1ee3f851","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/publish.js","shasum":"a55ba3f801cf8b754f8a0cc20585ae1c2012ffaf","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/rebuild.js","shasum":"301048bf08e2b839733e4f47c18a5c17387ea84e","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/reinstall.js","shasum":"b3cd9833e14d5d61705cbce047d6a29f09916581","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/reveal.js","shasum":"f70ca7275048686ba9dccf0d5d5a1a89ebec75bf","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/testbinary.js","shasum":"7f9e8c6f0ed523df0a489bd71164f27fa2bb674b","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/testpackage.js","shasum":"ca02a24f4c522b836402ee263792c89fb461844f","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/unpublish.js","shasum":"b5ca72ed97ce1e7958551f1d0f6817699682b0e0","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/util/compile.js","shasum":"7088bb5462fb2cc4ad9b026f879bb288414e0537","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/util/abi_crosswalk.json","shasum":"c64438026ddde7678ceab2c56922422d4b28e374","modified":1455047528000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/util/handle_gyp_opts.js","shasum":"aa761ce14eac57b0526247fc941f9c0d68df5ebf","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/util/nw-pre-gyp/index.html","shasum":"a98470c7571d877e59dab48204848ea87b2f0d8a","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/util/nw-pre-gyp/package.json","shasum":"3a785cd04b35cc9a5fb36ad1a97561e7d3c3cf53","modified":1394928774000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/util/s3_setup.js","shasum":"967f7f5dae61a38a86c3c7a4ffebb7df13eb1740","modified":1436835856000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1447359143000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/lib/util/versioning.js","shasum":"442a5db3101b773ba810f4b0e39c89a4a5a6d862","modified":1446679217000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/README.md","shasum":"dd491d80a00af3ba8c01730825f011eaf91c001b","modified":1447363130000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/bin/nopt.js","shasum":"f2a561712df0e004c712bfd6c9b0fdc70cc26e8e","modified":1447359143000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/examples/my-program.js","shasum":"de3d4a6a7f350fd6846d3ae06334d1fafffc7054","modified":1447359143000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/lib/nopt.js","shasum":"d3dcdbce19312c5473deb7e38672a2d5e034af79","modified":1447364058000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/node_modules/abbrev/CONTRIBUTING.md","shasum":"12ce7abccdd3aeebd1d093a30bb1768f120fb8cb","modified":1360631762000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/node_modules/abbrev/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1432169859000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/node_modules/abbrev/README.md","shasum":"c520bc857ec612ed88e13d794c47882d5aed3286","modified":1286218346000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/node_modules/abbrev/abbrev.js","shasum":"b75c6b10bbfac1092ef493079ae044cc89824dc0","modified":1397765081000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/node_modules/abbrev/package.json","shasum":"c373268f789711af182e2728d1a52aa780827010","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/node_modules/abbrev/test.js","shasum":"4af3fea0290e02e4d82225ce75721b423c212483","modified":1433026583000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/package.json","shasum":"6f10a92650c46043ccff0db996e96549861d0170","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/node_modules/nopt/test/basic.js","shasum":"83220640df8cb4211523fca22cdbf9d1094d07ee","modified":1447364293000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-pre-gyp/package.json","shasum":"031eb29685eff5e8f21c4e3a9cbc2e433712b93c","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/LICENSE.md","shasum":"09bedf3eb387e2883ded96ee501d16262350c9cd","modified":1425583776000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/README.md","shasum":"7ca0c673b27c3c4c50167b5077bb421711c2518b","modified":1447445668000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/benchmark/README.md","shasum":"783d814c48583b086ffd8b701a53844f799e7d0d","modified":1425583776000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/benchmark/bench.gnu","shasum":"26bd5d465f2588f4ebda09b9aa28f3fecffb9f4a","modified":1425583776000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/benchmark/bench.sh","shasum":"3f8daeb462ad5609c63fb8915efc4fa870a8fde5","modified":1425583776000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/benchmark/benchmark-native.c","shasum":"8d999ba3178ae2683a7ed30b9ff115fe9d9f41bd","modified":1425583776000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/benchmark/benchmark.js","shasum":"82dfd78c7f35bd52a84259e9afc36018f41bf58e","modified":1425583776000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/bin/uuid","shasum":"cc4874ec4258ffff8b743227a3619f895941b563","modified":1425583776000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/bower.json","shasum":"6d521f86833c6d9a6a75af623529479fcf89f917","modified":1447446668000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/component.json","shasum":"7e1d6df157d7075438267019c90f5cb158b26983","modified":1447446668000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/package.json","shasum":"ed86c0486730fef07e4a85e53ad1c626b1b75c4a","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/test/compare_v1.js","shasum":"ac9c80da67f4b232b0aff05c4160deda00dda2e6","modified":1425583776000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/test/test.html","shasum":"287decf793ae25e5cffda0f5a118a41ccf54fca0","modified":1425583776000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/test/test.js","shasum":"bd765f9091cfd101f0679e45330ce04a62266453","modified":1447291212000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/node-uuid/uuid.js","shasum":"91f473812e7748b91d6adb32ac704c4f8cdea13a","modified":1447446491000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/npmlog/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1444275719000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/npmlog/README.md","shasum":"8bc40cfe4367b91fb624febb536fd4c81bf81e7b","modified":1425164767000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/npmlog/example.js","shasum":"a6f0d0a2735b42bab3b36afcdacea47000a9aa57","modified":1414722499000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/npmlog/log.js","shasum":"6d281a81e21d694795aa7c58df849a8c686b0a39","modified":1452645460000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/npmlog/package.json","shasum":"1179729b4ba68bf013130f35f5d496fcb9734126","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/npmlog/test/basic.js","shasum":"8499ebd31b6852088e74c54d19ecfb915ed51db5","modified":1452645460000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/npmlog/test/progress.js","shasum":"e097be13d02499514d9448156f7b401277fa31ef","modified":1420650960000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/oauth-sign/LICENSE","shasum":"05979f0750cf5c2a17bd3aa12450849c151d8b7c","modified":1432536000000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/oauth-sign/README.md","shasum":"9f943ef5e4c1e530314bee287c8fd5b8addbc808","modified":1432536000000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/oauth-sign/index.js","shasum":"fb3d1f2193e77b18089fad077d3133143811f554","modified":1454224562000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/oauth-sign/package.json","shasum":"e64c96ebb3144df58c27d7977b1197fcb4e42bb7","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/oauth-sign/test.js","shasum":"972d35362f1eb47ba9e12409a6d49ecc23e8a968","modified":1432809220000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/once/README.md","shasum":"f980f2811a57fb0732e9fa9bc43c9e8a2d6b0011","modified":1382596021000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/once/once.js","shasum":"67e1e2cfe1a08a3cc9636382beab2e3cba80d9b6","modified":1448055900000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/once/package.json","shasum":"3a436d1d7e725ba7f1ebfa5f0cf5b39c2302f8fe","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/pinkie/index.js","shasum":"4ed6d8988b13d2c29cfa99c99cedb43fa6b51ee7","modified":1454324862000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/pinkie/package.json","shasum":"ea31c8d6471c4b9d1d4fc4bdcf373d07f9677c6a","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/pinkie/readme.md","shasum":"1673aa52b8f81f6ebf1c2e5ca0184a6f63522f78","modified":1454322504000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/pinkie-promise/index.js","shasum":"cc84d8fc33cad091d8dc7bc65c0481a8a915769b","modified":1447318268000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/pinkie-promise/readme.md","shasum":"450859283a97df6ee0918789a485d26786329eb1","modified":1447318268000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/pinkie-promise/package.json","shasum":"42b492ac5b0355e04b4afabb8aa58c2a4f1d4f70","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/process-nextick-args/index.js","shasum":"066a18ff5757235dbe5ea1a2c632946293dcff6f","modified":1449104960000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/process-nextick-args/license.md","shasum":"9def7167175d2ac68505dd2ae0c7b8dd63bc4c3d","modified":1449008551000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/process-nextick-args/package.json","shasum":"9f9b49fa355f269c5c73fdbaacc8fd6bbb315d9c","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/process-nextick-args/readme.md","shasum":"3eba0a30f0a115fd767a0c8c9761d60d1dc768c0","modified":1437048205000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/process-nextick-args/test.js","shasum":"279a062028d86a4ee0ab2ab800ecf7ca29f4905e","modified":1449008551000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/CONTRIBUTING.md","shasum":"61998267d75f17fdd423c1c742edc20a1561c1e2","modified":1450856430000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/CHANGELOG.md","shasum":"a8c66d98d8c1501b5a506709fc7f4285b59c7f82","modified":1453069331000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/LICENSE","shasum":"ddf13f1b7345d730677237125bc2e46fbbfbbf32","modified":1450856430000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/bower.json","shasum":"d278db3097c39d4df650b04bbc42d03021b87409","modified":1453070078000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/README.md","shasum":"9d57cdff65ba49f961ad3805df133c282c4672e0","modified":1453069466000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/component.json","shasum":"affe28b8b20dde94e6cdc469ce5b11bcd87bcb9a","modified":1453070078000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/lib/index.js","shasum":"227523195233e42a48c20f75a1ae350c6bcc5b47","modified":1453052046000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/lib/parse.js","shasum":"f85546c13d4cae0f65b3bb3693cc92e18636abe3","modified":1453052057000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/dist/qs.js","shasum":"4999c7f95ac28c994fc5f4772e51d9288ea8b6cd","modified":1453071516000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/lib/stringify.js","shasum":"910b15fb61e39f8c3fcb5eaf522f5f6daf1f3e77","modified":1453052046000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/lib/utils.js","shasum":"b4614510e0a35009a95de16f2f7a19dc8bbf9265","modified":1453052057000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/package.json","shasum":"3288a7e1f9e15142388b25e1aadbc61d18b2ba30","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/test/index.js","shasum":"3d9a66ca5549d2dd32f6a56c4ba0472498fb68a8","modified":1450861863000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/test/parse.js","shasum":"b7041aee47eca551b475d405957a019e61296bf5","modified":1452717606000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/test/stringify.js","shasum":"38ca94758266fbd37217faad5fc7bff6d3ef1e0a","modified":1452717606000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/qs/test/utils.js","shasum":"5f25e2ef762a18cff8719d88a1748840c1626d89","modified":1452717606000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/LICENSE.APACHE2","shasum":"e66a2c506febaaf8c744908ec3e5be148ffd1d86","modified":1451372897000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/LICENSE.BSD","shasum":"a93b16b3298b9ed28337b75b382b10ef616d404b","modified":1451372897000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/LICENSE.MIT","shasum":"6a911843ccabdd6bbdffaffc0083a03435ceb2b3","modified":1451372897000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/README.md","shasum":"3d04a532c78dd3c9bd7efd1b49fc1f68bfcd3a37","modified":1451372897000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/index.js","shasum":"2183e906b3d9ce1a867d9dcffe8f85a235b742be","modified":1451372897000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/browser.js","shasum":"7981b353221fdc9c2c9d92dc1f5ba0620d4c6280","modified":1451372897000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/lib/utils.js","shasum":"d67bfe3ea746f485caa0cb2743a4dedb2ba8264f","modified":1451372897000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/LICENSE","shasum":"b2e68ce937c1f851926f7e10280cc93221d4f53c","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/example/parse.js","shasum":"7684d952ceaa32a8c9e3cd21ba26a62e7ee14387","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/index.js","shasum":"cfede1ccd2ee41f74022c002b5c6d05e65c482c0","modified":1440424576000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/package.json","shasum":"c72bf224669c9af6c154d408dc2d029e7a41b6bf","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/readme.markdown","shasum":"067b8f01bd1fcf09a6418e3db4b323c8eb9ad479","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/all_bool.js","shasum":"d5f1721995050d6d9de35c56222e578d6a2a8b5e","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/bool.js","shasum":"a0ef26a085e4d5530ea59880049cf7aeeaf9bead","modified":1438902415000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/dash.js","shasum":"0fe20783b683b525cb3ff6872474ac6fd89a8b63","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/default_bool.js","shasum":"71da47b49e90b77c88caccb077c1bcfb555399f1","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/dotted.js","shasum":"edbda6ea34cff9e7dc3fe1953b72eca2f955cda9","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/kv_short.js","shasum":"e87208f3f2695b7de0c27e234bc4810cd6d49b8e","modified":1440424577000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/long.js","shasum":"f0ccd5d55358f78efbc928753264e4a32f7724fc","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/num.js","shasum":"6a52983a855113284f2aa9633876c1adf3710463","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/parse.js","shasum":"a9672d89e1623b05aed85a4b4afcfec7fbaa359c","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/parse_modified.js","shasum":"310215056f588e8c04e92f0cf6337ca28a8e0d78","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/short.js","shasum":"2ce00fdfe4906fc504286974c143c4ced6a11b12","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/stop_early.js","shasum":"dc728f383a53ce9e44c9c1c21360bb7ad71d6205","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/unknown.js","shasum":"b55d1e1d6ff269730e4578a108f4c340e70da262","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/node_modules/minimist/test/whitespace.js","shasum":"ea3a87137fa34c00a7d84a4d0350770e8d85ed9c","modified":1438902274000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/test/nested-env-vars.js","shasum":"6acf3954a61aca10fe42d316abe08e26ee520be6","modified":1451372897000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/package.json","shasum":"d602f1af0b859e06edb520d231080693a99e02ce","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/test/ini.js","shasum":"aa73cff807f34a5c00d03064a4748e6936163b42","modified":1451372897000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rc/test/test.js","shasum":"81b87bc710c4d0b8c0360a247ecb3817d71f3ffb","modified":1451372897000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/LICENSE","shasum":"73efe5bda3791d234730ab0dcc48eb619a2e0ec6","modified":1433891361000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/README.md","shasum":"113fddeaf3174b63954f81670dce9772fc252ad1","modified":1434936371000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/doc/wg-meetings/2015-01-30.md","shasum":"1fafe6e2e28a4404db90ae6dc867199b74468ca4","modified":1433891361000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/duplex.js","shasum":"5ff8b0af1efbb8ed54ac1b3f57167447cb902344","modified":1433891361000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/lib/_stream_duplex.js","shasum":"d4e2c0dbe893e97638262fb598f00472aa121cf0","modified":1448548407000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/doc/stream.markdown","shasum":"34bb6baba8a25fd40136c519215124cbce7ec78b","modified":1450290518000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/lib/_stream_passthrough.js","shasum":"51d9ab73b4265e9c011537e957c8f578bcf50d1e","modified":1448548407000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/lib/_stream_readable.js","shasum":"71fec1e21d268617a18c91742d57f3f43ed7a14b","modified":1450290518000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/lib/_stream_transform.js","shasum":"fbeb8123c9557d11283543efd471e659a80a1f1e","modified":1448548407000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/lib/_stream_writable.js","shasum":"e6b7ebcfcbf1648eeda0b5060f388028b5eabf97","modified":1450290518000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/package.json","shasum":"dbca445196c2aabaf73ce38ffe03e01f64aa003a","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/passthrough.js","shasum":"ff1590a9a778dc9d8ed51064670d82426782ee6e","modified":1433891361000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/readable.js","shasum":"f68ae09e1cfcd9f75f8d43cb82724b3dee5d9251","modified":1434936362000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/transform.js","shasum":"2d31b50e657e5b03ce5abc5ce6b77187e8e876c2","modified":1433891361000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/readable-stream/writable.js","shasum":"8a7bd86d1803614b9381a924ab9ef0a19fd70e6c","modified":1433891361000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/CONTRIBUTING.md","shasum":"a9fc87e51d92d75e09e391fed0b41d0916da1499","modified":1421769158000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/index.js","shasum":"6b96d838b3fae1c1d3fd963613b6465cd788e8c4","modified":1443190242000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/LICENSE","shasum":"05979f0750cf5c2a17bd3aa12450849c151d8b7c","modified":1413995097000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/README.md","shasum":"612f6c04bd0aceb60c1d22dcf1a5de5a5cf91698","modified":1453921187000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/lib/auth.js","shasum":"56bdda40a7df68f69c68cd256258017783e70d12","modified":1453921187000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/CHANGELOG.md","shasum":"142acbcd6d56904d1caa8775f56379738cb142b3","modified":1453921187000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/lib/cookies.js","shasum":"0b2a641d706209af1f92176a507f382e06b44379","modified":1453921187000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/lib/getProxyFromURI.js","shasum":"2e7c16e357f885401208174ad1f341b084965253","modified":1443190242000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/lib/har.js","shasum":"a4b894d836e3bd947a5d8afffec04128bf934fe5","modified":1453921187000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/lib/helpers.js","shasum":"c636e050b67bc00533adc7721e750f9520902917","modified":1443190242000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/lib/multipart.js","shasum":"66acc47cab8b774688502be7752501e4a44d3cda","modified":1453921187000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/lib/oauth.js","shasum":"8663a55221a216cc32d655f83086979ae9e666a9","modified":1443190242000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/lib/querystring.js","shasum":"b78be4d88327f11499fbf86610d0612d803b1ff4","modified":1443190242000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/lib/redirect.js","shasum":"08b710fe22cf8e28b2fecdcaaadb76923361299b","modified":1453921187000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/lib/tunnel.js","shasum":"97336f00dd29c7fdad5550e9ae4daf57d587d034","modified":1453921187000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1431999446000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/package.json","shasum":"16dd8f8fe64ff97129a8ce1eb4fb49c67b6a8708","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/README.md","shasum":"fec5cb034f99088fb8ceec58b6de8ac5f5fc04e7","modified":1450896185000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/request/request.js","shasum":"baa695ff90bacd0d7e7b56fc0f83bac22360fd99","modified":1453921187000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/bin.js","shasum":"366b465d5a8637f94cea9366f505a25fc78c8a83","modified":1447980323000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/common.js","shasum":"2216c2b406550fa30ce86669313721bc5a72fbf8","modified":1452292176000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/README.md","shasum":"11402eb3ef9b4c244d19d3176a3c5bb8beb0898f","modified":1451528302000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inflight/LICENSE","shasum":"515ec4469197395143dd4bfe9b1bc4e0d9b6b12a","modified":1412207810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/glob.js","shasum":"950021530921858aef80eefcf3296971350359d0","modified":1452292213000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inflight/inflight.js","shasum":"be7331b58b1433b0fa179d7a99ad9aca50f9d573","modified":1412318830000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inflight/README.md","shasum":"cabcd4da1794331188da1f8f864ea1aa0ca68657","modified":1412207810000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inflight/node_modules/wrappy/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1411081212000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inflight/node_modules/wrappy/README.md","shasum":"582d7139d169b0fc0b1014f2372a0aa26a52cfb8","modified":1411080623000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inflight/node_modules/wrappy/package.json","shasum":"3a67744519b96b3f4b723f61123e1e651d1ebc98","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inflight/node_modules/wrappy/test/basic.js","shasum":"be9621bb5c8a73660c26c049805cfdfd8adb5b3c","modified":1411082093000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inflight/node_modules/wrappy/wrappy.js","shasum":"7d5c1c908664b3df4a9b72400a126652ba0dd905","modified":1411082022000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inflight/package.json","shasum":"7e94479f720ef8e13932ed5f05f7a2495556679c","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inflight/test.js","shasum":"b063404038229fb650d55794be860bd5f74ca1f3","modified":1412318795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inherits/LICENSE","shasum":"3b0e8d58a362b1787ef3504fba4f593b22f3cee4","modified":1376950172000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inherits/README.md","shasum":"f2f8d26f1cf5fb1e3a68aa225221b064f999fefb","modified":1368714278000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inherits/inherits.js","shasum":"3146ed5f0e6053ad30398afdbd5a0d6a4133a4cb","modified":1368714177000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inherits/inherits_browser.js","shasum":"7c13eacf36e79e5e7dd257d80ec25846e4df7eb3","modified":1368715198000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inherits/package.json","shasum":"c3b5b5cb15b417c3fe558d6d5fdb42c27f5b1c7e","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/inherits/test.js","shasum":"ba3f458c9b47c1bcd3fdf5dd9289b7aa0ae90b1c","modified":1368715388000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/README.md","shasum":"fb5bec4ab02467cdb76cdb552613ff0547402439","modified":1407793656000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/README.md","shasum":"3ed262742cc9e8e0db93c5f1d729127af1ffbe82","modified":1446204351000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/minimatch.js","shasum":"16b28bcabd1eca778c2176d6c49330396907411e","modified":1437616284000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/example.js","shasum":"8a259435e31e75ac76d3abcbefd225af7f41c185","modified":1446204351000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/index.js","shasum":"6d8c3796c04fb513fd0a1d1d66e59ef73f075f76","modified":1446204351000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/LICENSE.md","shasum":"09013c002fbdd686da2ec13c5a6d014f0a294ba9","modified":1445519600000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/Makefile","shasum":"98cb6ef36a74f052f3bad15c72f01d78e2d0ba8e","modified":1445519548000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/README.md","shasum":"261a929745508f56c655d4ec306123bbfabdaa16","modified":1448714230000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/index.js","shasum":"8c1cf0e709f8668e14b11c9086a50c70a0b0434e","modified":1448714230000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/example.js","shasum":"27792bf4ffe9ce453c5d6896611d7647fd8f0e6b","modified":1445519548000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/package.json","shasum":"76bbc9bf9873f027deacfb2009568327b490958b","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/balanced-match/test/balanced.js","shasum":"706b6e79b2c13f0fed4d25706b63bbeec17c3600","modified":1448714230000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/LICENSE","shasum":"b2e68ce937c1f851926f7e10280cc93221d4f53c","modified":1391050985000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/README.markdown","shasum":"132e6e8fd1d19ec2422fdcde00840d8237e44094","modified":1354099276000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/example/map.js","shasum":"022a614b8d9f5ccb67b6ce1f478b1efd7aff298e","modified":1339124034000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/index.js","shasum":"a3063f014cc693b320dbd64de3243a79247c1e05","modified":1354939769000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/package.json","shasum":"a41434fcea8bb5fd17a8f84ea6270614f7cf1395","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/node_modules/concat-map/test/map.js","shasum":"162cce32c23628192cef64924a1ce768af399a4b","modified":1354099176000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/node_modules/brace-expansion/package.json","shasum":"94969ecccc823c5ce1a3b3dbc60b72334869039d","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/minimatch/package.json","shasum":"d5f39bdfd9fb0125f920467adb1f9789f342c0e8","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/once/README.md","shasum":"f980f2811a57fb0732e9fa9bc43c9e8a2d6b0011","modified":1382596021000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/once/node_modules/wrappy/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1411081212000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/once/node_modules/wrappy/README.md","shasum":"582d7139d169b0fc0b1014f2372a0aa26a52cfb8","modified":1411080623000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/once/node_modules/wrappy/package.json","shasum":"3882f0a070d5cfc4e42f2f14471afdc6c2fa8165","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/once/node_modules/wrappy/test/basic.js","shasum":"be9621bb5c8a73660c26c049805cfdfd8adb5b3c","modified":1411082093000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/once/node_modules/wrappy/wrappy.js","shasum":"7d5c1c908664b3df4a9b72400a126652ba0dd905","modified":1411082022000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/once/once.js","shasum":"67e1e2cfe1a08a3cc9636382beab2e3cba80d9b6","modified":1448055900000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/once/package.json","shasum":"9be018eaeac9b9cdd84bf7086b334777fcb272f1","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/path-is-absolute/index.js","shasum":"71259da8cc05832088437dd2d385b7eee54eab71","modified":1424141850000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/path-is-absolute/package.json","shasum":"1aaa7c5d8a2b2a9fc1cd25b01297f92193b2ad43","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/node_modules/path-is-absolute/readme.md","shasum":"bbe564e38bd40bd0f8c6f503d3064ebce4e6e87c","modified":1424141985000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/package.json","shasum":"d7d55326a725fd71ec8c3041b13c7e7fe49be01e","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/package.json","shasum":"1dbc68d383b1fcee00a3117009eb2c9916f026a6","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/node_modules/glob/sync.js","shasum":"6585718061bdd1f27bec952486252c6ee46ea35e","modified":1447632932000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/rimraf/rimraf.js","shasum":"89cc0eff35f036fb58f37f3dc629a653c7828545","modified":1450812580000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1430799955000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/bin/semver","shasum":"95e0a5fdac7ea5824aff144c4416ca4a31b2ea6f","modified":1413420141000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/README.md","shasum":"5ddc6177be9c6ba045bf2b9aec8f9ec6fa0f412d","modified":1447888625000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/package.json","shasum":"c162bc8d0b07367e00ecb8de62aa27e35dc847cb","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/range.bnf","shasum":"f6b2d9d1f2da93eead6d53fe1e26719fb628aa53","modified":1447888625000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/test/big-numbers.js","shasum":"872ac0774f3f343ccfd02ca284c07fa075cdce62","modified":1427475356000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/test/clean.js","shasum":"7a88bbd0388d1e2eede4a8dd9a9ba6210d7a39e9","modified":1412103158000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/semver.js","shasum":"f4dd45619f51cc8f7e60a3ba57c79c7b0bb87f48","modified":1447888625000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/test/gtr.js","shasum":"7359784e6c5e19855b9e32a2ef93f4df3a6d9d17","modified":1412119384000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/test/ltr.js","shasum":"69d7e8e5a76df2dd0928837fb929093bafe2fd1f","modified":1432937866000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/test/index.js","shasum":"92ee3c5a9daaaff9be1033c9f25dd25600009db8","modified":1441991317000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/semver/test/major-minor-patch.js","shasum":"c0f36d7d593f43792b7e0bea967ee138168300e6","modified":1423771405000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sntp/LICENSE","shasum":"1583807686100eb3d8287b4e4627818f002aabaf","modified":1409946595000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sntp/Makefile","shasum":"23079c0b043b0fd2f037fa6272e36d2562425c6d","modified":1409946595000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sntp/README.md","shasum":"5b5b1348b73a5ba7293f5924937015c6b6350b6d","modified":1409946595000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sntp/examples/offset.js","shasum":"5b78885677fd2f0eae4c2fb6c04c2d6e2f39bf49","modified":1409946595000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sntp/examples/time.js","shasum":"9a7e69f5ee15afc381ce433cfa867bff405ca81d","modified":1409946595000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sntp/index.js","shasum":"fbc929bb3b85e76c25fc52743d325d9f36fb3643","modified":1409946595000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sntp/package.json","shasum":"2aea6183b5c6cb9c65a56f7b05900a2af9fe00bb","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sntp/lib/index.js","shasum":"eeed7222493e633069fe267f915f7d13b12df094","modified":1409946595000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sntp/test/index.js","shasum":"bc5aae767cff3fcd90a9a4b2d6ec0e6fea66988f","modified":1409946595000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/LICENSE","shasum":"10b8ac49ffb8f7cc8bdca9303209a1b3b2f3587d","modified":1446856544000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/README.md","shasum":"7c00acdc8e5bf0eca47a16aa33c8fa17202fa4bb","modified":1447889453000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/bin/sshpk-conv","shasum":"fea08967162027695aed134d117056a5b789d188","modified":1452039039000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/bin/sshpk-sign","shasum":"e187df199ed0e1c1d782f679b4742df047919854","modified":1452565517000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/bin/sshpk-verify","shasum":"a74dd8749820e0a9e9d334bd09665d6e3e4885f2","modified":1452565517000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/algs.js","shasum":"95cac832aaaa1d70d2a18bd42559a147dafbf11b","modified":1446856544000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/dhe.js","shasum":"de6f67e80ebce95a5272c75afcf05ea84ac45b3b","modified":1449005123000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/errors.js","shasum":"94532c1445e72de790269b42a85741ac597c37e4","modified":1446856544000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/ed-compat.js","shasum":"a05999a5907f0027ba834b8ee4e819380a5108ea","modified":1452565517000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/fingerprint.js","shasum":"1d34b04f4b70508da86cbc87a4a4c16206189930","modified":1447889453000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/formats/auto.js","shasum":"ef4cc1499a3c7c3d96343b8edb2965c9630830a6","modified":1446856544000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/formats/pem.js","shasum":"8288839f3bc23aa06ff4be127a0c7099511668b1","modified":1447889453000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/formats/rfc4253.js","shasum":"d268965c5c90a6da158ccc2f1dbd512e8868830c","modified":1447889453000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/formats/pkcs1.js","shasum":"155a8e28b24cb78b4d2a9cc88acdbd24f8296e97","modified":1447889453000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/formats/pkcs8.js","shasum":"c9f73599e6447ef8cd55d670335b710bf9eb666e","modified":1447889453000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/formats/ssh-private.js","shasum":"cba9761409b07d0d383aa58185d968613edbd5ff","modified":1447889453000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/formats/ssh.js","shasum":"e05ce4d9981b2d0ccbbc6c5b28f1c4497adffe56","modified":1447889453000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/index.js","shasum":"1e6da7fba9b778c1791755723fb286b3d72d8b97","modified":1446856544000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/key.js","shasum":"fa8bce41330b09c7cda81be71b15772a57590eab","modified":1452565517000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/private-key.js","shasum":"a2d90ebfebf92206b78fba754ea43af97ac80841","modified":1447889453000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/signature.js","shasum":"9ca03d95eded537101b3b7e9f0537f3cb5e0217b","modified":1447889453000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/ssh-buffer.js","shasum":"e0a58a30c41e44e08e098467384b56a33f7c3213","modified":1452039039000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/lib/utils.js","shasum":"9dcea6ff1a1026a57b235f4608fc08480efa05fb","modified":1447889453000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/man/man1/sshpk-conv.1","shasum":"a64a4769ca648e2047d255bf5237ce051f6af15a","modified":1452565517000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/man/man1/sshpk-sign.1","shasum":"742f5bb2986ad635eb081bad695573cd6826c96b","modified":1452565517000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/man/man1/sshpk-verify.1","shasum":"a5c70f82de5313ee103ba9bf3cfb9774465de370","modified":1452565517000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/string_decoder/LICENSE","shasum":"8344f8cf34d06153cd7ffc797c070e00d69eb442","modified":1390012773000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/string_decoder/README.md","shasum":"c8dac065c0a3043936a7c07ea1d698234c3ad159","modified":1390012773000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/sshpk/package.json","shasum":"82ac0f1ce4c39c34eab979e2cd9bf61b0971ded6","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/string_decoder/index.js","shasum":"91f40da3177881cf70b87520444b755e1d9592ec","modified":1408767880000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/string_decoder/package.json","shasum":"673714ecd74d9412a84fedd3389ced2c08c78d2b","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/stringstream/LICENSE.txt","shasum":"e957fbece098eddf6df809165d5e73c2c1b2e10a","modified":1445815621000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/stringstream/README.md","shasum":"33c7843dec1919a17daad5a5ae2fb06d54018b38","modified":1358765250000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/stringstream/example.js","shasum":"17a98e07a319edf8fbeeea49d83515304922b1b4","modified":1361939998000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/stringstream/package.json","shasum":"5b7749e3bb2edd54001ba4ea5f3d4df4da935e7c","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/stringstream/stringstream.js","shasum":"400fe756da898736fe0642a709c7f88e21fda352","modified":1363491475000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/strip-ansi/index.js","shasum":"fa7b64a04c5989a1c9b78e83768b90384ac9abcc","modified":1403638286000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/strip-ansi/package.json","shasum":"32aed466a4ee4061e6347a643eb18f59a73f433f","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/strip-ansi/readme.md","shasum":"d3331d7da69d44abf7d6f3de7bcc279bb543a4f2","modified":1435683084000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/strip-json-comments/cli.js","shasum":"e53037afc5bd51da35bcb99ffc711e740f741231","modified":1438391694000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/strip-json-comments/package.json","shasum":"9bdcadd6252e3b73618e9033fab1b954f2ef9f1a","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/strip-json-comments/readme.md","shasum":"20404a3e5d9188c0e75354cb6600d82899458922","modified":1438391694000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/strip-json-comments/strip-json-comments.js","shasum":"bead8ba3eccaccb6dc64a76f3ff4552f4863ff50","modified":1438475808000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/supports-color/index.js","shasum":"669e4e82e32796eacb16a314bb3db270fb1d8572","modified":1435362323000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/supports-color/package.json","shasum":"fd3efaf248a2e6dc1e2716a626de6c0311f027ec","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/supports-color/readme.md","shasum":"a0227e37af9ebe9e998782cf0a1eb75338d68f8e","modified":1435704929000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/LICENSE","shasum":"c9f8d7fc9275e87bc85f85317ff575f5e0080cfa","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/README.md","shasum":"195deb7aea0e3da7c225cfad650c8bfb533e9d83","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/examples/extracter.js","shasum":"5d8e2fc93644c2ca104784eeaf20ace3beaefbe2","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/examples/packer.js","shasum":"0ac22b0e315bab4f3f2868dfb042284f1e2ddcbe","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/examples/reader.js","shasum":"cfad58596007c29f55e81c3f2ef0cbeb36fe405d","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/lib/buffer-entry.js","shasum":"b35d31f896a337c570f9c190eeb47ec9856363e5","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/lib/entry-writer.js","shasum":"f9b75bb753e430b2230368ed08eb72593974cb01","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/lib/entry.js","shasum":"c2bd4992c618912cd4f97a24ad2a08abb3cb1c2b","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/lib/extended-header-writer.js","shasum":"b0de18dcef271e4155ce5ea54fe338d2ea30454f","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/lib/extended-header.js","shasum":"2c7ddebe2574be81d74108f93eeb82bba51b6ce5","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/lib/extract.js","shasum":"e129e091bf774bd55306c83b236fc6a88439bad5","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/lib/global-header-writer.js","shasum":"290abcd884f307f01b5976f64513ada8123d369e","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/lib/header.js","shasum":"df2b7d40396b1196c12ac98f5edd71dfc82f0784","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/lib/pack.js","shasum":"a947d14daaeb9da1200effbbae8e1dd546bcafbb","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/lib/parse.js","shasum":"2b111ca0c4d1cc9b3774de8b173c780992f06481","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/package.json","shasum":"e850e3af5598e0cc9ddfa7b0a73b587e738585b5","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/tar.js","shasum":"9c3fa4f5bbdad4447d71b65858c8a4fda101a04f","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/00-setup-fixtures.js","shasum":"478d75b7e2f9f7e1ff2f67de28bc200dfec2f954","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/cb-never-called-1.0.1.tgz","shasum":"905212798798b872f044c27b121a89f9dc6acc36","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/dir-normalization.js","shasum":"69f737fb6122594c3ece01ed496bf1993b8bb1aa","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/error-on-broken.js","shasum":"f25a0ce92dae3c121813eeb92c030a89f4c7ac25","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/dir-normalization.tar","shasum":"a639e5983c0f19acf71640690805db289c615f0a","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/extract-move.js","shasum":"671800188ee6ae088149cf3d397baba1ac7922bf","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/extract.js","shasum":"17def7f8737eb5c57e01c216cd8e0dca06ce5d7e","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/header.js","shasum":"12629717346691f14ad95ac6eee7e6ce77b54f12","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/fixtures.tgz","shasum":"da2704914886317b2cb3d72f320ce260d9cab255","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/pack-no-proprietary.js","shasum":"c36cb44365b2464abf06e7544e1c8c24aca83165","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/pack.js","shasum":"88dcf40d91cde99fd8fff61da7afa64bddca0125","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/parse-discard.js","shasum":"8a179a875af81c7591861cdb84421fad4a4bbf8b","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/parse.js","shasum":"6308611e1f2a1c0e5861e880a6933e3df3a166b5","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar/test/zz-cleanup.js","shasum":"1974a7ab552f18e6b80a0b49e54d11ce79c48793","modified":1441849626000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar-pack/LICENSE","shasum":"6efc4d4fea00a6f4372fb1fa47bad354ec89a2db","modified":1454926145000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar-pack/README.md","shasum":"30dd9eda71bb41dec335c4e13d4c48f65f53fbf5","modified":1454926145000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar-pack/index.js","shasum":"f722f1ca905f54dbf17ac5f16ad8f8106613e1c6","modified":1454926145000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar-pack/package.json","shasum":"6f8eda07c649e45a227ebf99f8b4013ac3926f1c","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar-pack/test/fixtures/packed-file.txt","shasum":"62cdb7020ff920e5aa642c3d4066950dd1f01f4d","modified":1454926145000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar-pack/test/fixtures/packed.tar","shasum":"bd7369cf91552cf6f86bcec43cb21a2947711073","modified":1454926145000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar-pack/test/fixtures/packed.tar.gz","shasum":"c71cee8d77fefb1802845b3ef8c20aee21d200eb","modified":1454926145000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar-pack/test/fixtures/to-pack/bar.txt","shasum":"bbe960a25ea311d21d40669e93df2003ba9b90a2","modified":1454926145000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar-pack/test/fixtures/to-pack/foo.txt","shasum":"62cdb7020ff920e5aa642c3d4066950dd1f01f4d","modified":1454926145000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tar-pack/test/index.js","shasum":"9848b6dd7f13f501ab720ebbcea70b9babd1466c","modified":1454926145000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tough-cookie/README.md","shasum":"72dd4e35da08b98d01237a80b788ae1aa189de87","modified":1444173105000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tough-cookie/lib/memstore.js","shasum":"ecd6269063fe718d5b46d4127ff9d12065660a90","modified":1433972674000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tough-cookie/lib/pathMatch.js","shasum":"3d403b8aad536db9e97eef4915eb01ef53405323","modified":1432572908000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tough-cookie/lib/cookie.js","shasum":"30167425a77bef21e5eb390567ebef0f7532ca13","modified":1447378366000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tough-cookie/lib/permuteDomain.js","shasum":"700be205b7d0d3b4c4f442b7dc1b3299d47bf55d","modified":1432572908000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tough-cookie/lib/store.js","shasum":"bcce2205e56bb588b4e6cfcd48a34610a5eccf82","modified":1433972674000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tough-cookie/package.json","shasum":"9de2e085a4f4d0a7f9cf0c81c9e8bccfc184126c","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tunnel-agent/LICENSE","shasum":"05979f0750cf5c2a17bd3aa12450849c151d8b7c","modified":1446013763000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tunnel-agent/README.md","shasum":"fab5bff0eba532373f36d827d9775105d64ff719","modified":1446013763000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tunnel-agent/package.json","shasum":"f0a5bbdee306f28655231099a02e30b558cc90d0","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tunnel-agent/index.js","shasum":"e9320bd906e55558d9ba2569f76e92899da8744f","modified":1449585048000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tweetnacl/CHANGELOG.md","shasum":"068180ca96e0a5bf6807d8db5a8297b838b9a293","modified":1442499725000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tweetnacl/README.md","shasum":"040dc46c908d08a230dd2aec8c5dd876b3ef94af","modified":1452121326000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tweetnacl/nacl-fast.min.js","shasum":"f0a5e4246de9ad373cbbc7f74264603856debc68","modified":1442499742000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tweetnacl/nacl-fast.js","shasum":"687e1899d1b4c2d5fbf28469f8ddef1901fd6457","modified":1442499237000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tweetnacl/nacl.js","shasum":"23a049b84d01bd8e938ac0daca4cfd38e5e48a0a","modified":1442503875000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/uid-number/LICENSE","shasum":"515ec4469197395143dd4bfe9b1bc4e0d9b6b12a","modified":1392662379000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tweetnacl/nacl.min.js","shasum":"e6984ca5a8a67f259e440598e21e98ab088dd2be","modified":1442499737000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tweetnacl/package.json","shasum":"89257022f715004265d4c9d3948bb021aa726905","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/uid-number/README.md","shasum":"01146a7d333f05da63e9341243280743fdf67dfd","modified":1330396426000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/uid-number/get-uid-gid.js","shasum":"5a4786dc076636cab9a0741a162b7e02cdce52c6","modified":1374791681000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/uid-number/package.json","shasum":"8ffaa1ea4693dcdc0fe3545cf32f6aa2942b4331","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/uid-number/uid-number.js","shasum":"1b2adf78b8206f73ab665422f12a070b45b04803","modified":1392913385000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/util-deprecate/History.md","shasum":"1fc5b9cf603a0b6abeb852b35bec607a411e5b9b","modified":1444243047000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/util-deprecate/LICENSE","shasum":"cbde92577cb69b3b45dd33f8dc600732cf9e14cb","modified":1416945941000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/util-deprecate/README.md","shasum":"8e590b24df7b037031e571b7b2b9600217b83ae0","modified":1416945941000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/util-deprecate/browser.js","shasum":"335965112d6117af8926dce4497a1fb9fca022eb","modified":1444242970000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/util-deprecate/node.js","shasum":"26bb9fcabaf57f0bb50e5e026c13de394bc0c478","modified":1416945941000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/util-deprecate/package.json","shasum":"3af7e812f43db0165a06d139fff3388ef47f229e","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/LICENSE","shasum":"772b18147b3bf826978f984f8e01562a9e3cc254","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/Makefile","shasum":"89b6506d72bcdd045b63921d0b754227f824c4f1","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/Makefile.targ","shasum":"f66e38899fc918aac830c478ae402c66d8793bc7","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/examples/levels-verror.js","shasum":"f8e7f3d3dbce6e61b53ea2a49a63111d156cf18e","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/README.md","shasum":"94a2a13d3e722a3950176fa8ed55a1e7a7fd9d14","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/examples/levels-werror.js","shasum":"e6d95f8c3af86fe246ef883197c28df6b4884eb6","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/examples/varargs.js","shasum":"67c7570a5aa82ca71690b558a3f3d1d321a7508c","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/examples/verror.js","shasum":"8513abb6a724947494c7513adfa27d76931488d6","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/examples/werror.js","shasum":"10e842ef7ad2e6901398304c963c6ef1f44efcca","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/jsl.node.conf","shasum":"c9a618ebefdabda69fcf47f17406c254f7f07f9f","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/lib/verror.js","shasum":"def5538e73a39e2d14388970751c55e55f9b06fd","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/package.json","shasum":"e1247f2c86a2825ca65955ebc0e2977fe097f235","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/tests/tst.inherit.js","shasum":"298dabcdd9eff7081ee06a2b87e1118651190c9c","modified":1360175394000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/tests/tst.verror.js","shasum":"947c77e0a31ea025d156d9323d8a7283bf87871a","modified":1360175300000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/verror/tests/tst.werror.js","shasum":"6b4007d450a8dfb9311ad86f44e3a7817fdeca53","modified":1360175420000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/wrappy/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1411081212000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/wrappy/README.md","shasum":"582d7139d169b0fc0b1014f2372a0aa26a52cfb8","modified":1411080623000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/wrappy/package.json","shasum":"554e6aaab4cbefe64798a253fd0f9dd183f7806e","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/wrappy/test/basic.js","shasum":"be9621bb5c8a73660c26c049805cfdfd8adb5b3c","modified":1411082093000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/wrappy/wrappy.js","shasum":"7d5c1c908664b3df4a9b72400a126652ba0dd905","modified":1411082022000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/xtend/LICENCE","shasum":"c563ca2a6d330b98c2ca9473a0299c4a689bf6b8","modified":1446502746000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/xtend/README.md","shasum":"d7d6f2f31071911d99fef109646867a0b325c8a3","modified":1446502746000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/xtend/Makefile","shasum":"bf249732a0985e13f60552c8a9d6c3894c8fbb44","modified":1446502746000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/xtend/immutable.js","shasum":"3c1de57f8d038e3ebc9e1ab278fe2f683866079c","modified":1446502746000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/xtend/mutable.js","shasum":"0b00bff9bc925c6c258ef4afb77e7f50640e6555","modified":1446502746000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/xtend/package.json","shasum":"9faf90ad349f139251acea54ab68df1d2b218c8e","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/xtend/test.js","shasum":"3b51ee9fb4c95c82be0bdde62dddb31f4c18e648","modified":1446502746000},{"_id":"themes/yelee/node_modules/fsevents/package.json","shasum":"4bde8092f527988c0be99a4795259f6049d8e642","modified":1456469179000},{"_id":"themes/yelee/node_modules/fsevents/src/async.cc","shasum":"90f044c6bdc340273fabbc4aadcb00b9104f625a","modified":1438709307000},{"_id":"themes/yelee/node_modules/fsevents/src/constants.cc","shasum":"294d4d3825481686170a948bd4e1bbb72871b2c3","modified":1441032660000},{"_id":"themes/yelee/node_modules/fsevents/src/locking.cc","shasum":"3e7b5e357f7ef32d3acf05b6a4cc22464c3f2d6f","modified":1426989724000},{"_id":"themes/yelee/node_modules/fsevents/src/methods.cc","shasum":"2ef3634f231b6f58b16274fdc440955e900df2a2","modified":1441032660000},{"_id":"themes/yelee/node_modules/fsevents/src/storage.cc","shasum":"b12de056e310d86f344274d29fe180c0a7b24057","modified":1438709307000},{"_id":"themes/yelee/node_modules/fsevents/src/thread.cc","shasum":"1ec0b3f3a05b464738bd093b5830081f3ed4349c","modified":1438709307000},{"_id":"themes/yelee/node_modules/fsevents/test/fsevents.js","shasum":"748cf86b247c2b6ed01e12fa4d168514d39c8ec9","modified":1426989724000},{"_id":"themes/yelee/node_modules/fsevents/test/function.js","shasum":"3a20d642bcd6b9fa73f5ab538d1231f2141c2d2a","modified":1426989724000},{"_id":"themes/yelee/node_modules/generate-function/README.md","shasum":"d9255d9f65aeed364e61715ce43392b237dd10a7","modified":1406741356000},{"_id":"themes/yelee/node_modules/generate-function/example.js","shasum":"677d763dc7b82f9d69585388ff04094107481e4d","modified":1406741329000},{"_id":"themes/yelee/node_modules/generate-function/index.js","shasum":"2942e1c63f5a2013a70196110b4859029d09c48d","modified":1408639884000},{"_id":"themes/yelee/node_modules/generate-function/package.json","shasum":"94e03b6a1e1ad15021787f99cdf9e8d52f361d73","modified":1456469176000},{"_id":"themes/yelee/node_modules/generate-function/test.js","shasum":"9bb3d8f4f20a97f1af0ef033d8dbe32693f9fb3a","modified":1406740670000},{"_id":"themes/yelee/node_modules/generate-object-property/LICENSE","shasum":"a95ab3a4b0e4bd978897f09b3b430a449da20a08","modified":1427465395000},{"_id":"themes/yelee/node_modules/generate-object-property/README.md","shasum":"e300730218d5bbf519653e5d19cfbd5857b78796","modified":1427465395000},{"_id":"themes/yelee/node_modules/generate-object-property/index.js","shasum":"47eacac5534f58609e9f3ccc3a1c5879c20f9add","modified":1431893671000},{"_id":"themes/yelee/node_modules/generate-object-property/package.json","shasum":"6de1b1018217fa9bca2157ca45751e43a2e4100f","modified":1456469176000},{"_id":"themes/yelee/node_modules/generate-object-property/test.js","shasum":"b738cbfd474028baa30f5b003e228356d61c6a58","modified":1427465395000},{"_id":"themes/yelee/node_modules/glob-base/LICENSE","shasum":"f6794e2167dc92e7ab5f2b00a15f0af45639a5a1","modified":1442599168000},{"_id":"themes/yelee/node_modules/glob-base/README.md","shasum":"83e0e13e0f9d9bed8b85f401fd22e6fd146fbc49","modified":1442599168000},{"_id":"themes/yelee/node_modules/glob-base/index.js","shasum":"2f15588ede319f3f78ecb5b8be65c80f8c1570cf","modified":1442930224000},{"_id":"themes/yelee/node_modules/glob-base/package.json","shasum":"1d39c9ca1bba71c6e15b3d2d44bf88aeefca4861","modified":1456469176000},{"_id":"themes/yelee/node_modules/glob-parent/LICENSE","shasum":"0f5ecc10b17b4e9208f2eee02966ad7b02d7ebf6","modified":1426989797000},{"_id":"themes/yelee/node_modules/glob-parent/README.md","shasum":"741eed87e0324d39712974e26c15ab63d819589c","modified":1442588290000},{"_id":"themes/yelee/node_modules/glob-parent/index.js","shasum":"bc23a7b46fa7a53ce69d21ea1eaaed6cee918e66","modified":1442588290000},{"_id":"themes/yelee/node_modules/glob-parent/package.json","shasum":"e8b68480cfb1ef8f56039be6b5e3a84ebcc395c2","modified":1456469176000},{"_id":"themes/yelee/node_modules/glob-parent/test.js","shasum":"b839f9516685893bc7b6229577e403f19ab6804f","modified":1442588290000},{"_id":"themes/yelee/node_modules/graceful-fs/LICENSE","shasum":"6560c016f1644ce652d83d039d8ba9e64795fd49","modified":1435431095000},{"_id":"themes/yelee/node_modules/graceful-fs/README.md","shasum":"3ca4000bd861d5d95e8f861fc35d30a31b48677d","modified":1435601369000},{"_id":"themes/yelee/node_modules/graceful-fs/fs.js","shasum":"8b8116f2fc0e6393cfed3b1076810ce5d02e0f01","modified":1435436586000},{"_id":"themes/yelee/node_modules/graceful-fs/graceful-fs.js","shasum":"48c86f6a8c193aa2ee2969f4b8fbf3c722ab97d8","modified":1454449073000},{"_id":"themes/yelee/node_modules/graceful-fs/legacy-streams.js","shasum":"f4a3583d4c3e8b0c407ab8406bdafb02b4055b7f","modified":1435436586000},{"_id":"themes/yelee/node_modules/graceful-fs/package.json","shasum":"f0a4f42d34e9b7dc344b0b0c10d152b70bab411c","modified":1456469176000},{"_id":"themes/yelee/node_modules/graceful-fs/polyfills.js","shasum":"57619610164625aeff0f6bbefc4008ac2d909b43","modified":1435436586000},{"_id":"themes/yelee/node_modules/graceful-readlink/LICENSE","shasum":"e9f4a5c36ecaa401588e457af96e7a85d53a98f0","modified":1423665419000},{"_id":"themes/yelee/node_modules/graceful-readlink/README.md","shasum":"a3e9fe045614e9dc2473a75cd9a7e9a6315043c9","modified":1423714083000},{"_id":"themes/yelee/node_modules/graceful-readlink/index.js","shasum":"3ecfe7f28912aa64161b8a6e4129c2b4fbcf50a0","modified":1423714095000},{"_id":"themes/yelee/node_modules/graceful-readlink/package.json","shasum":"7282ac602b37b8eaab3a5197930128dcc6da284a","modified":1456469176000},{"_id":"themes/yelee/node_modules/har-validator/LICENSE","shasum":"57fc502455231f1d10c4d2e67c261f0fc56bb17d","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/README.md","shasum":"43ef10fa75b3eb5369012ac32654ab907a79fb14","modified":1453244556000},{"_id":"themes/yelee/node_modules/har-validator/bin/har-validator","shasum":"702b45900cba1bd2ee74c4df1a5b51db0aeab0d7","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/async.js","shasum":"864f1787c6e6521d6495d337d7894d844dba24b6","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/error.js","shasum":"e08730fe6ce867fea7b32e8e7c6f9266b7fce592","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/index.js","shasum":"099021ac86914964d97afb35a9594e29c136bd0e","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/runner.js","shasum":"c0c49bddac013682d52bfff6065cceae67474fb2","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/cache.json","shasum":"24dd76d544e1c3c4be343e1a88e9ffad19705021","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/content.json","shasum":"896c9f34e3f38c5687255edcec798bedc98221a0","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/cacheEntry.json","shasum":"abb6d0b052b7f624f2e9efd5508c0614c4831b36","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/cookie.json","shasum":"fc6b61b7f65667ebd270e2daadfc21e6b6aec452","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/creator.json","shasum":"b0096cca448769435a9a1dfc8835bc560957fa97","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/entry.json","shasum":"161d6c3ab62b4fc423c5aa1d3ee1f67d98c008ca","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/har.json","shasum":"9b5debe33b9aa8c6055bb950ca5f19b1a1d82a42","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/index.js","shasum":"1bab9e9eb0c54be915c5303ee23cba4faaff0194","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/log.json","shasum":"9c72f7600e6fad2818459e76de0140ed9cb67422","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/page.json","shasum":"d3ca0cf8dbcc30f33b91b8e8db85982b01cc5986","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/postData.json","shasum":"123d9c6853b0e1a33147e2c04404aa33cf53a1ff","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/pageTimings.json","shasum":"2661f2488c8bfaec68b30b4e9dee25089277e448","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/record.json","shasum":"23a2f8245bfef93b6b87696af51c1e9d4a0302df","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/request.json","shasum":"ecdaba295ca01aeaa9f3f9779d1c94a051af5578","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/response.json","shasum":"e01a380eeb0b3c87c37f936ebf4888eae55dc3b1","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/lib/schemas/timings.json","shasum":"4879ffeb448af68307aa46910bd2d3ac2fde9246","modified":1448373288000},{"_id":"themes/yelee/node_modules/har-validator/package.json","shasum":"15261aa7ee9cf80fc21ae80710a80abf8403293a","modified":1456469177000},{"_id":"themes/yelee/node_modules/has-ansi/index.js","shasum":"e7305f641b51be9dc463cdfc1e6b7afb8d03576e","modified":1402774137000},{"_id":"themes/yelee/node_modules/has-ansi/license","shasum":"0c94f137f6e0536db8cb2622a9dc84253b91b90c","modified":1396798991000},{"_id":"themes/yelee/node_modules/has-ansi/package.json","shasum":"9d2063153c889c1e37c13d2450accb41b7b0749d","modified":1456469176000},{"_id":"themes/yelee/node_modules/has-ansi/readme.md","shasum":"8f5dd99e33b07d2f4abaff2410728acca335ebfc","modified":1435680789000},{"_id":"themes/yelee/node_modules/hawk/LICENSE","shasum":"23dc309f4a3614d359884bbc4a64d0ca20e41d68","modified":1453233148000},{"_id":"themes/yelee/node_modules/hawk/bower.json","shasum":"0394736479292c80f177ca8d29263d9162d489b3","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/component.json","shasum":"004be58031f7d1cbdbff8ca684b464df449cde8c","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/README.md","shasum":"332080064c5f554a1ad68a43ab48a68d2b49a1a4","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/dist/client.js","shasum":"78e967c19bffde7606b06c595c41e83cde6c0d53","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/example/usage.js","shasum":"9c61ce5a46828c4c26b93e06141dbee8679c33a2","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/images/hawk.png","shasum":"756c85c7133e66dc5c119c47081f7f890d046f77","modified":1447968927000},{"_id":"themes/yelee/node_modules/hawk/lib/browser.js","shasum":"d4f08ffcfa0012fdb1a304d0fdda5586cf959af3","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/lib/client.js","shasum":"781eb260241b46515df2f2f009969a772aa9dbcc","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/lib/crypto.js","shasum":"06d65d9f325d49f11a0bf223dc683648f6fac977","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/lib/index.js","shasum":"64f1cfdf834d8d679d020071124865b83a6cae72","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/lib/utils.js","shasum":"befb760ea6a14654fcce187b2b790f8292b404b2","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/lib/server.js","shasum":"ecde371bb849aa221cd138ba993f5fb19fff160e","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/package.json","shasum":"c7c6d3915a24909992014d08ca31094b2f10619a","modified":1456469177000},{"_id":"themes/yelee/node_modules/hawk/test/client.js","shasum":"fabb1388ee6f94ffe25870f2152d1a46c480dde3","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/test/crypto.js","shasum":"222fe636eb910e343a0dd0db76224fac92a47647","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/test/index.js","shasum":"9e790c1104e148298687c0ed87fd48ee14a943a4","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/test/browser.js","shasum":"fda1c8242cc48078540c30464da1d36a64d223a6","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/test/readme.js","shasum":"e8743507f0a6c8d261e1d037e8aadc11cda3ac82","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/test/uri.js","shasum":"a7037450a234ee97c7bce23dc5c2f295fcddbd47","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/test/server.js","shasum":"45a0a16ecee59114ad2765a73af25443125278ba","modified":1453400406000},{"_id":"themes/yelee/node_modules/hawk/test/utils.js","shasum":"042ec97613b298b257e409d54eeca7a84ef3f84b","modified":1453400406000},{"_id":"themes/yelee/node_modules/hexo-fs/README.md","shasum":"e7b7392751106ec7779a4b46a3c073d6857f2058","modified":1423636479000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/LICENSE","shasum":"914158dfad0452ceb55ea5e1822605ca05984bd9","modified":1455316199000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/README.md","shasum":"c61dc638bacfcdcd29172fff3c5d5c1f21431805","modified":1456437388000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/changelog.md","shasum":"bc6df7caea3b83fa361fa0a96c9b34c09465a93a","modified":1455316199000},{"_id":"themes/yelee/node_modules/hexo-fs/lib/fs.js","shasum":"7c8223301082331d297ab9ea7d04e5dc3cd4667e","modified":1447232887000},{"_id":"themes/yelee/node_modules/hexo-fs/LICENSE","shasum":"fecd013bdadc9ead2732027f06bf8fc19761efcb","modified":1417874762000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/browser/bluebird.core.min.js","shasum":"754aa8aa94dcddb47048cb34e077e36de6c60a8e","modified":1456440962000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/any.js","shasum":"424dfe2a1afeaad729ca2be5ccfd443311716c41","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/assert.js","shasum":"429a0325a101244b087bf4e6c9df81220aac49d5","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/async.js","shasum":"d41fd87ef2f5be6a2f8e09773a2029444a6c629f","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/bind.js","shasum":"6ba64f83e985a1cb7dcf945490e4c280460ccb25","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/bluebird.js","shasum":"f68f4e491f49be5a5a3c5d04fafcd8abaf02fc2a","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/cancel.js","shasum":"307b92b9575bc60d4f2c809b39690384cc324fa8","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/call_get.js","shasum":"5a2648cc4117f5ee47900e20bd533fb7e2fae1aa","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/catch_filter.js","shasum":"cbdedec0db19fe2af76d5594ed8bf819000d7c79","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/context.js","shasum":"ea7eb1ab2c8231fa6bfa8446cf730736735396e0","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/direct_resolve.js","shasum":"470ca4d9a7e387ceceb383bc2640202f5fa6bda2","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/each.js","shasum":"5118806b7208aa64317717392af157db042293c1","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/errors.js","shasum":"98deaaee17f36851937108257e028a7e237b3f5e","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/debuggability.js","shasum":"e1755c5125e759c7dc8f76027a5b667da3d3a257","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/es5.js","shasum":"019c4e8b62031ea49aedc86dedd20318c6122698","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/filter.js","shasum":"a5f3aee4afbc67d372e5b4fbaeac047d0d9c779b","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/finally.js","shasum":"4b0cea33e6afb07456cd370ce0e9519314ff0c88","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/generators.js","shasum":"95307bef68bbb63ff93250e91c1588d40346a43d","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/join.js","shasum":"669e0cb20fbd709fad37ccd05c5d68594135113c","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/method.js","shasum":"02a5a493c2cf2045fbb20b2751381e4b4e29dbe8","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/nodeback.js","shasum":"813463c70c195eec056cf2456a6fcf84929b3fd1","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/nodeify.js","shasum":"ebd75c010fcf1c4f709f4b444e62b80cfcde2a0f","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/map.js","shasum":"b11d74d7802c0f2c5fa9684a3b511b90b69fd6bc","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/promise_array.js","shasum":"0712bdda0498dfa8641c19c80c22b9472878f169","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/promise.js","shasum":"0027b108ee12a4ff04904733c2a993b0795e3712","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/promisify.js","shasum":"3831be99120a57a3c07406f7012467f02346e92c","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/props.js","shasum":"af5fc480eacd6cce94f3239729689e0899f6cd5c","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/queue.js","shasum":"6c24c68f716db1a6c18b5cad2a951f0df6ee76ec","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/race.js","shasum":"5f5b5403be19793dec5658af27fe996173eb4990","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/reduce.js","shasum":"5c1ef0e38b20065851c1784ed4f8a4c9699574cc","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/settle.js","shasum":"36f97c3732ae907af622fd4c859d29da1255fdfa","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/schedule.js","shasum":"e293eabeddf9c8918cfe665cba59087425cf8d67","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/some.js","shasum":"b548ddd7eb6b35ae6e97d931e0a8ef6dd512b3b5","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/synchronous_inspection.js","shasum":"e9dc1fa033797719d2f4227d86f02806e0574755","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/thenables.js","shasum":"bd86eeab8746684e570f6522e9a2cf6b6f51fe52","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/timers.js","shasum":"6b92ddefb82954c53019788ed1489fb3c39e9e9f","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/using.js","shasum":"07e405aa38b78a94790baee548cc0adecc251431","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/release/util.js","shasum":"e2c30b2ebac9f97f97cff01043b6c4bc59c0ddb8","modified":1456440964000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/package.json","shasum":"c48e97ba4a229a3ec5397ba67556f22b2ee6d09a","modified":1456469177000},{"_id":"themes/yelee/node_modules/hexo-fs/package.json","shasum":"35955780d8afe3ffd2ece6db58de458d65744ccb","modified":1456469177000},{"_id":"themes/yelee/node_modules/hexo-math/Cakefile","shasum":"3f879c8fcf7467252d76418dcc24a79efd1db556","modified":1394135122000},{"_id":"themes/yelee/node_modules/hexo-math/LICENSE","shasum":"f0c7cd0dcb6f00b98393878068ff3e6bf5f321f1","modified":1394135122000},{"_id":"themes/yelee/node_modules/hexo-math/README.md","shasum":"8950fbe3f80e91ac9fc7389f47df3613598b1c5b","modified":1440427872000},{"_id":"themes/yelee/node_modules/hexo-math/asset/math-jax.ejs","shasum":"4444910acf318e60c3b8e26dcea5c0dc7f0f9b90","modified":1433148240000},{"_id":"themes/yelee/node_modules/hexo-math/bin/Layout.js","shasum":"45d2f065c3b8cff5140457fceaa313e7190f7748","modified":1440429286000},{"_id":"themes/yelee/node_modules/hexo-math/bin/Log.js","shasum":"787903bd188b271238a1d85883a2b14b36450097","modified":1440429286000},{"_id":"themes/yelee/node_modules/hexo-math/bin/index.js","shasum":"e9a3c9234e8303e884c6bf2b7c4a64c06a3b2559","modified":1440429286000},{"_id":"themes/yelee/node_modules/hexo-math/package.json","shasum":"f4c0b5e9349c1f947b353c0381568436fc81f258","modified":1456469177000},{"_id":"themes/yelee/node_modules/hexo-math/src/Layout.coffee","shasum":"559a8b94329bcadee5a6415fe6349873767a98ba","modified":1439971056000},{"_id":"themes/yelee/node_modules/hexo-math/src/Log.coffee","shasum":"aa8bf17d420445dbc43de99cc4a2b4d0adead17b","modified":1430922677000},{"_id":"themes/yelee/node_modules/hexo-math/src/index.coffee","shasum":"d4ca1a39613a431b285fbb76d27488c9e49bf826","modified":1440429156000},{"_id":"themes/yelee/node_modules/hexo-math/test-runner.js","shasum":"ff91e02d3bff4d87ebf66b7f1795b11fa30beb26","modified":1440426760000},{"_id":"themes/yelee/node_modules/hexo-math/tests/post.spec.coffee","shasum":"a198c8a2381ac138fbd24f9694f59b9de046e1b1","modified":1440428159000},{"_id":"themes/yelee/node_modules/hexo-util/LICENSE","shasum":"fecd013bdadc9ead2732027f06bf8fc19761efcb","modified":1417874762000},{"_id":"themes/yelee/node_modules/hexo-util/README.md","shasum":"505d7f1c0cb16d8fa29bc113113144b444e43ea3","modified":1432119513000},{"_id":"themes/yelee/node_modules/hexo-util/benchmark/fixtures/q3.js","shasum":"cf86d7a1ef538a16ab1820c73989ad9dca610ffd","modified":1423585554000},{"_id":"themes/yelee/node_modules/hexo-util/benchmark/highlight.js","shasum":"b4b315e793e28e8097c9d0c2dcc25d90f7fea54a","modified":1423904011000},{"_id":"themes/yelee/node_modules/hexo-util/lib/escape_html.js","shasum":"b377e22a4cd4bc8275f3000436c1adcc37240c19","modified":1423549049000},{"_id":"themes/yelee/node_modules/hexo-util/lib/escape_diacritic.js","shasum":"77d53b732b1ce386d83796699b9c1a195e529bc2","modified":1423549044000},{"_id":"themes/yelee/node_modules/hexo-util/lib/escape_regexp.js","shasum":"d4d9c2e8c8e44c1e3845d3ca1883417c242ec1d9","modified":1423549051000},{"_id":"themes/yelee/node_modules/hexo-util/lib/highlight.js","shasum":"91d4d979ad4a25064b1ccac38af6d45c61a906ee","modified":1432119401000},{"_id":"themes/yelee/node_modules/hexo-util/lib/html_tag.js","shasum":"72bec783fb4388baae36ab83f0e6f1b7739b88d1","modified":1423549056000},{"_id":"themes/yelee/node_modules/hexo-util/lib/index.js","shasum":"f856198dc384a34682848952ab2a061ee37b753c","modified":1423549059000},{"_id":"themes/yelee/node_modules/hexo-util/lib/pattern.js","shasum":"6419b61151392dd74792ca407b7b6e854a7148a2","modified":1423549062000},{"_id":"themes/yelee/node_modules/hexo-util/lib/permalink.js","shasum":"51a6d22296d90be2a220fec69af04e9a6dea63d0","modified":1423549065000},{"_id":"themes/yelee/node_modules/hexo-util/lib/spawn.js","shasum":"665bc5378078d6a9df6d9c17064b8e4e24eba0fc","modified":1423549071000},{"_id":"themes/yelee/node_modules/hexo-util/lib/slugize.js","shasum":"5ba8f5d602fe905f05d65fbdf061eb35f1af230c","modified":1423549067000},{"_id":"themes/yelee/node_modules/hexo-util/lib/strip_html.js","shasum":"242044008bd8843aabcf5dba3403973556bf98b4","modified":1423549074000},{"_id":"themes/yelee/node_modules/hexo-util/lib/truncate.js","shasum":"37670ea4ae572e7ea778f109bb99c834fcb6e956","modified":1423549077000},{"_id":"themes/yelee/node_modules/hexo-util/lib/word_wrap.js","shasum":"07740bd92985955d803fd57d7a8f5ca0785cb08e","modified":1423549085000},{"_id":"themes/yelee/node_modules/hexo-util/package.json","shasum":"e71f68b1ba0c35ada2050e9b19f85637ebff4e06","modified":1456469177000},{"_id":"themes/yelee/node_modules/highlight.js/LICENSE","shasum":"cd25196630fe891662ad77810f0f6dee5bc85ddc","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/api.rst","shasum":"7ea61691713b45ca2bba06ccd64d382d05296ccd","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/README.md","shasum":"a21a3ba34192a449bb31bbe5d980772862781461","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/building-testing.rst","shasum":"435f8700ad54ebdc199fea29bd5709cb50c16356","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/css-classes-reference.rst","shasum":"48e28ebc13f1a6e8133b639702d7db9b82f9a2e2","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/index.rst","shasum":"2634f417a4667f011707ac08978673d16fb542a0","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/language-contribution.rst","shasum":"755e23f46a3ff5d2f59ebef2a6c6d7a5317bcc40","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/language-guide.rst","shasum":"2b57bea2a18d717ec85be5d13f1a06bd1b015017","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/language-requests.rst","shasum":"d5de8f9936fa7450384696c4d2454e28c5102a6f","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/release-process.rst","shasum":"f33baf124c0d5fc87b00ba4d6a391ee8eff0900e","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/line-numbers.rst","shasum":"fb2b891ec631ba4e18214d467114bfb026e42c5c","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/reference.rst","shasum":"26601a5495ed9b60b51c3cb6f61f2c446ec2baf6","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/style-contribution.rst","shasum":"2ab5b5efd88e5a21ca2c0ded58cf0b08bfb5bf6c","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/docs/style-guide.rst","shasum":"5dca4c99eb8e3d8cc3f432ceb61a8753fa1816d0","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/lib/index.js","shasum":"d904c9ca4f10864333e0b982c8c8d0fb14fddec8","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/lib/highlight.js","shasum":"56b2416a000b4696806d7fd0667f6de5745e8959","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/1c.js","shasum":"61ed1b122cb4b66e99860202228bbcecf86688d7","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/accesslog.js","shasum":"348d234c7253b8b308b74376fd92824d7788e745","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/actionscript.js","shasum":"110c1d6e8cd8923ecd88143573000e69458733e5","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/apache.js","shasum":"e9a7f6d93f6df393afc765b13c0b79f7eb2fc510","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/applescript.js","shasum":"97602a06ab12d21be430434f1b7f5250044c4b77","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/armasm.js","shasum":"298a03e22aba431d02779773c83a71557ba98abc","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/asciidoc.js","shasum":"cb0ff2842460b98ba57cbfd74dd42f59a399e8c0","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/aspectj.js","shasum":"fccca663ff2c4319aa293d27a4556ba58ee80dfa","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/autohotkey.js","shasum":"e2792bae0850add4bd0a791c51dfdb29893cf87c","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/avrasm.js","shasum":"c497417ec9e6e93bee385214459f1d685f053908","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/axapta.js","shasum":"33865e7e36e25f7f1f16fde557a7339a414fb8a4","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/bash.js","shasum":"c1192048ddaf6b0978e978ea61cf02aff0a728dc","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/brainfuck.js","shasum":"b6d4f266923cc946678a9060be5ad4a02a358db8","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/cal.js","shasum":"7dcd3c1d4d54cc47af2bbe47dbdf37aff80c05a5","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/capnproto.js","shasum":"ce268c5b7a8b2debd7098b42e3c6cb0cd2f8ff54","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/ceylon.js","shasum":"559a928a3f7d2035d5b0f1d202410cdb0c12902f","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/clojure-repl.js","shasum":"bbc6ed46a75eac8686e6a579f1c9f1591a1b5421","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/clojure.js","shasum":"4bcf48dd668a16921ad35595f3fd3f5f1a77c47f","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/cmake.js","shasum":"deb21a64ead6c7a0a36c7223a8b53f2fa0098cc7","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/coffeescript.js","shasum":"bd4d69cd7e54c22fe436e9830eb9234714d99793","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/cpp.js","shasum":"dc653c01797481efa22544de479c183041857832","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/crmsh.js","shasum":"59ba1fc83bbf3ecda19c370c898876c95e241328","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/crystal.js","shasum":"859021318ae2178647d9f6d854b0d9d5f49a3049","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/cs.js","shasum":"f64640d2676e6fc9ae30a1f27cf6ae2a71c54240","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/css.js","shasum":"38b3998d0c7c4795909bee6243ef9c65291eae66","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/d.js","shasum":"2c5a4d98aec0b07d887c28840e513827ef5028a8","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/dart.js","shasum":"b35a466e43c9af8b9fbffad715b9fc87629e7772","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/delphi.js","shasum":"ac9c176dd6fe47fd2503ce5f2a9140fb2c29c68c","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/diff.js","shasum":"a07c33f6b720027207c6c6bf9415be4f1d8b3734","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/django.js","shasum":"4a06e057204142d6f4d15d9c1de68b7e4e2d5f1b","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/dns.js","shasum":"8abb28525182765379c9bc5e23cad54aacee8ab1","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/dockerfile.js","shasum":"84de7113a71f65d64542fb7ac87d7fd10575ab8a","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/dos.js","shasum":"e077531e84b108d337717cd5229875babd8d9179","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/dust.js","shasum":"3aa6b1926630e7b1dae64d6eb4335dec33b6623d","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/elixir.js","shasum":"b3b87d8e1f58d63a5d370015bfde97128dd6376e","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/elm.js","shasum":"a10e0d6325f971a3211c1ecf49cfb27c1b5a16e5","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/erb.js","shasum":"3e67ebd4a54e38f7c4352facbb0114b914df773d","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/erlang-repl.js","shasum":"79351b773436b5d88df7d44c6b40dbd719b3dfc1","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/erlang.js","shasum":"390b9bb4f16f51c82590136e7daabfd11edfa719","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/fix.js","shasum":"daf48ba346f1a2c6c0142b657012d693c9049cf9","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/fortran.js","shasum":"bdc04f702c69d42e9a4eae0f7921121e5d89df80","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/fsharp.js","shasum":"c3867683caa6260630b1b9b1a0efbfde70105623","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/gams.js","shasum":"ff0e9a2b4d5a71068815f552d71fc6cf3c76cb3e","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/gcode.js","shasum":"493eef264eccfac19029018a977a6292bddf6b4a","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/gherkin.js","shasum":"8d7a8fdf59e3b84bea705e7d32a0ee5a17964bb7","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/glsl.js","shasum":"36eaed94ae9d5528d4f2465640631ba51f03f3b0","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/go.js","shasum":"53c4d96ed684d0be2c96b0e1fcd8ee5333a3c849","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/golo.js","shasum":"5cfe2f157698bc3aef14a971a2ec5d6c358a2152","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/gradle.js","shasum":"3c7ba57616e77ac59b59810515bb6d2bebd6b6f2","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/groovy.js","shasum":"ececcffca70b607fa655c5eaf0a325bf41557415","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/haml.js","shasum":"ca0ca111914fd3367868f18c01584c45fb5080fe","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/handlebars.js","shasum":"a52bb63a442431ea0f64dfabd8cab68b410bd418","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/haskell.js","shasum":"19f391daddbf9df034e37d794e99c2aed5b73d50","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/haxe.js","shasum":"84c476ac55414cf65bba0e3a721656165cd9bf19","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/http.js","shasum":"15a54cce4dfa66b2349bd1a567ce1182bb640f1f","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/inform7.js","shasum":"b444ec5da41d23677cbbcc7a0e0bba8928648d7a","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/ini.js","shasum":"47d65b98340583ad92a22223c0ce5996bb79abfd","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/irpf90.js","shasum":"dd659158f3bf4b0e03abe31c664510250c86c2c8","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/java.js","shasum":"65b3369ffdf5c0a074e94e490ffc1457bdd667cb","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/javascript.js","shasum":"7aa13c3d6dadd71ec99ce7dd0085abd961fd622e","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/json.js","shasum":"62840f0827d6fea20131011a4584ea6b2fa87dea","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/julia.js","shasum":"6bb9988c1305cca4556d929b29b0d01e63e6f434","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/kotlin.js","shasum":"8b8e5d05f33d8efec059d7f4ccd967b89a8cb3f2","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/lasso.js","shasum":"f98c0315b7faec99ec0f407afd5679d7248ec821","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/less.js","shasum":"79e6c082568d6ba68a81037a97c6c0fa9ecc5800","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/lisp.js","shasum":"bb2824da20ec714f51871423275272de8f1cabe1","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/livecodeserver.js","shasum":"aae639ae0dec89eac37a39bf9efefb82d0b8460e","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/lua.js","shasum":"be1579ced5e9cc73c3121d254fc8ef6632ab6f70","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/livescript.js","shasum":"4319c4b7b89395e3a5d60f3688516cb0cf6d2df4","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/makefile.js","shasum":"e2f27cb356b2f156671a97833b07743e9b73fad8","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/markdown.js","shasum":"dd48057b9379a0aa58db9d1d9e0cc584c089b073","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/matlab.js","shasum":"5dd585f626ef96d8cbd3880de1566e9ae365f504","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/mel.js","shasum":"27451a7f902745f0e00e1d04b01e4001b33cd370","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/mercury.js","shasum":"ba475e04e5130742d71ab68d84664ead15ad70d2","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/mizar.js","shasum":"009acb028481b4f3ad95bec4d0386bb2184e7acf","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/mojolicious.js","shasum":"50b50206e149b48884243aee3fdc076b2609e095","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/monkey.js","shasum":"a751400f07f0e32cae87b4bb950be8b0583b9f82","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/nginx.js","shasum":"51763551247a1739aebf870c966a4e60f2350529","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/nimrod.js","shasum":"18c05d58ad3e4c9646039f3be47d39df303e7525","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/nix.js","shasum":"871988dff9dc4141699e45e83e99e0a50b4cb645","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/nsis.js","shasum":"6f4f9e7f1de4fe7363ff1f1590ba1b7f5e68cc76","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/objectivec.js","shasum":"88e27614c98ad0252612395f6e205900dd4a796a","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/ocaml.js","shasum":"9978a9ccf4917ca17e6e184d18b4357c073c7516","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/openscad.js","shasum":"152775f97933e6285e698a91f1b5f40eebfb5a32","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/oxygene.js","shasum":"8dc402a5f274062c54eb76d1ee2d0ee0a3f4ba6e","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/parser3.js","shasum":"6c38ffb148c96f192ff0313bdfa19ce7013ab819","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/perl.js","shasum":"bc50e37a87065629b75f24e3e571f274590b10b5","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/pf.js","shasum":"244281f22d31b13c0c155565e9fcc0d9eec2428a","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/php.js","shasum":"74c17503116bd6d4e8c2fe51fbd5bde8550a3676","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/powershell.js","shasum":"2173046b66c5755c5bda0bbdaa22e6a7f8b435f0","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/processing.js","shasum":"6bd347bf6486e0337684462988bf5addb6e2bd6f","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/profile.js","shasum":"685922148fc932ec49f8433a0d767def37701791","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/prolog.js","shasum":"69823127471c48ed600f73e0ba95f92222a802f0","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/protobuf.js","shasum":"ab7e40c2f5b0b04f88fd5feceef1285684d24ff3","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/puppet.js","shasum":"7b0bb7da0f65611f5396fff63b0608ba82d2c33e","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/python.js","shasum":"a884224794f97e69d62a0b6db6f0678e591cb197","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/q.js","shasum":"116a650c0c30b52141693a208097e147bd9d1378","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/r.js","shasum":"d4e0224fa019df6fbfdf32173aa6667748e9ea11","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/rib.js","shasum":"6ac4095f443d77730802603b2b9161a9bcf72100","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/roboconf.js","shasum":"a1ec38aedf65a53abfce1b04e0bbd54fda03c2e6","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/rsl.js","shasum":"68f867e17a901b743af1a624680ef26fdb8e9e93","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/ruby.js","shasum":"570806e9162d6394fc6885c82f5c27bb11311799","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/ruleslanguage.js","shasum":"ace3153b01664dc4b8a51f62c02018e73e2f2db4","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/rust.js","shasum":"1d6ad910ec4dcd1d27a86df7a41b80aecc86a6d5","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/scala.js","shasum":"936f51637c364721051fc827927d95066878dad7","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/scheme.js","shasum":"68f01b2d3de0300cb28d4020ec8f6fd7df18d84b","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/scilab.js","shasum":"81221b510c6272236592413a235d9adee342ac1e","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/scss.js","shasum":"fad120e03a9e8183392b60a9b56f0d3860cb47c0","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/smali.js","shasum":"e3a841dfdb71cd73d08bc45e7959ef94166ed591","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/smalltalk.js","shasum":"9b24b75f9f8a17c11921fbcb7470d7149bc29db3","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/sml.js","shasum":"96dacca1adac072a435fa4e261a412b3ff2399e8","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/sqf.js","shasum":"32517e6e810f6393b501143b88b55e5528c1efe6","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/sql.js","shasum":"d777cb844d1c5ed6663dd273dc1c99860ada750c","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/stata.js","shasum":"b386d678ab5fd53248f031a073f8208987ac6101","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/step21.js","shasum":"62b3588474ca51e89654c57d89284863998a209f","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/stylus.js","shasum":"b8b9e7fc5fca0db652d478014a1a115ee7df5aba","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/swift.js","shasum":"c1b0ced507c0160443086e536100f47154260402","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/tcl.js","shasum":"6713527feb82802794d99a720db8c8df9bca6bb1","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/tex.js","shasum":"ff02877d2c34038a3653aaa1a713365a133e20b2","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/thrift.js","shasum":"47c807c1cc33a57f6f2ecb9e609f56ae74d5ef77","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/tp.js","shasum":"6ce686b52e9b7584593272458b62f98e37656c82","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/twig.js","shasum":"568c30ad66bd5b12e4b0bf1501e7ab06978c3861","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/typescript.js","shasum":"3fc36d7a97a6d6ead113554a8b00423aa0963240","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/vala.js","shasum":"8611195b4bb27192592a459bfbd165de91e42c4b","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/vbnet.js","shasum":"d7da8c3103102fe6ff90944fa0cfaea9d0fd9583","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/vbscript-html.js","shasum":"af6c349a4ce7cabf9e94168aa75dfa350664a021","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/vbscript.js","shasum":"29df599716e626e26b384e259f052c9a68fd29f0","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/verilog.js","shasum":"3c41b6191d6cfa51106bbe26f4882136d64e2f0a","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/vhdl.js","shasum":"f0f69611e81cccb5b43fa96cf32ddb8641ea1382","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/vim.js","shasum":"94df96a30f542f96941ca68461c8f6a1b0131153","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/x86asm.js","shasum":"f3cd86bb639bcf19d6d2fbf35632255079ca9b97","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/xl.js","shasum":"6f756582e5a2e6d09bc604daf71b8982c4a3bd32","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/xml.js","shasum":"ff60e90a9fe5a24b1e55e40d32412c0e238dd662","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/xquery.js","shasum":"8966fab0692d542b4a72da5e36d5b1705d650fad","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/zephir.js","shasum":"04302b6372d311ec54039b774f3cf2d207048141","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/package.json","shasum":"f675e3d6dd159d3ea83afc6fa68ddaa5d6539c16","modified":1456469177000},{"_id":"themes/yelee/node_modules/highlight.js/styles/agate.css","shasum":"0fbb15c9b6ad15cef60cfdf420e4df927a7ecab6","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/androidstudio.css","shasum":"7975515dd4054ab242d2bfc7a5930104aad176f2","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/arta.css","shasum":"df88af40b83fd852221e98c13fbb691a3a242fb5","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/ascetic.css","shasum":"382055a60d38dc255f78309365c6939cac024c05","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-cave.dark.css","shasum":"3e9337c582a6bbb5e9f8dbfaad38fb5052b91e76","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-cave.light.css","shasum":"d3a6bcbabb52e428ebfc4eb3e6c6f7af01010af1","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-dune.dark.css","shasum":"85c4c34762de07402969170bea730e93f5fbe430","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-dune.light.css","shasum":"b20449228e2b8e4722d7a915caa3a5c2a47de6bb","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-estuary.dark.css","shasum":"1313f34214c0a2ccf4cc0e3a5c1f180dd5682395","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-estuary.light.css","shasum":"0eaedb3476ae9f4666a1bfa88b5f3c961264dfe9","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-forest.dark.css","shasum":"03fa294773c1d23ffd3e46a3bd4f72710c874f9f","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-forest.light.css","shasum":"3f1119c02679eb5255a6d602cea509accb20bc73","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-heath.dark.css","shasum":"32f01466ea6ba09c12b313339d6422ccaf5f2d66","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-heath.light.css","shasum":"fd878219c09b2abc4ba5a1d860a5c2931885e8cc","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-lakeside.dark.css","shasum":"6fdba8847238f7ebeb691f389ce4820d01826ae4","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-lakeside.light.css","shasum":"40e617deac0510adc7244ece8fa5027a9ae07e85","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-plateau.dark.css","shasum":"53aaeb480a7cb6f66dd1854f2903f76ea192faae","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-plateau.light.css","shasum":"623a20e55598f0e4b2e3d7097fda8f2425d6e789","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-savanna.dark.css","shasum":"3a389804a3c012a0fb0861dd53a976399e2ca13a","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-savanna.light.css","shasum":"72b67963ff9f6e408de9649a06ff5d7c5ba1f86e","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-seaside.dark.css","shasum":"f4caafcfc8f13a23c178db3a98aca49d08de2e17","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-seaside.light.css","shasum":"673e4c94b36edc212d35c922e5528f0e04b2b227","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-sulphurpool.dark.css","shasum":"e91ddfb4c112913210d8a4416bb38bc9d8ff131e","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/atelier-sulphurpool.light.css","shasum":"357faf52514bc8a195b7a84f53b68c370e1e331b","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/brown_paper.css","shasum":"583d09e7059b84fe72d02b18a9023b46218500d9","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/brown_papersq.png","shasum":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/codepen-embed.css","shasum":"c9e340a2e6a8c062722e1e33e7e841ed349f798c","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/color-brewer.css","shasum":"66b81f39fcb69febe03d3018d729efc6a2cbbcf1","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/dark.css","shasum":"0f893c1f0a37af0cac6f075a357e5de84747695e","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/darkula.css","shasum":"db07929ea9403200c45532af9852aab061fbfb56","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/default.css","shasum":"fc74c98fbdb179d75e150b9cf0432f258285dc2e","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/docco.css","shasum":"8db030f528692f94936e3ac710e08f521a49a0ec","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/far.css","shasum":"6f154bc013488a9deb4f4717bfa8e6b16bc93b41","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/foundation.css","shasum":"1545f3d63ada40db75b1b71f7ed3f90e57e1749c","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/github-gist.css","shasum":"2800b036956e2e72d5f15c412de0a2537831e358","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/github.css","shasum":"d8b1aaf953f8e2052922c814eb4dcbbaa64e52e6","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/googlecode.css","shasum":"d0f57be2df19ff76a2e5c21ac0094b61fd643cc8","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/grayscale.css","shasum":"167d783f4875abfde4a8aaafa623f0529df62416","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/hopscotch.css","shasum":"52d16e503f2640e90aeae8ab80cc9c4163300bb8","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/hybrid.css","shasum":"17e57397682f2886905776366e771197076bb631","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/idea.css","shasum":"5fd4d8b1e0e3f8331fa55474f1c71eb2facdd51d","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/ir_black.css","shasum":"d38e60030d8e2b7a57b2ae815c956fc7bc0884d3","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/kimbie.dark.css","shasum":"1d9657ec0423d7814e59b66eafa831ac3b542750","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/kimbie.light.css","shasum":"8f16189114599e7a8eba8239d7fa4f013a3e519d","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/magula.css","shasum":"6e073517a27a7b7976105444f4070df047711b9b","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/mono-blue.css","shasum":"cf79468d71e4aa85e09eebaac95df9217d2e1d17","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/monokai.css","shasum":"2ec82c30dc528fbfadbe7183592c96818fb8f414","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/monokai_sublime.css","shasum":"b9942180dc9885f97332380f7393301b9f831e5c","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/obsidian.css","shasum":"ec9ab28a0a3c759cec98fd5ceec4dd7a9e94e65b","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/paraiso.dark.css","shasum":"9fe2f1ce4a4ce18e7911af3479e38a54a4d83470","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/paraiso.light.css","shasum":"4b8898be4e40eeea6848c5a5b543466123f1a1d4","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/pojoaque.css","shasum":"ed3bc0de4cfa705cea98f4f07f277c4810a75527","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/pojoaque.jpg","shasum":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/railscasts.css","shasum":"0a5019aef66510fa5c158ec6d3003a92240d4424","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/rainbow.css","shasum":"e1bef38c83e64617b7d7b0badaab2f364e877dfa","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/school_book.css","shasum":"716c7c5eb4d2529cfe4ef4e74177dbfb21f1cc9b","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/school_book.png","shasum":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/solarized_dark.css","shasum":"a9d1a0974dd5e30303b788f5963ef99906676aa4","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/solarized_light.css","shasum":"d116ab023b13147b8a4a65fa794ddf5a751c1e6d","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/sunburst.css","shasum":"17fa1331860966d3c0cf0b4ba843e1f08ff72151","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/tomorrow-night-blue.css","shasum":"75fb844eb5067597913e5bc70f7eb0549c3743bd","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/tomorrow-night-bright.css","shasum":"1693875456b84c7181adf57ee7801b7605e757ce","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/tomorrow-night-eighties.css","shasum":"a5f10d6219d89529e14b693096bff207bd571345","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/tomorrow-night.css","shasum":"8da392d6043506f726a7b9e336f08230f3d039f9","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/tomorrow.css","shasum":"6506530a73d3ca424b00f0abd8d906a39b87acb6","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/vs.css","shasum":"8bda9de8667c5a3c54283b9f9dcfbcd6984844c5","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/xcode.css","shasum":"8f6bd0eb192b17346eaca292776c61148e48a56f","modified":1445295323000},{"_id":"themes/yelee/node_modules/highlight.js/styles/zenburn.css","shasum":"8ceec984b4ac7cd39ec17ba6ee38cc3be04b06db","modified":1445295323000},{"_id":"themes/yelee/node_modules/hoek/CONTRIBUTING.md","shasum":"61998267d75f17fdd423c1c742edc20a1561c1e2","modified":1441988248000},{"_id":"themes/yelee/node_modules/hoek/LICENSE","shasum":"8798f9342afed7351f4aa459b96e4d1062c1dd89","modified":1441988248000},{"_id":"themes/yelee/node_modules/hoek/lib/escape.js","shasum":"5ccf43b55ca0fbbc307a91235127af5601bd1187","modified":1441988248000},{"_id":"themes/yelee/node_modules/hoek/lib/index.js","shasum":"cfd3b556015082fc786d83c3e85ade81f448aafb","modified":1442857232000},{"_id":"themes/yelee/node_modules/hoek/images/hoek.png","shasum":"61fce871b635b32957b3c8c4e3c523eb2b2ac58f","modified":1441988248000},{"_id":"themes/yelee/node_modules/hoek/README.md","shasum":"fa10590d10b5c14546e9124bf634621583235285","modified":1442428161000},{"_id":"themes/yelee/node_modules/hoek/package.json","shasum":"959e30c5f468cc3ec0aafb9aad717022cf02338e","modified":1456469177000},{"_id":"themes/yelee/node_modules/hoek/test/escaper.js","shasum":"206886beb62a1d9d907b3838b20eb2037826167a","modified":1441988248000},{"_id":"themes/yelee/node_modules/hoek/test/modules/test1.js","shasum":"32aceae0ba03e9116b108f41d74bea7d163bb56f","modified":1441988248000},{"_id":"themes/yelee/node_modules/hoek/test/modules/test2.js","shasum":"31071671a8bdb854825c1cd90e29c30e9203b9fc","modified":1441988248000},{"_id":"themes/yelee/node_modules/hoek/test/modules/test3.js","shasum":"4b695a807655475e7d89966828af28b7dee15ec5","modified":1441988248000},{"_id":"themes/yelee/node_modules/html-entities/LICENSE","shasum":"f10f3a5e9b16a526fbf6abc4be406e6f07ecad93","modified":1408403203000},{"_id":"themes/yelee/node_modules/html-entities/README.md","shasum":"c7fac7bcffcb689b87be76cbd84c784b680eee76","modified":1440607446000},{"_id":"themes/yelee/node_modules/html-entities/index.js","shasum":"eb15b4fed782c7736a02ad14c97901080ab85f44","modified":1421057245000},{"_id":"themes/yelee/node_modules/html-entities/lib/html4-entities.js","shasum":"eb793b1708bd3305c33b0db77a15d04d330a6d95","modified":1444335075000},{"_id":"themes/yelee/node_modules/html-entities/lib/html5-entities.js","shasum":"ec6bfa76b6e8f84c13b96f7af392d212abe71e59","modified":1444335075000},{"_id":"themes/yelee/node_modules/html-entities/lib/xml-entities.js","shasum":"f7a40c06be6bdb504476f1c864db0fb49898e8ee","modified":1444335075000},{"_id":"themes/yelee/node_modules/html-entities/package.json","shasum":"2b24d87aa482d9ade5a350b98270d37fb74d76f7","modified":1456469177000},{"_id":"themes/yelee/node_modules/http-signature/CHANGES.md","shasum":"59a2ab5cc1ac7f7691560038beb2349e628eeacc","modified":1453759387000},{"_id":"themes/yelee/node_modules/http-signature/LICENSE","shasum":"10b8ac49ffb8f7cc8bdca9303209a1b3b2f3587d","modified":1442600921000},{"_id":"themes/yelee/node_modules/http-signature/README.md","shasum":"5847fa2ec86a2ca744776acd5528fdfd6c3377fc","modified":1444857627000},{"_id":"themes/yelee/node_modules/http-signature/http_signing.md","shasum":"945eb22661d1c43e547371ac8d354a4b761eab09","modified":1453759268000},{"_id":"themes/yelee/node_modules/http-signature/lib/index.js","shasum":"996c8efa1d7896034c980e498bec866824662d52","modified":1444858648000},{"_id":"themes/yelee/node_modules/http-signature/lib/parser.js","shasum":"c47fbe5cb6f1be3c5a5d62f9085273f3403ff401","modified":1444858648000},{"_id":"themes/yelee/node_modules/http-signature/lib/utils.js","shasum":"dce96d033869c424854178ae71991fe39b7c58b5","modified":1444858648000},{"_id":"themes/yelee/node_modules/http-signature/lib/verify.js","shasum":"f0603457d003b72d484d608b266566e771644438","modified":1447890069000},{"_id":"themes/yelee/node_modules/http-signature/package.json","shasum":"90b8224f9f0f66686e13317e0b54cbffc692d1d3","modified":1456469177000},{"_id":"themes/yelee/node_modules/http-signature/lib/signer.js","shasum":"5e312acbe0c57117dad754fa369a36dca4569bbd","modified":1453759272000},{"_id":"themes/yelee/node_modules/inherits/LICENSE","shasum":"3b0e8d58a362b1787ef3504fba4f593b22f3cee4","modified":1376950172000},{"_id":"themes/yelee/node_modules/inherits/README.md","shasum":"f2f8d26f1cf5fb1e3a68aa225221b064f999fefb","modified":1368714278000},{"_id":"themes/yelee/node_modules/inherits/inherits_browser.js","shasum":"7c13eacf36e79e5e7dd257d80ec25846e4df7eb3","modified":1368715198000},{"_id":"themes/yelee/node_modules/inherits/package.json","shasum":"d54a3e589cf048c1d2ac452fc77ac7c1bb744ef6","modified":1456469176000},{"_id":"themes/yelee/node_modules/inherits/inherits.js","shasum":"3146ed5f0e6053ad30398afdbd5a0d6a4133a4cb","modified":1368714177000},{"_id":"themes/yelee/node_modules/inherits/test.js","shasum":"ba3f458c9b47c1bcd3fdf5dd9289b7aa0ae90b1c","modified":1368715388000},{"_id":"themes/yelee/node_modules/is-binary-path/index.js","shasum":"575833c2dfcc83b547352b7432bac1e82bcbee35","modified":1432553532000},{"_id":"themes/yelee/node_modules/is-binary-path/license","shasum":"0c94f137f6e0536db8cb2622a9dc84253b91b90c","modified":1396798991000},{"_id":"themes/yelee/node_modules/is-binary-path/package.json","shasum":"8769aeee92d4ef57cd415b696448cb8e962a9123","modified":1456469176000},{"_id":"themes/yelee/node_modules/is-binary-path/readme.md","shasum":"1f6cadc94e211099cf21ef60f65fa27c4d765c26","modified":1428394458000},{"_id":"themes/yelee/node_modules/is-buffer/LICENSE","shasum":"07d9563f6153658de124707787ff43f0458ab24a","modified":1442461838000},{"_id":"themes/yelee/node_modules/is-buffer/README.md","shasum":"911a274167f1829e07fa8486b876a8530b77613b","modified":1452660628000},{"_id":"themes/yelee/node_modules/is-buffer/index.js","shasum":"a86311f370aef9487822f239d639daf0bad8ca1c","modified":1442462053000},{"_id":"themes/yelee/node_modules/is-buffer/package.json","shasum":"eb1809041904bdbbeda117f1cd79e4775e26eeee","modified":1456469176000},{"_id":"themes/yelee/node_modules/is-dotfile/LICENSE","shasum":"7e21c9f5aa0a1be61e943a935506095ea40bbafc","modified":1421900238000},{"_id":"themes/yelee/node_modules/is-buffer/test/basic.js","shasum":"350e8942b46982704e563ceb0583f7b253cfc849","modified":1442461838000},{"_id":"themes/yelee/node_modules/is-dotfile/README.md","shasum":"a339a6cc02297687e3420dc751b47b9ae7d400a4","modified":1445317061000},{"_id":"themes/yelee/node_modules/is-dotfile/index.js","shasum":"c1a0fc16e3b10c1dbdfc77cb46097575bf7293e0","modified":1445316868000},{"_id":"themes/yelee/node_modules/is-dotfile/package.json","shasum":"e0d1280948b5cf1d9cc45ef90b14b2e4c462cb55","modified":1456469176000},{"_id":"themes/yelee/node_modules/is-equal-shallow/LICENSE","shasum":"f6794e2167dc92e7ab5f2b00a15f0af45639a5a1","modified":1424905916000},{"_id":"themes/yelee/node_modules/is-equal-shallow/README.md","shasum":"d3ec7e25f88751d4aa7536c376f32d97816038ec","modified":1435030788000},{"_id":"themes/yelee/node_modules/is-equal-shallow/index.js","shasum":"8ad23aff08c366907d80bf6f3d24a6c6a13d6a89","modified":1435030513000},{"_id":"themes/yelee/node_modules/is-equal-shallow/package.json","shasum":"bd1c3e27178353ac668602ee02809f3810911605","modified":1456469176000},{"_id":"themes/yelee/node_modules/is-extendable/LICENSE","shasum":"f6794e2167dc92e7ab5f2b00a15f0af45639a5a1","modified":1435545738000},{"_id":"themes/yelee/node_modules/is-extendable/README.md","shasum":"e47f712e0969fbe6cda9f18339d0fc7ad37cb62c","modified":1436050202000},{"_id":"themes/yelee/node_modules/is-extendable/index.js","shasum":"c38e98e8a299a93debd6e95bdcb56da06580a884","modified":1436049745000},{"_id":"themes/yelee/node_modules/is-extendable/package.json","shasum":"529193b5df16a77f0841f7b2fe1119b3635c0bad","modified":1456469176000},{"_id":"themes/yelee/node_modules/is-extglob/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1424431146000},{"_id":"themes/yelee/node_modules/is-extglob/README.md","shasum":"70fccdf58f29062dbed00016f2790ae604a83d54","modified":1425675606000},{"_id":"themes/yelee/node_modules/is-extglob/index.js","shasum":"f2caa8e7efa77712cf91d0f349830dc563f1c9fa","modified":1425675072000},{"_id":"themes/yelee/node_modules/is-extglob/package.json","shasum":"83dc18b3488d15cac2fd358f58e99ee66ce0a506","modified":1456469176000},{"_id":"themes/yelee/node_modules/is-glob/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1424431146000},{"_id":"themes/yelee/node_modules/is-glob/README.md","shasum":"c63677aa8188743e55fa3988d143b031e08ade12","modified":1443760455000},{"_id":"themes/yelee/node_modules/is-glob/index.js","shasum":"b3dcfb08edc51fa11b2f6a028e432f7f81c67ca8","modified":1443759204000},{"_id":"themes/yelee/node_modules/is-glob/package.json","shasum":"dd1de889eacf686009f7a93cdcbf1295c320b6a5","modified":1456469176000},{"_id":"themes/yelee/node_modules/is-my-json-valid/LICENSE","shasum":"a95ab3a4b0e4bd978897f09b3b430a449da20a08","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/README.md","shasum":"f2703730d556b550b13e00597a8ccb2f43eb1941","modified":1456180252000},{"_id":"themes/yelee/node_modules/is-my-json-valid/example.js","shasum":"cee9de4194e0c4ba372b5678983d6d701385d355","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/formats.js","shasum":"2d511859d3d654f3bf604a47e13f98e9b1bc305c","modified":1453067668000},{"_id":"themes/yelee/node_modules/is-my-json-valid/package.json","shasum":"4ce9e0fe4100b3fe3956f8391ef3e7b271e2b382","modified":1456469177000},{"_id":"themes/yelee/node_modules/is-my-json-valid/index.js","shasum":"6c62fa78f5375a9db47f9006b883e049ebe700bb","modified":1456180252000},{"_id":"themes/yelee/node_modules/is-my-json-valid/require.js","shasum":"24081d202d91cdd0b4910b57dfd434ab41543b07","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/fixtures/cosmic.js","shasum":"94a2af635cae7d0491fce9767a67d06f651e0244","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/additionalItems.json","shasum":"75644b309367675ce21d8b35b9baee049a58e159","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/additionalProperties.json","shasum":"34478026a586b1ff8b96dbe54efdf7515099da7d","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/allOf.json","shasum":"e98aea1d36d932870561f0c32c32fc5858f251f9","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/anyOf.json","shasum":"8081feb305d328878b37a7cc3b296eb5544c239d","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/bignum.json","shasum":"32b70fb2c2156c979702eec5c18a86c1fe6d0bd7","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/default.json","shasum":"17c051cc94a9fb40ad627b04a41d7dce9150e3b5","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/definitions.json","shasum":"0963ac4f014a0faf6ad37554c9af03f63dad9b02","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/dependencies.json","shasum":"d239f1bb8cfffb7487335c73e02c6cda10d4ef5b","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/enum.json","shasum":"4b96cc24245950f9fad0916113a5056d9f51c2e5","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/format.json","shasum":"3d60bdb3fbb2d47da991e99e51bb9ab241703c44","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/items.json","shasum":"873828cf8ad5d2701022650e99367cb0a89624b0","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/maxItems.json","shasum":"580cdb7c89cd07b45f3fdadb2279bb13108b79b4","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/maxLength.json","shasum":"3f6273e86c31605607384559df5ee9c92201c5bc","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/maxProperties.json","shasum":"1703d6ef976a74eae8ea6cd21c131853c6ca5f6c","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/maximum.json","shasum":"c205edb4c5bd171c9e1f4955f5cc3b94ca78cb0c","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/minItems.json","shasum":"176fedc074768c6ec5c7ceb979f23a6a4bd0be58","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/minLength.json","shasum":"99eb79755bf43df641900a01e8ac9ff5becec8d5","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/minProperties.json","shasum":"b61b2829899d8a5f6bbc8bde2b694b69bb35d38a","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/multipleOf.json","shasum":"e8c9555c09db80f5398d2d73840358a0aec80529","modified":1456180252000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/minimum.json","shasum":"1a849968c80db05a9ad0a92481edd93dee567804","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/not.json","shasum":"5b9567e8409e28b256f3704ca83447f0d0abb707","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/nullAndFormat.json","shasum":"8682b818844ecab9f69642d3f121eea59877f6e0","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/oneOf.json","shasum":"6772cacb066e5458a7fca9a47cfee27b56110d6b","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/pattern.json","shasum":"5b09d287b8d5170ba4442429bf5309eae1f3cec8","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/patternProperties.json","shasum":"e0080348b213f1d004af7d5c43c2f3f29375224b","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/nullAndObject.json","shasum":"dc0ff1a9b5740271c3e92436a697a50ee8168046","modified":1437940209000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/properties.json","shasum":"1aacdf890a9b844c7275f6ad2f3acc2f9100219c","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/ref.json","shasum":"a9dd881b0a9d5272897be0cc8550c5a64841fc8c","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/refRemote.json","shasum":"ef0c43623cad9a3ceb7b407272062ca55c1c9c7e","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/required.json","shasum":"35b980ec46ea56c7c7c38afc63c84a863d4b3132","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/type.json","shasum":"e2e4371fb68d01ecbc7a5022348c0ffd05d1fd9b","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema-draft4/uniqueItems.json","shasum":"8c9909ffd2abf8f625f81c18a43c789efa369e34","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/json-schema.js","shasum":"c5ef8e3da495a6ca1c7cc9dd0cb8d8c415dcc245","modified":1434031383000},{"_id":"themes/yelee/node_modules/is-my-json-valid/test/misc.js","shasum":"b87118a5e1a59dad1e6c7cc97d3f21f1791affcc","modified":1455779973000},{"_id":"themes/yelee/node_modules/is-number/README.md","shasum":"6a27818480a55a97b4c590b0ddd1827b6ff836d9","modified":1430553159000},{"_id":"themes/yelee/node_modules/is-number/index.js","shasum":"be43df441aa52b7b5827318a5bb9e17601c1f616","modified":1436588444000},{"_id":"themes/yelee/node_modules/is-number/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1425580476000},{"_id":"themes/yelee/node_modules/is-number/package.json","shasum":"21ff748dd46e233faf49b1f9d135f6b4754bdb89","modified":1456469176000},{"_id":"themes/yelee/node_modules/is-primitive/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1426564547000},{"_id":"themes/yelee/node_modules/is-primitive/README.md","shasum":"13fde70833e452345cce4c999e73872f5ce83d49","modified":1426564595000},{"_id":"themes/yelee/node_modules/is-primitive/package.json","shasum":"46d6b0e59785382c96ebb57e288333f179c176eb","modified":1456469176000},{"_id":"themes/yelee/node_modules/is-property/LICENSE","shasum":"50fe55ab192fa4860c14bd57bcec5d090904eb97","modified":1374156563000},{"_id":"themes/yelee/node_modules/is-primitive/index.js","shasum":"4d12a2283734792d84b1b92555671f52adc55a99","modified":1426564547000},{"_id":"themes/yelee/node_modules/is-property/README.md","shasum":"dc4d53b5d6c1d1387fd41fb6bf3597d9642540a4","modified":1374156267000},{"_id":"themes/yelee/node_modules/is-property/package.json","shasum":"136bea02edca4fc85fd82c2b5fede58e322a8023","modified":1456469176000},{"_id":"themes/yelee/node_modules/is-property/is-property.js","shasum":"d09cd64e2bcead412c4d3be1d95f76fe1e315794","modified":1419518893000},{"_id":"themes/yelee/node_modules/is-typedarray/LICENSE.md","shasum":"b2e68ce937c1f851926f7e10280cc93221d4f53c","modified":1401649683000},{"_id":"themes/yelee/node_modules/is-typedarray/README.md","shasum":"8f33b0dd445cfa2ab6712dee34df082f480a5a76","modified":1401649785000},{"_id":"themes/yelee/node_modules/is-typedarray/index.js","shasum":"b7ff45ac41fdcb4bb75dd771d6cb9bfbd129e56d","modified":1431824601000},{"_id":"themes/yelee/node_modules/is-typedarray/package.json","shasum":"e97ade9544af40c12a83bbb7a8ed61bad8a75789","modified":1456469176000},{"_id":"themes/yelee/node_modules/isarray/README.md","shasum":"34470c173ddf6ddfbf9683cf343e83cea1629049","modified":1369676403000},{"_id":"themes/yelee/node_modules/isarray/build/build.js","shasum":"711567b86256a86ed22bd637c35786d13e0f73b3","modified":1369676297000},{"_id":"themes/yelee/node_modules/isarray/component.json","shasum":"88615028e91d7872104932a02b78a75f04df8465","modified":1369676355000},{"_id":"themes/yelee/node_modules/is-typedarray/test.js","shasum":"c3aa563061f8d086aaf066b389b0e811444e3913","modified":1401649839000},{"_id":"themes/yelee/node_modules/isarray/index.js","shasum":"eec5f3c0d16211678cfc7c2d9c18bc4718adf700","modified":1369249661000},{"_id":"themes/yelee/node_modules/isarray/package.json","shasum":"eb073ddbdb53a73077ca541219c9f9420e5c1b32","modified":1456469176000},{"_id":"themes/yelee/node_modules/isobject/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1429583250000},{"_id":"themes/yelee/node_modules/isobject/README.md","shasum":"f61432497d224c56a4c6fc84705e0cdedd3a3622","modified":1437438290000},{"_id":"themes/yelee/node_modules/isobject/index.js","shasum":"1ed5712a3b7e14f4074e28fe1d668626324ad069","modified":1437437998000},{"_id":"themes/yelee/node_modules/isobject/package.json","shasum":"09447aceec3b0aa4fbedba297815e21751ea18eb","modified":1456469176000},{"_id":"themes/yelee/node_modules/isstream/LICENSE.md","shasum":"3fc5bd6825a9d8fd53c0cd8de0bd16d1c1a7f37a","modified":1425687271000},{"_id":"themes/yelee/node_modules/isstream/README.md","shasum":"0563c8dd8178c335de8d882a14c0408ba179789b","modified":1425687291000},{"_id":"themes/yelee/node_modules/isstream/isstream.js","shasum":"db3d8708d100bdb66fd33e1eeb6d2b232016934b","modified":1396827239000},{"_id":"themes/yelee/node_modules/isstream/package.json","shasum":"0a0ca694ab7d4bf99721587a6a5021a435860936","modified":1456469177000},{"_id":"themes/yelee/node_modules/isstream/test.js","shasum":"3c3c171729a3738bd73b12d311265c7fcfb2a9fa","modified":1396831146000},{"_id":"themes/yelee/node_modules/jodid25519/AUTHORS.md","shasum":"cc3f12565134b1da757450b40b5f3fa80c7fc132","modified":1445881497000},{"_id":"themes/yelee/node_modules/jodid25519/LICENSE","shasum":"4fe6ded38ad123523792104dcf60f28badd905f2","modified":1445881497000},{"_id":"themes/yelee/node_modules/jodid25519/README.md","shasum":"3a28ce7b2aa6b6343508cfe28eadec9733fd14e7","modified":1445881497000},{"_id":"themes/yelee/node_modules/jodid25519/almond.0","shasum":"216d893df0f002babc23e63d4c98005db5e8104e","modified":1445881497000},{"_id":"themes/yelee/node_modules/jodid25519/almond.1","shasum":"157b7bc54f90865debe5b1f817a8c1155b580dd8","modified":1445881497000},{"_id":"themes/yelee/node_modules/jodid25519/index.js","shasum":"29e0b96fa095b35ecac9be6c2afde6c9b769e73b","modified":1445885964000},{"_id":"themes/yelee/node_modules/jodid25519/jsdoc.json","shasum":"5a3782a2b7072783e0e5aa3b74d9c87c423818dc","modified":1445881497000},{"_id":"themes/yelee/node_modules/jodid25519/lib/core.js","shasum":"55894ff0a71a08de470029f7689b3967c2ce9233","modified":1446502968000},{"_id":"themes/yelee/node_modules/jodid25519/lib/curve255.js","shasum":"fdc3f9501dbda3945b6478cecaab0b0e1ecd2d63","modified":1446502968000},{"_id":"themes/yelee/node_modules/jodid25519/lib/dh.js","shasum":"e9a0561e419e956f953570d7121e65c84fa72488","modified":1446502968000},{"_id":"themes/yelee/node_modules/jodid25519/lib/eddsa.js","shasum":"bacec5f12e7d5303cee9b0493e22b3743a19ef1e","modified":1446502968000},{"_id":"themes/yelee/node_modules/jodid25519/lib/utils.js","shasum":"5b4e9a60c9f4758bf714e52f9064df0d33fd019a","modified":1446502968000},{"_id":"themes/yelee/node_modules/jodid25519/package.json","shasum":"6986102cbfeeed407e556c6c0ec47ab869524057","modified":1456469177000},{"_id":"themes/yelee/node_modules/jsbn/LICENSE","shasum":"d9b1b910dfea689402ffdb75f5467ec263f8480d","modified":1446141666000},{"_id":"themes/yelee/node_modules/jsbn/README.md","shasum":"6db673c03e15b4e75f95e25ba87177799511ad0c","modified":1446141602000},{"_id":"themes/yelee/node_modules/jsbn/example.html","shasum":"ec1f94b093e0f1457642f8647294be35d4af033f","modified":1446141602000},{"_id":"themes/yelee/node_modules/jsbn/example.js","shasum":"ba7f33b1196eca41a007177372fe237ac7a85c1b","modified":1446141602000},{"_id":"themes/yelee/node_modules/jsbn/index.js","shasum":"f53a89111c54f03ab39eab110c924b560b877051","modified":1446141602000},{"_id":"themes/yelee/node_modules/jsbn/package.json","shasum":"c532faec2be1f993411334173fb67ade2707d1f7","modified":1456469176000},{"_id":"themes/yelee/node_modules/json-schema/README.md","shasum":"9065e9ab354ce910706716a42584222674fe1470","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-00/hyper-schema","shasum":"a5972bcc99abc4936ff350f116a69390f8ac99e8","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-00/json-ref","shasum":"b5f7e93c3edc2eb501e913441ddfdeef0c04386a","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-00/links","shasum":"490c91fb104a16a76290377797a5411d21379614","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-00/schema","shasum":"253c4fcfccaf49023c10a1a92d81cc3d21344e8a","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-01/hyper-schema","shasum":"51802f7884c813fe2a002776aa97a440c7442d9a","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-01/json-ref","shasum":"2132a5a9319f8bf190040b49150e005e0916ed22","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-01/links","shasum":"09b2131c15d754a61a1baf1158a8e6c73644287f","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-01/schema","shasum":"10942d74811e1e16425e6219b0ba808b493321ab","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-02/hyper-schema","shasum":"117eb70efaa120edeb97caa6ca7e53eae8f761e2","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-02/json-ref","shasum":"31b76b211e24e56b0ff5ae3ba739835039cd96b8","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-02/links","shasum":"f8a835ea08959ceca9682cf1c30df6d5cf9ff033","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-02/schema","shasum":"ba84a3e7e9332328db986a1123084f2a6dba57f7","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-03/examples/address","shasum":"b6e70440f5faf725b978da4e92f6f39100377674","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-03/examples/calendar","shasum":"3e53cb296ba1799f39c5a00bc4627fa10e26e165","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-03/examples/card","shasum":"c1405e471f81bbb4eea94c2ef85fa07195a8ad80","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-03/examples/geo","shasum":"74d8c66f1ba74c6cd330b8acd5948efb5f2879e4","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-03/examples/interfaces","shasum":"9666b12a3d05e526886aa2650f0439d32b25f0dd","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-03/hyper-schema","shasum":"552aaa9921cbeb19c2c9b485e64965f7a98e22fc","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-03/json-ref","shasum":"9f121cedcda14cbdd55e2fd80a96e289d9a1f2f9","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-03/links","shasum":"5f1601142843a6028beb35cef8b851413a4dfa91","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-03/schema","shasum":"4b500e66b7c4a36bc4d3ff6da089d6228c54f94c","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-04/hyper-schema","shasum":"362194bf4c6690db17b848c1a796ef747bf7a6c1","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-04/links","shasum":"92cd269ccdfe3f3bc673205133cb9940afa465c4","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-04/schema","shasum":"7a6839ef21cf49fd6bdc687be7dbfbb92c97ac7c","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-zyp-json-schema-03.xml","shasum":"da15453583b019a448fae4b857fe29a583bc1a38","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/draft-zyp-json-schema-04.xml","shasum":"02845f4b0406bffb06ff5cb01eca43f492db6901","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/lib/links.js","shasum":"9d0d0289e4dd2840778b88834f17bad854b013b5","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/lib/validate.js","shasum":"97195ad80d4a217293a8bc240ee44c0c89a7fe79","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-schema/package.json","shasum":"71e736deec85d05928a37b20010f47a53534eec8","modified":1456469177000},{"_id":"themes/yelee/node_modules/json-schema/test/tests.js","shasum":"f3f322d2cec777f57df41b071818a05e97d35f2a","modified":1345750810000},{"_id":"themes/yelee/node_modules/json-stringify-safe/CHANGELOG.md","shasum":"d9b3407ce2eef8d2dadc6b2839a8b16b783eef47","modified":1431999690000},{"_id":"themes/yelee/node_modules/json-stringify-safe/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1431999719000},{"_id":"themes/yelee/node_modules/json-stringify-safe/Makefile","shasum":"589819e00a30573f50fa4a11ddb22fb45b372a65","modified":1431999690000},{"_id":"themes/yelee/node_modules/json-stringify-safe/README.md","shasum":"a2972dd72d8ec7c8b1f229f7732f911ed721dbca","modified":1431999690000},{"_id":"themes/yelee/node_modules/json-stringify-safe/package.json","shasum":"b7e784286baf1313c09f85a8f8fe44faab8adc40","modified":1456469177000},{"_id":"themes/yelee/node_modules/json-stringify-safe/stringify.js","shasum":"b36a3a8d0f794fae13dc8e1c93bd4a8cae311bf2","modified":1431999708000},{"_id":"themes/yelee/node_modules/json-stringify-safe/test/mocha.opts","shasum":"98216b4fbc2e0c1c17ee946b02272a26fcc1f4c1","modified":1431999690000},{"_id":"themes/yelee/node_modules/json-stringify-safe/test/stringify_test.js","shasum":"4760401b04513ae7eb79fff0e1239a9947a8af78","modified":1431999690000},{"_id":"themes/yelee/node_modules/jsonpointer/README.md","shasum":"7b05e3bfb84beb3a5e7607912fc47ccc8d2b1e33","modified":1430458330000},{"_id":"themes/yelee/node_modules/jsonpointer/jsonpointer.js","shasum":"cd510cab1d95a07efc733965dd2533a3fad50e51","modified":1432622187000},{"_id":"themes/yelee/node_modules/jsonpointer/package.json","shasum":"6627fd6465be544b3847d344d3383564f1e672db","modified":1456469176000},{"_id":"themes/yelee/node_modules/jsonpointer/test.js","shasum":"ac5befd353f47b170e2efececbf1ef6d82bc6ade","modified":1432622760000},{"_id":"themes/yelee/node_modules/jsprim/CHANGES.md","shasum":"56da97f41e22a449194235ad13ee30a2f4758956","modified":1444953672000},{"_id":"themes/yelee/node_modules/jsprim/LICENSE","shasum":"772b18147b3bf826978f984f8e01562a9e3cc254","modified":1416249172000},{"_id":"themes/yelee/node_modules/jsprim/README.md","shasum":"78fa58f9e0acaee38db00e4ff234394308cef93d","modified":1444856653000},{"_id":"themes/yelee/node_modules/jsprim/lib/jsprim.js","shasum":"b6fb3f70d3ba7ce276c625e0dd5cb7dfb0af67d1","modified":1444953536000},{"_id":"themes/yelee/node_modules/jsprim/package.json","shasum":"51dd29119df6d8279e7b048f2e55c0ab2ae84870","modified":1456469176000},{"_id":"themes/yelee/node_modules/kind-of/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1447758397000},{"_id":"themes/yelee/node_modules/kind-of/README.md","shasum":"869daa808413a39c57575817281556cf63495c58","modified":1447759311000},{"_id":"themes/yelee/node_modules/kind-of/index.js","shasum":"ad67453f6b331b33d38b5b0e5c7c8516bc57b5da","modified":1447158387000},{"_id":"themes/yelee/node_modules/kind-of/package.json","shasum":"719473690b527f8408cb021be97cbe48d30c0203","modified":1456469176000},{"_id":"themes/yelee/node_modules/lru-cache/CONTRIBUTORS","shasum":"6a6e5148568ff15b4756ee478f0da581ea97fc01","modified":1385053079000},{"_id":"themes/yelee/node_modules/lru-cache/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1431999527000},{"_id":"themes/yelee/node_modules/lru-cache/README.md","shasum":"129fd032ba2ac7580e57e0d9988a4d06f1b344fd","modified":1448474798000},{"_id":"themes/yelee/node_modules/lru-cache/lib/lru-cache.js","shasum":"d4091806568fef3089f4522f09d5976d91912dd4","modified":1448475000000},{"_id":"themes/yelee/node_modules/lru-cache/package.json","shasum":"f90819e195b947edc30d93c5be440d8309afe8d2","modified":1456469177000},{"_id":"themes/yelee/node_modules/lru-cache/test/basic.js","shasum":"caffd5539b398fb1f369ed259c14dc4d00eda244","modified":1448474452000},{"_id":"themes/yelee/node_modules/lru-cache/test/foreach.js","shasum":"5493ce987892f9c740837c36acd5240d9cf93644","modified":1448413217000},{"_id":"themes/yelee/node_modules/lru-cache/test/memory-leak.js","shasum":"5b5690f4e32c4d2fc501e7f408fdcfd25f8b4e3a","modified":1435688444000},{"_id":"themes/yelee/node_modules/lru-cache/test/serialize.js","shasum":"6383a06c3f56cce6eb364b66f2301eea00db5828","modified":1448474452000},{"_id":"themes/yelee/node_modules/micromatch/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1450565572000},{"_id":"themes/yelee/node_modules/micromatch/index.js","shasum":"20605ff35f61f5d56ba1224cd19b65e1f8faed6c","modified":1450565705000},{"_id":"themes/yelee/node_modules/micromatch/README.md","shasum":"eba0e0ae3e48e963ccee0076042885ffb4c03197","modified":1450565572000},{"_id":"themes/yelee/node_modules/micromatch/lib/chars.js","shasum":"10dede99931a8786b6c738b202ac8bda153ea112","modified":1450565572000},{"_id":"themes/yelee/node_modules/micromatch/lib/expand.js","shasum":"d94dec073a967959a17f4896e50943b2cb50ffa8","modified":1450565705000},{"_id":"themes/yelee/node_modules/micromatch/lib/glob.js","shasum":"100291bc1b0e543fa2d491f9d157aa06c11aa496","modified":1450565705000},{"_id":"themes/yelee/node_modules/micromatch/lib/utils.js","shasum":"6d5a578a0f53305d62c502f4d88091a272952619","modified":1450565725000},{"_id":"themes/yelee/node_modules/micromatch/package.json","shasum":"98768c6a1ac41b5c6ed96f7e3ea6de5b189b997b","modified":1456469177000},{"_id":"themes/yelee/node_modules/mime-db/HISTORY.md","shasum":"d1bb492efb205450ad3430dfb072c2aea37dc0fb","modified":1455558628000},{"_id":"themes/yelee/node_modules/mime-db/LICENSE","shasum":"b559c45c8d07f2679620d9771e68696ee3d5964b","modified":1411631388000},{"_id":"themes/yelee/node_modules/mime-db/README.md","shasum":"1018078c0d9fd0331ca23ac5d97ace15596bf46c","modified":1449721722000},{"_id":"themes/yelee/node_modules/mime-db/index.js","shasum":"31180f8d0ae079b1bee7ee03e77ea5323583eb06","modified":1411631388000},{"_id":"themes/yelee/node_modules/mime-db/package.json","shasum":"3cd2a360049e623f008454b940e6f832e8b3c5fd","modified":1456469177000},{"_id":"themes/yelee/node_modules/mime-types/HISTORY.md","shasum":"e99031ef66245a8b0473c1a4cd56e7eb640af2e1","modified":1455574470000},{"_id":"themes/yelee/node_modules/mime-types/LICENSE","shasum":"f027af3e61af3880fd7f7b8ba9452a85dd215738","modified":1455569104000},{"_id":"themes/yelee/node_modules/mime-types/README.md","shasum":"bdc1c75e9234d1d6fc56c819cec51f568be5c68b","modified":1455572366000},{"_id":"themes/yelee/node_modules/mime-types/index.js","shasum":"d1983bb9d10cc678f693be62ef05e1b8c2638ef0","modified":1455569104000},{"_id":"themes/yelee/node_modules/mime-types/package.json","shasum":"2cc0e046b56ab2af1a0be3f2821a8aeb05ad6f4f","modified":1456469176000},{"_id":"themes/yelee/node_modules/minimatch/LICENSE","shasum":"bb408e929caeb1731945b2ba54bc337edb87cc66","modified":1431999466000},{"_id":"themes/yelee/node_modules/minimatch/README.md","shasum":"fb5bec4ab02467cdb76cdb552613ff0547402439","modified":1407793656000},{"_id":"themes/yelee/node_modules/nan/CHANGELOG.md","shasum":"e221674e5a8b9fa810c3da81bdc918f82bf093c9","modified":1452351065000},{"_id":"themes/yelee/node_modules/nan/LICENSE.md","shasum":"efb645e33e8b96f7fc3bf62f083d1d8f2d78fc79","modified":1452350917000},{"_id":"themes/yelee/node_modules/minimatch/browser.js","shasum":"04c30625df185494a153c238296f5859aed9c963","modified":1437616294000},{"_id":"themes/yelee/node_modules/minimatch/minimatch.js","shasum":"16b28bcabd1eca778c2176d6c49330396907411e","modified":1437616284000},{"_id":"themes/yelee/node_modules/minimatch/package.json","shasum":"4179a906ca529c03a8348d8d76f2983f8894abb0","modified":1456469176000},{"_id":"themes/yelee/node_modules/nan/README.md","shasum":"8546788add06c939f21cb3fa4f1cb019a5b235de","modified":1452351065000},{"_id":"themes/yelee/node_modules/nan/appveyor.yml","shasum":"fec84487904d69e902d98260d1b0bb93ddf59e10","modified":1452349051000},{"_id":"themes/yelee/node_modules/nan/doc/asyncworker.md","shasum":"d08c62b641082ffdd635f7048201f975730a3223","modified":1444243260000},{"_id":"themes/yelee/node_modules/nan/doc/buffers.md","shasum":"379d606e2e03de0cbe5ca3f28d6267b59da7986e","modified":1444248499000},{"_id":"themes/yelee/node_modules/nan/doc/callback.md","shasum":"ffe38c04228985bece1442a891793cd3b438e625","modified":1444248499000},{"_id":"themes/yelee/node_modules/nan/doc/converters.md","shasum":"87a44ab8436a0a2c5ca5878fb0e3b40d067c3d9c","modified":1444243260000},{"_id":"themes/yelee/node_modules/nan/doc/errors.md","shasum":"1eacf4e82465545bdc5b7def1cf0ab27b003b03d","modified":1444243260000},{"_id":"themes/yelee/node_modules/nan/doc/maybe_types.md","shasum":"545e51098bce1a351784d1f9cca9f19f93302929","modified":1452349062000},{"_id":"themes/yelee/node_modules/nan/doc/methods.md","shasum":"450accc8b6aacc34146c4021a1edcddd6c5faefb","modified":1452349051000},{"_id":"themes/yelee/node_modules/nan/doc/new.md","shasum":"342778da9fdf2393a7de91a922e8d89d1baf7568","modified":1444248499000},{"_id":"themes/yelee/node_modules/nan/doc/node_misc.md","shasum":"a6e668fb8cb18a5a2d2f32b6b2db2a7284d614f7","modified":1452349051000},{"_id":"themes/yelee/node_modules/nan/doc/object_wrappers.md","shasum":"562c6b37edc2d16c36f231aedce4d5ea427c074e","modified":1452349051000},{"_id":"themes/yelee/node_modules/nan/doc/persistent.md","shasum":"43a25f5b31914f9fc6e8ecaa15b8064790f96e9f","modified":1444248499000},{"_id":"themes/yelee/node_modules/nan/doc/scopes.md","shasum":"1ec6947eaa9b7cd384129c826e4048ab8920b2a6","modified":1444243260000},{"_id":"themes/yelee/node_modules/nan/doc/script.md","shasum":"5b150c97506b154aa270e8ba2fd4c01a8f631236","modified":1444243260000},{"_id":"themes/yelee/node_modules/nan/doc/string_bytes.md","shasum":"f2d9b8259c38fc4fe88f1f1324273481ac0d328e","modified":1444243260000},{"_id":"themes/yelee/node_modules/nan/doc/v8_internals.md","shasum":"0d417bca198f1700d7b3d866c23355dd0eb328ed","modified":1444248499000},{"_id":"themes/yelee/node_modules/nan/doc/v8_misc.md","shasum":"a31716bd78f1fac323a714e3108ddf6be1a32d44","modified":1452349051000},{"_id":"themes/yelee/node_modules/nan/include_dirs.js","shasum":"cd38e47a4ea58e4b7b31355a1af480ccd04b568f","modified":1444241269000},{"_id":"themes/yelee/node_modules/nan/nan_callbacks.h","shasum":"f589a9eec7ce1f1dd49c634e4e8e865a9d74b0e6","modified":1452350395000},{"_id":"themes/yelee/node_modules/nan/nan_callbacks_12_inl.h","shasum":"ac058de8fd74c712fd465c4096486c8f7290ec24","modified":1452350388000},{"_id":"themes/yelee/node_modules/nan/nan_callbacks_pre_12_inl.h","shasum":"ba39b9a944d9aaddc379236b68a79ee548e998c4","modified":1452350398000},{"_id":"themes/yelee/node_modules/nan/nan_converters.h","shasum":"34b76a47cc52016e84011ea44544f535564a20ea","modified":1452350406000},{"_id":"themes/yelee/node_modules/nan/nan_converters_43_inl.h","shasum":"315acfe32ba9e812a85c5f09e9a5d42f4acf8ca6","modified":1452350402000},{"_id":"themes/yelee/node_modules/nan/nan_converters_pre_43_inl.h","shasum":"7989a21608e3aa16ac75f57cfc266270133075a3","modified":1452350410000},{"_id":"themes/yelee/node_modules/nan/nan_implementation_pre_12_inl.h","shasum":"28b3eb83a8c89fe05e76e2d54be313465c37d286","modified":1452350426000},{"_id":"themes/yelee/node_modules/nan/nan_implementation_12_inl.h","shasum":"1da7e4b17c52b332eb416dcee9cbfe25a666fb9f","modified":1452350422000},{"_id":"themes/yelee/node_modules/nan/nan_maybe_43_inl.h","shasum":"5c01c487730707e70cc9110d8f29658b22d0c3ff","modified":1452350430000},{"_id":"themes/yelee/node_modules/nan/nan_maybe_pre_43_inl.h","shasum":"d754702112c40fe7a0a7e6f817df162685e28e18","modified":1452350434000},{"_id":"themes/yelee/node_modules/nan/nan_object_wrap.h","shasum":"95518fbd2d92d8b81f10b304515b7f60015b886d","modified":1452350441000},{"_id":"themes/yelee/node_modules/nan/nan_new.h","shasum":"fbb57235690d81756e70414710fc92aaa8dbaedb","modified":1452350437000},{"_id":"themes/yelee/node_modules/nan/nan_persistent_12_inl.h","shasum":"2725049d9bda7b9d8dc1690c8dc72641cb0a5f70","modified":1452350445000},{"_id":"themes/yelee/node_modules/nan/nan_persistent_pre_12_inl.h","shasum":"e25a3c8e5ec7983ea397080c2ed87eb894cfc3d1","modified":1452350452000},{"_id":"themes/yelee/node_modules/nan/nan_string_bytes.h","shasum":"bdf8bfb9e779171768a04ec6e9d1e074c10874e1","modified":1444243260000},{"_id":"themes/yelee/node_modules/nan/nan_typedarray_contents.h","shasum":"78b55f04c9f1969425b209271ad1869129c3973c","modified":1452350469000},{"_id":"themes/yelee/node_modules/nan/nan_weak.h","shasum":"50feae1dc8a5531acb17bcd8399485f819dfef07","modified":1452350474000},{"_id":"themes/yelee/node_modules/nan/package.json","shasum":"368ab63065900b1d723ae408e76cb39fc462f8c6","modified":1456469177000},{"_id":"themes/yelee/node_modules/nan/tools/README.md","shasum":"a5103d8b2150ba5fd2736fbb6fd2a2a819596244","modified":1444243260000},{"_id":"themes/yelee/node_modules/nan/tools/1to2.js","shasum":"e37a19a2f75556de8756befc2a3fc5a3d5bbd3fe","modified":1452350885000},{"_id":"themes/yelee/node_modules/nan/tools/package.json","shasum":"c8b6de0212f33be85f01aea1581791bd14aa2a73","modified":1444243260000},{"_id":"themes/yelee/node_modules/node-uuid/LICENSE.md","shasum":"09bedf3eb387e2883ded96ee501d16262350c9cd","modified":1425583776000},{"_id":"themes/yelee/node_modules/node-uuid/README.md","shasum":"7ca0c673b27c3c4c50167b5077bb421711c2518b","modified":1447445668000},{"_id":"themes/yelee/node_modules/node-uuid/benchmark/README.md","shasum":"783d814c48583b086ffd8b701a53844f799e7d0d","modified":1425583776000},{"_id":"themes/yelee/node_modules/node-uuid/benchmark/bench.gnu","shasum":"26bd5d465f2588f4ebda09b9aa28f3fecffb9f4a","modified":1425583776000},{"_id":"themes/yelee/node_modules/node-uuid/benchmark/bench.sh","shasum":"3f8daeb462ad5609c63fb8915efc4fa870a8fde5","modified":1425583776000},{"_id":"themes/yelee/node_modules/node-uuid/benchmark/benchmark-native.c","shasum":"8d999ba3178ae2683a7ed30b9ff115fe9d9f41bd","modified":1425583776000},{"_id":"themes/yelee/node_modules/node-uuid/bin/uuid","shasum":"cc4874ec4258ffff8b743227a3619f895941b563","modified":1425583776000},{"_id":"themes/yelee/node_modules/node-uuid/benchmark/benchmark.js","shasum":"82dfd78c7f35bd52a84259e9afc36018f41bf58e","modified":1425583776000},{"_id":"themes/yelee/node_modules/node-uuid/bower.json","shasum":"6d521f86833c6d9a6a75af623529479fcf89f917","modified":1447446668000},{"_id":"themes/yelee/node_modules/node-uuid/component.json","shasum":"7e1d6df157d7075438267019c90f5cb158b26983","modified":1447446668000},{"_id":"themes/yelee/node_modules/node-uuid/package.json","shasum":"bc5df34022c2262faa38983f6b9802c5899027b3","modified":1456469177000},{"_id":"themes/yelee/node_modules/node-uuid/test/compare_v1.js","shasum":"ac9c80da67f4b232b0aff05c4160deda00dda2e6","modified":1425583776000},{"_id":"themes/yelee/node_modules/node-uuid/test/test.html","shasum":"287decf793ae25e5cffda0f5a118a41ccf54fca0","modified":1425583776000},{"_id":"themes/yelee/node_modules/node-uuid/test/test.js","shasum":"bd765f9091cfd101f0679e45330ce04a62266453","modified":1447291212000},{"_id":"themes/yelee/node_modules/node-uuid/uuid.js","shasum":"91f473812e7748b91d6adb32ac704c4f8cdea13a","modified":1447446491000},{"_id":"themes/yelee/node_modules/normalize-path/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1422062974000},{"_id":"themes/yelee/node_modules/normalize-path/README.md","shasum":"83f0d8c7ef174ff6b375a48765494088ba5c93a6","modified":1443938634000},{"_id":"themes/yelee/node_modules/normalize-path/index.js","shasum":"1fa7549f17a96f788cb935c242c33d122f5bb005","modified":1447763472000},{"_id":"themes/yelee/node_modules/normalize-path/package.json","shasum":"e36f551fa669b3002cf2e9026a5b8dc041d89e2a","modified":1456469176000},{"_id":"themes/yelee/node_modules/oauth-sign/README.md","shasum":"9f943ef5e4c1e530314bee287c8fd5b8addbc808","modified":1432536000000},{"_id":"themes/yelee/node_modules/oauth-sign/LICENSE","shasum":"05979f0750cf5c2a17bd3aa12450849c151d8b7c","modified":1432536000000},{"_id":"themes/yelee/node_modules/oauth-sign/index.js","shasum":"fb3d1f2193e77b18089fad077d3133143811f554","modified":1454224562000},{"_id":"themes/yelee/node_modules/oauth-sign/package.json","shasum":"c4b14ac8600dcd29102cd6991376a2d023abd10b","modified":1456469176000},{"_id":"themes/yelee/node_modules/oauth-sign/test.js","shasum":"972d35362f1eb47ba9e12409a6d49ecc23e8a968","modified":1432809220000},{"_id":"themes/yelee/node_modules/object.omit/LICENSE","shasum":"cce8f85bce93fb036bc1846f001ffea1b098108c","modified":1428554275000},{"_id":"themes/yelee/node_modules/object.omit/README.md","shasum":"1b8bcc9834b67c3a49946e23a44a1edb4bd92833","modified":1437545968000},{"_id":"themes/yelee/node_modules/object.omit/index.js","shasum":"859e8fa5823e361cf0b34ec07263765a36923ebf","modified":1437545718000},{"_id":"themes/yelee/node_modules/object.omit/package.json","shasum":"03b6a81a68ce699379e89824e9ae1a8bc806794b","modified":1456469176000},{"_id":"themes/yelee/node_modules/parse-glob/LICENSE","shasum":"f6794e2167dc92e7ab5f2b00a15f0af45639a5a1","modified":1442931829000},{"_id":"themes/yelee/node_modules/parse-glob/README.md","shasum":"b08c9fd27a7da80a2e0afb00003498384f3aabbb","modified":1442934996000},{"_id":"themes/yelee/node_modules/parse-glob/index.js","shasum":"80de4342abc02723990d3849ef8f5710a3bfc2a0","modified":1442931829000},{"_id":"themes/yelee/node_modules/path/LICENSE","shasum":"469a9940ed48958c0d900e24f72c06a2b1529a27","modified":1442156078000},{"_id":"themes/yelee/node_modules/parse-glob/package.json","shasum":"baced47d22a65939522c005491275fee9a7fdb82","modified":1456469176000},{"_id":"themes/yelee/node_modules/path/README.md","shasum":"c36a59ad8daa1c74f181053251ebdb5f0c8b036c","modified":1442156078000},{"_id":"themes/yelee/node_modules/path/package.json","shasum":"f2934441bd731269a8d8ae4358261429b0ead497","modified":1456469176000},{"_id":"themes/yelee/node_modules/path/path.js","shasum":"e1c52aaaa3eeb1673305f174539d878343aec379","modified":1442157112000},{"_id":"themes/yelee/node_modules/path-is-absolute/index.js","shasum":"71259da8cc05832088437dd2d385b7eee54eab71","modified":1424141850000},{"_id":"themes/yelee/node_modules/path-is-absolute/license","shasum":"0c94f137f6e0536db8cb2622a9dc84253b91b90c","modified":1396798991000},{"_id":"themes/yelee/node_modules/path-is-absolute/package.json","shasum":"8d4180416ef4755411eefd6f611867d8e1298829","modified":1456469176000},{"_id":"themes/yelee/node_modules/path-is-absolute/readme.md","shasum":"bbe564e38bd40bd0f8c6f503d3064ebce4e6e87c","modified":1424141985000},{"_id":"themes/yelee/node_modules/pinkie/index.js","shasum":"4ed6d8988b13d2c29cfa99c99cedb43fa6b51ee7","modified":1454324862000},{"_id":"themes/yelee/node_modules/pinkie/license","shasum":"91c700b5dac5967632cf497f1f3316352b1b45ce","modified":1454217969000},{"_id":"themes/yelee/node_modules/pinkie/package.json","shasum":"9d9ed0667de0d9a182c55dba2eec7944fd0d9051","modified":1456469176000},{"_id":"themes/yelee/node_modules/pinkie/readme.md","shasum":"1673aa52b8f81f6ebf1c2e5ca0184a6f63522f78","modified":1454322504000},{"_id":"themes/yelee/node_modules/pinkie-promise/license","shasum":"91c700b5dac5967632cf497f1f3316352b1b45ce","modified":1447318268000},{"_id":"themes/yelee/node_modules/pinkie-promise/index.js","shasum":"cc84d8fc33cad091d8dc7bc65c0481a8a915769b","modified":1447318268000},{"_id":"themes/yelee/node_modules/pinkie-promise/package.json","shasum":"d681066c77894ddca7f03ea6885e527323ec4c18","modified":1456469176000},{"_id":"themes/yelee/node_modules/pinkie-promise/readme.md","shasum":"450859283a97df6ee0918789a485d26786329eb1","modified":1447318268000},{"_id":"themes/yelee/node_modules/preserve/LICENSE","shasum":"d99d5158898474f25efb4c8790f9fcc4cf55b350","modified":1420928487000},{"_id":"themes/yelee/node_modules/preserve/README.md","shasum":"daedd5d9696a86795f63b002cfd4537033d639ec","modified":1420928487000},{"_id":"themes/yelee/node_modules/preserve/index.js","shasum":"1d37d615f1ea0e2469a6e1a8a64eb7c1c7b6f110","modified":1420928487000},{"_id":"themes/yelee/node_modules/preserve/package.json","shasum":"acaf8ded9e888b6dcfdd80b65e8e7c021007abc0","modified":1456469177000},{"_id":"themes/yelee/node_modules/preserve/test.js","shasum":"3baac5a1e812bcc42443c2dc6a401c0a55d01f4c","modified":1420928674000},{"_id":"themes/yelee/node_modules/process/LICENSE","shasum":"1433c1355cae4a748820ba1862b32bb231ac04b6","modified":1386516960000},{"_id":"themes/yelee/node_modules/process/README.md","shasum":"6bc187da95fd0394e3b87b2a58d9303e2ba1aae3","modified":1441759726000},{"_id":"themes/yelee/node_modules/process/browser.js","shasum":"48c5490fa029e282317f5e10c4cbdc56a8f00cb5","modified":1441759817000},{"_id":"themes/yelee/node_modules/process/index.js","shasum":"0eb7b4e67705373adef4a706b1380f680d263c0b","modified":1386516960000},{"_id":"themes/yelee/node_modules/process/package.json","shasum":"f677200b9f4137d19e853b7563d2939f7fe2e2d0","modified":1456469176000},{"_id":"themes/yelee/node_modules/process/test.js","shasum":"ed6fe488903ec725d0ee9defdc784e05f081432e","modified":1429902052000},{"_id":"themes/yelee/node_modules/process-nextick-args/index.js","shasum":"066a18ff5757235dbe5ea1a2c632946293dcff6f","modified":1449104960000},{"_id":"themes/yelee/node_modules/process-nextick-args/license.md","shasum":"9def7167175d2ac68505dd2ae0c7b8dd63bc4c3d","modified":1449008551000},{"_id":"themes/yelee/node_modules/process-nextick-args/package.json","shasum":"098a9e97b5730b76cd2b3de314704e7acbec3b37","modified":1456469176000},{"_id":"themes/yelee/node_modules/process-nextick-args/readme.md","shasum":"3eba0a30f0a115fd767a0c8c9761d60d1dc768c0","modified":1437048205000},{"_id":"themes/yelee/node_modules/process-nextick-args/test.js","shasum":"279a062028d86a4ee0ab2ab800ecf7ca29f4905e","modified":1449008551000},{"_id":"themes/yelee/node_modules/punycode/LICENSE-MIT.txt","shasum":"d7384cd3ed0c9614f87dde0f86568017f369814c","modified":1408532732000},{"_id":"themes/yelee/node_modules/punycode/README.md","shasum":"9854b804b32cc0191af177cd8fea432b1e25875c","modified":1409501399000},{"_id":"themes/yelee/node_modules/punycode/package.json","shasum":"f96c9b9b3429ea0f751545c8922e26c7077d2130","modified":1456469176000},{"_id":"themes/yelee/node_modules/punycode/punycode.js","shasum":"4e703e940e4620f1c8ac328496167287f19b322f","modified":1413979177000},{"_id":"themes/yelee/node_modules/qs/CONTRIBUTING.md","shasum":"61998267d75f17fdd423c1c742edc20a1561c1e2","modified":1450856430000},{"_id":"themes/yelee/node_modules/qs/CHANGELOG.md","shasum":"a8c66d98d8c1501b5a506709fc7f4285b59c7f82","modified":1453069331000},{"_id":"themes/yelee/node_modules/qs/LICENSE","shasum":"ddf13f1b7345d730677237125bc2e46fbbfbbf32","modified":1450856430000},{"_id":"themes/yelee/node_modules/qs/README.md","shasum":"9d57cdff65ba49f961ad3805df133c282c4672e0","modified":1453069466000},{"_id":"themes/yelee/node_modules/qs/bower.json","shasum":"d278db3097c39d4df650b04bbc42d03021b87409","modified":1453070078000},{"_id":"themes/yelee/node_modules/qs/component.json","shasum":"affe28b8b20dde94e6cdc469ce5b11bcd87bcb9a","modified":1453070078000},{"_id":"themes/yelee/node_modules/qs/dist/qs.js","shasum":"4999c7f95ac28c994fc5f4772e51d9288ea8b6cd","modified":1453071516000},{"_id":"themes/yelee/node_modules/qs/lib/index.js","shasum":"227523195233e42a48c20f75a1ae350c6bcc5b47","modified":1453052046000},{"_id":"themes/yelee/node_modules/qs/lib/parse.js","shasum":"f85546c13d4cae0f65b3bb3693cc92e18636abe3","modified":1453052057000},{"_id":"themes/yelee/node_modules/qs/lib/stringify.js","shasum":"910b15fb61e39f8c3fcb5eaf522f5f6daf1f3e77","modified":1453052046000},{"_id":"themes/yelee/node_modules/qs/lib/utils.js","shasum":"b4614510e0a35009a95de16f2f7a19dc8bbf9265","modified":1453052057000},{"_id":"themes/yelee/node_modules/qs/package.json","shasum":"312f074c9b9234b321b0ceb1e5134a9c43d7817f","modified":1456469177000},{"_id":"themes/yelee/node_modules/qs/test/index.js","shasum":"3d9a66ca5549d2dd32f6a56c4ba0472498fb68a8","modified":1450861863000},{"_id":"themes/yelee/node_modules/qs/test/parse.js","shasum":"b7041aee47eca551b475d405957a019e61296bf5","modified":1452717606000},{"_id":"themes/yelee/node_modules/qs/test/stringify.js","shasum":"38ca94758266fbd37217faad5fc7bff6d3ef1e0a","modified":1452717606000},{"_id":"themes/yelee/node_modules/qs/test/utils.js","shasum":"5f25e2ef762a18cff8719d88a1748840c1626d89","modified":1452717606000},{"_id":"themes/yelee/node_modules/querystring/History.md","shasum":"b19d8f7359a49c49c4171389181a92b20dd0ade8","modified":1362519151000},{"_id":"themes/yelee/node_modules/querystring/License.md","shasum":"4051887547e070bbe1e1d2dcab3a46f44beeacb2","modified":1351024476000},{"_id":"themes/yelee/node_modules/querystring/Readme.md","shasum":"9d3abbe245c90a38c365e89e8cbe94f07d1a6b1e","modified":1362519108000},{"_id":"themes/yelee/node_modules/querystring/decode.js","shasum":"78c13537ae65852bb6b1df4563ced3a27f848376","modified":1362518500000},{"_id":"themes/yelee/node_modules/querystring/encode.js","shasum":"bc42441192cea9de787398850f1d308980421017","modified":1362518500000},{"_id":"themes/yelee/node_modules/querystring/index.js","shasum":"cb7fd2835f652938cfe501f3f0c225e2646eb801","modified":1362518500000},{"_id":"themes/yelee/node_modules/querystring/package.json","shasum":"8980605354ec112ab95dbb66c1473618c250b963","modified":1456469177000},{"_id":"themes/yelee/node_modules/querystring/test/common-index.js","shasum":"639fc036bb30ff8541f4c2bddfb70ddbc626def8","modified":1358665842000},{"_id":"themes/yelee/node_modules/querystring/test/index.js","shasum":"babf2311efbb9456ba96c404507d80ba403a8dde","modified":1362518989000},{"_id":"themes/yelee/node_modules/querystring/test/tap-index.js","shasum":"f1741495b86e7e359c13b5b7cdc772fb32aab99a","modified":1358668762000},{"_id":"themes/yelee/node_modules/randomatic/LICENSE","shasum":"2fc7036acf8dab2c91ea48a293a2a52f37662c34","modified":1420215893000},{"_id":"themes/yelee/node_modules/randomatic/README.md","shasum":"1cfbcf24eeeba70bd12cd724052a67e50c71c2a8","modified":1449768911000},{"_id":"themes/yelee/node_modules/randomatic/index.js","shasum":"b3eab954771903c20e51724faafa84685dca1ccc","modified":1447157175000},{"_id":"themes/yelee/node_modules/randomatic/package.json","shasum":"7899e8780d6721cc6bb8d02d4ce41525e98d0a0b","modified":1456469176000},{"_id":"themes/yelee/node_modules/readable-stream/LICENSE","shasum":"73efe5bda3791d234730ab0dcc48eb619a2e0ec6","modified":1433891361000},{"_id":"themes/yelee/node_modules/readable-stream/README.md","shasum":"113fddeaf3174b63954f81670dce9772fc252ad1","modified":1434936371000},{"_id":"themes/yelee/node_modules/readable-stream/doc/wg-meetings/2015-01-30.md","shasum":"1fafe6e2e28a4404db90ae6dc867199b74468ca4","modified":1433891361000},{"_id":"themes/yelee/node_modules/readable-stream/duplex.js","shasum":"5ff8b0af1efbb8ed54ac1b3f57167447cb902344","modified":1433891361000},{"_id":"themes/yelee/node_modules/readable-stream/lib/_stream_duplex.js","shasum":"d4e2c0dbe893e97638262fb598f00472aa121cf0","modified":1448548407000},{"_id":"themes/yelee/node_modules/readable-stream/doc/stream.markdown","shasum":"34bb6baba8a25fd40136c519215124cbce7ec78b","modified":1450290518000},{"_id":"themes/yelee/node_modules/readable-stream/lib/_stream_passthrough.js","shasum":"51d9ab73b4265e9c011537e957c8f578bcf50d1e","modified":1448548407000},{"_id":"themes/yelee/node_modules/readable-stream/lib/_stream_transform.js","shasum":"fbeb8123c9557d11283543efd471e659a80a1f1e","modified":1448548407000},{"_id":"themes/yelee/node_modules/readable-stream/lib/_stream_readable.js","shasum":"71fec1e21d268617a18c91742d57f3f43ed7a14b","modified":1450290518000},{"_id":"themes/yelee/node_modules/readable-stream/lib/_stream_writable.js","shasum":"e6b7ebcfcbf1648eeda0b5060f388028b5eabf97","modified":1450290518000},{"_id":"themes/yelee/node_modules/readable-stream/package.json","shasum":"a7cd37c9aad10c2032ac43b9ed13a2f4bf8a289b","modified":1456469177000},{"_id":"themes/yelee/node_modules/readable-stream/passthrough.js","shasum":"ff1590a9a778dc9d8ed51064670d82426782ee6e","modified":1433891361000},{"_id":"themes/yelee/node_modules/readable-stream/readable.js","shasum":"f68ae09e1cfcd9f75f8d43cb82724b3dee5d9251","modified":1434936362000},{"_id":"themes/yelee/node_modules/readable-stream/transform.js","shasum":"2d31b50e657e5b03ce5abc5ce6b77187e8e876c2","modified":1433891361000},{"_id":"themes/yelee/node_modules/readable-stream/writable.js","shasum":"8a7bd86d1803614b9381a924ab9ef0a19fd70e6c","modified":1433891361000},{"_id":"themes/yelee/node_modules/readdirp/LICENSE","shasum":"b2e68ce937c1f851926f7e10280cc93221d4f53c","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/README.md","shasum":"caf3972fc843ec620aad623e672a8536469c443a","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/examples/Readme.md","shasum":"b019e9ebb387f5ddfb2313b7cb79e62cad77f83d","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/examples/callback-api.js","shasum":"bc8172824ff3c01eed53b563f95f99f1d90c2435","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/examples/grep.js","shasum":"03dd42417a46ccac5adcb5d3cf4ae328b20cb90b","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/examples/package.json","shasum":"63aecfe08596ce3954da36160fd30e4c15fe0bb9","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/examples/stream-api-pipe.js","shasum":"3bed4d356d63f329ed4c3d6745b41215c2b2ffad","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/examples/stream-api.js","shasum":"56ebe5e04e674c190e9d9e14363475672922edd2","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/package.json","shasum":"467ae8e48b7cb680b48ae0412d5f1e29ff013066","modified":1456469177000},{"_id":"themes/yelee/node_modules/readdirp/readdirp.js","shasum":"d2b155e274f6d22bdddabbdf2bc85e7d1bb30ccb","modified":1418419176000},{"_id":"themes/yelee/node_modules/readdirp/stream-api.js","shasum":"9c81fcea57ab4bfccad3e3d6c0e431802cc194a2","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/test/readdirp-stream.js","shasum":"afbceb4eb293e5f454e79185f4ec9039079ddb12","modified":1418419137000},{"_id":"themes/yelee/node_modules/readdirp/test/readdirp.js","shasum":"04bb5ac265a4f6e10f05c7f6311366eb2d6dfda8","modified":1418419137000},{"_id":"themes/yelee/node_modules/regex-cache/LICENSE","shasum":"7e21c9f5aa0a1be61e943a935506095ea40bbafc","modified":1423430290000},{"_id":"themes/yelee/node_modules/regex-cache/README.md","shasum":"45aa40e5f1a33b680e01a62ccc6a6795917ebfa0","modified":1427322479000},{"_id":"themes/yelee/node_modules/regex-cache/index.js","shasum":"ada9405a781d2cf3953394ecaa0580429c4f06fe","modified":1424169012000},{"_id":"themes/yelee/node_modules/regex-cache/package.json","shasum":"a0389fc6d2bdf23a04c5a27c2b34d3b3dd3170db","modified":1456469176000},{"_id":"themes/yelee/node_modules/repeat-element/LICENSE","shasum":"7e21c9f5aa0a1be61e943a935506095ea40bbafc","modified":1421019371000},{"_id":"themes/yelee/node_modules/repeat-element/README.md","shasum":"230540131df8177d53f6ee1a57eec5d9413992ec","modified":1430968550000},{"_id":"themes/yelee/node_modules/repeat-element/index.js","shasum":"33ee2f6ac8638233b7d7eb0a35b43249f05ee5c5","modified":1430968437000},{"_id":"themes/yelee/node_modules/repeat-element/package.json","shasum":"cab414a8ab826ca48cea6f249871db943b2651d5","modified":1456469176000},{"_id":"themes/yelee/node_modules/repeat-string/LICENSE","shasum":"d99d5158898474f25efb4c8790f9fcc4cf55b350","modified":1427925999000},{"_id":"themes/yelee/node_modules/repeat-string/README.md","shasum":"1dbcc50870b2e1d3338d4a22ece1790e499c50be","modified":1427933810000},{"_id":"themes/yelee/node_modules/repeat-string/index.js","shasum":"eb06cff804ee286c2bba2833ebf293dbca3914bf","modified":1427925999000},{"_id":"themes/yelee/node_modules/repeat-string/package.json","shasum":"ffda2de6c5f4ef7eaae01326701023abf36809ab","modified":1456469176000},{"_id":"themes/yelee/node_modules/request/CONTRIBUTING.md","shasum":"a9fc87e51d92d75e09e391fed0b41d0916da1499","modified":1421769158000},{"_id":"themes/yelee/node_modules/request/LICENSE","shasum":"05979f0750cf5c2a17bd3aa12450849c151d8b7c","modified":1413995097000},{"_id":"themes/yelee/node_modules/request/CHANGELOG.md","shasum":"142acbcd6d56904d1caa8775f56379738cb142b3","modified":1453921187000},{"_id":"themes/yelee/node_modules/request/index.js","shasum":"6b96d838b3fae1c1d3fd963613b6465cd788e8c4","modified":1443190242000},{"_id":"themes/yelee/node_modules/request/README.md","shasum":"612f6c04bd0aceb60c1d22dcf1a5de5a5cf91698","modified":1453921187000},{"_id":"themes/yelee/node_modules/request/lib/cookies.js","shasum":"0b2a641d706209af1f92176a507f382e06b44379","modified":1453921187000},{"_id":"themes/yelee/node_modules/request/lib/auth.js","shasum":"56bdda40a7df68f69c68cd256258017783e70d12","modified":1453921187000},{"_id":"themes/yelee/node_modules/request/lib/getProxyFromURI.js","shasum":"2e7c16e357f885401208174ad1f341b084965253","modified":1443190242000},{"_id":"themes/yelee/node_modules/request/lib/har.js","shasum":"a4b894d836e3bd947a5d8afffec04128bf934fe5","modified":1453921187000},{"_id":"themes/yelee/node_modules/request/lib/helpers.js","shasum":"c636e050b67bc00533adc7721e750f9520902917","modified":1443190242000},{"_id":"themes/yelee/node_modules/request/lib/multipart.js","shasum":"66acc47cab8b774688502be7752501e4a44d3cda","modified":1453921187000},{"_id":"themes/yelee/node_modules/request/lib/oauth.js","shasum":"8663a55221a216cc32d655f83086979ae9e666a9","modified":1443190242000},{"_id":"themes/yelee/node_modules/request/lib/querystring.js","shasum":"b78be4d88327f11499fbf86610d0612d803b1ff4","modified":1443190242000},{"_id":"themes/yelee/node_modules/request/lib/redirect.js","shasum":"08b710fe22cf8e28b2fecdcaaadb76923361299b","modified":1453921187000},{"_id":"themes/yelee/node_modules/request/lib/tunnel.js","shasum":"97336f00dd29c7fdad5550e9ae4daf57d587d034","modified":1453921187000},{"_id":"themes/yelee/node_modules/request/package.json","shasum":"93cc2fdef537935d82c9ec6e6969a63450a19952","modified":1456469177000},{"_id":"themes/yelee/node_modules/sntp/LICENSE","shasum":"1583807686100eb3d8287b4e4627818f002aabaf","modified":1409946595000},{"_id":"themes/yelee/node_modules/request/request.js","shasum":"baa695ff90bacd0d7e7b56fc0f83bac22360fd99","modified":1453921187000},{"_id":"themes/yelee/node_modules/sntp/Makefile","shasum":"23079c0b043b0fd2f037fa6272e36d2562425c6d","modified":1409946595000},{"_id":"themes/yelee/node_modules/sntp/README.md","shasum":"5b5b1348b73a5ba7293f5924937015c6b6350b6d","modified":1409946595000},{"_id":"themes/yelee/node_modules/sntp/examples/offset.js","shasum":"5b78885677fd2f0eae4c2fb6c04c2d6e2f39bf49","modified":1409946595000},{"_id":"themes/yelee/node_modules/sntp/examples/time.js","shasum":"9a7e69f5ee15afc381ce433cfa867bff405ca81d","modified":1409946595000},{"_id":"themes/yelee/node_modules/sntp/index.js","shasum":"fbc929bb3b85e76c25fc52743d325d9f36fb3643","modified":1409946595000},{"_id":"themes/yelee/node_modules/sntp/lib/index.js","shasum":"eeed7222493e633069fe267f915f7d13b12df094","modified":1409946595000},{"_id":"themes/yelee/node_modules/sntp/package.json","shasum":"943f244a6ffcef539293a58cd1ddec29e4a87db6","modified":1456469177000},{"_id":"themes/yelee/node_modules/sntp/test/index.js","shasum":"bc5aae767cff3fcd90a9a4b2d6ec0e6fea66988f","modified":1409946595000},{"_id":"themes/yelee/node_modules/sshpk/LICENSE","shasum":"10b8ac49ffb8f7cc8bdca9303209a1b3b2f3587d","modified":1446856544000},{"_id":"themes/yelee/node_modules/sshpk/README.md","shasum":"7c00acdc8e5bf0eca47a16aa33c8fa17202fa4bb","modified":1447889453000},{"_id":"themes/yelee/node_modules/sshpk/bin/sshpk-conv","shasum":"fea08967162027695aed134d117056a5b789d188","modified":1452039039000},{"_id":"themes/yelee/node_modules/sshpk/bin/sshpk-sign","shasum":"e187df199ed0e1c1d782f679b4742df047919854","modified":1452565517000},{"_id":"themes/yelee/node_modules/sshpk/bin/sshpk-verify","shasum":"a74dd8749820e0a9e9d334bd09665d6e3e4885f2","modified":1452565517000},{"_id":"themes/yelee/node_modules/sshpk/lib/algs.js","shasum":"95cac832aaaa1d70d2a18bd42559a147dafbf11b","modified":1446856544000},{"_id":"themes/yelee/node_modules/sshpk/lib/dhe.js","shasum":"de6f67e80ebce95a5272c75afcf05ea84ac45b3b","modified":1449005123000},{"_id":"themes/yelee/node_modules/sshpk/lib/ed-compat.js","shasum":"a05999a5907f0027ba834b8ee4e819380a5108ea","modified":1452565517000},{"_id":"themes/yelee/node_modules/sshpk/lib/errors.js","shasum":"94532c1445e72de790269b42a85741ac597c37e4","modified":1446856544000},{"_id":"themes/yelee/node_modules/sshpk/lib/fingerprint.js","shasum":"1d34b04f4b70508da86cbc87a4a4c16206189930","modified":1447889453000},{"_id":"themes/yelee/node_modules/sshpk/lib/formats/auto.js","shasum":"ef4cc1499a3c7c3d96343b8edb2965c9630830a6","modified":1446856544000},{"_id":"themes/yelee/node_modules/sshpk/lib/formats/pem.js","shasum":"8288839f3bc23aa06ff4be127a0c7099511668b1","modified":1447889453000},{"_id":"themes/yelee/node_modules/sshpk/lib/formats/pkcs1.js","shasum":"155a8e28b24cb78b4d2a9cc88acdbd24f8296e97","modified":1447889453000},{"_id":"themes/yelee/node_modules/sshpk/lib/formats/pkcs8.js","shasum":"c9f73599e6447ef8cd55d670335b710bf9eb666e","modified":1447889453000},{"_id":"themes/yelee/node_modules/sshpk/lib/formats/rfc4253.js","shasum":"31768dec67a622cb3a29e665467a2c6506923da2","modified":1455236041000},{"_id":"themes/yelee/node_modules/sshpk/lib/formats/ssh-private.js","shasum":"cba9761409b07d0d383aa58185d968613edbd5ff","modified":1447889453000},{"_id":"themes/yelee/node_modules/sshpk/lib/formats/ssh.js","shasum":"e05ce4d9981b2d0ccbbc6c5b28f1c4497adffe56","modified":1447889453000},{"_id":"themes/yelee/node_modules/sshpk/lib/index.js","shasum":"1e6da7fba9b778c1791755723fb286b3d72d8b97","modified":1446856544000},{"_id":"themes/yelee/node_modules/sshpk/lib/key.js","shasum":"fa8bce41330b09c7cda81be71b15772a57590eab","modified":1452565517000},{"_id":"themes/yelee/node_modules/sshpk/lib/private-key.js","shasum":"a2d90ebfebf92206b78fba754ea43af97ac80841","modified":1447889453000},{"_id":"themes/yelee/node_modules/sshpk/lib/signature.js","shasum":"9ca03d95eded537101b3b7e9f0537f3cb5e0217b","modified":1447889453000},{"_id":"themes/yelee/node_modules/sshpk/lib/ssh-buffer.js","shasum":"e0a58a30c41e44e08e098467384b56a33f7c3213","modified":1452039039000},{"_id":"themes/yelee/node_modules/sshpk/lib/utils.js","shasum":"9dcea6ff1a1026a57b235f4608fc08480efa05fb","modified":1447889453000},{"_id":"themes/yelee/node_modules/sshpk/man/man1/sshpk-conv.1","shasum":"a64a4769ca648e2047d255bf5237ce051f6af15a","modified":1452565517000},{"_id":"themes/yelee/node_modules/sshpk/man/man1/sshpk-sign.1","shasum":"742f5bb2986ad635eb081bad695573cd6826c96b","modified":1452565517000},{"_id":"themes/yelee/node_modules/sshpk/man/man1/sshpk-verify.1","shasum":"a5c70f82de5313ee103ba9bf3cfb9774465de370","modified":1452565517000},{"_id":"themes/yelee/node_modules/sshpk/package.json","shasum":"406c4301061c7dc76e05b2e31ae669007270bd22","modified":1456469177000},{"_id":"themes/yelee/node_modules/string_decoder/LICENSE","shasum":"8344f8cf34d06153cd7ffc797c070e00d69eb442","modified":1390012773000},{"_id":"themes/yelee/node_modules/string_decoder/README.md","shasum":"c8dac065c0a3043936a7c07ea1d698234c3ad159","modified":1390012773000},{"_id":"themes/yelee/node_modules/string_decoder/index.js","shasum":"91f40da3177881cf70b87520444b755e1d9592ec","modified":1408767880000},{"_id":"themes/yelee/node_modules/string_decoder/package.json","shasum":"b83e37447e6dd0ffa68dd7fae5a71135b1acfded","modified":1456469176000},{"_id":"themes/yelee/node_modules/stringstream/LICENSE.txt","shasum":"e957fbece098eddf6df809165d5e73c2c1b2e10a","modified":1445815621000},{"_id":"themes/yelee/node_modules/stringstream/README.md","shasum":"33c7843dec1919a17daad5a5ae2fb06d54018b38","modified":1358765250000},{"_id":"themes/yelee/node_modules/stringstream/example.js","shasum":"17a98e07a319edf8fbeeea49d83515304922b1b4","modified":1361939998000},{"_id":"themes/yelee/node_modules/stringstream/package.json","shasum":"a76650259d3fcf70cd85a0607771b80ea615e8d7","modified":1456469176000},{"_id":"themes/yelee/node_modules/stringstream/stringstream.js","shasum":"400fe756da898736fe0642a709c7f88e21fda352","modified":1363491475000},{"_id":"themes/yelee/node_modules/strip-ansi/index.js","shasum":"fa7b64a04c5989a1c9b78e83768b90384ac9abcc","modified":1424597013000},{"_id":"themes/yelee/node_modules/strip-ansi/license","shasum":"0c94f137f6e0536db8cb2622a9dc84253b91b90c","modified":1424597013000},{"_id":"themes/yelee/node_modules/strip-ansi/package.json","shasum":"c40a95761487d77f9b4efc95c3e7ce5276c0fe11","modified":1456469176000},{"_id":"themes/yelee/node_modules/strip-ansi/readme.md","shasum":"ee19204de1797a46e3101e8b064a3cfd4741fd6c","modified":1456056884000},{"_id":"themes/yelee/node_modules/supports-color/index.js","shasum":"669e4e82e32796eacb16a314bb3db270fb1d8572","modified":1435362323000},{"_id":"themes/yelee/node_modules/supports-color/license","shasum":"0c94f137f6e0536db8cb2622a9dc84253b91b90c","modified":1396798991000},{"_id":"themes/yelee/node_modules/supports-color/package.json","shasum":"aece41eeb7cdec35059d5665fb4a3015bcca3bf2","modified":1456469176000},{"_id":"themes/yelee/node_modules/supports-color/readme.md","shasum":"a0227e37af9ebe9e998782cf0a1eb75338d68f8e","modified":1435704929000},{"_id":"themes/yelee/node_modules/tough-cookie/LICENSE","shasum":"d453b8d6be98bbb6cff7074794f5776ff3a17115","modified":1443808008000},{"_id":"themes/yelee/node_modules/tough-cookie/lib/cookie.js","shasum":"30167425a77bef21e5eb390567ebef0f7532ca13","modified":1447378366000},{"_id":"themes/yelee/node_modules/tough-cookie/lib/memstore.js","shasum":"ecd6269063fe718d5b46d4127ff9d12065660a90","modified":1433972674000},{"_id":"themes/yelee/node_modules/tough-cookie/lib/pathMatch.js","shasum":"3d403b8aad536db9e97eef4915eb01ef53405323","modified":1432572908000},{"_id":"themes/yelee/node_modules/tough-cookie/lib/permuteDomain.js","shasum":"700be205b7d0d3b4c4f442b7dc1b3299d47bf55d","modified":1432572908000},{"_id":"themes/yelee/node_modules/tough-cookie/README.md","shasum":"72dd4e35da08b98d01237a80b788ae1aa189de87","modified":1444173105000},{"_id":"themes/yelee/node_modules/tough-cookie/lib/store.js","shasum":"bcce2205e56bb588b4e6cfcd48a34610a5eccf82","modified":1433972674000},{"_id":"themes/yelee/node_modules/tough-cookie/package.json","shasum":"8e0c8f676e68a6e9663bfcbf1085d9a9e30edac2","modified":1456469177000},{"_id":"themes/yelee/node_modules/tunnel-agent/LICENSE","shasum":"05979f0750cf5c2a17bd3aa12450849c151d8b7c","modified":1446013763000},{"_id":"themes/yelee/node_modules/tunnel-agent/README.md","shasum":"fab5bff0eba532373f36d827d9775105d64ff719","modified":1446013763000},{"_id":"themes/yelee/node_modules/tunnel-agent/index.js","shasum":"e9320bd906e55558d9ba2569f76e92899da8744f","modified":1449585048000},{"_id":"themes/yelee/node_modules/tunnel-agent/package.json","shasum":"be7b4047c86fb7e127b17cd47288d6bd739db170","modified":1456469176000},{"_id":"themes/yelee/node_modules/tweetnacl/CHANGELOG.md","shasum":"1d5290965ca2f4b840087ff8ad622c8a16f9c051","modified":1456360460000},{"_id":"themes/yelee/node_modules/tweetnacl/COPYING.txt","shasum":"92d8cef4ad2ad4c50c8741cad9dfd4a3f1ecb14d","modified":1456349123000},{"_id":"themes/yelee/node_modules/tweetnacl/README.md","shasum":"1cd9e0ee76559125884f4c4c73fcb16430c24235","modified":1455974941000},{"_id":"themes/yelee/node_modules/tweetnacl/nacl-fast.min.js","shasum":"afded67e9b12156534d384d4b10f0c2384d418fd","modified":1455984388000},{"_id":"themes/yelee/node_modules/tweetnacl/nacl-fast.js","shasum":"b13f5e9c2d99a866bc1c5d66e58071cc8d4ae293","modified":1456360360000},{"_id":"themes/yelee/node_modules/tweetnacl/nacl.js","shasum":"523fe36259524a0f35d056416a18de5ae96027a3","modified":1455960849000},{"_id":"themes/yelee/node_modules/tweetnacl/nacl.min.js","shasum":"807244ced1f262b7ffcf43d5ce8e9c3d17d96ba2","modified":1455984386000},{"_id":"themes/yelee/node_modules/tweetnacl/package.json","shasum":"060790ecb054aa76a8ea7ef9f7ea3f86d4d9edcc","modified":1456469177000},{"_id":"themes/yelee/node_modules/url/LICENSE","shasum":"6e02c7c9d5befe1c0407466d8377a0475ddd2d40","modified":1420169637000},{"_id":"themes/yelee/node_modules/url/README.md","shasum":"a57875ddbe6d06e86164eddce5a724f5f7534ebc","modified":1440689784000},{"_id":"themes/yelee/node_modules/url/package.json","shasum":"6f3d346fbe6a4c75c0b03cc65ed8c67fc2d8b77a","modified":1456469177000},{"_id":"themes/yelee/node_modules/url/url.js","shasum":"78d0ac233252dbbecf7afc93c2c3ad56965f53e2","modified":1440689626000},{"_id":"themes/yelee/node_modules/url/util.js","shasum":"b83cee072b6381001e94414862d934d65004d92b","modified":1440689626000},{"_id":"themes/yelee/node_modules/url/test.js","shasum":"218082759e538553cb66e6956acbafe83201aa97","modified":1440689626000},{"_id":"themes/yelee/node_modules/util/LICENSE","shasum":"73efe5bda3791d234730ab0dcc48eb619a2e0ec6","modified":1391793275000},{"_id":"themes/yelee/node_modules/util/README.md","shasum":"800a5b9b844394d482310cd82f5dd0c5e5b9f313","modified":1385144346000},{"_id":"themes/yelee/node_modules/util/package.json","shasum":"eff382719c54b788611e4e354b06131eff5c0a89","modified":1456469177000},{"_id":"themes/yelee/node_modules/util/support/isBuffer.js","shasum":"ab526fa0e6a7e7f560d2126a632cc8342158334d","modified":1385142754000},{"_id":"themes/yelee/node_modules/util/support/isBufferBrowser.js","shasum":"b8367e5d8c922ba31fef26a3bfdde03fa6549394","modified":1387550223000},{"_id":"themes/yelee/node_modules/util/test/browser/inspect.js","shasum":"85c46df14faf4a9fc53decee72df962cb1fed6e3","modified":1387552267000},{"_id":"themes/yelee/node_modules/util/test/browser/is.js","shasum":"aed2e812c0eb4fc431b76dad123ea6328fa1287f","modified":1387550223000},{"_id":"themes/yelee/node_modules/util/test/node/debug.js","shasum":"7d875f76046f15f766af9f269120580da0321d18","modified":1385142754000},{"_id":"themes/yelee/node_modules/util/test/node/format.js","shasum":"45c0e3d208a550cdaeac56e19ea80f15cd7372d4","modified":1385142754000},{"_id":"themes/yelee/node_modules/util/test/node/util.js","shasum":"1105a294af7c2569317193d577b979abd55cc9d6","modified":1385142754000},{"_id":"themes/yelee/node_modules/util/util.js","shasum":"cda85059c26c964651c093b8a78bbe5a0dea0ab4","modified":1387552736000},{"_id":"themes/yelee/node_modules/util-deprecate/History.md","shasum":"1fc5b9cf603a0b6abeb852b35bec607a411e5b9b","modified":1444243047000},{"_id":"themes/yelee/node_modules/util/test/node/inspect.js","shasum":"45495c8dac3274dd814d62480bc768f08e3d386d","modified":1385142754000},{"_id":"themes/yelee/node_modules/util/test/node/log.js","shasum":"4ef8a0d8a1354361f90e7b8a91cf5070b47a297a","modified":1385142754000},{"_id":"themes/yelee/node_modules/util-deprecate/LICENSE","shasum":"cbde92577cb69b3b45dd33f8dc600732cf9e14cb","modified":1416945941000},{"_id":"themes/yelee/node_modules/util-deprecate/README.md","shasum":"8e590b24df7b037031e571b7b2b9600217b83ae0","modified":1416945941000},{"_id":"themes/yelee/node_modules/util-deprecate/browser.js","shasum":"335965112d6117af8926dce4497a1fb9fca022eb","modified":1444242970000},{"_id":"themes/yelee/node_modules/util-deprecate/node.js","shasum":"26bb9fcabaf57f0bb50e5e026c13de394bc0c478","modified":1416945941000},{"_id":"themes/yelee/node_modules/util-deprecate/package.json","shasum":"f02ac425c5573315ebeb8295eb8dfd30175460a8","modified":1456469176000},{"_id":"themes/yelee/node_modules/verror/LICENSE","shasum":"772b18147b3bf826978f984f8e01562a9e3cc254","modified":1360175300000},{"_id":"themes/yelee/node_modules/verror/Makefile","shasum":"89b6506d72bcdd045b63921d0b754227f824c4f1","modified":1360175300000},{"_id":"themes/yelee/node_modules/verror/Makefile.targ","shasum":"f66e38899fc918aac830c478ae402c66d8793bc7","modified":1360175300000},{"_id":"themes/yelee/node_modules/verror/README.md","shasum":"94a2a13d3e722a3950176fa8ed55a1e7a7fd9d14","modified":1360175300000},{"_id":"themes/yelee/node_modules/verror/examples/levels-verror.js","shasum":"f8e7f3d3dbce6e61b53ea2a49a63111d156cf18e","modified":1360175300000},{"_id":"themes/yelee/node_modules/verror/examples/levels-werror.js","shasum":"e6d95f8c3af86fe246ef883197c28df6b4884eb6","modified":1360175300000},{"_id":"themes/yelee/node_modules/verror/examples/varargs.js","shasum":"67c7570a5aa82ca71690b558a3f3d1d321a7508c","modified":1360175300000},{"_id":"themes/yelee/node_modules/verror/examples/verror.js","shasum":"8513abb6a724947494c7513adfa27d76931488d6","modified":1360175300000},{"_id":"themes/yelee/node_modules/verror/examples/werror.js","shasum":"10e842ef7ad2e6901398304c963c6ef1f44efcca","modified":1360175300000},{"_id":"themes/yelee/node_modules/verror/jsl.node.conf","shasum":"c9a618ebefdabda69fcf47f17406c254f7f07f9f","modified":1360175300000},{"_id":"themes/yelee/node_modules/verror/lib/verror.js","shasum":"def5538e73a39e2d14388970751c55e55f9b06fd","modified":1360175300000},{"_id":"themes/yelee/node_modules/verror/package.json","shasum":"8d6625aacdaaae976f5e0cd41753cadae4cce384","modified":1456469177000},{"_id":"themes/yelee/node_modules/verror/tests/tst.inherit.js","shasum":"298dabcdd9eff7081ee06a2b87e1118651190c9c","modified":1360175394000},{"_id":"themes/yelee/node_modules/verror/tests/tst.verror.js","shasum":"947c77e0a31ea025d156d9323d8a7283bf87871a","modified":1360175300000},{"_id":"themes/yelee/node_modules/verror/tests/tst.werror.js","shasum":"6b4007d450a8dfb9311ad86f44e3a7817fdeca53","modified":1360175420000},{"_id":"themes/yelee/node_modules/xtend/LICENCE","shasum":"c563ca2a6d330b98c2ca9473a0299c4a689bf6b8","modified":1446502746000},{"_id":"themes/yelee/node_modules/xtend/Makefile","shasum":"bf249732a0985e13f60552c8a9d6c3894c8fbb44","modified":1446502746000},{"_id":"themes/yelee/node_modules/xtend/README.md","shasum":"d7d6f2f31071911d99fef109646867a0b325c8a3","modified":1446502746000},{"_id":"themes/yelee/node_modules/xtend/immutable.js","shasum":"3c1de57f8d038e3ebc9e1ab278fe2f683866079c","modified":1446502746000},{"_id":"themes/yelee/node_modules/xtend/mutable.js","shasum":"0b00bff9bc925c6c258ef4afb77e7f50640e6555","modified":1446502746000},{"_id":"themes/yelee/node_modules/xtend/package.json","shasum":"24993ffa5427ac6d9dd5ba1bb045283595aceda5","modified":1456469177000},{"_id":"themes/yelee/node_modules/xtend/test.js","shasum":"3b51ee9fb4c95c82be0bdde62dddb31f4c18e648","modified":1446502746000},{"_id":"themes/yelee/package.json","shasum":"8f03c577fc6e599142cb619f955180cbdc3a7f6c","modified":1456469185000},{"_id":"themes/yelee/source/css/_extend.styl","shasum":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/archive.styl","shasum":"053c1684b6edaca7fa0c94a7f9fca637ccece2c2","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/article.styl","shasum":"174ccc6f83b81504f7e54d986196aa24f1d79eb8","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/customise/blockquote.styl","shasum":"7e0853ec8a7767ca87ca54df62cc706de5f21553","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/customise/code-block.styl","shasum":"4db1a992a06fd92b779f0afc9bb8bb3667bdb101","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/customise/inline-code.styl","shasum":"aedbcd697c9fbaeeb93c068be3db771c41feba0d","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/customise/social-icon.styl","shasum":"55cf30c47f0a124eb78d52f12b4ddb6aca9499a5","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/footer.styl","shasum":"2277125ef35f96a1ba76a1b84fc570526826453d","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/header.styl","shasum":"67e59feb18eee6026717cb440d86ab9551782628","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/highlight.styl","shasum":"48f409828549190efedb9067dae0c6828a4d22b0","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/instagram.styl","shasum":"a093443add2f529396d6b6bdef1675bc3acf3958","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/main.styl","shasum":"65e18e08e6ce1db19d741d4094842131929a7e1b","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/mobile-slider.styl","shasum":"211a4286f60751c372090fa96f384521e2ce352c","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/mobile.styl","shasum":"6f2f78d5d5ba7e4e035f7ea3948b9e196b0b7136","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/page.styl","shasum":"ca3f871adf8fdb296e4394070605dded53d93cb2","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/post/youyan.styl","shasum":"ac2869e2e0fb3a1ee0df4b0c0a233a2b1923ea20","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/scroll.styl","shasum":"f32deb9192568a2ea789d77a23a08d07f4e57d59","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/share.styl","shasum":"3cfc59278c21b504f8f633e08767a449e03af8d0","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/tagcloud.styl","shasum":"ec9053b3b2ae962cb44b6f915701927e400e1dfe","modified":1456461572000},{"_id":"themes/yelee/source/css/_partial/wheelmenu.styl","shasum":"9e57421eab562ea13d0ed2b2e1415eee79fa23d0","modified":1456461572000},{"_id":"themes/yelee/source/css/_util/grid.styl","shasum":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1456461572000},{"_id":"themes/yelee/source/css/_util/mixin.styl","shasum":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1456461572000},{"_id":"themes/yelee/source/css/_variables.styl","shasum":"77cd2c0c9d9111eab278ff46946b6166b6a840d2","modified":1456461572000},{"_id":"themes/yelee/source/css/style.styl","shasum":"909c2aa1ce08cb891420852210c5c51a661339aa","modified":1457265467000},{"_id":"themes/yelee/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"6394c48092085788a8c0ef72670b0652006231a1","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/jquery.fancybox.css","shasum":"96138eaddfbd305160ddcb98a5f08555ca6cb4ee","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/jquery.fancybox.pack.js","shasum":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1456461572000},{"_id":"themes/yelee/source/fancybox/jquery.fancybox.js","shasum":"004bb0812414554ab48067792f09e978603253b6","modified":1456461572000},{"_id":"themes/yelee/source/font-awesome/css/font-awesome.css","shasum":"b488600451227b445414796e9b8550e7c1bd6d29","modified":1456461572000},{"_id":"themes/yelee/source/font-awesome/css/font-awesome.min.css","shasum":"12d6861075de8e293265ff6ff03b1f3adcb44c76","modified":1456461572000},{"_id":"themes/yelee/source/img/GitHub.png","shasum":"08c955a91b6733bd51913b54c69fe742d546d0ec","modified":1456461572000},{"_id":"themes/yelee/source/img/SegmentFault.png","shasum":"52bd4ddf6df129b6958398b21fa370f17cadb428","modified":1456461572000},{"_id":"themes/yelee/source/img/V2EX.png","shasum":"9adab6af95db9318e980c01cadbc5de800b4c816","modified":1456461572000},{"_id":"themes/yelee/source/img/coderwall.png","shasum":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1456461572000},{"_id":"themes/yelee/source/img/delicious.png","shasum":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1456461572000},{"_id":"themes/yelee/source/img/facebook.png","shasum":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1456461572000},{"_id":"themes/yelee/source/img/favicon.png","shasum":"d939d7d97f2de43d8bd6bc28a97adf81eeac10c2","modified":1454763894000},{"_id":"themes/yelee/source/img/google.png","shasum":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1456461572000},{"_id":"themes/yelee/source/img/img-err.png","shasum":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1456461572000},{"_id":"themes/yelee/source/img/img-loading.png","shasum":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1456461572000},{"_id":"themes/yelee/source/img/linkedin.png","shasum":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1456461572000},{"_id":"themes/yelee/source/img/mail.png","shasum":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1456461572000},{"_id":"themes/yelee/source/img/pinboard.png","shasum":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1456461572000},{"_id":"themes/yelee/source/img/pinterest.png","shasum":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1456461573000},{"_id":"themes/yelee/source/img/rss.png","shasum":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1456461573000},{"_id":"themes/yelee/source/img/scrollbar_arrow.png","shasum":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1456461573000},{"_id":"themes/yelee/source/img/stackoverflow.png","shasum":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1456461573000},{"_id":"themes/yelee/source/img/twitter.png","shasum":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1456461573000},{"_id":"themes/yelee/source/img/新浪微博.png","shasum":"c9fb558158f491104fd8dbafc92c30591ad0299e","modified":1456461573000},{"_id":"themes/yelee/source/img/知乎.png","shasum":"50e43bad8fefb3950b13dc86aaa86de8a79432ae","modified":1456461573000},{"_id":"themes/yelee/source/img/TiddlyWiki.png","shasum":"58be3c981c6d25b47ddaab2f254838f9baa01d59","modified":1456461572000},{"_id":"themes/yelee/source/img/简书.png","shasum":"bfe5e7b6146de19d180f36fa5a2b074c2bc23406","modified":1456461573000},{"_id":"themes/yelee/source/img/网易云音乐.png","shasum":"8bc2a2e2c4312ee9d4879b24f9e2bd51e6436840","modified":1456461573000},{"_id":"themes/yelee/source/img/虾米音乐.png","shasum":"d3ff836d5d58e10fb30fac1bae0aae34cfe2038f","modified":1456461573000},{"_id":"themes/yelee/source/img/豆瓣.png","shasum":"9f4798298548727052fa6ae809933c9e8ac42571","modified":1456461573000},{"_id":"themes/yelee/source/js/GithubRepoWidget.js","shasum":"624e81a3b0e57495b0c0e0b3e056296c6e8ae5df","modified":1456461573000},{"_id":"themes/yelee/source/js/clipboard.min.js","shasum":"c13b4bb8fee46447284590d2afc0efca0ea3cb7b","modified":1456461573000},{"_id":"themes/yelee/source/js/instagram.js","shasum":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1456461573000},{"_id":"themes/yelee/source/js/jquery.lazyload.js","shasum":"9c34c37b4dca82386648d364da913153d1db902e","modified":1456461573000},{"_id":"themes/yelee/source/js/main.js","shasum":"b626dd0c971c4e7bb725511c591a54fffff6b191","modified":1456634620000},{"_id":"themes/yelee/source/js/mobile.js","shasum":"baed8d560883c842c2b8c3e0fadcf359f97140d0","modified":1456461573000},{"_id":"themes/yelee/source/js/pc.js","shasum":"188915f13cec49c2bdca9ffdc377adbc5bed24e8","modified":1456461573000},{"_id":"themes/yelee/node_modules/bluebird/js/browser/bluebird.min.js","shasum":"7983e7650a5be5d5636815f8477c685d966e0c3a","modified":1443731946000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hawk/images/logo.png","shasum":"7b9844914960e180d2f243d74a50f2b4fa23fbdb","modified":1447968927000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/hoek/test/index.js","shasum":"f9112be27168572ac86d62b7abfdfbf94661c8b6","modified":1442857555000},{"_id":"themes/yelee/node_modules/hawk/images/logo.png","shasum":"7b9844914960e180d2f243d74a50f2b4fa23fbdb","modified":1447968927000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/browser/bluebird.core.js","shasum":"89a00d6c3140f573a30dae5f71348ebf6749f1bf","modified":1456440962000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/browser/bluebird.min.js","shasum":"44e4280b7ed053e20d71beb1ce1ec5efe0ff644d","modified":1456440966000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/autoit.js","shasum":"b5a7f4bc8fe5166e547b8178d8b036bb4e24c0a4","modified":1445295322000},{"_id":"themes/yelee/node_modules/highlight.js/lib/languages/mathematica.js","shasum":"aa8237d4cfb20b0aa38860dd9d3d8dc2f2755089","modified":1445295322000},{"_id":"themes/yelee/node_modules/hoek/test/index.js","shasum":"f9112be27168572ac86d62b7abfdfbf94661c8b6","modified":1442857555000},{"_id":"themes/yelee/node_modules/nan/nan.h","shasum":"6658ef10fe1b0f3d6cf3b31221f3c7bb4eb05899","modified":1452351065000},{"_id":"themes/yelee/source/font-awesome/fonts/FontAwesome.otf","shasum":"42c179eef588854b5ec151bcf6a3f58aa8b79b11","modified":1456461572000},{"_id":"themes/yelee/source/font-awesome/fonts/fontawesome-webfont.eot","shasum":"986eed8dca049714e43eeebcb3932741a4bec76d","modified":1456461572000},{"_id":"themes/yelee/source/font-awesome/fonts/fontawesome-webfont.woff2","shasum":"638c652d623280a58144f93e7b552c66d1667a11","modified":1456461572000},{"_id":"themes/yelee/source/font-awesome/fonts/fontawesome-webfont.woff","shasum":"4a313eb93b959cc4154c684b915b0a31ddb68d84","modified":1456461572000},{"_id":"themes/yelee/node_modules/bluebird/js/browser/bluebird.js","shasum":"2659d8978645301ec08c0e379bdd68ac2b0d008f","modified":1443731946000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/mime-db/db.json","shasum":"79ce354a3bd34e49cea2d742e789d154d3c446e7","modified":1452093795000},{"_id":"themes/yelee/node_modules/fsevents/node_modules/tough-cookie/lib/pubsuffix.js","shasum":"56aac14d8b2dcacfe05e3447a6e4bf9dff2fa0d9","modified":1443808008000},{"_id":"themes/yelee/node_modules/hexo-fs/node_modules/bluebird/js/browser/bluebird.js","shasum":"3cc9f4a20a63f6544b2199df43aba1f233c449b1","modified":1456440966000},{"_id":"themes/yelee/node_modules/mime-db/db.json","shasum":"e939c0dbc4ece9e04a3a36bcab40a544d32d7ad5","modified":1455558380000},{"_id":"themes/yelee/node_modules/tough-cookie/lib/pubsuffix.js","shasum":"56aac14d8b2dcacfe05e3447a6e4bf9dff2fa0d9","modified":1443808008000},{"_id":"themes/yelee/source/font-awesome/fonts/fontawesome-webfont.ttf","shasum":"6484f1af6b485d5096b71b344e67f4164c33dd1f","modified":1456461572000},{"_id":"themes/yelee/source/background/bg-528.jpg","shasum":"d0441d582f601fd5cdeb0212c2f8245866f623d7","modified":1456746793000},{"_id":"themes/yelee/source/font-awesome/fonts/fontawesome-webfont.svg","shasum":"b06b5c8f67fd632cdc62a33b62ae4f74194131b3","modified":1456461572000},{"_id":"themes/yelee/source/background/bg-0.jpg","shasum":"5b3de75c262333f42c064d391fb659d3d08c3294","modified":1456475869000},{"_id":"themes/yelee/source/apple-touch-icon.png","shasum":"34d23362b3cacda441e45bf43f0ca2ad2fbe39d4","modified":1457741932000},{"_id":"themes/yelee/source/img/avatar.png","shasum":"34d23362b3cacda441e45bf43f0ca2ad2fbe39d4","modified":1456461838000},{"_id":"public/js/pc.js","modified":1458647620889,"shasum":"b87be014e501a14329bac4f443dfb47375205e19"},{"_id":"public/js/mobile.js","modified":1458647620903,"shasum":"d3847e5bcaf39108931724ecb02770c62b10889f"},{"_id":"public/js/main.js","modified":1458647620905,"shasum":"6d7f1c932c58f0bd17e393a2c4c9a18d48af1b50"},{"_id":"public/js/jquery.lazyload.js","modified":1458647620908,"shasum":"c11a2e7b330d16d06feabd0a8477099adf9d6799"},{"_id":"public/js/instagram.js","modified":1458647620911,"shasum":"f19adbcc0dac33536bc6660598059048ec901882"},{"_id":"public/js/clipboard.min.js","modified":1458647620914,"shasum":"c13b4bb8fee46447284590d2afc0efca0ea3cb7b"},{"_id":"public/js/GithubRepoWidget.js","modified":1458647620916,"shasum":"624e81a3b0e57495b0c0e0b3e056296c6e8ae5df"},{"_id":"public/img/豆瓣.png","modified":1458647620920,"shasum":"9f4798298548727052fa6ae809933c9e8ac42571"},{"_id":"public/img/虾米音乐.png","modified":1458647620926,"shasum":"d3ff836d5d58e10fb30fac1bae0aae34cfe2038f"},{"_id":"public/img/网易云音乐.png","modified":1458647620928,"shasum":"8bc2a2e2c4312ee9d4879b24f9e2bd51e6436840"},{"_id":"public/img/简书.png","modified":1458647620931,"shasum":"bfe5e7b6146de19d180f36fa5a2b074c2bc23406"},{"_id":"public/img/知乎.png","modified":1458647620934,"shasum":"50e43bad8fefb3950b13dc86aaa86de8a79432ae"},{"_id":"public/img/新浪微博.png","modified":1458647620936,"shasum":"c9fb558158f491104fd8dbafc92c30591ad0299e"},{"_id":"public/img/twitter.png","modified":1458647620952,"shasum":"14dbb8e62d056525253bc0de13acd1723da7a934"},{"_id":"public/img/stackoverflow.png","modified":1458647620955,"shasum":"da5dfe9043055c95e479d49c78cd3b020de608f2"},{"_id":"public/img/scrollbar_arrow.png","modified":1458647620962,"shasum":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0"},{"_id":"public/img/rss.png","modified":1458647620966,"shasum":"430fd47340e75214c081abd05cd7410cf7c71b86"},{"_id":"public/img/pinterest.png","modified":1458647620969,"shasum":"9c72917f8779c083157c6ce7a5d62ed4874f0630"},{"_id":"public/img/pinboard.png","modified":1458647620971,"shasum":"0891fbb6d092fa012bf936019923383d84c6aeb0"},{"_id":"public/img/mail.png","modified":1458647620973,"shasum":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7"},{"_id":"public/img/linkedin.png","modified":1458647620979,"shasum":"e203138fb53c257cb214e97f4e30091b9c568d2c"},{"_id":"public/img/img-loading.png","modified":1458647620982,"shasum":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031"},{"_id":"public/img/img-err.png","modified":1458647620985,"shasum":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b"},{"_id":"public/img/google.png","modified":1458647620988,"shasum":"61a21fec7346fa3400b747ac9a201cf3d5bc013d"},{"_id":"public/img/favicon.png","modified":1458647620994,"shasum":"d939d7d97f2de43d8bd6bc28a97adf81eeac10c2"},{"_id":"public/img/facebook.png","modified":1458647620999,"shasum":"d19ad7a0903daf26817afd8753cd97e0cc714f54"},{"_id":"public/img/delicious.png","modified":1458647621003,"shasum":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd"},{"_id":"public/img/coderwall.png","modified":1458647621006,"shasum":"fa84676c4d654e040e51fd34bfcd9f9348cd5331"},{"_id":"public/img/avatar.png","modified":1458647621030,"shasum":"34d23362b3cacda441e45bf43f0ca2ad2fbe39d4"},{"_id":"public/img/V2EX.png","modified":1458647621041,"shasum":"9adab6af95db9318e980c01cadbc5de800b4c816"},{"_id":"public/img/TiddlyWiki.png","modified":1458647621046,"shasum":"58be3c981c6d25b47ddaab2f254838f9baa01d59"},{"_id":"public/img/SegmentFault.png","modified":1458647621052,"shasum":"52bd4ddf6df129b6958398b21fa370f17cadb428"},{"_id":"public/img/GitHub.png","modified":1458647621054,"shasum":"08c955a91b6733bd51913b54c69fe742d546d0ec"},{"_id":"public/font-awesome/fonts/fontawesome-webfont.woff2","modified":1458647621066,"shasum":"638c652d623280a58144f93e7b552c66d1667a11"},{"_id":"public/font-awesome/fonts/fontawesome-webfont.woff","modified":1458647621074,"shasum":"4a313eb93b959cc4154c684b915b0a31ddb68d84"},{"_id":"public/font-awesome/fonts/fontawesome-webfont.ttf","modified":1458647621083,"shasum":"6484f1af6b485d5096b71b344e67f4164c33dd1f"},{"_id":"public/font-awesome/fonts/fontawesome-webfont.svg","modified":1458647621089,"shasum":"b06b5c8f67fd632cdc62a33b62ae4f74194131b3"},{"_id":"public/font-awesome/fonts/fontawesome-webfont.eot","modified":1458647621101,"shasum":"986eed8dca049714e43eeebcb3932741a4bec76d"},{"_id":"public/font-awesome/fonts/FontAwesome.otf","modified":1458647621105,"shasum":"42c179eef588854b5ec151bcf6a3f58aa8b79b11"},{"_id":"public/font-awesome/css/font-awesome.min.css","modified":1458647621109,"shasum":"12d6861075de8e293265ff6ff03b1f3adcb44c76"},{"_id":"public/font-awesome/css/font-awesome.css","modified":1458647621115,"shasum":"b488600451227b445414796e9b8550e7c1bd6d29"},{"_id":"public/fancybox/jquery.fancybox.pack.js","modified":1458647621119,"shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e"},{"_id":"public/fancybox/jquery.fancybox.js","modified":1458647621121,"shasum":"a82597493d75ea989ca586e09173cff332efe41e"},{"_id":"public/fancybox/jquery.fancybox.css","modified":1458647621124,"shasum":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1458647621126,"shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1458647621128,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","modified":1458647621131,"shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","modified":1458647621133,"shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","modified":1458647621135,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/fancybox/helpers/fancybox_buttons.png","modified":1458647621136,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/fancybox/fancybox_sprite@2x.png","modified":1458647621138,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/fancybox/fancybox_sprite.png","modified":1458647621140,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/fancybox/fancybox_overlay.png","modified":1458647621143,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/fancybox/fancybox_loading@2x.gif","modified":1458647621144,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/fancybox/fancybox_loading.gif","modified":1458647621147,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/fancybox/blank.gif","modified":1458647621151,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/css/style.css","modified":1458647622384,"shasum":"8ed3cc559475965811d4603f0018e30217e50c6d"},{"_id":"public/background/bg-528.jpg","modified":1458647622726,"shasum":"d0441d582f601fd5cdeb0212c2f8245866f623d7"},{"_id":"public/background/bg-0.jpg","modified":1458647622731,"shasum":"5b3de75c262333f42c064d391fb659d3d08c3294"},{"_id":"public/apple-touch-icon.png","modified":1458647622740,"shasum":"34d23362b3cacda441e45bf43f0ca2ad2fbe39d4"},{"_id":"public/virtualbox-archlinux/hotkey.png","modified":1458647622750,"shasum":"aca0dac1c68edb971a77b72a0db588f3c034c426"},{"_id":"public/virtualbox-archlinux/network.png","modified":1458647622755,"shasum":"23bd9c4bd71642cd4176ae1737e545bc121724f2"},{"_id":"public/virtualbox-archlinux/port.png","modified":1458647622760,"shasum":"bb684dd8b616413e3e0e27c5efce118249a54113"},{"_id":"public/virtualbox-archlinux/screenfetch.png","modified":1458647622766,"shasum":"edd38d6098ab0cb8d1c6bf35578379f4fd0de96d"},{"_id":"public/virtualbox-archlinux/share.png","modified":1458647622771,"shasum":"8f7c7dcf96cf750b6e0098b07fe257cfd65d22f8"},{"_id":"public/virtualbox-archlinux/terminal.png","modified":1458647622776,"shasum":"8960a9c80feac7fefd5894684fdd6d0a174ba426"},{"_id":"public/uva-11538/cells.png","modified":1458647622783,"shasum":"3a162829c312a17639950c3620cd70799ed94a49"},{"_id":"public/splay-notes-1/splay.png","modified":1458647622786,"shasum":"ee64a4a43e084b0011003b743a680eb2ec2b9a13"},{"_id":"public/osx-softwares/dropbox.png","modified":1458647622790,"shasum":"c57885f99a5af62b94eb53a510edbc2faab47e7b"},{"_id":"public/osx-softwares/feeluown.png","modified":1458647622795,"shasum":"70c4a0b923c3d8688d64f0036ec09d34d214a7eb"},{"_id":"public/osx-softwares/fileroller.png","modified":1458647622801,"shasum":"9bf831aec4309e525791f286c346a447c6605acd"},{"_id":"public/osx-softwares/flashlight.png","modified":1458647622804,"shasum":"c251a90415340d44655c18461ed5b186167cd03a"},{"_id":"public/osx-softwares/gimp.png","modified":1458647622811,"shasum":"8d1f18af30cbe2639375bc13d993d81894d916ab"},{"_id":"public/osx-softwares/go2shell.png","modified":1458647622818,"shasum":"538be85641e7b95ec18bf577ac1353d757637817"},{"_id":"public/osx-softwares/karabiner.png","modified":1458647622825,"shasum":"0b24e2252a00f402e681a6dd84a679a4be9706be"},{"_id":"public/osx-softwares/libreoffice-writer.png","modified":1458647622830,"shasum":"f0e740eef5a31433f798a9ab689bca320b3ec05f"},{"_id":"public/osx-softwares/macdown.png","modified":1458647622835,"shasum":"f655bf9258ec412c856078653aadac847f69bd08"},{"_id":"public/osx-softwares/macvim.png","modified":1458647622843,"shasum":"550e044c4af938acbd373649bacff7dd4f020f8c"},{"_id":"public/osx-softwares/shadowsocksx.png","modified":1458647622849,"shasum":"e4d6e7dac5744d19d5303ba13b3f8411953a0427"},{"_id":"public/osx-softwares/teamviewer.png","modified":1458647622851,"shasum":"c9c00c296ccdc4c234cc945bc6b3653e9742797f"},{"_id":"public/osx-softwares/virtualbox.png","modified":1458647622855,"shasum":"7401b6a6f6543356234d9ecbaa5fd8026455ead4"},{"_id":"public/osx-softwares/vlc.png","modified":1458647622858,"shasum":"395a973310d204c78cdefb9da9929c3892479b73"},{"_id":"public/osx-enable-retina/plist-edit.png","modified":1458647622863,"shasum":"94dd75a8fba5775cd97fcc5cc9f917f5bba40061"},{"_id":"public/cut-tree-notes/cutTree.png","modified":1458647622865,"shasum":"12de28c1f402f876a3826dcd7bfc8525d555ce1e"},{"_id":"public/bzoj-2683/cdq.png","modified":1458647622874,"shasum":"a95d0b02b915f092df6656298add0f0fc9662341"},{"_id":"public/friends/index.html","modified":1458647622996,"shasum":"9f950f977a7fc758eac42fea30c284cd2ee0fd65"},{"_id":"public/about-me/index.html","modified":1458647623010,"shasum":"9e94de2b4e3659752a3bd65661c94ab55e19331a"},{"_id":"public/bzoj-2143/index.html","modified":1458647623050,"shasum":"8c945b10cac6d74e2ea64edcefe2900a8fc2ae48"},{"_id":"public/scoi2015-flag/index.html","modified":1458647623075,"shasum":"13d92fbcf88770585eff7d1442d534af87776c31"},{"_id":"public/scoi2015-message/index.html","modified":1458647623103,"shasum":"290d984605ef862f08bc8b1093b96e1872d83d04"},{"_id":"public/scoi2015-matrix/index.html","modified":1458647623130,"shasum":"e425bd72cf47812272e348814eb9edd0cf695dbc"},{"_id":"public/20160318-color/index.html","modified":1458647623169,"shasum":"fbb841269c77192cce11f14dc45432e0849ad9bc"},{"_id":"public/20160319-candy/index.html","modified":1458647623192,"shasum":"1db8b4e17b0cfed2b593f20360355f634c8e6460"},{"_id":"public/20160319-set/index.html","modified":1458647623209,"shasum":"bd9093e49445586e75d3229167d73e27e26e0518"},{"_id":"public/osx-enable-retina/index.html","modified":1458647623230,"shasum":"2ccc5e98c1e6eeec6d46ad16a779f5e8867c6c78"},{"_id":"public/sdoi2008-cave/index.html","modified":1458647623254,"shasum":"7414b13933fd60cfd29d2d664fba0b888679482e"},{"_id":"public/combinatorics-notes/index.html","modified":1458647623283,"shasum":"26184b4f9eaebf806458d2bd2b20888e544b9733"},{"_id":"public/uva-10253/index.html","modified":1458647623308,"shasum":"d5bb401ad2165fcc129f62512848dbb5d9706dc8"},{"_id":"public/uva-11361/index.html","modified":1458647623340,"shasum":"fe1a89ee0455f2548defed408c71a1d2e2d00abd"},{"_id":"public/bigint-template/index.html","modified":1458647623373,"shasum":"5606c5396c197d1855e5384eed5fee54e2a2247d"},{"_id":"public/uva-1362/index.html","modified":1458647623399,"shasum":"d052c24aebd85436f1ac6389355c3e4207f53b04"},{"_id":"public/poj-1737/index.html","modified":1458647623435,"shasum":"4f916ff6822784ff4fd6c0e89352f6ccd282fc3b"},{"_id":"public/osx-softwares/index.html","modified":1458647623466,"shasum":"7366fe1313a9062ab597bc46450112d25d96cd66"},{"_id":"public/uva-11174/index.html","modified":1458647623491,"shasum":"501f343b8d2ed336fba93e6d22444e51b0dfa65a"},{"_id":"public/uva-11137/index.html","modified":1458647623512,"shasum":"e50e0b4fb2b4995d243018f7d7d93005585080ef"},{"_id":"public/uva-11375/index.html","modified":1458647623538,"shasum":"ddbd4de54ebb2e90a55ce39a7301a75ed23700b5"},{"_id":"public/uva-11538/index.html","modified":1458647623561,"shasum":"8d901cabc9c913da7812acf30b23081f731940d3"},{"_id":"public/uva-11806/index.html","modified":1458647623587,"shasum":"1ea67f70040ba5b7c701603c508782f7316128fe"},{"_id":"public/poj-2728/index.html","modified":1458647623623,"shasum":"2a2820d88369e2c06aed1aca5357e4cf10ffb1a1"},{"_id":"public/apio2009-atm/index.html","modified":1458647623656,"shasum":"3d075891db6e66378d24f3d59883a9deac3d4c07"},{"_id":"public/noi2006-profit/index.html","modified":1458647623688,"shasum":"eb7ce64fa0454bbecd525a69cfa1f8b56dd86df1"},{"_id":"public/scoi2007-repair/index.html","modified":1458647623716,"shasum":"e6a5f74b53f6aba45b54ebadbf327df84d346b27"},{"_id":"public/ahoi2008-meet/index.html","modified":1458647623753,"shasum":"c86eb545cf129ce7dc38416e3c4f88e69ff0137b"},{"_id":"public/scoi2010-game/index.html","modified":1458647623782,"shasum":"cf8296e6baba1fb2c3ee6dac5cf674fcc02f27fc"},{"_id":"public/virtualbox-archlinux/index.html","modified":1458647623798,"shasum":"431faa079fc988827f4d8926a7ff603baaa3d7b2"},{"_id":"public/noi2003-editor/index.html","modified":1458647623836,"shasum":"ca705080d6f0ac425428ddd12b5d33f95051204b"},{"_id":"public/scoi2011-candy/index.html","modified":1458647623867,"shasum":"d7d65008689d9b95aeea21aa1493ea9a7e13386d"},{"_id":"public/haoi2006-cow/index.html","modified":1458647623899,"shasum":"0d2b08ae37e6daa606aa6be30c8d0cbc0850240d"},{"_id":"public/codevs-2822/index.html","modified":1458647623930,"shasum":"c841d02c536c6b3c3f81e1d3d5e9671fa4cfb6ab"},{"_id":"public/tarjan-scc-notes/index.html","modified":1458647623955,"shasum":"a2ed20447e90325c5348c3c598f3644fd21f100a"},{"_id":"public/sdoi2010-starrace/index.html","modified":1458647623984,"shasum":"c373542a6584c430f90a71a2f22f41f23a6ee1cd"},{"_id":"public/sdoi2015-war/index.html","modified":1458647624021,"shasum":"988f70b46b40ab3b70f4bfe74092b6d353b0f39d"},{"_id":"public/cogs-741/index.html","modified":1458647624059,"shasum":"503f3f841b16e78fe623ec077eff36cc4185471f"},{"_id":"public/cogs-740/index.html","modified":1458647624083,"shasum":"435cf839fc49f0cc048a42fdd60bf4b682182b8e"},{"_id":"public/ctsc1999-home/index.html","modified":1458647624114,"shasum":"4476bbc7768bba535a1edc8c995b07da0fa166de"},{"_id":"public/cogs-742/index.html","modified":1458647624136,"shasum":"06f8470c19517dc79006cb7d2d1ebc0697e65fe2"},{"_id":"public/cogs-739/index.html","modified":1458647624164,"shasum":"68b2d3b9ef831eaf34e60172d173f15a2f3f2d86"},{"_id":"public/jsoi2008-maxnumber/index.html","modified":1458647624199,"shasum":"278d193722572a67913d75e37c41d34307d4f710"},{"_id":"public/edmonds-karp-notes/index.html","modified":1458647624218,"shasum":"d7119cdb55229200f6d4107cefb208205f1820df"},{"_id":"public/noip2010-prison/index.html","modified":1458647624238,"shasum":"979f516ea8cfe3292be4bdc3b0449e17586c39e2"},{"_id":"public/cogs-746/index.html","modified":1458647624264,"shasum":"e9db47db20d141575960462b30376ee8746567f3"},{"_id":"public/cogs-738/index.html","modified":1458647624300,"shasum":"0787a063e07f891fa09c650e1f00ec1adcde89f0"},{"_id":"public/cogs-734/index.html","modified":1458647624325,"shasum":"43f18fa5b6830ed6324b725fdc26f312dddfbaac"},{"_id":"public/cogs-439/index.html","modified":1458647624348,"shasum":"d40177baf7c5557d1e4d0cee6d2befba5d3d4c5b"},{"_id":"public/cogs-727/index.html","modified":1458647624377,"shasum":"ae462f574eeb0a6b7f45ea4c95d78eb279c8c136"},{"_id":"public/cogs-731/index.html","modified":1458647624401,"shasum":"2e2f235520dabb595827d83e6d749f3784ddace0"},{"_id":"public/cogs-729/index.html","modified":1458647624434,"shasum":"70162787eab092673f6660912e9268dd8e3295f0"},{"_id":"public/cogs-396/index.html","modified":1458647624449,"shasum":"2a0cc8553d9237644b82f981995a4fe18e1bada3"},{"_id":"public/cogs-728/index.html","modified":1458647624472,"shasum":"f325f30fc2287ecf6fd70aa462d98814cce25919"},{"_id":"public/cogs-14/index.html","modified":1458647624492,"shasum":"b227465ef3d87cc4b00b3134d71e99c38333e7ff"},{"_id":"public/bzoj-2683/index.html","modified":1458647624515,"shasum":"f65e8eaa831a82ea1fcbd327108faa533480d48a"},{"_id":"public/codevs-1563/index.html","modified":1458647624543,"shasum":"3db97c0b2cabd362663864a1ea83df01d34b5a10"},{"_id":"public/gnu-debugger/index.html","modified":1458647624576,"shasum":"6cf89b549920fb2024057c483ee5c4f81a6101d2"},{"_id":"public/dinic-notes/index.html","modified":1458647624596,"shasum":"96cdbcaeeaba22a1ac770c8fcbf463e27caf5baf"},{"_id":"public/markdown-latex-helper/index.html","modified":1458647624609,"shasum":"c7d3985985c38c4eaeee2f836f4e0f5fb4809224"},{"_id":"public/bzoj-1756/index.html","modified":1458647624634,"shasum":"c24f2d52e8fc887e95742d3b525156f2cfef3d46"},{"_id":"public/noi2004-cashier/index.html","modified":1458647624671,"shasum":"46f962d36dc82ec0b25e060aecd8fa44f2778769"},{"_id":"public/bzoj-1477/index.html","modified":1458647624691,"shasum":"779e0cf95af07b306edf05c5e72e7470ec8f0644"},{"_id":"public/noi2015-manager/index.html","modified":1458647624724,"shasum":"f53ce2cf620734b7bd362fec7023489e2039fac4"},{"_id":"public/noi2015-prog/index.html","modified":1458647624750,"shasum":"8f5a00cce5a91c925b2bb384a7545140da9e36bc"},{"_id":"public/number-theory-notes-1/index.html","modified":1458647624782,"shasum":"c25e23aecdaa00aa1bc866cbe8db920b5054957d"},{"_id":"public/noip2012-mod/index.html","modified":1458647624796,"shasum":"499a003927ba626c848f156b72c1fc4771bc51cf"},{"_id":"public/link-cut-tree-notes/index.html","modified":1458647624837,"shasum":"36cf4c28eecd589f387dc91cea79215aea5c2ca1"},{"_id":"public/splay-notes-3/index.html","modified":1458647624871,"shasum":"c09c781c1302ce57679396a40d6505dcaeadb1ad"},{"_id":"public/bzoj-1251/index.html","modified":1458647624916,"shasum":"52803bcc040fd1af68940a0bf6bfa36cd4b0dd6f"},{"_id":"public/noip2006-budget/index.html","modified":1458647624933,"shasum":"600d7f1f5ae2e1d71819cd68b640a3a99727029f"},{"_id":"public/bzoj-2442/index.html","modified":1458647624951,"shasum":"056a6e9b12f5a9e53c9ac31642f0d02ed0cb1dd8"},{"_id":"public/codevs-3269-monotone-queue/index.html","modified":1458647624969,"shasum":"1af05a577a82f08e133b9b574fe1d1a62151c41d"},{"_id":"public/monotone-queue-notes/index.html","modified":1458647624989,"shasum":"b60e4da67fa853676f9197ec030519d3dad16bd9"},{"_id":"public/codevs-1345/index.html","modified":1458647625005,"shasum":"1f69ddd3e2c746eec2d9012018f0400bf555848c"},{"_id":"public/noip2003-game/index.html","modified":1458647625033,"shasum":"5aa5848311a11b63dad160e33306c1d10a6a8722"},{"_id":"public/noip2006-energy/index.html","modified":1458647625055,"shasum":"08f2ab229cbc2cf89867503ed44e6be863857826"},{"_id":"public/tyvj-3317/index.html","modified":1458647625070,"shasum":"571f5728fa51e9723a9e0572946998e64fd21f27"},{"_id":"public/codevs-2598/index.html","modified":1458647625089,"shasum":"b243fc1b312dc5e4e074b9827a2aca1ff871b503"},{"_id":"public/noip2000-cheng-ji-zui-da/index.html","modified":1458647625105,"shasum":"c184ce7705e879c39e0310bd6a05cfb19266afbf"},{"_id":"public/ctsc1997-course/index.html","modified":1458647625125,"shasum":"5364f8e42f10813d0f998314d48aaa1fcd0be1ce"},{"_id":"public/codevs-3168-3162/index.html","modified":1458647625164,"shasum":"c14587d3a4810e88cc9428c715069a5e85731678"},{"_id":"public/minimum-spanning-tree-notes/index.html","modified":1458647625196,"shasum":"1947a0ec08e79a7e0c52a93941649bf579fe5b35"},{"_id":"public/system-of-difference-constraints-notes/index.html","modified":1458647625215,"shasum":"5c0408b1929fd6e2807c028af0cf27a1567e0eaf"},{"_id":"public/kmp-notes/index.html","modified":1458647625237,"shasum":"cdaa8d823782127373e565439c8ec0f5d0dff176"},{"_id":"public/cut-tree-notes/index.html","modified":1458647625293,"shasum":"8b781759629b74bb333787d9dbf3f4e389110f78"},{"_id":"public/stl-in-oi/index.html","modified":1458647625330,"shasum":"a4541f880b696414fe3963ff1e6babcdb2f5096b"},{"_id":"public/splay-notes-2/index.html","modified":1458647625393,"shasum":"ddf8cfd8badcd6627a70c173532b91fe6155dd29"},{"_id":"public/splay-notes-1/index.html","modified":1458647625442,"shasum":"3482fcc8e0e60e05a1e95d22750c78c813d86549"},{"_id":"public/hnoi2004-pet/index.html","modified":1458647625463,"shasum":"d2bad2316f44a64e4fab89af5c9c47c60a612450"},{"_id":"public/codevs-3269/index.html","modified":1458647625479,"shasum":"bfe10c60b0555dd1363cebb8f72f7bc85156901b"},{"_id":"public/noi2002-galaxy/index.html","modified":1458647625513,"shasum":"24fce136b58d31b505039c4ba570dd1351bccb78"},{"_id":"public/archives/index.html","modified":1458647625541,"shasum":"abdd8eb91c30bdbe697521695c6b52204af3f5f1"},{"_id":"public/archives/page/2/index.html","modified":1458647625560,"shasum":"599305c9e97b33350ea0dc22b4009cdb09c11237"},{"_id":"public/archives/page/3/index.html","modified":1458647625591,"shasum":"649690a618ead6116bd34466bf105a2eaed1d592"},{"_id":"public/archives/page/4/index.html","modified":1458647625630,"shasum":"c275cef5be1c3704ae95c41987f245dc02d8fd0c"},{"_id":"public/archives/page/5/index.html","modified":1458647625657,"shasum":"d08a448a9a89d9984eca33238bd6aa701960d420"},{"_id":"public/archives/page/6/index.html","modified":1458647625682,"shasum":"ae31121f0bcddd86b21c0b8bf850999f2e14d4be"},{"_id":"public/archives/page/7/index.html","modified":1458647625701,"shasum":"d56a9b7dd65eaca026d52147913901f6f87b9eaf"},{"_id":"public/archives/page/8/index.html","modified":1458647625725,"shasum":"bf16ed5c6672d0b19be917ece20c31be6dcf5039"},{"_id":"public/archives/page/9/index.html","modified":1458647625752,"shasum":"997f957b331f0d4a8f5ea671ae6e570fcae45afe"},{"_id":"public/archives/2015/index.html","modified":1458647625782,"shasum":"f90af93238e05f2a10370231b732085b5b496b03"},{"_id":"public/archives/2015/11/index.html","modified":1458647625788,"shasum":"f329b0ac7d71f6a6f8b218d1a56882d069a0ec2e"},{"_id":"public/archives/2015/12/index.html","modified":1458647625805,"shasum":"bffa772296f99165f722c3f8d2053c14676b63ff"},{"_id":"public/archives/2016/index.html","modified":1458647625830,"shasum":"13bd7f7063655ce3ab99e3525d5d6b5a9763d473"},{"_id":"public/archives/2016/page/2/index.html","modified":1458647625854,"shasum":"55c33fcfc338d82cc1b36e0f69e998d6f7420ddd"},{"_id":"public/archives/2016/page/3/index.html","modified":1458647625873,"shasum":"c84112afca8abbea65e4c8b09fa79530e6c0f6a9"},{"_id":"public/archives/2016/page/4/index.html","modified":1458647625904,"shasum":"938bf7ab8d052a8ac39673fae5ecbabec27d2aac"},{"_id":"public/archives/2016/page/5/index.html","modified":1458647625928,"shasum":"5adcd7663b6be65b379f7a4a0530acc0f5518ed9"},{"_id":"public/archives/2016/page/6/index.html","modified":1458647625952,"shasum":"7147b1e85020de9e3efad4a3dc52f8ebac7e1e18"},{"_id":"public/archives/2016/page/7/index.html","modified":1458647625981,"shasum":"47cc1aaf21f767b58ce96409105600a11ea4f1d7"},{"_id":"public/archives/2016/page/8/index.html","modified":1458647626004,"shasum":"d62e675d8298b786a9c2770cb7fa9d9f3ec1a90d"},{"_id":"public/archives/2016/page/9/index.html","modified":1458647626018,"shasum":"dc9baae602eda40db73e8936762c6174314915cd"},{"_id":"public/archives/2016/01/index.html","modified":1458647626051,"shasum":"619b57b5f5d70b0c7d3e355a937c3fd2fa71d82f"},{"_id":"public/archives/2016/01/page/2/index.html","modified":1458647626082,"shasum":"93c40daf5005c081fc2dc6a2d9cf64d60647c300"},{"_id":"public/archives/2016/01/page/3/index.html","modified":1458647626100,"shasum":"a46e7cc40749cab8681565abefe665ab0fb54746"},{"_id":"public/archives/2016/02/index.html","modified":1458647626123,"shasum":"52127030b3ef17bcdff4ff0c5225f4502b03a46e"},{"_id":"public/archives/2016/02/page/2/index.html","modified":1458647626148,"shasum":"f6bddfcc5986dd0fa50c7cc1c7a1b9567b98a9d6"},{"_id":"public/archives/2016/02/page/3/index.html","modified":1458647626166,"shasum":"1a58557da665598c11586ce64fe281ae618fa307"},{"_id":"public/archives/2016/03/index.html","modified":1458647626198,"shasum":"cc8a383175e423eb701bd16247a6e65d013dcd03"},{"_id":"public/archives/2016/03/page/2/index.html","modified":1458647626228,"shasum":"8ac737d30161e5a66671accbaad6e09879fde8ab"},{"_id":"public/archives/2016/03/page/3/index.html","modified":1458647626246,"shasum":"7c9ddea85ec61f2034b7af7ff5e028f71f164600"},{"_id":"public/archives/2016/03/page/4/index.html","modified":1458647626256,"shasum":"3e97658eed0400dca56fa919ebb0ca29151bc283"},{"_id":"public/categories/oi/index.html","modified":1458647626278,"shasum":"7f069c98a9ef6575ed1c4163b5faa778b1b6783c"},{"_id":"public/categories/oi/page/2/index.html","modified":1458647626301,"shasum":"45aa4fa3cfa16268d0650e45444d052c852a2d8b"},{"_id":"public/categories/oi/page/3/index.html","modified":1458647626320,"shasum":"4623e4034c5c0d48609819a712c7b894dc752846"},{"_id":"public/categories/oi/page/4/index.html","modified":1458647626361,"shasum":"d55ff1d80d9b1a34410f3f0a3fc44cc6fe724f59"},{"_id":"public/categories/oi/page/5/index.html","modified":1458647626392,"shasum":"0a2c8a66ed83017d50b0b9e9c1ec8d26213143b3"},{"_id":"public/categories/oi/page/6/index.html","modified":1458647626413,"shasum":"a13f6a8d4e049d45fc19b7ee629fbace6701611f"},{"_id":"public/categories/oi/page/7/index.html","modified":1458647626431,"shasum":"cfdabfd34ccd6ae816f9e60890fe2464de3e7ee5"},{"_id":"public/categories/oi/page/8/index.html","modified":1458647626453,"shasum":"820c40f01e62580beb194704a691ff06b7fcc2f9"},{"_id":"public/categories/oi/page/9/index.html","modified":1458647626466,"shasum":"19094c5e1b8e429eb1bb77ce05c12dea8e3b73bc"},{"_id":"public/categories/geek/index.html","modified":1458647626476,"shasum":"0fddc67f7720993fc8aa7762edd3dec23e26516d"},{"_id":"public/atom.xml","modified":1458647626484,"shasum":"b1a800ff438b20194639a8d431850d77f4dcb941"},{"_id":"public/index.html","modified":1458647626512,"shasum":"5a4d7b96f70aa6def8e0c165324961bd8e952aa9"},{"_id":"public/page/2/index.html","modified":1458647626532,"shasum":"ec620b1537175cffb433b071d97092f4eb4cd9e9"},{"_id":"public/page/3/index.html","modified":1458647626557,"shasum":"20f33fd38fd306af3d178015a7a2afcce3e43396"},{"_id":"public/page/4/index.html","modified":1458647626587,"shasum":"d720d930596e24ac993cdd579d05ea55bb4d03e1"},{"_id":"public/page/5/index.html","modified":1458647626618,"shasum":"d562096ce165a7176053e166b54c08294a1eeb37"},{"_id":"public/page/6/index.html","modified":1458647626644,"shasum":"b16a2d3460b720820f4a375cc3fb64eb29fc9c22"},{"_id":"public/page/7/index.html","modified":1458647626666,"shasum":"966b436050acb58807a619689df43fe51a6d8acc"},{"_id":"public/page/8/index.html","modified":1458647626696,"shasum":"cba8a6e117815e5f6d9bde497e1ea2762f6936bf"},{"_id":"public/page/9/index.html","modified":1458647626731,"shasum":"0a939f7e834eab40af404dee8bbe34a89906fbc5"},{"_id":"public/sitemap.xml","modified":1458647626733,"shasum":"d77674d375ab75ef25ab6d6ca54a45bdfc8e13c1"},{"_id":"public/tag/安师大附中集训/index.html","modified":1458647626748,"shasum":"1fc32adff7416ed8e59a34c7a70335dfce810cb6"},{"_id":"public/tag/树链剖分/index.html","modified":1458647626756,"shasum":"1931397e61504c9adc2af882f814c8ab53a8d2bf"},{"_id":"public/tag/线段树/index.html","modified":1458647626764,"shasum":"2cd3c3d9f45a90f70c721075473c88770b61c8b2"},{"_id":"public/tag/数据结构/index.html","modified":1458647626791,"shasum":"92ed6bb1af0578b0ba29b7b4dc5f2817b7d69351"},{"_id":"public/tag/数据结构/page/2/index.html","modified":1458647626803,"shasum":"776d2609427e88083b00255a98fb3a1a594b1b21"},{"_id":"public/tag/高级数据结构/index.html","modified":1458647626828,"shasum":"a83645cdde7febc0f35e0862f73db75f54b9f1c7"},{"_id":"public/tag/高级数据结构/page/2/index.html","modified":1458647626845,"shasum":"1382256977ba81ed5224c7aed5f5a92e47e48931"},{"_id":"public/tag/os-x/index.html","modified":1458647626856,"shasum":"a1d54b7877a0a63cd8be1c93d751c9bdd73a44d6"},{"_id":"public/tag/linux/index.html","modified":1458647626864,"shasum":"4cbbd93aa74aab125a56324ba51cefd6ff8e9889"},{"_id":"public/tag/archlinux/index.html","modified":1458647626871,"shasum":"9da7e5b7c2fe76e36ef3c969fc3c0105771f23bf"},{"_id":"public/tag/virtualbox/index.html","modified":1458647626876,"shasum":"58ae693872cf84958df64a047de9812f47f2bba1"},{"_id":"public/tag/虚拟机/index.html","modified":1458647626882,"shasum":"475c45cec3c8507d063773a3f347d06dba90b19d"},{"_id":"public/tag/ssh/index.html","modified":1458647626889,"shasum":"70e34a5d351fcbe0fa25cab4ab82f6dfa7b12d6c"},{"_id":"public/tag/uva/index.html","modified":1458647626917,"shasum":"a44159647d547394e035bf77edd354290b0bcadb"},{"_id":"public/tag/数学/index.html","modified":1458647626946,"shasum":"50fc67ad2d4de8a71c735b57dcf58c27dd086af7"},{"_id":"public/tag/数学/page/2/index.html","modified":1458647626955,"shasum":"30a2cb392ba3421a6fe066d267b8a2668881357a"},{"_id":"public/tag/dp/index.html","modified":1458647626978,"shasum":"57227b9496cfb3201995b2a9ef0bc9c7bce81fba"},{"_id":"public/tag/dp/page/2/index.html","modified":1458647626998,"shasum":"6a75fcc56ca5d0e37a5240f470bdb3ec33e95f13"},{"_id":"public/tag/区间dp/index.html","modified":1458647627009,"shasum":"43de5a91cbe9b6a37570751e27883cd7e1b11225"},{"_id":"public/tag/计数原理/index.html","modified":1458647627033,"shasum":"df40a602c07409fedafc4751b1a9c3624a32a85c"},{"_id":"public/tag/组合数学/index.html","modified":1458647627046,"shasum":"a240e0c8e84667377a48647a2d5139e280ce5ca1"},{"_id":"public/tag/容斥原理/index.html","modified":1458647627054,"shasum":"b8f613e2e98c5b248a66caa718a35e2c960f1e27"},{"_id":"public/tag/递推/index.html","modified":1458647627069,"shasum":"004833ae21fa97c8dd65715e057d8599a89c4f6e"},{"_id":"public/tag/高精度/index.html","modified":1458647627079,"shasum":"65c76f9697effdcafadf1baf97c0a6fe141188a9"},{"_id":"public/tag/数位dp/index.html","modified":1458647627086,"shasum":"46a1d2a89d56785b51cce32f3164649d227dc68c"},{"_id":"public/tag/数论/index.html","modified":1458647627098,"shasum":"2207e9583c0cd33e682f52c72b98c40ac9172fac"},{"_id":"public/tag/乘法逆元/index.html","modified":1458647627107,"shasum":"05a83f41f5052d28700fa6c97f4cb00a28fcc1a5"},{"_id":"public/tag/全排列/index.html","modified":1458647627114,"shasum":"3e156d793e911846f7e5e017acdc82a05cd4a1ee"},{"_id":"public/tag/背包dp/index.html","modified":1458647627128,"shasum":"e847a6105dbdd947c757d460e092f4b064521f60"},{"_id":"public/tag/组合数/index.html","modified":1458647627135,"shasum":"b7fd175d34d2ca2cc695783473ec8acbacc3a9ea"},{"_id":"public/tag/整数划分/index.html","modified":1458647627140,"shasum":"b27269278719c7a0fe1b9cccbee6fa801d97af42"},{"_id":"public/tag/回溯/index.html","modified":1458647627150,"shasum":"d86b0d57444563b3d158a7a6fc7ed053a374df53"},{"_id":"public/tag/codevs/index.html","modified":1458647627183,"shasum":"a5a3f13c05bf36c8da7fd907deb9207d5578ef4b"},{"_id":"public/tag/codevs/page/2/index.html","modified":1458647627204,"shasum":"47997d932249263008c30f87ca56b9900dae3f37"},{"_id":"public/tag/codevs/page/3/index.html","modified":1458647627216,"shasum":"e5a3a1fe619d891b958314cde6665c1ce0632336"},{"_id":"public/tag/tyvj/index.html","modified":1458647627234,"shasum":"30b65512cc5585a8e9f76af6ce7c078b464265fe"},{"_id":"public/tag/划分dp/index.html","modified":1458647627242,"shasum":"c3bd63fb3a0c6e2548b8b7e6d804cc4f2967f3c3"},{"_id":"public/tag/学习笔记/index.html","modified":1458647627264,"shasum":"1477cf4c2a5bd008896fef0b9e1eed61a82bd18b"},{"_id":"public/tag/学习笔记/page/2/index.html","modified":1458647627273,"shasum":"1b16d44b37a6b4233a49307ecf30d5e52022625e"},{"_id":"public/tag/图论/index.html","modified":1458647627294,"shasum":"b92eea08fecd75bce557c86709ff3ec0cead9e18"},{"_id":"public/tag/图论/page/2/index.html","modified":1458647627312,"shasum":"007f89065cc732c746f9e95def1c4e1b01ec7458"},{"_id":"public/tag/图论/page/3/index.html","modified":1458647627328,"shasum":"b47d046f45c7efa85c800c5add3fc19e6a3c84ad"},{"_id":"public/tag/强联通分量/index.html","modified":1458647627338,"shasum":"c55e7a2d47e1a738c16caf38b04218454251a267"},{"_id":"public/tag/tarjan/index.html","modified":1458647627349,"shasum":"e23817ce780c21523f318fca2bb213545d29748a"},{"_id":"public/tag/算法模板/index.html","modified":1458647627369,"shasum":"149f53eb229e3f3522c7f71b46528c90a8d72800"},{"_id":"public/tag/算法模板/page/2/index.html","modified":1458647627380,"shasum":"92724fa8b0bab77ce4978d725a79022785227b6a"},{"_id":"public/tag/差分约束系统/index.html","modified":1458647627387,"shasum":"ff5edf250ab6545b4b2fa0cdce587518b60cdc63"},{"_id":"public/tag/最短路/index.html","modified":1458647627393,"shasum":"602a17beb781c0e436f7ac8e6748d55324a750fc"},{"_id":"public/tag/c/index.html","modified":1458647627404,"shasum":"cf99c6facd44d9b428ae54d6fb3acdd53c3a832f"},{"_id":"public/tag/stl/index.html","modified":1458647627412,"shasum":"402d93911670157353b1464fc62141056a7843fb"},{"_id":"public/tag/splay/index.html","modified":1458647627431,"shasum":"36bc95892b4ad9caa5ab94f25dee8eed275363fe"},{"_id":"public/tag/bzoj/index.html","modified":1458647627449,"shasum":"edb4a1116e81238fb6cfe2a4e86b01013bcdf856"},{"_id":"public/tag/bzoj/page/2/index.html","modified":1458647627467,"shasum":"3e11f14ce153276928c147393f4e61b0da8b4521"},{"_id":"public/tag/bzoj/page/3/index.html","modified":1458647627485,"shasum":"aa8c932a1f66637bcd23f0761264aaa85bb43a6b"},{"_id":"public/tag/sdoi/index.html","modified":1458647627495,"shasum":"8fbd9bb58143c6343fc80aa201177cd9bc462fb0"},{"_id":"public/tag/dinic/index.html","modified":1458647627513,"shasum":"5688d7e66aa7359b410a65c4da27d522941e0b36"},{"_id":"public/tag/dinic/page/2/index.html","modified":1458647627529,"shasum":"f5666a6521734b3d54a939d04f8eaedd1e101f2b"},{"_id":"public/tag/网络流/index.html","modified":1458647627548,"shasum":"abeb34f0fdb7debc9d6bdbc56bf002f6e4c2cbfe"},{"_id":"public/tag/网络流/page/2/index.html","modified":1458647627571,"shasum":"203c6155dfdc75f13c17cb41c7821285b7b8fe15"},{"_id":"public/tag/网络流/page/3/index.html","modified":1458647627576,"shasum":"1c5a94e1fc231fc664781068b36ca6ffcaa3fde4"},{"_id":"public/tag/二分答案/index.html","modified":1458647627590,"shasum":"a0fa89010e5033026e545e7134c6142a50bf3855"},{"_id":"public/tag/实数二分/index.html","modified":1458647627597,"shasum":"18af542b12f180b90145cb34cea34dc0bcc39960"},{"_id":"public/tag/edmonds-karp/index.html","modified":1458647627617,"shasum":"0f541f30b640dfcf6dbfb1cf3411a3da97880720"},{"_id":"public/tag/费用流/index.html","modified":1458647627631,"shasum":"b1469bdeba26d572adae4311f0e2cb40331695a5"},{"_id":"public/tag/动态树/index.html","modified":1458647627640,"shasum":"4aed9b064803bc828a4d3a2cebecf687d5ec0149"},{"_id":"public/tag/link-cut-tree/index.html","modified":1458647627649,"shasum":"c1c47684d0804fcbe8b16ece137a503434547f83"},{"_id":"public/tag/scoi/index.html","modified":1458647627666,"shasum":"99701fc571b8bbf99fb1e90dc456ed428b4f2979"},{"_id":"public/tag/离线/index.html","modified":1458647627670,"shasum":"d8cdb58faef7cf8a958f58eab33074d21f224b6a"},{"_id":"public/tag/二分图匹配/index.html","modified":1458647627686,"shasum":"f8ee1aea953e9aedfe69e48316de584d1906ac40"},{"_id":"public/tag/贪心/index.html","modified":1458647627696,"shasum":"2fd387d1cb087b73b4b062c263739d980100b80e"},{"_id":"public/tag/倍增/index.html","modified":1458647627708,"shasum":"461509180b8a6205af6a26b944daf82bc3b06f1b"},{"_id":"public/tag/缩点/index.html","modified":1458647627727,"shasum":"d5c417ac62d95e2591ee06540f2ad03cc2cc7464"},{"_id":"public/tag/拓扑排序/index.html","modified":1458647627735,"shasum":"7635fa0459a1a3435d63bddb530079aa9520479e"},{"_id":"public/tag/匈牙利算法/index.html","modified":1458647627740,"shasum":"c741693b5b892e5f627990b7ac623784ac0c035d"},{"_id":"public/tag/枚举答案/index.html","modified":1458647627749,"shasum":"bb9bd40f3970de6faef512be4f1ce1c7e24cf56d"},{"_id":"public/tag/poj/index.html","modified":1458647627762,"shasum":"db9963da54b0de7ca26abd1ccbb0fac4127308ad"},{"_id":"public/tag/prim/index.html","modified":1458647627769,"shasum":"4eab4e4df5515a667bc970e694f7525c7f642ce8"},{"_id":"public/tag/生成树/index.html","modified":1458647627775,"shasum":"a950bb0dfefcd35fcfd6b407b122ec1dc7361f66"},{"_id":"public/tag/分数规划/index.html","modified":1458647627781,"shasum":"6bd5d5e75fd48a7563389389f3da03775ecb4b7e"},{"_id":"public/tag/软件/index.html","modified":1458647627792,"shasum":"e9ac2c0df6c59e624ef494b43a5b23f51231099d"},{"_id":"public/tag/hidpi/index.html","modified":1458647627797,"shasum":"8121c3681bfe547f9fbf609de9d0f8a7aeb92a63"},{"_id":"public/tag/noip/index.html","modified":1458647627813,"shasum":"72ee6b5bd7284a4c49b87cc5f269d97c1cce57f4"},{"_id":"public/tag/exgcd/index.html","modified":1458647627820,"shasum":"bdf711369c7632e8d20c4a0f4d32e4014972c551"},{"_id":"public/tag/vijos/index.html","modified":1458647627828,"shasum":"c1a00af5d4a46c2175221c467894a75d5faa31ed"},{"_id":"public/tag/洛谷/index.html","modified":1458647627838,"shasum":"7d017b75a52a762182781406858ee55f1e3319bb"},{"_id":"public/tag/二分图染色/index.html","modified":1458647627846,"shasum":"0d55064b954711e8a239bcb2b0b3cc9f129f9fe2"},{"_id":"public/tag/树形dp/index.html","modified":1458647627854,"shasum":"c09b1568289540affe122ca7386c8c777c213198"},{"_id":"public/tag/noi/index.html","modified":1458647627875,"shasum":"2ea3b51814b7f64cb96731041d7f6861da207a9a"},{"_id":"public/tag/离散化/index.html","modified":1458647627883,"shasum":"97f12da62737e5f84b7bc7af2e0d9375ea72468b"},{"_id":"public/tag/并查集/index.html","modified":1458647627897,"shasum":"df87dbc23092459aeac12d1bf2bdd6fd420e1873"},{"_id":"public/tag/哈希/index.html","modified":1458647627907,"shasum":"b74288cbff1b227ecc578c7ab9d1ff84c0bde4ee"},{"_id":"public/tag/map/index.html","modified":1458647627916,"shasum":"ea34acf121fbb83ad622f78584fb0d3943f4aaf6"},{"_id":"public/tag/最小割/index.html","modified":1458647627923,"shasum":"7cc24e0647516280ae4b579620670e04ee5189fb"},{"_id":"public/tag/最大权闭合子图/index.html","modified":1458647627930,"shasum":"39b8ad104a01270bc30f060e9d2972934fc6a1f7"},{"_id":"public/tag/单调队列/index.html","modified":1458647627955,"shasum":"8ae45454a58e68ddaddb754b9d54a17c69334c7b"},{"_id":"public/tag/kruskal/index.html","modified":1458647627965,"shasum":"2915ac6f9dda9750582964d436a8be84f5aadf95"},{"_id":"public/tag/最小生成树/index.html","modified":1458647627973,"shasum":"b9b3fe03500f441e282035a9b211420d8237ae6b"},{"_id":"public/tag/markdown/index.html","modified":1458647627980,"shasum":"7c9a55681293a15a9d3fed42d8bafa165fca952b"},{"_id":"public/tag/latex/index.html","modified":1458647627988,"shasum":"a6461338d77d736343331897dd2a32ce40a6fcfc"},{"_id":"public/tag/github/index.html","modified":1458647627998,"shasum":"6806098c29c26b939c89a92b337c9137283f7f84"},{"_id":"public/tag/kmp/index.html","modified":1458647628006,"shasum":"bff4efc3978da631ed9d0386210d10797346605a"},{"_id":"public/tag/字符串/index.html","modified":1458647628018,"shasum":"15f53780022e996cca7b1f4bf841dc2a1c321f1d"},{"_id":"public/tag/jsoi/index.html","modified":1458647628025,"shasum":"f3eb9a136fc0a696a6ddda0deadef227dd4b571f"},{"_id":"public/tag/hnoi/index.html","modified":1458647628031,"shasum":"5eadef3040209242f28addcbd4aa681131ba0239"},{"_id":"public/tag/set/index.html","modified":1458647628039,"shasum":"c3bb525ebfc67e7adc27d28a80857adddcc5024d"},{"_id":"public/tag/haoi/index.html","modified":1458647628047,"shasum":"51cc73d0c8b4b1be914d7bd8d36457ee13738af1"},{"_id":"public/tag/gdb/index.html","modified":1458647628053,"shasum":"3c54341df597cc21a22d9cd8fa875971af4c7d8a"},{"_id":"public/tag/调试/index.html","modified":1458647628067,"shasum":"a2506cb66ad4f0324d80236f95a93c5eeed5b08e"},{"_id":"public/tag/cogs/index.html","modified":1458647628095,"shasum":"86dfb2efc87bc4846bfbb4ae762ac8a9b636f34b"},{"_id":"public/tag/cogs/page/2/index.html","modified":1458647628106,"shasum":"e91181b788ce38ccd32659f225bdf6991e451813"},{"_id":"public/tag/ctsc/index.html","modified":1458647628120,"shasum":"9834a82977c9c0ccee218b84e0389c2cdf2b0a3d"},{"_id":"public/tag/网络流24题/index.html","modified":1458647628145,"shasum":"fceb7ddbf40c706acb2784f9c9981ce62ec85cd3"},{"_id":"public/tag/网络流24题/page/2/index.html","modified":1458647628156,"shasum":"27714d08fb2c80d82f883d3633e3cecc3cb01569"},{"_id":"public/tag/最大独立集/index.html","modified":1458647628165,"shasum":"366671f6bbf6051db3479344b99ab68284d07a19"},{"_id":"public/tag/最大权闭合图/index.html","modified":1458647628173,"shasum":"fd2aab64628c29a34335cfe21fc24048c920d025"},{"_id":"public/tag/搜索/index.html","modified":1458647628182,"shasum":"6bce0077b76dfa9833e37b9da6844a33c57bc136"},{"_id":"public/tag/记忆化搜索/index.html","modified":1458647628194,"shasum":"27106a2d59474970ea10f2cab83e198a70f58a73"},{"_id":"public/tag/位运算/index.html","modified":1458647628199,"shasum":"f8549ce67a1bdccbd4cd93bbecdad99c861e37a7"},{"_id":"public/tag/线性dp/index.html","modified":1458647628206,"shasum":"14f80ff5811d8e3e3611f976f39f781eed327bf5"},{"_id":"public/tag/cdq/index.html","modified":1458647628212,"shasum":"35ceaea98d67822ca46844500e99f1c7bc141281"},{"_id":"public/tag/树状数组/index.html","modified":1458647628221,"shasum":"bd03fea3b08c320fad25860b74ac4e85a0a4d3d5"},{"_id":"public/tag/dijkstra/index.html","modified":1458647628230,"shasum":"313d7eabe7dcbe706dbd89fd97a7e9ac8e80c06d"},{"_id":"public/tag/apio/index.html","modified":1458647628239,"shasum":"a49c155dd71fec8240cff57874d21491e8b26472"},{"_id":"public/tag/dag/index.html","modified":1458647628245,"shasum":"7d5df0057e7ad89f30a78b4ce841d434a72bdbb8"},{"_id":"public/tag/最长路/index.html","modified":1458647628251,"shasum":"e1731f9730f02322fa12e5d2ecdf384f839af670"},{"_id":"public/tag/bellman-ford/index.html","modified":1458647628257,"shasum":"9897f93eb3ed6e50bc8ebe5764e585a9dfda1776"},{"_id":"public/tag/ahoi/index.html","modified":1458647628270,"shasum":"5ec56ba4dab84da4a111fee80c26a231dd36abef"},{"_id":"public/tag/lca/index.html","modified":1458647628275,"shasum":"123d75b7e4550e424a6d0663bad05bb35b014384"},{"_id":"public/tag/乱搞/index.html","modified":1458647628281,"shasum":"2a4efaf615d1fa468cdb7f80f442d4ae817449ee"},{"_id":"public/tag/矩阵乘法/index.html","modified":1458647628291,"shasum":"6626714a55834a896c7d0e0072e2ad307eb40222"},{"_id":"public/tag/快速幂/index.html","modified":1458647628299,"shasum":"1f21ac297458418075875744f16c8d9e854dd319"},{"_id":"public/tag/扫描线/index.html","modified":1458647628305,"shasum":"3f3f7dd96457d75b8945d0ed26e80bf47a1982de"},{"_id":"public/tag/链表/index.html","modified":1458647628310,"shasum":"046bed090dbc7ed6f44f973772e17d3dd0313f2a"}],"Category":[{"name":"OI","_id":"cim3d4mx70001ofdkfy3px9kl"},{"name":"Geek","_id":"cim3d4myh000gofdk5um61roz"}],"Data":[],"Page":[{"title":"Friends","date":"2016-01-18T13:08:05.000Z","_content":"\n<style>\n#oier {\n\tline-height: 1em;\n}\n\n#oier tr:nth-child(2n) {\n\tbackground: none !important;\n}\n\n#oier tr:nth-child(2n) td:not([rowspan]) {\n\tbackground: rgba(158,188,226,0.12);\t\n}\n\n#oier td {\n\ttext-align: center;\n\tvertical-align: middle;\n}\n\n#oier a, #oier span {\n\tdisplay: block;\n}\n\n#oier tr:hover {\n\tbackground: inherit;\n}\n\n#oier tbody tr:not(:nth-child(2n)):hover td:not([rowspan]) {\n\tbackground: #efefef;\n}\n</style>\n\n<table width=\"100%\" id=\"oier\">\n<thead>\n<tr class=\"header\">\n<th><span>From</span></th>\n<th><span>Link</span></th>\n<th><span>School</span></th>\n</tr>\n</thead>\n\n<tbody>\n<tr>\n<td rowspan=\"7\"><span>QQ群「SDOI 2016」</span></td>\n<td>[Ofsxb](http://www.cnblogs.com/ofsxb/)</td>\n<td><span>齐河一中</span></td>\n</tr>\n\n<tr>\n<td>[Creation <span style=\"color: #FFA200; display: inline; \"><b>Au</b></span>gust](http://blog.csdn.net/creationaugust)</td>\n<td><span>胜利十中</span></td>\n</tr>\n\n<tr>\n<td>[yts1999](http://yts1999.coding.io/)</td>\n<td><span>青岛二中</span></td>\n</tr>\n\n<tr>\n<td>[Travis](http://travisbraps.top/)</td>\n<td><span>烟台一中</span></td>\n</tr>\n\n<tr>\n<td>[Erii](http://erii.moe)</td>\n<td><span>烟台一中</span></td>\n</tr>\n\n<tr>\n<td>[ws_fqk](http://blog.csdn.net/phenix_2015)</td>\n<td><span>昌邑一中</span></td>\n</tr>\n\n<tr>\n<td>[ws_yzy](http://blog.csdn.net/ws_yzy)</td>\n<td><span>昌邑一中</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"2\"><span>QQ群「CodeVS交流群」</span></td>\n<td>[Dashgua](http://dashgua.coding.io/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[MedalPluS](http://medalplus.com/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"3\"><span>QQ群「在路上，同梦行」</span></td>\n<td>[FireStorm](http://blog.csdn.net/farestorm)</td>\n<td><span>莱芜一中</span></td>\n</tr>\n\n<tr>\n<td>[Loi_DQS](http://blog.csdn.net/loi_dqs)</td>\n<td><span>莱芜一中</span></td>\n</tr>\n\n<tr>\n<td>[danihao123](http://danihao123.is-programmer.com/)</td>\n<td><span>烟台二中</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"1\"><span>QQ群「COGS交流群」</span></td>\n<td>[Rapiz](http://www.cnblogs.com/rapiz/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"3\"><span>2016安徽师大附中集训</span></td>\n<td>[Fancy](http://fancypei.github.io/)</td>\n<td><span>郑州外国语学校</span></td>\n</tr>\n\n<tr>\n<td>[CXCXCXC](http://www.cnblogs.com/CXCXCXC)</td>\n<td><span>郑州外国语学校</span></td>\n</tr>\n\n<tr>\n<td>[sui](http://1115825064.github.io/)</td>\n<td><span>郑州外国语学校</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"3\"><span>其它</span></td>\n<td>[zean](http://blog.zean.xyz/)</td>\n<td><span>烟台二中</span></td>\n</tr>\n\n<tr>\n<td>[lkMiles](http://lkmiles.lofter.com/)</td>\n<td><span>成都七中</span></td>\n</tr>\n\n<tr>\n<td>[FeLJ](http://www.felj.top/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"4\"><span>本校</span></td>\n<td>[Angelic47](http://www.angelic47.com/)</td>\n<td><span>临沂一中</span></td>\n</tr>\n\n<tr>\n<td>[ZMOIYNLP](http://blog.csdn.net/zmoiynlp/)</td>\n<td><span>临沂一中</span></td>\n</tr>\n\n<tr>\n<td>[Hellc](http://5261.github.io/)</td>\n<td><span>临沂一中</span></td>\n</tr>\n\n<tr>\n<td>[凌风仙鸡](http://chickger.pw/)</td>\n<td><span>临沂一中</span></td>\n</tr>\n</tbody>\n\n</table>\n\n# 其它\n\n[盒子の自留地](http://www.18tilab.com/)\n\n[Arondight](http://arondight.me/)\n","source":"friends.md","raw":"title: Friends\npermalink: friends/\ndate: 2016-01-18 21:08:05\n---\n\n<style>\n#oier {\n\tline-height: 1em;\n}\n\n#oier tr:nth-child(2n) {\n\tbackground: none !important;\n}\n\n#oier tr:nth-child(2n) td:not([rowspan]) {\n\tbackground: rgba(158,188,226,0.12);\t\n}\n\n#oier td {\n\ttext-align: center;\n\tvertical-align: middle;\n}\n\n#oier a, #oier span {\n\tdisplay: block;\n}\n\n#oier tr:hover {\n\tbackground: inherit;\n}\n\n#oier tbody tr:not(:nth-child(2n)):hover td:not([rowspan]) {\n\tbackground: #efefef;\n}\n</style>\n\n<table width=\"100%\" id=\"oier\">\n<thead>\n<tr class=\"header\">\n<th><span>From</span></th>\n<th><span>Link</span></th>\n<th><span>School</span></th>\n</tr>\n</thead>\n\n<tbody>\n<tr>\n<td rowspan=\"7\"><span>QQ群「SDOI 2016」</span></td>\n<td>[Ofsxb](http://www.cnblogs.com/ofsxb/)</td>\n<td><span>齐河一中</span></td>\n</tr>\n\n<tr>\n<td>[Creation <span style=\"color: #FFA200; display: inline; \"><b>Au</b></span>gust](http://blog.csdn.net/creationaugust)</td>\n<td><span>胜利十中</span></td>\n</tr>\n\n<tr>\n<td>[yts1999](http://yts1999.coding.io/)</td>\n<td><span>青岛二中</span></td>\n</tr>\n\n<tr>\n<td>[Travis](http://travisbraps.top/)</td>\n<td><span>烟台一中</span></td>\n</tr>\n\n<tr>\n<td>[Erii](http://erii.moe)</td>\n<td><span>烟台一中</span></td>\n</tr>\n\n<tr>\n<td>[ws_fqk](http://blog.csdn.net/phenix_2015)</td>\n<td><span>昌邑一中</span></td>\n</tr>\n\n<tr>\n<td>[ws_yzy](http://blog.csdn.net/ws_yzy)</td>\n<td><span>昌邑一中</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"2\"><span>QQ群「CodeVS交流群」</span></td>\n<td>[Dashgua](http://dashgua.coding.io/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[MedalPluS](http://medalplus.com/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"3\"><span>QQ群「在路上，同梦行」</span></td>\n<td>[FireStorm](http://blog.csdn.net/farestorm)</td>\n<td><span>莱芜一中</span></td>\n</tr>\n\n<tr>\n<td>[Loi_DQS](http://blog.csdn.net/loi_dqs)</td>\n<td><span>莱芜一中</span></td>\n</tr>\n\n<tr>\n<td>[danihao123](http://danihao123.is-programmer.com/)</td>\n<td><span>烟台二中</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"1\"><span>QQ群「COGS交流群」</span></td>\n<td>[Rapiz](http://www.cnblogs.com/rapiz/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"3\"><span>2016安徽师大附中集训</span></td>\n<td>[Fancy](http://fancypei.github.io/)</td>\n<td><span>郑州外国语学校</span></td>\n</tr>\n\n<tr>\n<td>[CXCXCXC](http://www.cnblogs.com/CXCXCXC)</td>\n<td><span>郑州外国语学校</span></td>\n</tr>\n\n<tr>\n<td>[sui](http://1115825064.github.io/)</td>\n<td><span>郑州外国语学校</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"3\"><span>其它</span></td>\n<td>[zean](http://blog.zean.xyz/)</td>\n<td><span>烟台二中</span></td>\n</tr>\n\n<tr>\n<td>[lkMiles](http://lkmiles.lofter.com/)</td>\n<td><span>成都七中</span></td>\n</tr>\n\n<tr>\n<td>[FeLJ](http://www.felj.top/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td rowspan=\"4\"><span>本校</span></td>\n<td>[Angelic47](http://www.angelic47.com/)</td>\n<td><span>临沂一中</span></td>\n</tr>\n\n<tr>\n<td>[ZMOIYNLP](http://blog.csdn.net/zmoiynlp/)</td>\n<td><span>临沂一中</span></td>\n</tr>\n\n<tr>\n<td>[Hellc](http://5261.github.io/)</td>\n<td><span>临沂一中</span></td>\n</tr>\n\n<tr>\n<td>[凌风仙鸡](http://chickger.pw/)</td>\n<td><span>临沂一中</span></td>\n</tr>\n</tbody>\n\n</table>\n\n# 其它\n\n[盒子の自留地](http://www.18tilab.com/)\n\n[Arondight](http://arondight.me/)\n","updated":"2016-03-18T10:54:27.000Z","path":"friends/index.html","comments":1,"layout":"page","_id":"cim3d4my6000dofdkg7ewq0ty"},{"title":"About Me","date":"2015-11-22T21:36:32.000Z","_content":"\n一只学 OI 的~~可爱的~~男孩子，~~大家可以叫我黄学弟~~。\n\n来自山东省临沂一中，目前高一，从 2015 年 8 月开始学 OI，正在为省选而努力。\n\n<!-- 想要拿 NOI 金牌。 -->\n\n> 用这灿烂时光，绽放不一样的光。\n","source":"about-me.md","raw":"title: About Me\npermalink: about-me/\ndate: 2015-11-23 05:36:32\n---\n\n一只学 OI 的~~可爱的~~男孩子，~~大家可以叫我黄学弟~~。\n\n来自山东省临沂一中，目前高一，从 2015 年 8 月开始学 OI，正在为省选而努力。\n\n<!-- 想要拿 NOI 金牌。 -->\n\n> 用这灿烂时光，绽放不一样的光。\n","updated":"2016-03-21T14:46:29.000Z","path":"about-me/index.html","comments":1,"layout":"page","_id":"cim3d4mya000eofdk6xjfm1c7"}],"Post":[{"title":"「省选模拟赛」染色 - 树链剖分","date":"2016-03-20T15:07:32.000Z","_content":"\n给定一棵 $ n $ 个节点的树，树的节点标号从 $ 0 $ 开始。每个节点可以是白色或黑色，初始时每个节点的颜色为白色。要求支持以下两种操作：\n\n1. 将节点 $ x $ 涂黑；\n2. 查询节点 $ x $ 到所有黑点距离之和。\n\n<!-- more -->\n\n### 解题思路\n先预处理出所有点到根的距离之和，维护当前所有黑点到根的距离之和 $ sum $ 和黑点总数 $ count $。\n\n考虑询问由根节点的向它的某个子节点 u 移动，则答案为：\n\n$$ sum + (count - count(u)) * d_i - count(u) * d_i $$\n\n即\n\n$$ sum + count * d_i - 2 * count(u) * d_i $$\n\n树链剖分，用线段树维护 $ count(u) * d_i $ 在链上的总和，每次 $ O(log ^ 2 n) $ 计算。\n\n### AC代码\n```c++\n#include <cstdio>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100000; \nconst int MAXM = 100000; \n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lchild, *rchild;\n\n\tint blackCount;\n\tint count, lazyCount, base;\n\tlong long sum;\n\n\tSegmentTree(int l, int r, SegmentTree *lchild, SegmentTree *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), blackCount(0), count(0), lazyCount(0), base(0), sum(0) {}\n\n\t~SegmentTree() {\n\t\tif (lchild) delete lchild;\n\t\tif (rchild) delete rchild;\n\t}\n\n\tvoid pushDown() {\n\t\tif (lazyCount) {\n\t\t\tif (lchild) lchild->lazyCount += lazyCount, lchild->count += lazyCount, lchild->sum += (long long)lchild->base * lazyCount;\n\t\t\tif (rchild) rchild->lazyCount += lazyCount, rchild->count += lazyCount, rchild->sum += (long long)rchild->base * lazyCount;\n\t\t\tlazyCount = 0;\n\t\t}\n\t}\n\n\tlong long querySum(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlong long result = 0;\n\t\t\tif (lchild) result += lchild->querySum(l, r);\n\t\t\tif (rchild) result += rchild->querySum(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint queryCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return count;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryCount(l, r);\n\t\t\tif (rchild) result += rchild->queryCount(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateCount(int l, int r, int delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) lazyCount += delta, count += delta, sum += (long long)delta * base;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tsum = count = 0;\n\t\t\tif (lchild) lchild->updateCount(l, r, delta), count += lchild->count, sum += lchild->sum;\n\t\t\tif (rchild) rchild->updateCount(l, r, delta), count += rchild->count, sum += rchild->sum;\n\t\t}\n\t}\n\n\tvoid setBase(int x, int base) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) this->base = base;\n\t\telse {\n\t\t\tif (lchild) lchild->setBase(x, base);\n\t\t\tif (rchild) rchild->setBase(x, base);\n\t\t\tthis->base = lchild->base + rchild->base;\n\t\t}\n\t}\n\n\tint queryBlackCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return blackCount;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryBlackCount(l, r);\n\t\t\tif (rchild) result += rchild->queryBlackCount(l, r);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateBlackCount(int x, int delta) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) blackCount += delta;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tblackCount = 0;\n\t\t\tif (lchild) lchild->updateBlackCount(x, delta), blackCount += lchild->blackCount;\n\t\t\tif (rchild) rchild->updateBlackCount(x, delta), blackCount += rchild->blackCount;\n\t\t}\n\t}\n};\n\nSegmentTree *buildSegmentTree(int l, int r) {\n\tif (l > r) return NULL;\n\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\telse return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) >> 1)), buildSegmentTree(l + ((r - l) >> 1) + 1, r));\n}\n\nstruct Tree;\nstruct Path;\n\nstruct Tree {\n\tTree *firstChild, *next, *parent, *maxSizeChild;\n\tbool visited, colored;\n\tPath *path;\n\tint size, depth, pos, posEnd;\n\tlong long cost, costPrefixSum;\n} trees[MAXN];\n\nstruct Path {\n\tTree *top;\n\tint length;\n\tPath(Tree *top) : top(top), length(1) {}\n};\n\ninline void addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n}\n\nint n, m, blackCount;\nlong long sum;\nSegmentTree *segment;\n\ninline void cut() {\n\tstd::stack<Tree *> s;\n\ts.push(&trees[0]);\n\ttrees[0].depth = 1;\n\ttrees[0].costPrefixSum = 0;\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tc->depth = t->depth + 1;\n\t\t\t\tc->costPrefixSum = t->costPrefixSum + c->cost;\n\t\t\t\ts.push(c);\n\t\t\t}\n\t\t} else {\n\t\t\tt->size = 1;\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) t->maxSizeChild = c;\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\ts.push(&trees[0]);\n\n\tint timeStamp = 0;\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tif (t->parent == NULL || t->parent->maxSizeChild != t) t->path = new Path(t);\n\t\t\telse t->path = t->parent->path, t->path->length++;\n\n\t\t\tt->pos = ++timeStamp;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\t\t} else {\n\t\t\tt->posEnd = timeStamp;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = buildSegmentTree(1, n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsegment->setBase(trees[i].pos, trees[i].cost);\n\t}\n}\n\ninline int queryDist(int u, int v) {\n\tif (u == v) return 0;\n\n\tTree *a = &trees[u], *b = &trees[v];\n\tint sum = 0;\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) std::swap(a, b);\n\t\tsum += segment->querySum(a->path->top->pos, a->pos);\n\t\t// printf(\"query(%d, %d)::sum = %d\\n\", u, v, sum);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) std::swap(a, b);\n\tsum += segment->querySum(a->pos, b->pos);\n\tsum -= a->cost;\n\n\treturn sum;\n}\n\ninline void updateToBlack(int u) {\n\tif (trees[u].colored) return;\n\ttrees[u].colored = true;\n\tsum += trees[u].costPrefixSum;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) {\n\t\tsegment->updateCount(t->path->top->pos, t->pos, 1);\n\t}\n\tsegment->updateBlackCount(trees[u].pos, 1);\n\tblackCount++;\n}\n\ninline long long queryAllDist(int u) {\n\tTree *t = &trees[u];\n\tint childBlackCount = segment->queryBlackCount(t->pos, t->posEnd);\n\tlong long tmp = 0;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) tmp += segment->querySum(t->path->top->pos, t->pos);\n\treturn sum + t->costPrefixSum * blackCount - 2 * tmp;\n}\n\nint main() {\n\t// freopen(\"color.in\", \"r\", stdin);\n\t// freopen(\"color.out\", \"w\", stdout);\n\t\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint parent;\n\t\tscanf(\"%d\", &parent);\n\n\t\taddRelation(i, parent);\n\t}\n\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%lld\", &trees[i].cost);\n\t}\n\n\tcut();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint t, u;\n\t\tscanf(\"%d %d\", &t, &u);\n\n\t\tif (t == 1) updateToBlack(u);\n\t\telse printf(\"%lld\\n\", queryAllDist(u));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n\n","source":"_posts/20160318-color.md","raw":"title: 「省选模拟赛」染色 - 树链剖分\ncategories: OI\ntags: \n  - 安师大附中集训\n  - 树链剖分\n  - 线段树\n  - 数据结构\n  - 高级数据结构\npermalink: 20160318-color\ndate: 2016-03-20 23:07:32\n---\n\n给定一棵 $ n $ 个节点的树，树的节点标号从 $ 0 $ 开始。每个节点可以是白色或黑色，初始时每个节点的颜色为白色。要求支持以下两种操作：\n\n1. 将节点 $ x $ 涂黑；\n2. 查询节点 $ x $ 到所有黑点距离之和。\n\n<!-- more -->\n\n### 解题思路\n先预处理出所有点到根的距离之和，维护当前所有黑点到根的距离之和 $ sum $ 和黑点总数 $ count $。\n\n考虑询问由根节点的向它的某个子节点 u 移动，则答案为：\n\n$$ sum + (count - count(u)) * d_i - count(u) * d_i $$\n\n即\n\n$$ sum + count * d_i - 2 * count(u) * d_i $$\n\n树链剖分，用线段树维护 $ count(u) * d_i $ 在链上的总和，每次 $ O(log ^ 2 n) $ 计算。\n\n### AC代码\n```c++\n#include <cstdio>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100000; \nconst int MAXM = 100000; \n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lchild, *rchild;\n\n\tint blackCount;\n\tint count, lazyCount, base;\n\tlong long sum;\n\n\tSegmentTree(int l, int r, SegmentTree *lchild, SegmentTree *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), blackCount(0), count(0), lazyCount(0), base(0), sum(0) {}\n\n\t~SegmentTree() {\n\t\tif (lchild) delete lchild;\n\t\tif (rchild) delete rchild;\n\t}\n\n\tvoid pushDown() {\n\t\tif (lazyCount) {\n\t\t\tif (lchild) lchild->lazyCount += lazyCount, lchild->count += lazyCount, lchild->sum += (long long)lchild->base * lazyCount;\n\t\t\tif (rchild) rchild->lazyCount += lazyCount, rchild->count += lazyCount, rchild->sum += (long long)rchild->base * lazyCount;\n\t\t\tlazyCount = 0;\n\t\t}\n\t}\n\n\tlong long querySum(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlong long result = 0;\n\t\t\tif (lchild) result += lchild->querySum(l, r);\n\t\t\tif (rchild) result += rchild->querySum(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint queryCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return count;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryCount(l, r);\n\t\t\tif (rchild) result += rchild->queryCount(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateCount(int l, int r, int delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) lazyCount += delta, count += delta, sum += (long long)delta * base;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tsum = count = 0;\n\t\t\tif (lchild) lchild->updateCount(l, r, delta), count += lchild->count, sum += lchild->sum;\n\t\t\tif (rchild) rchild->updateCount(l, r, delta), count += rchild->count, sum += rchild->sum;\n\t\t}\n\t}\n\n\tvoid setBase(int x, int base) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) this->base = base;\n\t\telse {\n\t\t\tif (lchild) lchild->setBase(x, base);\n\t\t\tif (rchild) rchild->setBase(x, base);\n\t\t\tthis->base = lchild->base + rchild->base;\n\t\t}\n\t}\n\n\tint queryBlackCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return blackCount;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryBlackCount(l, r);\n\t\t\tif (rchild) result += rchild->queryBlackCount(l, r);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateBlackCount(int x, int delta) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) blackCount += delta;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tblackCount = 0;\n\t\t\tif (lchild) lchild->updateBlackCount(x, delta), blackCount += lchild->blackCount;\n\t\t\tif (rchild) rchild->updateBlackCount(x, delta), blackCount += rchild->blackCount;\n\t\t}\n\t}\n};\n\nSegmentTree *buildSegmentTree(int l, int r) {\n\tif (l > r) return NULL;\n\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\telse return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) >> 1)), buildSegmentTree(l + ((r - l) >> 1) + 1, r));\n}\n\nstruct Tree;\nstruct Path;\n\nstruct Tree {\n\tTree *firstChild, *next, *parent, *maxSizeChild;\n\tbool visited, colored;\n\tPath *path;\n\tint size, depth, pos, posEnd;\n\tlong long cost, costPrefixSum;\n} trees[MAXN];\n\nstruct Path {\n\tTree *top;\n\tint length;\n\tPath(Tree *top) : top(top), length(1) {}\n};\n\ninline void addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n}\n\nint n, m, blackCount;\nlong long sum;\nSegmentTree *segment;\n\ninline void cut() {\n\tstd::stack<Tree *> s;\n\ts.push(&trees[0]);\n\ttrees[0].depth = 1;\n\ttrees[0].costPrefixSum = 0;\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tc->depth = t->depth + 1;\n\t\t\t\tc->costPrefixSum = t->costPrefixSum + c->cost;\n\t\t\t\ts.push(c);\n\t\t\t}\n\t\t} else {\n\t\t\tt->size = 1;\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) t->maxSizeChild = c;\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\ts.push(&trees[0]);\n\n\tint timeStamp = 0;\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tif (t->parent == NULL || t->parent->maxSizeChild != t) t->path = new Path(t);\n\t\t\telse t->path = t->parent->path, t->path->length++;\n\n\t\t\tt->pos = ++timeStamp;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\t\t} else {\n\t\t\tt->posEnd = timeStamp;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = buildSegmentTree(1, n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsegment->setBase(trees[i].pos, trees[i].cost);\n\t}\n}\n\ninline int queryDist(int u, int v) {\n\tif (u == v) return 0;\n\n\tTree *a = &trees[u], *b = &trees[v];\n\tint sum = 0;\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) std::swap(a, b);\n\t\tsum += segment->querySum(a->path->top->pos, a->pos);\n\t\t// printf(\"query(%d, %d)::sum = %d\\n\", u, v, sum);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) std::swap(a, b);\n\tsum += segment->querySum(a->pos, b->pos);\n\tsum -= a->cost;\n\n\treturn sum;\n}\n\ninline void updateToBlack(int u) {\n\tif (trees[u].colored) return;\n\ttrees[u].colored = true;\n\tsum += trees[u].costPrefixSum;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) {\n\t\tsegment->updateCount(t->path->top->pos, t->pos, 1);\n\t}\n\tsegment->updateBlackCount(trees[u].pos, 1);\n\tblackCount++;\n}\n\ninline long long queryAllDist(int u) {\n\tTree *t = &trees[u];\n\tint childBlackCount = segment->queryBlackCount(t->pos, t->posEnd);\n\tlong long tmp = 0;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) tmp += segment->querySum(t->path->top->pos, t->pos);\n\treturn sum + t->costPrefixSum * blackCount - 2 * tmp;\n}\n\nint main() {\n\t// freopen(\"color.in\", \"r\", stdin);\n\t// freopen(\"color.out\", \"w\", stdout);\n\t\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint parent;\n\t\tscanf(\"%d\", &parent);\n\n\t\taddRelation(i, parent);\n\t}\n\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%lld\", &trees[i].cost);\n\t}\n\n\tcut();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint t, u;\n\t\tscanf(\"%d %d\", &t, &u);\n\n\t\tif (t == 1) updateToBlack(u);\n\t\telse printf(\"%lld\\n\", queryAllDist(u));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n\n","slug":"20160318-color","published":1,"updated":"2016-03-22T09:50:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4mws0000ofdkzo4y48ox"},{"title":"OS X 与虚拟机中 Linux 无缝整合","date":"2016-03-07T01:04:27.000Z","_content":"\nOS X 中有很多与 GNU/Linux 相似的地方，但也有很大的差异，很多时候 GNU/Linux 系统比 OS X 好用一些，而 OS X 的图形界面比 GNU/Linux 不知要高到哪里去了 …… 二者兼得的方法，就是使用虚拟机。\n\n下面以最好用的虚拟机软件 `VirtualBox` 为例，演示配置 Archlinux 虚拟机与 OS X 主机无缝整合的步骤。\n\n<!-- more -->\n\n## 安装 OpenSSH\n首先，在虚拟机中安装好 Arch Linux 系统，并安装好增强工具。\n\n安装 OpenSSH：\n\n```bash\nsudo pacman -S openssh\nsudo systemctl enable sshd\nsudo systemctl start sshd\n```\n\n## 配置端口转发\n打开「设置」→「网络」，选择「网络地址转换「NAT」连接方式。\n\n![网络设置](virtualbox-archlinux/network.png)\n\n点击「端口转发」。\n\n![端口转发](virtualbox-archlinux/port.png)\n\n子系统端口填写 `22`，主机端口填一个大于 `1000` 的值，因为在 OS X 下，非 `root` 用户的进程是无法绑定 `1000` 以下的端口的。\n\n确定后，在主机的 Terminal 中尝试连接。\n\n```bash\nssh -p5280 127.0.0.1\n```\n\n## 共享文件夹\n在 Virtualbox 的「设置」→「共享文件夹」中设置共享根目录。\n\n![共享文件夹](virtualbox-archlinux/share.png)\n\n为了解决权限问题，不要选择「自动挂载」，而是手动配置自动挂载。\n\n### `rc.local` 服务\n\nArchlinux 的 systemd 原生不支持开机自动执行 `rc.local` 文件，所以我们需要先添加一个服务。\n\n```bash\nsudo nano /usr/lib/systemd/system/rc-local.service\n```\n\n输入以下内容：\n\n```ini\n[Unit]\nDescription=\"/etc/rc.local Compatibility\"\nAfter=vboxadd.service vboxadd-service.service\n\n[Service]\nType=forking\nExecStart=/etc/rc.local start\nTimeoutSec=0\nStandardInput=tty\nRemainAfterExit=yes\nSysVStartPriority=999\n\n[Install]\nWantedBy=multi-user.target\n```\n\n保存后启用服务，并创建 `rc.local` 文件：\n\n```bash\nsudo systemctl enable rc-local\n```\n\n### 自动挂载脚本\n\n```bash\nsudo touch /etc/rc.local\nsudo chmod +x /etc/rc.local\nsudo nano /etc/rc.local\n```\n\n```bash\n#!/bin/bash\n\n/usr/bin/mount -t vboxsf Host /media/Host -o uid=1000,gid=1000\n/usr/bin/mount --bind /media/Host/Users/Menci /home/Menci\n\nexit 0\n```\n\n重启后，虚拟机中的主目录就和主机上的主目录共享啦。\n\n## SSH 免密码登录\n进行完以上步骤后，已经可以在主机通过 SSH 连接到虚拟机了，但需要输入密码。我们可以使用私钥认证的方式免去输入密码。\n\n```bash\nssh-keygen -b 1024 -t rsa\n```\n\n一路回车后，会在 `~/.ssh` 目录下生成私钥和公钥。\n\n```bash\ncat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys\n```\n\n因为主机和虚拟机的主目录是共享的，所以在主机里设置后，虚拟机里也会生效。\n\n现在试试 SSH 连接到虚拟机，应该不需要密码了。\n\n## 配置 Terminal 快捷键\n众所周知，Terminal 中以默认设置打开新窗口的快捷键是 `Command + N`。我们也可以设置打开新窗口并 SSH 连接到虚拟机的快捷键。\n\n### 添加描述文件\n在 Terminal 的偏好设置中，选择「描述文件」，把「Basic」配置复制一份，命名为「Basic Linux」，并在 `Shell` 一栏中填写「运行命令」为 SSH，不勾选下方的「在 Shell 中运行」。\n\n![共享文件夹](virtualbox-archlinux/terminal.png)\n\n这样就已经可以在菜单中打开连接虚拟机的新窗口了。\n\n### 添加快捷键\n在系统偏好设置中添加快捷键：\n\n「系统偏好设置」→「键盘」→「快捷键」→「应用程序快捷键」→「添加」\n\n![共享文件夹](virtualbox-archlinux/hotkey.png)\n\n点击「添加」后，就可以使用快捷键啦！\n\n## 成果\n在 Terminal 中，按下 `Command + B`：\n\n![共享文件夹](virtualbox-archlinux/screenfetch.png)\n\n为了比较好的效果，可以改一下 `screenfetch`。\n","source":"_posts/virtualbox-archlinux.md","raw":"title: OS X 与虚拟机中 Linux 无缝整合\ncategories: Geek\ntags: \n  - OS X\n  - Linux\n  - Archlinux\n  - VirtualBox\n  - 虚拟机\n  - SSH\npermalink: virtualbox-archlinux\ndate: 2016-03-07 09:04:27\n---\n\nOS X 中有很多与 GNU/Linux 相似的地方，但也有很大的差异，很多时候 GNU/Linux 系统比 OS X 好用一些，而 OS X 的图形界面比 GNU/Linux 不知要高到哪里去了 …… 二者兼得的方法，就是使用虚拟机。\n\n下面以最好用的虚拟机软件 `VirtualBox` 为例，演示配置 Archlinux 虚拟机与 OS X 主机无缝整合的步骤。\n\n<!-- more -->\n\n## 安装 OpenSSH\n首先，在虚拟机中安装好 Arch Linux 系统，并安装好增强工具。\n\n安装 OpenSSH：\n\n```bash\nsudo pacman -S openssh\nsudo systemctl enable sshd\nsudo systemctl start sshd\n```\n\n## 配置端口转发\n打开「设置」→「网络」，选择「网络地址转换「NAT」连接方式。\n\n![网络设置](virtualbox-archlinux/network.png)\n\n点击「端口转发」。\n\n![端口转发](virtualbox-archlinux/port.png)\n\n子系统端口填写 `22`，主机端口填一个大于 `1000` 的值，因为在 OS X 下，非 `root` 用户的进程是无法绑定 `1000` 以下的端口的。\n\n确定后，在主机的 Terminal 中尝试连接。\n\n```bash\nssh -p5280 127.0.0.1\n```\n\n## 共享文件夹\n在 Virtualbox 的「设置」→「共享文件夹」中设置共享根目录。\n\n![共享文件夹](virtualbox-archlinux/share.png)\n\n为了解决权限问题，不要选择「自动挂载」，而是手动配置自动挂载。\n\n### `rc.local` 服务\n\nArchlinux 的 systemd 原生不支持开机自动执行 `rc.local` 文件，所以我们需要先添加一个服务。\n\n```bash\nsudo nano /usr/lib/systemd/system/rc-local.service\n```\n\n输入以下内容：\n\n```ini\n[Unit]\nDescription=\"/etc/rc.local Compatibility\"\nAfter=vboxadd.service vboxadd-service.service\n\n[Service]\nType=forking\nExecStart=/etc/rc.local start\nTimeoutSec=0\nStandardInput=tty\nRemainAfterExit=yes\nSysVStartPriority=999\n\n[Install]\nWantedBy=multi-user.target\n```\n\n保存后启用服务，并创建 `rc.local` 文件：\n\n```bash\nsudo systemctl enable rc-local\n```\n\n### 自动挂载脚本\n\n```bash\nsudo touch /etc/rc.local\nsudo chmod +x /etc/rc.local\nsudo nano /etc/rc.local\n```\n\n```bash\n#!/bin/bash\n\n/usr/bin/mount -t vboxsf Host /media/Host -o uid=1000,gid=1000\n/usr/bin/mount --bind /media/Host/Users/Menci /home/Menci\n\nexit 0\n```\n\n重启后，虚拟机中的主目录就和主机上的主目录共享啦。\n\n## SSH 免密码登录\n进行完以上步骤后，已经可以在主机通过 SSH 连接到虚拟机了，但需要输入密码。我们可以使用私钥认证的方式免去输入密码。\n\n```bash\nssh-keygen -b 1024 -t rsa\n```\n\n一路回车后，会在 `~/.ssh` 目录下生成私钥和公钥。\n\n```bash\ncat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys\n```\n\n因为主机和虚拟机的主目录是共享的，所以在主机里设置后，虚拟机里也会生效。\n\n现在试试 SSH 连接到虚拟机，应该不需要密码了。\n\n## 配置 Terminal 快捷键\n众所周知，Terminal 中以默认设置打开新窗口的快捷键是 `Command + N`。我们也可以设置打开新窗口并 SSH 连接到虚拟机的快捷键。\n\n### 添加描述文件\n在 Terminal 的偏好设置中，选择「描述文件」，把「Basic」配置复制一份，命名为「Basic Linux」，并在 `Shell` 一栏中填写「运行命令」为 SSH，不勾选下方的「在 Shell 中运行」。\n\n![共享文件夹](virtualbox-archlinux/terminal.png)\n\n这样就已经可以在菜单中打开连接虚拟机的新窗口了。\n\n### 添加快捷键\n在系统偏好设置中添加快捷键：\n\n「系统偏好设置」→「键盘」→「快捷键」→「应用程序快捷键」→「添加」\n\n![共享文件夹](virtualbox-archlinux/hotkey.png)\n\n点击「添加」后，就可以使用快捷键啦！\n\n## 成果\n在 Terminal 中，按下 `Command + B`：\n\n![共享文件夹](virtualbox-archlinux/screenfetch.png)\n\n为了比较好的效果，可以改一下 `screenfetch`。\n","slug":"virtualbox-archlinux","published":1,"updated":"2016-03-15T01:05:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4myf000fofdkvorc8dw7"},{"title":"「UVa 1362」Exploring Pyramids - 区间DP + 计数原理","date":"2016-03-14T08:32:16.000Z","_content":"\n给定一棵树的欧拉序列，树的子节点是有序的，求有多少棵树满足这个欧拉序列。\n\n<!-- more -->\n\n### 题目链接\n[UVa 1362](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4108)\n\n### 解题思路\n书上的解法，用 $ f(i, j) $ 表示欧拉序列 $ S $ 中的第 $ i $ 到第 $ j $ 个字符所表示的树的数量，则有：\n\n1. 当 $ i = j $ 时，$ f(i, j) = 1 $；\n2. 当 $ S(i) \\neq S(j) $ 时，$ f(i, j) = 0 $，因为欧拉序列的第一个点和最后一个点都必须是根节点。\n\n欧拉序列的一个特点是，每一次回溯到根都会将根节点记录下来。所以我们可以枚举中转点 $ k $，当 $ i = k = j $ 时，递归计算 $ (i, k) $ 区间内（第一棵子树）的答案和 $ [k, j] $ 区间的答案（其它子树），并将其相乘。\n\n多组数据一定要清数组，一定要清数组，一定要清数组 ……\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 300;\nconst long long MOD = 1000000000;\n\nchar str[MAXN + 1];\n\nlong long search(int i, int j, bool reset = false) {\n\tstatic long long mem[MAXN][MAXN];\n\tstatic bool calced[MAXN][MAXN];\n\n\tif (reset) {\n\t\tmemset(mem, 0, sizeof(mem));\n\t\tmemset(calced, 0, sizeof(calced));\n\t}\n\n\tlong long &ans = mem[i][j];\n\n\tif (calced[i][j]) return ans;\n\tcalced[i][j] = true;\n\n\tif (i == j) return ans = 1;\n\telse if (str[i] != str[j]) return ans = 0;\n\telse {\n\t\tans = 0;\n\t\tfor (int k = i + 2; k <= j; k++) {\n\t\t\tif (str[i] != str[k]) continue;\n\t\t\tans += search(i + 1, k - 1) * search(k, j) % MOD;\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tfor (; ~scanf(\"%s\", str); printf(\"%lld\\n\", search(0, strlen(str) - 1, true)));\n\treturn 0;\n}\n```\n","source":"_posts/uva-1362.md","raw":"title: 「UVa 1362」Exploring Pyramids - 区间DP + 计数原理\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - DP\n  - 区间DP\n  - 计数原理\npermalink: uva-1362\ndate: 2016-03-14 16:32:16\n---\n\n给定一棵树的欧拉序列，树的子节点是有序的，求有多少棵树满足这个欧拉序列。\n\n<!-- more -->\n\n### 题目链接\n[UVa 1362](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4108)\n\n### 解题思路\n书上的解法，用 $ f(i, j) $ 表示欧拉序列 $ S $ 中的第 $ i $ 到第 $ j $ 个字符所表示的树的数量，则有：\n\n1. 当 $ i = j $ 时，$ f(i, j) = 1 $；\n2. 当 $ S(i) \\neq S(j) $ 时，$ f(i, j) = 0 $，因为欧拉序列的第一个点和最后一个点都必须是根节点。\n\n欧拉序列的一个特点是，每一次回溯到根都会将根节点记录下来。所以我们可以枚举中转点 $ k $，当 $ i = k = j $ 时，递归计算 $ (i, k) $ 区间内（第一棵子树）的答案和 $ [k, j] $ 区间的答案（其它子树），并将其相乘。\n\n多组数据一定要清数组，一定要清数组，一定要清数组 ……\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 300;\nconst long long MOD = 1000000000;\n\nchar str[MAXN + 1];\n\nlong long search(int i, int j, bool reset = false) {\n\tstatic long long mem[MAXN][MAXN];\n\tstatic bool calced[MAXN][MAXN];\n\n\tif (reset) {\n\t\tmemset(mem, 0, sizeof(mem));\n\t\tmemset(calced, 0, sizeof(calced));\n\t}\n\n\tlong long &ans = mem[i][j];\n\n\tif (calced[i][j]) return ans;\n\tcalced[i][j] = true;\n\n\tif (i == j) return ans = 1;\n\telse if (str[i] != str[j]) return ans = 0;\n\telse {\n\t\tans = 0;\n\t\tfor (int k = i + 2; k <= j; k++) {\n\t\t\tif (str[i] != str[k]) continue;\n\t\t\tans += search(i + 1, k - 1) * search(k, j) % MOD;\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tfor (; ~scanf(\"%s\", str); printf(\"%lld\\n\", search(0, strlen(str) - 1, true)));\n\treturn 0;\n}\n```\n","slug":"uva-1362","published":1,"updated":"2016-03-15T01:05:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4mzu000uofdkp17nlmwn"},{"title":"「UVa 11806」Cheerleaders - 组合数 + 容斥原理","date":"2016-03-11T14:10:34.000Z","_content":"\n在一个 $ M * N $ 的矩阵中摆放 $ K $ 只石子，要求第一行、第一列、第 $ \nM $ 行、第 $ N $ 列必须有石子，求方案总数。\n\n<!-- more -->\n\n### 题目链接\n[UVa \n11806](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2906)\n\n### 解题思路\n1. 设 $ A $、$ C $ 分别表示第一行、第 $ M $ \n行**没有**摆放石子的方案集合；\n2. 设 $ B $、$ D $ 分别表示第一列、第 $ N $ \n列**没有**摆放石子的方案集合；\n3. 设 $ S $ 表示在 $ M * N $ 的矩阵中**任意**摆放 $ K $ \n只石子的方案集合。\n\n则问题转化为，求在集合 $ S $ 内但不在集合 $ A $、$ B $、$ C $、$ D $ \n内的元素总数。\n\n由容斥原理得，答案\n$$\n\\begin{align*}\n& = |S| \\\\\n& - |A| - |B| - |C| - |D| \\\\\n& + |A{\\cup}B| + |B{\\cup}C| + |C{\\cup}D| + |D{\\cup}A| + |A{\\cup}C| + \n|B{\\cup}D| \\\\\n& - |A{\\cup}B{\\cup}C| - |B{\\cup}C{\\cup}D| - |A{\\cup}C{\\cup}D| - \n|A{\\cup}B{\\cup}D| \\\\\n& + |A{\\cup}B{\\cup}C{\\cup}D| \\\\\n\\end{align*}\n$$\n\n各个集合的元素数量可用组合数计算，组合数需要预处理。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXT = 50;\nconst int MAXN = 20;\nconst int MAXK = 500;\nconst int p = 1000007;\n\nint combo[MAXK + 1][MAXK + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 0; i <= MAXK; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tcombo[i][j] = (combo[i - 1][j] + combo[i - \n1][j - 1]) % p;\n\t\t}\n\t}\n}\n\ninline long long C(int a, int b) {\n\treturn (long long)combo[a][b];\n}\n\ninline int solve(int m, int n, int k) {\n\tlong long ans = C(m * n, k);\n\n\t// |A| = |C| = C(m(n - 1), k)\n\t// |B| = |D| = C((m - 1)n, k)\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\n\t// |AB| = |BC| = |CD| = |DA| = C((m - 1)(n - 1), k)\n\t// |AC| = C(m(n - 2), k)\n\t// |BD| = C((m - 2)n, k)\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C(m * (n - 2), k), ans %= p;\n\tans += C((m - 2) * n, k), ans %= p;\n\n\t// |ABC| = |ADC| = C((m - 1)(n - 2), k)\n\t// |ABD| = |CBD| = C((m - 2)(n - 1), k)\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\n\t// |ABCD| = C((m - 2)(n - 2), k);\n\tans += C((m - 2) * (n - 2), k), ans %= p;\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 1; i <= t; i++) {\n\t\tint n, m, k;\n\t\tscanf(\"%d %d %d\", &m, &n, &k);\n\t\tprintf(\"Case %d: %d\\n\", i, solve(m, n, k));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11806.md","raw":"title: 「UVa 11806」Cheerleaders - 组合数 + 容斥原理\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - 组合数学\n  - 容斥原理\npermalink: uva-11806\ndate: 2016-03-11 22:10:34\n---\n\n在一个 $ M * N $ 的矩阵中摆放 $ K $ 只石子，要求第一行、第一列、第 $ \nM $ 行、第 $ N $ 列必须有石子，求方案总数。\n\n<!-- more -->\n\n### 题目链接\n[UVa \n11806](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2906)\n\n### 解题思路\n1. 设 $ A $、$ C $ 分别表示第一行、第 $ M $ \n行**没有**摆放石子的方案集合；\n2. 设 $ B $、$ D $ 分别表示第一列、第 $ N $ \n列**没有**摆放石子的方案集合；\n3. 设 $ S $ 表示在 $ M * N $ 的矩阵中**任意**摆放 $ K $ \n只石子的方案集合。\n\n则问题转化为，求在集合 $ S $ 内但不在集合 $ A $、$ B $、$ C $、$ D $ \n内的元素总数。\n\n由容斥原理得，答案\n$$\n\\begin{align*}\n& = |S| \\\\\n& - |A| - |B| - |C| - |D| \\\\\n& + |A{\\cup}B| + |B{\\cup}C| + |C{\\cup}D| + |D{\\cup}A| + |A{\\cup}C| + \n|B{\\cup}D| \\\\\n& - |A{\\cup}B{\\cup}C| - |B{\\cup}C{\\cup}D| - |A{\\cup}C{\\cup}D| - \n|A{\\cup}B{\\cup}D| \\\\\n& + |A{\\cup}B{\\cup}C{\\cup}D| \\\\\n\\end{align*}\n$$\n\n各个集合的元素数量可用组合数计算，组合数需要预处理。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXT = 50;\nconst int MAXN = 20;\nconst int MAXK = 500;\nconst int p = 1000007;\n\nint combo[MAXK + 1][MAXK + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 0; i <= MAXK; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tcombo[i][j] = (combo[i - 1][j] + combo[i - \n1][j - 1]) % p;\n\t\t}\n\t}\n}\n\ninline long long C(int a, int b) {\n\treturn (long long)combo[a][b];\n}\n\ninline int solve(int m, int n, int k) {\n\tlong long ans = C(m * n, k);\n\n\t// |A| = |C| = C(m(n - 1), k)\n\t// |B| = |D| = C((m - 1)n, k)\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\n\t// |AB| = |BC| = |CD| = |DA| = C((m - 1)(n - 1), k)\n\t// |AC| = C(m(n - 2), k)\n\t// |BD| = C((m - 2)n, k)\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C(m * (n - 2), k), ans %= p;\n\tans += C((m - 2) * n, k), ans %= p;\n\n\t// |ABC| = |ADC| = C((m - 1)(n - 2), k)\n\t// |ABD| = |CBD| = C((m - 2)(n - 1), k)\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\n\t// |ABCD| = C((m - 2)(n - 2), k);\n\tans += C((m - 2) * (n - 2), k), ans %= p;\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 1; i <= t; i++) {\n\t\tint n, m, k;\n\t\tscanf(\"%d %d %d\", &m, &n, &k);\n\t\tprintf(\"Case %d: %d\\n\", i, solve(m, n, k));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11806","published":1,"updated":"2016-03-15T01:05:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n050016ofdk78tkozav"},{"title":"「UVa 11538」Chess Queen - 计数原理","date":"2016-03-12T02:47:13.000Z","_content":"\n在一个 $ N * M $ 棋盘中放置两个皇后，使得它们可以相互攻击，求方案总数。\n\n<!-- more -->\n\n### 题目链接\n[UVa 11538](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2533)\n\n### 解题思路\n两个皇后可以互相攻击，当且仅当它们在「同一行」或「同一列」或「同一对角线」。这三种情况互相独立，可以用加法原理。\n\n考虑「同一行」的情况，用 $ f(a, b) $ 表示在一个 $ a $ 行 $ b $ 列的棋盘中放置两个皇后在同一行的方案数。令 $ a = 1 $，此时第一个皇后有 $ b $ 种放置方法，第二个有 $ b - 1 $ 种，即\n\n$$ f(1, b) = b(b - 1) $$\n\n推广到多行的情况，每一行的情况互不影响，可以用加法原理，即：\n\n$$\n\\begin{align}\nf(a, b) & = \\sum_{i = 1}^{a} b(b - 1) \\\\\n& = ab(b - 1) \\\\\n\\end{align}\n$$\n\n「同一列」和「同一行」原理相同，行列数互换后代入上式即可。\n\n「同一对角线」的情况比较复杂，假设 $ m ≥ n $，则同一方向的对角线中，有 $ m - n + 1 $ 条的长度为 $ n $（蓝色部分），剩下的两边分别有 $ n - 1 $ 条长度递增。\n\n![（图片使用 \nLibreOffice Calc \n制作）](uva-11538/cells.png)\n\n中间的一撮所对应的情况相当于在一个 $ m - n + 1 $ 行 $ n $ 列的棋盘中放置，使得两个皇后在**同一行**，即 $ f(m - n + 1, n) $。\n\n两边长度递增的对角线也要按照类似「同一行」的方法推导，即：\n\n$$ \\sum_{i = 1}^{n - 1} f(1, i) $$\n\n但是根据题目的数据范围，$ O(n) $ 地每次计算是会超时的，考虑展开。\n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} f(1, i) \\\\\n= & \\sum_{i = 1}^{n - 1} i(i - 1) \\\\\n= & \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n\\end{align}\n$$\n\n分别使用平方和公式和等差数列求和公式展开，得\n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n= & \\frac{(n - 1)n(2n - 1)}{6} - \\frac{n(n - 1)}{2} \\\\\n= & \\frac{n(n - 1)(2n - 4)}{6} \\\\\n= & \\frac{n(n - 1)(n - 2)}{3} \\\\\n\\end{align}\n$$\n\n这是一边的长度递增的对角线上的方案数，两边的要乘以二，因为有两个方向，所以最后还要乘以二。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 5000;\nconst int MAXN = 1000000;\n\ninline long long f(long long a, long long b) {\n\treturn a * (b - 1) * b;\n}\n\ninline long long g(long long n, long long m) {\n\t// m >= n\n\tif (m < n) std::swap(m, n);\n\tunsigned long long x = ((n - 1) * n * (n - 2)) / 3;\n\treturn f(m - n + 1, n) + x * 2;\n}\n\nint main() {\n\tint n, m;\n\twhile (~scanf(\"%d %d\", &n, &m), !(n == 0 && m == 0)) {\n\t\tprintf(\"%llu\\n\", f(n, m) + f(m, n) + g(n, m) * 2);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11538.md","raw":"title: 「UVa 11538」Chess Queen - 计数原理\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - 组合数学\n  - 计数原理\npermalink: uva-11538\ndate: 2016-03-12 10:47:13\n---\n\n在一个 $ N * M $ 棋盘中放置两个皇后，使得它们可以相互攻击，求方案总数。\n\n<!-- more -->\n\n### 题目链接\n[UVa 11538](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2533)\n\n### 解题思路\n两个皇后可以互相攻击，当且仅当它们在「同一行」或「同一列」或「同一对角线」。这三种情况互相独立，可以用加法原理。\n\n考虑「同一行」的情况，用 $ f(a, b) $ 表示在一个 $ a $ 行 $ b $ 列的棋盘中放置两个皇后在同一行的方案数。令 $ a = 1 $，此时第一个皇后有 $ b $ 种放置方法，第二个有 $ b - 1 $ 种，即\n\n$$ f(1, b) = b(b - 1) $$\n\n推广到多行的情况，每一行的情况互不影响，可以用加法原理，即：\n\n$$\n\\begin{align}\nf(a, b) & = \\sum_{i = 1}^{a} b(b - 1) \\\\\n& = ab(b - 1) \\\\\n\\end{align}\n$$\n\n「同一列」和「同一行」原理相同，行列数互换后代入上式即可。\n\n「同一对角线」的情况比较复杂，假设 $ m ≥ n $，则同一方向的对角线中，有 $ m - n + 1 $ 条的长度为 $ n $（蓝色部分），剩下的两边分别有 $ n - 1 $ 条长度递增。\n\n![（图片使用 \nLibreOffice Calc \n制作）](uva-11538/cells.png)\n\n中间的一撮所对应的情况相当于在一个 $ m - n + 1 $ 行 $ n $ 列的棋盘中放置，使得两个皇后在**同一行**，即 $ f(m - n + 1, n) $。\n\n两边长度递增的对角线也要按照类似「同一行」的方法推导，即：\n\n$$ \\sum_{i = 1}^{n - 1} f(1, i) $$\n\n但是根据题目的数据范围，$ O(n) $ 地每次计算是会超时的，考虑展开。\n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} f(1, i) \\\\\n= & \\sum_{i = 1}^{n - 1} i(i - 1) \\\\\n= & \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n\\end{align}\n$$\n\n分别使用平方和公式和等差数列求和公式展开，得\n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n= & \\frac{(n - 1)n(2n - 1)}{6} - \\frac{n(n - 1)}{2} \\\\\n= & \\frac{n(n - 1)(2n - 4)}{6} \\\\\n= & \\frac{n(n - 1)(n - 2)}{3} \\\\\n\\end{align}\n$$\n\n这是一边的长度递增的对角线上的方案数，两边的要乘以二，因为有两个方向，所以最后还要乘以二。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 5000;\nconst int MAXN = 1000000;\n\ninline long long f(long long a, long long b) {\n\treturn a * (b - 1) * b;\n}\n\ninline long long g(long long n, long long m) {\n\t// m >= n\n\tif (m < n) std::swap(m, n);\n\tunsigned long long x = ((n - 1) * n * (n - 2)) / 3;\n\treturn f(m - n + 1, n) + x * 2;\n}\n\nint main() {\n\tint n, m;\n\twhile (~scanf(\"%d %d\", &n, &m), !(n == 0 && m == 0)) {\n\t\tprintf(\"%llu\\n\", f(n, m) + f(m, n) + g(n, m) * 2);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11538","published":1,"updated":"2016-03-15T01:05:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n0c001eofdk774u3r1g"},{"title":"「UVa 11375」Matches - 递推","date":"2016-03-13T03:07:45.000Z","_content":"\n有 $ N $ 个火柴，用这些火柴能摆出非负整数，摆出的数不能有前导零，火柴不必用完，求方案总数。\n\n<!-- more -->\n\n### 题目链接\n[UVa 11375](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2370)\n\n### 解题思路\n首先考虑不存在数字 0 的情况，用 $ f(i) $ 表示用 $ i $ 个火柴棒能摆出的方案总数，用 $ c(x) $ 表示摆出数字 x 使用的火柴棒数量。\n\n前导零是不被允许的，所以初始状态要把 1 ~ 9 几个数字的方案数加一。\n\n每次递推用 $ f(i) $ 去更新 $ f(i + c(x)) $（$ 0 \\leq x \\leq 9,i + c(x) \\leq 2000 $），表示在 $ f(i) $ 表示的数字尾部添加一个 $ x $ 所得的方案。\n\n递推计算完成后求出前缀和 $ s(n) = \\sum\\limits_{i = 2}^{n}f(i) $ 即为答案，如果 $ n \\geq 6 $ 则需要将答案加一（考虑单独的数字 0）。\n\n需要使用高精度。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXT = 100;\nconst int MAXN = 2000;\nconst int C[] = { 6, 2, 5, 5, 4, 5, 6, 3, 7, 6 };\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tconst std::vector<char> &v = x.v;\n\tfor (int i = v.size() - 1; i >= 0; i--) out << (char)(v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt r;\n\tr.v.reserve(std::max(a.v.size(), b.v.size()) + 1);\n\n\tbool flag = false;\n\tfor (int i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < a.v.size()) tmp += a.v[i];\n\t\tif (i < b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tr.v.push_back(tmp);\n\t}\n\tif (flag) r.v.push_back(1);\n\n\treturn r;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt f[MAXN + 1], sum[MAXN + 1];\n\ninline void makeTable() {\n\tfor (int i = 1; i < 10; i++) f[C[i]] += 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tif (i + C[j] <= MAXN) f[i + C[j]] += f[i];\n\t\t}\n\t}\n\n\tsum[2] = f[2];\n\tfor (int i = 3; i <= MAXN; i++) sum[i] = sum[i - 1] + f[i];\n}\n\nint main() {\n\tmakeTable();\n\n\tint n;\n\twhile (~scanf(\"%d\", &n)) {\n\t\tif (n == 0 || n == 1) puts(\"0\");\n\t\telse if (n < 6) std::cout << sum[n] << std::endl;\n\t\telse std::cout << sum[n] + 1 << std::endl;\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/uva-11375.md","raw":"title: 「UVa 11375」Matches - 递推\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - 递推\n  - 高精度\npermalink: uva-11375\ndate: 2016-03-13 11:07:45\n---\n\n有 $ N $ 个火柴，用这些火柴能摆出非负整数，摆出的数不能有前导零，火柴不必用完，求方案总数。\n\n<!-- more -->\n\n### 题目链接\n[UVa 11375](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2370)\n\n### 解题思路\n首先考虑不存在数字 0 的情况，用 $ f(i) $ 表示用 $ i $ 个火柴棒能摆出的方案总数，用 $ c(x) $ 表示摆出数字 x 使用的火柴棒数量。\n\n前导零是不被允许的，所以初始状态要把 1 ~ 9 几个数字的方案数加一。\n\n每次递推用 $ f(i) $ 去更新 $ f(i + c(x)) $（$ 0 \\leq x \\leq 9,i + c(x) \\leq 2000 $），表示在 $ f(i) $ 表示的数字尾部添加一个 $ x $ 所得的方案。\n\n递推计算完成后求出前缀和 $ s(n) = \\sum\\limits_{i = 2}^{n}f(i) $ 即为答案，如果 $ n \\geq 6 $ 则需要将答案加一（考虑单独的数字 0）。\n\n需要使用高精度。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXT = 100;\nconst int MAXN = 2000;\nconst int C[] = { 6, 2, 5, 5, 4, 5, 6, 3, 7, 6 };\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tconst std::vector<char> &v = x.v;\n\tfor (int i = v.size() - 1; i >= 0; i--) out << (char)(v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt r;\n\tr.v.reserve(std::max(a.v.size(), b.v.size()) + 1);\n\n\tbool flag = false;\n\tfor (int i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < a.v.size()) tmp += a.v[i];\n\t\tif (i < b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tr.v.push_back(tmp);\n\t}\n\tif (flag) r.v.push_back(1);\n\n\treturn r;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt f[MAXN + 1], sum[MAXN + 1];\n\ninline void makeTable() {\n\tfor (int i = 1; i < 10; i++) f[C[i]] += 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tif (i + C[j] <= MAXN) f[i + C[j]] += f[i];\n\t\t}\n\t}\n\n\tsum[2] = f[2];\n\tfor (int i = 3; i <= MAXN; i++) sum[i] = sum[i - 1] + f[i];\n}\n\nint main() {\n\tmakeTable();\n\n\tint n;\n\twhile (~scanf(\"%d\", &n)) {\n\t\tif (n == 0 || n == 1) puts(\"0\");\n\t\telse if (n < 6) std::cout << sum[n] << std::endl;\n\t\telse std::cout << sum[n] + 1 << std::endl;\n\t}\n\treturn 0;\n}\n```\n","slug":"uva-11375","published":1,"updated":"2016-03-15T01:05:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n0q001kofdkhukbg2re"},{"title":"「UVa 11361」Investigating Div-Sum Property - 数位DP","date":"2016-03-15T00:53:05.000Z","_content":"\n问在区间 $ [a, b] $ 内有多少数 $ x $ 满足：\n\n1. $ x $ 是 $ k $ 的倍数；\n2. $ x $ 的各位数之和是 $ k $ 的倍数。\n\n<!-- more -->\n\n### 题目链接\n[UVa 11361](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2346)\n\n### 解题思路\n设 $ {\\rm sum}(x) $ 表示 $ x $ 的各位数之和，$ g(x, m_1, m_2) $ 表示 $ [0, x] $ 内有多少正整数 $ i $ 满足 $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $ 且 $ i \\ {\\rm mod} \\ k = m_2 $，问题转化为求 $ g(b, 0, 0) - g(a - 1, 0, 0) $。\n\n设 $ f(n, m_1, m_2) $ 表示有多少 $ n $ 位数 $ i $ 满足 $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $ 且 $ i \\ {\\rm mod} \\ k = m_2 $，计算 $ f $ 函数可以枚举最高位数字 1 ~ 9，并递归计算。\n\n$ g $ 函数也可以递归求，设参数 $ x $ 的最高位上的数为 $ t $，则可以先在 $ [0, t) $ 枚举最高位上的数，此时后面的低位数是任意的，可以由 $ f $ 函数来计算；最后令最高位为 $ x $，递归处理低位的数，累加起来就是答案。\n\n题目有坑，$ k $ 较大时结果直接为零 ……\n\n### AC代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 99;\nconst int MAXX = 1 << 31;\nconst int MAXK = 9999;\nconst int MAXK_HEHE = 100;\n\nint k, pow10[12];\n\nlong long mem[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\nbool calced[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\n\ninline void makeTable() {\n\tpow10[0] = 1;\n\tfor (int i = 1; i <= 11; i++) pow10[i] = pow10[i - 1] * 10;\n}\n\ninline int length(int x) {\n\tint result = 0;\n\tdo result++; while (x /= 10);\n\treturn result;\n}\n\ninline int sum(int x) {\n\tint result = 0;\n\tdo result += x % 10; while (x /= 10);\n\treturn result;\n}\n\ninline int mod(int a, int b) {\n\treturn (a % b + b) % b;\n}\n\nint f(int x, int m1, int m2) {\n\tlong long &ans = mem[x][m1][m2];\n\tif (calced[x][m1][m2]) return ans;\n\tcalced[x][m1][m2] = true;\n\n\tans = 0;\n\tif (x == 1) {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tans += f(x - 1, mod(m1 - i, k), mod(m2 - i * pow10[x - 1] % k, k));\n\t\t}\n\t}\n\n\t// printf(\"f(%d, %d, %d) = %d\\n\", x, m1, m2, ans);\n\treturn ans;\n}\n\nint dp(int x, int m1, int m2) {\n\tint ans = 0;\n\tif (x < 10) {\n\t\tfor (int i = 0; i <= x; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tint n = length(x), first = x / pow10[n - 1];\n\t\tfor (int i = 0; i < first; i++) {\n\t\t\tans += f(n - 1, mod(m1 - i, k), mod(m2 - pow10[n - 1] * i, k));\n\t\t}\n\t\tans += dp(x % pow10[n - 1], mod(m1 - first, k), mod(m2 - pow10[n - 1] * first, k));\n\t}\n\n\treturn ans;\n}\n\n/*\ninline int solve(int x) {\n\tint n = length(x), left = 0;\n\tint ans = 0;\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tint curr = (x % pow10[i + 1]) / pow10[i];\n\t\t// printf(\"curr = %d\\n\", curr);\n\t\tfor (int j = 0; j < curr; j++) {\n\t\t\tint t = left * 10 + j;\n\t\t\t// printf(\"sum(t) = %d; %d\\n\", sum(t), t * pow10[i - 1]);\n\t\t\tans += f(i, mod(k - sum(t), k), mod(t * pow10[i] % k, k));\n\t\t}\n\t\tleft = left * 10 + curr;\n\t}\n\n\tfor (int i = 0; i <= x % 10; i++) {\n\t\tif ((x - i) % k == 0 && sum(x - i) % k == 0) ans++;\n\t}\n\n\treturn ans;\n}\n*/\n\ninline void cleanUp() {\n\tmemset(mem, 0, sizeof(mem));\n\tmemset(calced, 0, sizeof(calced));\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d %d\", &a, &b, &k);\n\t\tif (k >= 100) puts(\"0\"); // hehe\n\t\telse printf(\"%d\\n\", dp(b, 0, 0) - dp(a - 1, 0, 0));\n\t\tcleanUp();\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11361.md","raw":"title: 「UVa 11361」Investigating Div-Sum Property - 数位DP\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - 递推\n  - DP\n  - 数位DP\npermalink: uva-11361\ndate: 2016-03-15 08:53:05\n---\n\n问在区间 $ [a, b] $ 内有多少数 $ x $ 满足：\n\n1. $ x $ 是 $ k $ 的倍数；\n2. $ x $ 的各位数之和是 $ k $ 的倍数。\n\n<!-- more -->\n\n### 题目链接\n[UVa 11361](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2346)\n\n### 解题思路\n设 $ {\\rm sum}(x) $ 表示 $ x $ 的各位数之和，$ g(x, m_1, m_2) $ 表示 $ [0, x] $ 内有多少正整数 $ i $ 满足 $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $ 且 $ i \\ {\\rm mod} \\ k = m_2 $，问题转化为求 $ g(b, 0, 0) - g(a - 1, 0, 0) $。\n\n设 $ f(n, m_1, m_2) $ 表示有多少 $ n $ 位数 $ i $ 满足 $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $ 且 $ i \\ {\\rm mod} \\ k = m_2 $，计算 $ f $ 函数可以枚举最高位数字 1 ~ 9，并递归计算。\n\n$ g $ 函数也可以递归求，设参数 $ x $ 的最高位上的数为 $ t $，则可以先在 $ [0, t) $ 枚举最高位上的数，此时后面的低位数是任意的，可以由 $ f $ 函数来计算；最后令最高位为 $ x $，递归处理低位的数，累加起来就是答案。\n\n题目有坑，$ k $ 较大时结果直接为零 ……\n\n### AC代码\n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 99;\nconst int MAXX = 1 << 31;\nconst int MAXK = 9999;\nconst int MAXK_HEHE = 100;\n\nint k, pow10[12];\n\nlong long mem[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\nbool calced[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\n\ninline void makeTable() {\n\tpow10[0] = 1;\n\tfor (int i = 1; i <= 11; i++) pow10[i] = pow10[i - 1] * 10;\n}\n\ninline int length(int x) {\n\tint result = 0;\n\tdo result++; while (x /= 10);\n\treturn result;\n}\n\ninline int sum(int x) {\n\tint result = 0;\n\tdo result += x % 10; while (x /= 10);\n\treturn result;\n}\n\ninline int mod(int a, int b) {\n\treturn (a % b + b) % b;\n}\n\nint f(int x, int m1, int m2) {\n\tlong long &ans = mem[x][m1][m2];\n\tif (calced[x][m1][m2]) return ans;\n\tcalced[x][m1][m2] = true;\n\n\tans = 0;\n\tif (x == 1) {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tans += f(x - 1, mod(m1 - i, k), mod(m2 - i * pow10[x - 1] % k, k));\n\t\t}\n\t}\n\n\t// printf(\"f(%d, %d, %d) = %d\\n\", x, m1, m2, ans);\n\treturn ans;\n}\n\nint dp(int x, int m1, int m2) {\n\tint ans = 0;\n\tif (x < 10) {\n\t\tfor (int i = 0; i <= x; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tint n = length(x), first = x / pow10[n - 1];\n\t\tfor (int i = 0; i < first; i++) {\n\t\t\tans += f(n - 1, mod(m1 - i, k), mod(m2 - pow10[n - 1] * i, k));\n\t\t}\n\t\tans += dp(x % pow10[n - 1], mod(m1 - first, k), mod(m2 - pow10[n - 1] * first, k));\n\t}\n\n\treturn ans;\n}\n\n/*\ninline int solve(int x) {\n\tint n = length(x), left = 0;\n\tint ans = 0;\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tint curr = (x % pow10[i + 1]) / pow10[i];\n\t\t// printf(\"curr = %d\\n\", curr);\n\t\tfor (int j = 0; j < curr; j++) {\n\t\t\tint t = left * 10 + j;\n\t\t\t// printf(\"sum(t) = %d; %d\\n\", sum(t), t * pow10[i - 1]);\n\t\t\tans += f(i, mod(k - sum(t), k), mod(t * pow10[i] % k, k));\n\t\t}\n\t\tleft = left * 10 + curr;\n\t}\n\n\tfor (int i = 0; i <= x % 10; i++) {\n\t\tif ((x - i) % k == 0 && sum(x - i) % k == 0) ans++;\n\t}\n\n\treturn ans;\n}\n*/\n\ninline void cleanUp() {\n\tmemset(mem, 0, sizeof(mem));\n\tmemset(calced, 0, sizeof(calced));\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d %d\", &a, &b, &k);\n\t\tif (k >= 100) puts(\"0\"); // hehe\n\t\telse printf(\"%d\\n\", dp(b, 0, 0) - dp(a - 1, 0, 0));\n\t\tcleanUp();\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11361","published":1,"updated":"2016-03-15T01:05:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n0z001sofdk8y6w9rfe"},{"title":"「UVa 11174」Stand in a Line - 计数原理 + 乘法逆元","date":"2016-03-13T09:20:34.000Z","_content":"\n分别属于多个家族的 $ N $（$ N \\leq 40000 $）个人想要站成一排，但没有人想站在他爹前面，求方案总数。\n\n<!-- more -->\n\n### 题目链接\n[UVa 11174](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2115)\n\n### 解题思路\n题目描述的父子关系组成了一个森林，每个家族对应一棵树，我们可以添加一个虚拟节点，让它成为每个家族祖先的「父亲」，然后求出整棵树的方案数即为答案。\n\n用 $ f(i) $ 表示以 $ i $ 为根的子树的方案数，用 $ s(i) $ 表示以 $ i $ 为根的子树的大小。\n\n首先，$ i $ 的几棵子树各自的排列方案是相互独立的，可以使用乘法原理来计算。\n\n还要注意一点，$ i $ 的几棵子树的节点是可以穿插排列的，即只需要保证每对父子的相对位置而整体是无序的。如果对所有子树的节点做全排列，那么改变了原有的父子相对位置的排列方案都是无效的，即**同一种穿插方式中多次改变父子相对位置只有一次有效**。我们可以把同一个子树的节点看做相同的，然后做**有重复元素的全排列**，就可以得到正确结果，因为每一种排列都对应且只对应一种顺序。\n\n「子树各自的排列方案」和「节点的穿插顺序」是相互独立的，因此要用乘法原理。\n\n用 $ c(i) $ 表示 $ i $ 的子节点的集合，则递归计算的公式为：\n\n$$ f(i) = \\prod\\limits_{j \\in c(i)}f(j) * \\frac{s(i) - 1}{\\prod\\limits_{j \\in c(i)}{s(i)}} $$\n\n公式中使用了除法，模意义下的除以一个数等于乘以这个数的**乘法逆元**，所以要在程序开始时递推预处理出所有数的阶乘，并求出对应的乘法逆元。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst long long MOD = 1000000007;\nconst int MAXN = 40000;\n\nstruct Tree {\n\tTree *firstChild, *parent, *next;\n\tint childCount, size;\n\tlong long ans;\n\n\tlong long solve();\n} trees[MAXN + 1];\n\nlong long fac[MAXN + 1], facInverse[MAXN + 1];\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nlong long inverse(long long num) {\n\tlong long g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn (x % MOD + MOD) % MOD;\n}\n\nvoid makeTable() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfacInverse[i] = inverse(fac[i]);\n\t}\n}\n\nvoid addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n\ttrees[parent].childCount++;\n}\n\nvoid cleanUp(int n) {\n\tmemset(trees, 0, sizeof(Tree) * (n + 1));\n}\n\nlong long Tree::solve() {\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tc->solve();\n\t\tsize += c->size;\n\t}\n\tsize++;\n\n\tans = fac[size - 1];\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tans = ans * c->ans % MOD;\n\t\tans = ans * facInverse[c->size] % MOD;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint child, parent;\n\t\t\tscanf(\"%d %d\", &child, &parent);\n\n\t\t\taddRelation(child, parent);\n\t\t}\n\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (trees[i].parent == NULL) addRelation(i, 0);\n\t\t}\n\n\t\tprintf(\"%lld\\n\", trees[0].solve());\n\t\tcleanUp(n);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11174.md","raw":"title: 「UVa 11174」Stand in a Line - 计数原理 + 乘法逆元\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - 数论\n  - 递推\n  - 计数原理\n  - 乘法逆元\n  - 全排列\npermalink: uva-11174\ndate: 2016-03-13 17:20:34\n---\n\n分别属于多个家族的 $ N $（$ N \\leq 40000 $）个人想要站成一排，但没有人想站在他爹前面，求方案总数。\n\n<!-- more -->\n\n### 题目链接\n[UVa 11174](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2115)\n\n### 解题思路\n题目描述的父子关系组成了一个森林，每个家族对应一棵树，我们可以添加一个虚拟节点，让它成为每个家族祖先的「父亲」，然后求出整棵树的方案数即为答案。\n\n用 $ f(i) $ 表示以 $ i $ 为根的子树的方案数，用 $ s(i) $ 表示以 $ i $ 为根的子树的大小。\n\n首先，$ i $ 的几棵子树各自的排列方案是相互独立的，可以使用乘法原理来计算。\n\n还要注意一点，$ i $ 的几棵子树的节点是可以穿插排列的，即只需要保证每对父子的相对位置而整体是无序的。如果对所有子树的节点做全排列，那么改变了原有的父子相对位置的排列方案都是无效的，即**同一种穿插方式中多次改变父子相对位置只有一次有效**。我们可以把同一个子树的节点看做相同的，然后做**有重复元素的全排列**，就可以得到正确结果，因为每一种排列都对应且只对应一种顺序。\n\n「子树各自的排列方案」和「节点的穿插顺序」是相互独立的，因此要用乘法原理。\n\n用 $ c(i) $ 表示 $ i $ 的子节点的集合，则递归计算的公式为：\n\n$$ f(i) = \\prod\\limits_{j \\in c(i)}f(j) * \\frac{s(i) - 1}{\\prod\\limits_{j \\in c(i)}{s(i)}} $$\n\n公式中使用了除法，模意义下的除以一个数等于乘以这个数的**乘法逆元**，所以要在程序开始时递推预处理出所有数的阶乘，并求出对应的乘法逆元。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst long long MOD = 1000000007;\nconst int MAXN = 40000;\n\nstruct Tree {\n\tTree *firstChild, *parent, *next;\n\tint childCount, size;\n\tlong long ans;\n\n\tlong long solve();\n} trees[MAXN + 1];\n\nlong long fac[MAXN + 1], facInverse[MAXN + 1];\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nlong long inverse(long long num) {\n\tlong long g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn (x % MOD + MOD) % MOD;\n}\n\nvoid makeTable() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfacInverse[i] = inverse(fac[i]);\n\t}\n}\n\nvoid addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n\ttrees[parent].childCount++;\n}\n\nvoid cleanUp(int n) {\n\tmemset(trees, 0, sizeof(Tree) * (n + 1));\n}\n\nlong long Tree::solve() {\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tc->solve();\n\t\tsize += c->size;\n\t}\n\tsize++;\n\n\tans = fac[size - 1];\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tans = ans * c->ans % MOD;\n\t\tans = ans * facInverse[c->size] % MOD;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint child, parent;\n\t\t\tscanf(\"%d %d\", &child, &parent);\n\n\t\t\taddRelation(child, parent);\n\t\t}\n\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (trees[i].parent == NULL) addRelation(i, 0);\n\t\t}\n\n\t\tprintf(\"%lld\\n\", trees[0].solve());\n\t\tcleanUp(n);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11174","published":1,"updated":"2016-03-15T01:05:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n150020ofdkh3mdembu"},{"title":"「UVa 11137」Ingenuous Cubrency - 递推 / 背包DP","date":"2016-03-13T03:56:43.000Z","_content":"\n给出一个正整数 $ N $（$ N \\leq 1000 $），求有多少种方案把 $ N $ 表示成几个正整数的立方和的形式。\n\n<!-- more -->\n\n### 题目链接\n[UVa 11137](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2078)\n\n### 解题思路\n书上的解法：用 $ f(i, j) $ 表示使用不超过 $ i $ 的整数的立方和表示数 $ j $ 的方案数。以 i 为阶段进行递推，对于每个 j，枚举新一个 $ i^3 $ 项的系数 $ x $ 使 $ j + xi^3 \\leq 1000 $，用 $ f(i - 1, j) $ 去更新 $ f(i, j + xi^3) $。最后 $ f(21, n) $ 即为答案。\n\n书上在最后提到可以优化。考虑将每个立方数看做物品，将 1000 看做背包，则问题转化为：求装满背包的方案。\n\n直接进行完全背包即可。\n\n### AC代码\n#### 解法一\n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXI][MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int j = 0; j <= MAXN; j++) {\n\t\t\tfor (int x = 0, tmp; (tmp = j + x * cube(i)) <= MAXN; x++) f[i][tmp] += f[i - 1][j];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[MAXI][n]);\n\t}\n\treturn 0;\n}\n```\n\n#### 解法二\n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int c = cube(i), j = c; j <= MAXN; j++) {\n\t\t\tf[j] += f[j - c];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[n]);\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/uva-11137.md","raw":"title: 「UVa 11137」Ingenuous Cubrency - 递推 / 背包DP\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - 递推\n  - DP\n  - 背包DP\npermalink: uva-11137\ndate: 2016-03-13 11:56:43\n---\n\n给出一个正整数 $ N $（$ N \\leq 1000 $），求有多少种方案把 $ N $ 表示成几个正整数的立方和的形式。\n\n<!-- more -->\n\n### 题目链接\n[UVa 11137](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2078)\n\n### 解题思路\n书上的解法：用 $ f(i, j) $ 表示使用不超过 $ i $ 的整数的立方和表示数 $ j $ 的方案数。以 i 为阶段进行递推，对于每个 j，枚举新一个 $ i^3 $ 项的系数 $ x $ 使 $ j + xi^3 \\leq 1000 $，用 $ f(i - 1, j) $ 去更新 $ f(i, j + xi^3) $。最后 $ f(21, n) $ 即为答案。\n\n书上在最后提到可以优化。考虑将每个立方数看做物品，将 1000 看做背包，则问题转化为：求装满背包的方案。\n\n直接进行完全背包即可。\n\n### AC代码\n#### 解法一\n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXI][MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int j = 0; j <= MAXN; j++) {\n\t\t\tfor (int x = 0, tmp; (tmp = j + x * cube(i)) <= MAXN; x++) f[i][tmp] += f[i - 1][j];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[MAXI][n]);\n\t}\n\treturn 0;\n}\n```\n\n#### 解法二\n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int c = cube(i), j = c; j <= MAXN; j++) {\n\t\t\tf[j] += f[j - c];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[n]);\n\t}\n\treturn 0;\n}\n```\n","slug":"uva-11137","published":1,"updated":"2016-03-15T01:05:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n1d002cofdkbfyq92d0"},{"title":"「UVa 10253」Series-Parallel Networks - 整数划分 + 组合数","date":"2016-03-15T07:35:55.000Z","_content":"\n串并联网络有两个端点，一个是源，一个是汇，递归定义如下：\n\n1. 一条单独的边是串并联网络；\n2. 若 $ G1 $ 和 $ G2 $ 是串并联网络，则将它们的源和汇分别接在一起也能得到串并联网络（并联）；\n3. 若 $ G1 $ 和 $ G2 $ 是串并联网络，则将 $ G1 $ 的源和 $ G2 $ 的汇接在一起也能得到串并联网络（串联）；\n\n并联或串联在一起的各个部分可以调换顺序，顺序改变后的串并联网络和之前是相同的。求 $ N $ 条边能组成多少种不同的串并联网络。\n\n<!-- more -->\n\n### 题目链接\n[UVa 10253](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1194)\n\n### 解题思路\n书上的解法，考虑每个串并联网络都是一棵树，组成网络的几个部分是树的子节点，那么叶子节点就对应了网络中的边，并且整棵树从根到叶子，父子关系所代表的连接方式是交替着的，某一层是并联，则下一层即为串联。同一种树的形态，第一层的连接方式不同，也就对应了两个网络。\n\n问题转化为，求有多少子节点有序且有 $ N $ 个叶子节点的形态不同的树。设 $ f(n) $ 为答案，则可以根据各个子树所『分得』的叶子节点数量来递归求解 —— 回溯法枚举 $ n $ 的**整数划分**，就得到了单层子树所有的情况。\n\n假设整数划分的某一种方案中，有 $ k $ 个 $ i $，求这 $ k $ 棵子树的方案数可使用组合数：从 $ f(i) $ 个中选择 $ k $ 个，可重复选择，答案为 $ \\binom{f(i) + k - 1}{k} $。计算出每一组子树的方案数，相乘即为根节点的答案。\n\n最终答案为 $ f(n) * 2 $，注意 $ n = 1 $ 时答案为 $ 1 $。\n\n### AC代码\n```c++\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 30;\n\nlong long solve(int n);\nvoid search(std::vector<int> &v, int t, int r);\n\nlong long C(long long n, long long m) {\n\tlong long result = 1;\n\tfor (int k = 1; k <= m; k++) {\n\t\tresult = result * (n - k + 1) / k;\n\t}\n\treturn result;\n}\n\nlong long process(std::vector<int> &v) {\n\tlong long ans = 1;\n\tint count = 0, last = 0;\n\tfor (int i = 0; i < (int)v.size(); i++) {\n\t\tif (last != v[i] && last != 0) {\n\t\t\tans *= C(solve(last) + count - 1, count);\n\t\t\tcount = 1;\n\t\t} else {\n\t\t\tcount++;\n\t\t}\n\n\t\tlast = v[i];\n\t}\n\n\tans *= C(solve(last) + count - 1, count);\n\n\t// printf(\"process = %lld\\n\", ans);\n\treturn ans;\n}\n\nlong long divide(std::vector<int> &v, int r, int t = 1) {\n\tif (r == 0) {\n\t\tif (v.size() == 1) return 0;\n\t\t// for (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) printf(\"%d \", *p);\n\t\t// putchar('\\n');\n\t\t// return 0;\n\t\treturn process(v);\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = t; i <= r; i++) {\n\t\tv.push_back(i);\n\t\tans += divide(v, r - i, i);\n\t\tv.pop_back();\n\t}\n\n\treturn ans;\n}\n\nlong long solve(int n) {\n\tstatic long long mem[MAXN];\n\tstatic bool calced[MAXN];\n\tlong long &ans = mem[n - 1];\n\t\n\tif (calced[n - 1]) return ans;\n\tcalced[n - 1] = true;\n\n\tif (n == 1) return ans = 1;\n\n\tstd::vector<int> v;\n\tans = divide(v, n);\n\n\t// printf(\"f(%d) = %lld\\n\", n, ans);\n\treturn ans;\n}\n\nint main() {\n\tfor (int n; ~scanf(\"%d\", &n) && n != 0; printf(\"%lld\\n\", n == 1 ? 1 : solve(n) * 2));\n\treturn 0;\n}\n```\n","source":"_posts/uva-10253.md","raw":"title: 「UVa 10253」Series-Parallel Networks - 整数划分 + 组合数\ncategories: OI\ntags: \n  - UVa\n  - 数学\n  - 递推\n  - 计数原理\n  - 组合数\n  - 整数划分\n  - 回溯\npermalink: uva-10253\ndate: 2016-03-15 15:35:55\n---\n\n串并联网络有两个端点，一个是源，一个是汇，递归定义如下：\n\n1. 一条单独的边是串并联网络；\n2. 若 $ G1 $ 和 $ G2 $ 是串并联网络，则将它们的源和汇分别接在一起也能得到串并联网络（并联）；\n3. 若 $ G1 $ 和 $ G2 $ 是串并联网络，则将 $ G1 $ 的源和 $ G2 $ 的汇接在一起也能得到串并联网络（串联）；\n\n并联或串联在一起的各个部分可以调换顺序，顺序改变后的串并联网络和之前是相同的。求 $ N $ 条边能组成多少种不同的串并联网络。\n\n<!-- more -->\n\n### 题目链接\n[UVa 10253](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1194)\n\n### 解题思路\n书上的解法，考虑每个串并联网络都是一棵树，组成网络的几个部分是树的子节点，那么叶子节点就对应了网络中的边，并且整棵树从根到叶子，父子关系所代表的连接方式是交替着的，某一层是并联，则下一层即为串联。同一种树的形态，第一层的连接方式不同，也就对应了两个网络。\n\n问题转化为，求有多少子节点有序且有 $ N $ 个叶子节点的形态不同的树。设 $ f(n) $ 为答案，则可以根据各个子树所『分得』的叶子节点数量来递归求解 —— 回溯法枚举 $ n $ 的**整数划分**，就得到了单层子树所有的情况。\n\n假设整数划分的某一种方案中，有 $ k $ 个 $ i $，求这 $ k $ 棵子树的方案数可使用组合数：从 $ f(i) $ 个中选择 $ k $ 个，可重复选择，答案为 $ \\binom{f(i) + k - 1}{k} $。计算出每一组子树的方案数，相乘即为根节点的答案。\n\n最终答案为 $ f(n) * 2 $，注意 $ n = 1 $ 时答案为 $ 1 $。\n\n### AC代码\n```c++\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 30;\n\nlong long solve(int n);\nvoid search(std::vector<int> &v, int t, int r);\n\nlong long C(long long n, long long m) {\n\tlong long result = 1;\n\tfor (int k = 1; k <= m; k++) {\n\t\tresult = result * (n - k + 1) / k;\n\t}\n\treturn result;\n}\n\nlong long process(std::vector<int> &v) {\n\tlong long ans = 1;\n\tint count = 0, last = 0;\n\tfor (int i = 0; i < (int)v.size(); i++) {\n\t\tif (last != v[i] && last != 0) {\n\t\t\tans *= C(solve(last) + count - 1, count);\n\t\t\tcount = 1;\n\t\t} else {\n\t\t\tcount++;\n\t\t}\n\n\t\tlast = v[i];\n\t}\n\n\tans *= C(solve(last) + count - 1, count);\n\n\t// printf(\"process = %lld\\n\", ans);\n\treturn ans;\n}\n\nlong long divide(std::vector<int> &v, int r, int t = 1) {\n\tif (r == 0) {\n\t\tif (v.size() == 1) return 0;\n\t\t// for (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) printf(\"%d \", *p);\n\t\t// putchar('\\n');\n\t\t// return 0;\n\t\treturn process(v);\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = t; i <= r; i++) {\n\t\tv.push_back(i);\n\t\tans += divide(v, r - i, i);\n\t\tv.pop_back();\n\t}\n\n\treturn ans;\n}\n\nlong long solve(int n) {\n\tstatic long long mem[MAXN];\n\tstatic bool calced[MAXN];\n\tlong long &ans = mem[n - 1];\n\t\n\tif (calced[n - 1]) return ans;\n\tcalced[n - 1] = true;\n\n\tif (n == 1) return ans = 1;\n\n\tstd::vector<int> v;\n\tans = divide(v, n);\n\n\t// printf(\"f(%d) = %lld\\n\", n, ans);\n\treturn ans;\n}\n\nint main() {\n\tfor (int n; ~scanf(\"%d\", &n) && n != 0; printf(\"%lld\\n\", n == 1 ? 1 : solve(n) * 2));\n\treturn 0;\n}\n```\n","slug":"uva-10253","published":1,"updated":"2016-03-15T09:12:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n1h002kofdkt0rfrcr0"},{"title":"「Tyvj 3317」火车票 - 划分DP","id":"18","updated":"2016-01-19T13:05:08.000Z","date":"2016-01-11T21:29:30.000Z","_content":"\n铁路线上有n（2 ≤ n ≤ 10000）个火车站，每个火车站到该线路的首发火车站距离都是已知的。任意两站之间的票价如下表所示：\n\n$$\\cases{0< X≤L1 & C1 \\\\ L1< X≤L2 & C2 \\\\ L2< X≤L3 & C3}$$\n\n其中L1，L2，L3，C1，C2，C3都是已知的正整数，且($1 ≤ L1 < L2 < L3 ≤ 10^9$, $1 ≤ C1 < C2 < C3 ≤ 10^9$)。显然若两站之间的距离大于 L3，那么从一站到另一站至少要买两张票。\n\n注意：每一张票在使用时只能从一站开始到另一站结束。\n\n对于给出的起点和终点，求出最省钱的方案。\n\n<!-- more -->\n\n### 题目链接\n[Tyvj 3317](http://tyvj.cn/p/3317)  \n[CodeVS 1349](http://codevs.cn/problem/1349/)\n\n### 解题思路\n以经过火车站站点的数量划分阶段，用 $a[i]$表示从站点 `0` 到站点 `i` 的距离，用 $f[i]$ 表示从起点 `s` 到站点 `i` 所需要的最少花费，则转移方程为：\n\n$$ f[i] = \\min\\{f[k]+cost(k,i),k{\\in}[s,i) \\ {\\rm and} \\ a[i]-a[k]≤L3\\} $$\n\n边界条件为\n\n$$ f[s] = 0 $$\n\n### AC代码\n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10000;\n\nint n, a[MAXN], s, t;\nint L1, L2, L3, C1, C2, C3;\n\nint ans[MAXN];\nbool calced[MAXN];\n\ninline int cost(int s, int t) {\n\tint L = a[t - 1] - a[s - 1];\n\tif (L > L3) return INT_MAX;\n\telse if (L > L2) return C3;\n\telse if (L > L1) return C2;\n\telse return C1;\n}\n\nint search(int i) {\n\tif (i == s) return 0;\n\n\tif (!calced[i - 1]) {\n\t\tans[i - 1] = INT_MAX;\n\t\tfor (int k = s; k < i; k++) {\n\t\t\tif (cost(k, i) == INT_MAX) continue;\n\t\t\tans[i - 1] = std::min(ans[i - 1], search(k) + cost(k, i));\n\t\t}\n\t\tcalced[i - 1] = true;\n\t}\n\n\treturn ans[i - 1];\n}\n\nint main() {\n\tscanf(\"%d %d %d %d %d %d\", &L1, &L2, &L3, &C1, &C2, &C3);\n\tscanf(\"%d\\n%d %d\", &n, &s, &t);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tif (s > t) std::swap(s, t);\n\n\tprintf(\"%d\\n\", search(t));\n\n\treturn 0;\n}\n```","source":"_posts/tyvj-3317.md","raw":"title: 「Tyvj 3317」火车票 - 划分DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - Tyvj\n  - 划分DP\npermalink: tyvj-3317\nid: 18\nupdated: '2016-01-19 21:05:08'\ndate: 2016-01-12 05:29:30\n---\n\n铁路线上有n（2 ≤ n ≤ 10000）个火车站，每个火车站到该线路的首发火车站距离都是已知的。任意两站之间的票价如下表所示：\n\n$$\\cases{0< X≤L1 & C1 \\\\ L1< X≤L2 & C2 \\\\ L2< X≤L3 & C3}$$\n\n其中L1，L2，L3，C1，C2，C3都是已知的正整数，且($1 ≤ L1 < L2 < L3 ≤ 10^9$, $1 ≤ C1 < C2 < C3 ≤ 10^9$)。显然若两站之间的距离大于 L3，那么从一站到另一站至少要买两张票。\n\n注意：每一张票在使用时只能从一站开始到另一站结束。\n\n对于给出的起点和终点，求出最省钱的方案。\n\n<!-- more -->\n\n### 题目链接\n[Tyvj 3317](http://tyvj.cn/p/3317)  \n[CodeVS 1349](http://codevs.cn/problem/1349/)\n\n### 解题思路\n以经过火车站站点的数量划分阶段，用 $a[i]$表示从站点 `0` 到站点 `i` 的距离，用 $f[i]$ 表示从起点 `s` 到站点 `i` 所需要的最少花费，则转移方程为：\n\n$$ f[i] = \\min\\{f[k]+cost(k,i),k{\\in}[s,i) \\ {\\rm and} \\ a[i]-a[k]≤L3\\} $$\n\n边界条件为\n\n$$ f[s] = 0 $$\n\n### AC代码\n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10000;\n\nint n, a[MAXN], s, t;\nint L1, L2, L3, C1, C2, C3;\n\nint ans[MAXN];\nbool calced[MAXN];\n\ninline int cost(int s, int t) {\n\tint L = a[t - 1] - a[s - 1];\n\tif (L > L3) return INT_MAX;\n\telse if (L > L2) return C3;\n\telse if (L > L1) return C2;\n\telse return C1;\n}\n\nint search(int i) {\n\tif (i == s) return 0;\n\n\tif (!calced[i - 1]) {\n\t\tans[i - 1] = INT_MAX;\n\t\tfor (int k = s; k < i; k++) {\n\t\t\tif (cost(k, i) == INT_MAX) continue;\n\t\t\tans[i - 1] = std::min(ans[i - 1], search(k) + cost(k, i));\n\t\t}\n\t\tcalced[i - 1] = true;\n\t}\n\n\treturn ans[i - 1];\n}\n\nint main() {\n\tscanf(\"%d %d %d %d %d %d\", &L1, &L2, &L3, &C1, &C2, &C3);\n\tscanf(\"%d\\n%d %d\", &n, &s, &t);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tif (s > t) std::swap(s, t);\n\n\tprintf(\"%d\\n\", search(t));\n\n\treturn 0;\n}\n```","slug":"tyvj-3317","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n1u002wofdkmrks4ex1"},{"title":"Tarjan 强联通分量学习笔记","date":"2016-03-03T13:12:23.000Z","_content":"\n在一个有向图中，如果某两点间都有**互相**到达的路径，那么称中两个点**强联通**，如果任意两点都强联通，那么称这个图为**强联通图**；一个有向图的**极大**强联通子图称为**强联通分量**。\n\nTarjan 算法可以在 $ O(n + m) $ 的时间内求出一个图的所有强联通分量。\n\n<!-- more -->\n\n### 定义\nTarjan 算法的核心过程是一次 DFS，它基于的事实是，一个强联通分量中的点一定处于搜索树中同一棵子树中。\n\n栈，搜索树中同一棵子树中的点在栈中是相邻的。\n\n$ {\\rm dfn}(u) $ 表示进入节点 $ u $ 时的时间。\n\n$ {\\rm low}(u) $ 表示由节点 $ u $ 开始搜索所能到达的点中，在搜索树上是 $ u $ 的祖先且 $ {\\rm dfn} $ 最小的节点的 $ {\\rm dfn} $。\n\n### 算法描述\n1. 从起点开始 DFS；\n2. 进入一个节点时，初始化它的 $ {\\rm dfn} $ 和 $ {\\rm low} $ 均为当前时间戳，并进栈；\n3. 枚举当前点 $ v $ 的所有邻接点；\n4. 如果某个邻接点 $ u $ 已在栈中，则更新 $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $；\n5. 如果某个邻接点 $ u $ 未被访问过，则对 $ u $ 进行 DFS，并在回溯后更新 $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low(u)}) $；\n6. 所有邻接点回溯完成后，如果当前点仍满足 $ {\\rm low}(v) = {\\rm dfn}(v) $，则将栈中从 $ v $ 到栈顶的所有元素出栈，并标记为一个强联通分量。\n\n### 解释\n枚举 $ v $ 的邻接点时，如果某个邻接点 $ u $ 已在栈中，则更新\n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $$\n\n因为栈中的所有点均为搜索树上点 $ v $ 的祖先，从搜索树上一个点搜到它的祖先，说明找到了一个环。此时用 $ u $ 去更新 $ v $ 的最远祖先。\n\n如果某个邻接点 $ u $ 未被访问过，则对 $ u $ 进行 DFS，并在回溯后更新\n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low}(u)) $$\n\n点 $ u $ 出发能到达的点，点 $ v $ 必定也能到达。尽管 $ {\\rm low}(u) $ 可能不是 $ v $ 的祖先（可能是 $ u $ 或 $ v $ 本身），但这并不影响。\n\n所有邻接点回溯完成后，如果当前点仍满足\n\n$$ {\\rm low}(v) = {\\rm dfn}(v) $$\n\n说明从当前点出发不可能回到任意一个搜索树上的祖先，即当前节点是某个强联通分量所在子树的根节点，而这些节点都在当前节点之后被压在了栈中。\n\n注意，$ {\\rm low} $ 值相同的两个点**一定**在同一个强联通分量中，但反之不成立，同一个强联通分量的点可能有不同的 $ {\\rm low} $ 值。\n\n### 模板\n实际代码中要用到两个栈，一个用于控制 DFS（代码中的 `s`），另一个用于 Tarjan 算法（代码中的 `t`）。\n\n因为图不一定是弱连通图，所以要以每个点为起点进行一次上述算法。\n\n```cpp\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tConnected *connected;\n\tint dfn, low;\n\tbool inStack, visited, pushed;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n} connecteds[MAXN];\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n```\n","source":"_posts/tarjan-scc-notes.md","raw":"title: Tarjan 强联通分量学习笔记\ncategories: OI\ntags: \n  - 学习笔记\n  - 图论\n  - 强联通分量\n  - Tarjan\n  - 算法模板\npermalink: tarjan-scc-notes\ndate: 2016-03-03 21:12:23\n---\n\n在一个有向图中，如果某两点间都有**互相**到达的路径，那么称中两个点**强联通**，如果任意两点都强联通，那么称这个图为**强联通图**；一个有向图的**极大**强联通子图称为**强联通分量**。\n\nTarjan 算法可以在 $ O(n + m) $ 的时间内求出一个图的所有强联通分量。\n\n<!-- more -->\n\n### 定义\nTarjan 算法的核心过程是一次 DFS，它基于的事实是，一个强联通分量中的点一定处于搜索树中同一棵子树中。\n\n栈，搜索树中同一棵子树中的点在栈中是相邻的。\n\n$ {\\rm dfn}(u) $ 表示进入节点 $ u $ 时的时间。\n\n$ {\\rm low}(u) $ 表示由节点 $ u $ 开始搜索所能到达的点中，在搜索树上是 $ u $ 的祖先且 $ {\\rm dfn} $ 最小的节点的 $ {\\rm dfn} $。\n\n### 算法描述\n1. 从起点开始 DFS；\n2. 进入一个节点时，初始化它的 $ {\\rm dfn} $ 和 $ {\\rm low} $ 均为当前时间戳，并进栈；\n3. 枚举当前点 $ v $ 的所有邻接点；\n4. 如果某个邻接点 $ u $ 已在栈中，则更新 $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $；\n5. 如果某个邻接点 $ u $ 未被访问过，则对 $ u $ 进行 DFS，并在回溯后更新 $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low(u)}) $；\n6. 所有邻接点回溯完成后，如果当前点仍满足 $ {\\rm low}(v) = {\\rm dfn}(v) $，则将栈中从 $ v $ 到栈顶的所有元素出栈，并标记为一个强联通分量。\n\n### 解释\n枚举 $ v $ 的邻接点时，如果某个邻接点 $ u $ 已在栈中，则更新\n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $$\n\n因为栈中的所有点均为搜索树上点 $ v $ 的祖先，从搜索树上一个点搜到它的祖先，说明找到了一个环。此时用 $ u $ 去更新 $ v $ 的最远祖先。\n\n如果某个邻接点 $ u $ 未被访问过，则对 $ u $ 进行 DFS，并在回溯后更新\n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low}(u)) $$\n\n点 $ u $ 出发能到达的点，点 $ v $ 必定也能到达。尽管 $ {\\rm low}(u) $ 可能不是 $ v $ 的祖先（可能是 $ u $ 或 $ v $ 本身），但这并不影响。\n\n所有邻接点回溯完成后，如果当前点仍满足\n\n$$ {\\rm low}(v) = {\\rm dfn}(v) $$\n\n说明从当前点出发不可能回到任意一个搜索树上的祖先，即当前节点是某个强联通分量所在子树的根节点，而这些节点都在当前节点之后被压在了栈中。\n\n注意，$ {\\rm low} $ 值相同的两个点**一定**在同一个强联通分量中，但反之不成立，同一个强联通分量的点可能有不同的 $ {\\rm low} $ 值。\n\n### 模板\n实际代码中要用到两个栈，一个用于控制 DFS（代码中的 `s`），另一个用于 Tarjan 算法（代码中的 `t`）。\n\n因为图不一定是弱连通图，所以要以每个点为起点进行一次上述算法。\n\n```cpp\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tConnected *connected;\n\tint dfn, low;\n\tbool inStack, visited, pushed;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n} connecteds[MAXN];\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n```\n","slug":"tarjan-scc-notes","published":1,"updated":"2016-03-15T01:45:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n2f0035ofdk17kt6res"},{"title":"差分约束系统学习笔记","date":"2016-01-01T16:18:34.000Z","_content":"\n差分约束系统，就是给出一组形如 $x_i-x_j>=d$ 的不等式，求出这组不等式的一组解。这类问题通常转化为图论中的最短路来解。\n\n<!-- more -->\n\n### 原理\n在图论中，求解单源最短路的算法在进行每一次每条边上的“松弛”操作时，都是根据以下条件：\n\n（其中 `from`、`to` 表示边的起点、终点，`$` 表示某个点到源点的当前距离）\n\n```php\nif ($to > $from + w) {\n    $to = $from + w;\n}\n```\n\n也就是说，每一次松弛操作保证了：\n\n```php\n$to - $from >= w\n```\n\n于是，我们可以把差分约束系统中的变量看做图中的**点**，把不等关系看做**边**，然后对整个图进行一次单源最短路算法，即可使所有不等式满足。\n\n如果图中存在**权值和为负**的环，则说明不等式组无解。\n\n### 实现\n对于每一个不等式 $x_i-x_j>=d$，从 `j` 向 `i` 连一条边，权值为 `d`。\n\n如果不等号的方向相反，即 $x_i-x_j>=d$，则应在不等式两边同时乘以 `-1`，变成 $x_j-x_i<=-d$，即从 `i` 到 `j` 连一条边，权值为 `-d`。\n\n算法初始化时，将源点的 `dist` 置为 `0`，其他的点 `dist` 置为无穷大。若有解，则算法结束后每个点的 `dist` 值即为解。\n\n如果图中有负边，则必须使用 Bellman-Ford 算法，如果 Bellman-Ford 算法在 `n - 1` 次松弛后还继续进行松弛，则说明图中有**权值和为负**的环，原不等式组无解。\n\n如果使用带有队列优化的 Bellman-Ford 算法，则每个点入队次数超过 `n` 时说明图中有**权值和为负**的环，原不等式组无解。\n\n### 例题\n[CodeVS 4416](http://codevs.cn/problem/4416/) - FFF 团卧底的后宫\n\n给出 `n` 个形如 $x_i-x_j<=d$ 或 $x_i-x_j>=d$ 的不等式，求一组使 $x_1$ 与 $x_n$ 差最大的解，输出最大差值，若无解输出 `-1`，若 $x_1$ 与 $x_n$ 的差为无限大则输出 `-2`。\n\n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 10000;\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tbool inQueue;\n\tint dist;\n\tint count;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nint n, m, k;\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].edges = new Edge(&nodes[from], &nodes[to], w);\n}\n\ninline bool bellmanFord() {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\t\tnode->inQueue = false;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->dist > node->dist + edge->w) {\n\t\t\t\tedge->to->dist = node->dist + edge->w;\n\n\t\t\t\tif (!edge->to->inQueue) {\n\t\t\t\t\tedge->to->inQueue = true;\n\t\t\t\t\tedge->to->count++;\n\t\t\t\t\tq.push(edge->to);\n\n\t\t\t\t\tif (edge->to->count > n) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].dist = INT_MAX;\n\t}\n\n\tnodes[0].dist = 0;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(a, b, d);\n\t\t// $b - $a <= d\n\t\t// $a + d >= $b\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(b, a, -d);\n\t\t// $b - $a >= d\n\t\t// $a - $b <= -d\n\t\t// $b + -d >= $a\n\t}\n\n\tif (!bellmanFord()) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tif (nodes[n - 1].dist == INT_MAX) {\n\t\t\tputs(\"-2\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", nodes[n - 1].dist);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/system-of-difference-constraints-notes.md","raw":"title: 差分约束系统学习笔记\ncategories: OI\ntags: \n  - 图论\n  - 学习笔记\n  - 差分约束系统\n  - 最短路\n  - 算法模板\npermalink: system-of-difference-constraints-notes\ndate: 2016-01-02 00:18:34\n---\n\n差分约束系统，就是给出一组形如 $x_i-x_j>=d$ 的不等式，求出这组不等式的一组解。这类问题通常转化为图论中的最短路来解。\n\n<!-- more -->\n\n### 原理\n在图论中，求解单源最短路的算法在进行每一次每条边上的“松弛”操作时，都是根据以下条件：\n\n（其中 `from`、`to` 表示边的起点、终点，`$` 表示某个点到源点的当前距离）\n\n```php\nif ($to > $from + w) {\n    $to = $from + w;\n}\n```\n\n也就是说，每一次松弛操作保证了：\n\n```php\n$to - $from >= w\n```\n\n于是，我们可以把差分约束系统中的变量看做图中的**点**，把不等关系看做**边**，然后对整个图进行一次单源最短路算法，即可使所有不等式满足。\n\n如果图中存在**权值和为负**的环，则说明不等式组无解。\n\n### 实现\n对于每一个不等式 $x_i-x_j>=d$，从 `j` 向 `i` 连一条边，权值为 `d`。\n\n如果不等号的方向相反，即 $x_i-x_j>=d$，则应在不等式两边同时乘以 `-1`，变成 $x_j-x_i<=-d$，即从 `i` 到 `j` 连一条边，权值为 `-d`。\n\n算法初始化时，将源点的 `dist` 置为 `0`，其他的点 `dist` 置为无穷大。若有解，则算法结束后每个点的 `dist` 值即为解。\n\n如果图中有负边，则必须使用 Bellman-Ford 算法，如果 Bellman-Ford 算法在 `n - 1` 次松弛后还继续进行松弛，则说明图中有**权值和为负**的环，原不等式组无解。\n\n如果使用带有队列优化的 Bellman-Ford 算法，则每个点入队次数超过 `n` 时说明图中有**权值和为负**的环，原不等式组无解。\n\n### 例题\n[CodeVS 4416](http://codevs.cn/problem/4416/) - FFF 团卧底的后宫\n\n给出 `n` 个形如 $x_i-x_j<=d$ 或 $x_i-x_j>=d$ 的不等式，求一组使 $x_1$ 与 $x_n$ 差最大的解，输出最大差值，若无解输出 `-1`，若 $x_1$ 与 $x_n$ 的差为无限大则输出 `-2`。\n\n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 10000;\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tbool inQueue;\n\tint dist;\n\tint count;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nint n, m, k;\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].edges = new Edge(&nodes[from], &nodes[to], w);\n}\n\ninline bool bellmanFord() {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\t\tnode->inQueue = false;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->dist > node->dist + edge->w) {\n\t\t\t\tedge->to->dist = node->dist + edge->w;\n\n\t\t\t\tif (!edge->to->inQueue) {\n\t\t\t\t\tedge->to->inQueue = true;\n\t\t\t\t\tedge->to->count++;\n\t\t\t\t\tq.push(edge->to);\n\n\t\t\t\t\tif (edge->to->count > n) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].dist = INT_MAX;\n\t}\n\n\tnodes[0].dist = 0;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(a, b, d);\n\t\t// $b - $a <= d\n\t\t// $a + d >= $b\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(b, a, -d);\n\t\t// $b - $a >= d\n\t\t// $a - $b <= -d\n\t\t// $b + -d >= $a\n\t}\n\n\tif (!bellmanFord()) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tif (nodes[n - 1].dist == INT_MAX) {\n\t\t\tputs(\"-2\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", nodes[n - 1].dist);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"system-of-difference-constraints-notes","published":1,"updated":"2016-03-15T01:45:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n2l003hofdki6w2w8en"},{"title":"STL 在 OI 中的应用","id":"8","updated":"2016-02-17T02:35:37.000Z","date":"2015-12-23T21:43:15.000Z","_content":"\n在 OI 竞赛中，可以使用的语言有 C++、C、Pascal，其中 C++ 最大的优势是，它本身提供了一个模板库 —— Standard Template Library（标准模板库），简称 STL。STL 包含一系列算法和容器等，合理地使用 STL，可以在提高编写代码的效率。NOI 系列比赛自 2011 年起允许 C++ 选手使用 STL，所以我们应该利用好 STL，发挥 C++ 语言的优势。\n\n<!-- more -->\n\n### 分类\n> STL 可分为容器（containers）、迭代器（iterators）、空间配置器（allocator）、配接器（adapters）、算法（algorithms）、仿函数（functors）六个部分。\n\n本文主要讲解容器、迭代器、算法，其他的几个部分在竞赛中很少使用到。\n\n### 命名空间\n命名空间（namespace）是 C++ 的一个特性，它被用于解决名称冲突，比如假设 Menci 和 aby890 都在自己的头文件里编写了一个 `work()` 函数，如果这两个函数我们都要用，则名称会产生冲突，但如果两人都将自己的函数写在单独的命名空间内，就成了 `Menci::work()` 和 `aby890::work()`，就不会冲突了。\n\nSTL 的所有内容都包含在 `std` 命名空间内。为什么命名空间不叫 `stl`？我也不知道。\n\n如果我们要调用 STL 中的 `sort` 函数（下文会有提到），要这样写：\n\n```cpp\nstd::sort(a, a + n);\n```\n\n我们也可以将 `std::sort` 这个函数“导入”到全局中，就可以直接 `sort(a, a + n)` 这样调用了。  \n使用 `using` 关键字来“导入”命名空间中的函数或类。\n\n```cpp\nusing std::sort;\n```\n\n也可以将整个命名空间导入全局，这样就可以直接访问命名空间中的所有内容，但更容易产生名称冲突（比如你可能会声明一个叫做 `max` 的变量，但它会覆盖 STL 中的 `max` 函数）。  \n使用 `using namespace` 来“导入”整个命名空间。\n\n```cpp\nusing namespace std;\n```\n\n### 算法\nSTL 中的算法主要包含在 `<algorithm>` 头文件中，这个文件名要记住，每天念一遍。\n\n##### 排序\nSTL 中提供一系列与排序有关的函数，其中最常用到的是 `sort` 和 `stable_sort`，`sort` 是不稳定的排序，它的期望时间复杂度为 $O(n {\\log} n)$，`stable_sort` 是稳定的排序，它的时间复杂度为 $O(n {\\log} n)$。\n\n`sort` 使用类似与快速排序的算法，在大多数情况下能获得最高的效率，`stable_sort` 使用多路归并排序算法，可以在稳定的前提下取得较高的效率。一般常用 `sort`。\n\n用法（以 `sort` 为例，`stable_sort` 相同）：\n\n对左闭右开区间 [l, r) 排序，使用 `sort(l, r)`。其中 l 和 r 是指向元素的**迭代器**，在了解**迭代器**之前，我们可以将其理解为指向元素的指针。\n\n注意这里的区间表示是一个**左闭右开区间**，STL 中经常会出现这种区间，如果我们要对一个数组 a 的前 n 个元素进行排序，则对应区间为 [a, a + n)，因为 a 指向数组的第一个元素（下标为 0），a + n 指向数组的第 n 个元素**之后**。\n\n`sort` 函数默认是升序排序，如果需要降序，可以通过自定义“比较函数”来实现。\n\n```cpp\nbool compare(int a, int b) {\n    return a > b;\n}\n\nstd::sort(a, a + n, &compare);\n```\n\n下面的代码演示了读入 n（n <= 100000）个数，并**降序**排序后输出。\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint n;\nint a[MAXN];\n\nbool compare(int a, int b) {\n    return a > b;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tstd::sort(a, a + n, &compare);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d\\n\", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n降序排序是**大于号**，升序排序是**小于号**（注意**不能**加等号变成大于等于、小于等于），如果不指定比较函数，默认为**升序**。\n\n也可以通过**重载运算符**或者定义**比较函数**的方法对结构体进行排序：\n\n```cpp\nstruct student_t {\n    unsigned int id;\n    long double score;\n \n    bool operator<(const student_t &other) const {\n        return score < other.score;\n    }\n} students[MAXN];\n \nbool compare(const student_t &student1, const student_t &student2) {\n    return student1.score < student2.score;\n}\n \nstd::sort(students, students + n, &compare);\n```\n\n写在结构体中的 `operator<` 即为重载运算符，这让我们的结构体支持小于号的比较操作。  \n结构体下面的 `compare` 是比较函数，**比较函数**和**重载运算符**只需要写一个就够了。\n\n注意两种写法中的 `const` 和 `&` 都不能省略。\n\n##### 去重\n\n使用 `unique` 函数来去除数组中的重复元素，其调用格式与 `sort` 类似，注意调用 `unique` 前必须保证数组是有序的（升序降序都可以）。\n\n```cpp\nstd::sort(a, a + n);\nstd::unique(a, a + n);\n```\n\n`unique` 函数返回去重后的数组的最后一个元素之后，一般通过用返回值减去首地址的方法获得不重复的元素数量：\n\n```cpp\nint count = std::unique(a, a + n) - a;\n```\n\n下面的代码演示了读入 n（n <= 100000）个数，并升序排序并去重后输出。\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n \nconst int MAXN = 100000;\n \nint n;\nint a[MAXN];\n \nint main() {\n    scanf(\"%d\", &n);\n \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n \n    std::sort(a, a + n);\n    int count = std::unique(a, a + n) - a;\n \n    for (int i = 0; i < count; i++) {\n        printf(\"%d\\n\", a[i]);\n    }\n \n    return 0;\n}\n```\n\n##### 较大、较小值\n\n使用 `max` 和 `min` 来取得两个数中较大或较小的。\n\n```cpp\nint a = -1, b = 890;\nx = std::max(a, b); // 结果为 890\ny = std::min(a, b); // 结果为 -1\n```\n\n##### 查找\n\nSTL 中常用的用于查找的函数有三个：`lower_bound`、`upper_bound`、`binary_search`，一般 `lower_bound` 最为常用。\n\n`lower_bound` 用于在一个升序序列中查找某个元素，并返回第一个**不小于**该元素的元素的迭代器，如果找不到，则返回指向序列中最后一个元素**之后**的迭代器。\n\n`upper_bound` 用于在一个升序序列中查找某个元素，并返回第一个**大于**该元素的元素的迭代器，如果找不到，则返回指向序列中最后一个元素**之后**的迭代器。\n\n`binary_search` 用于确定某个元素有没有在一个升序序列中出现过，返回 `true` 或 `false`。\n\n三个函数的时间复杂度均为$O({\\log}n)$。\n\n```cpp\nint a[8] = { -9, 5, -1, 2, 7, 1, -2, 2 }, n = 8;\n\nstd::sort(a, a + n);\n\n// a = { -9, -2, -1, 1, 2, 2, 5, 7 }\n\nint *p1 = std::lower_bound(a, a + n, 1);\n// p1 指向 a 中第 4 个元素 a[3] = 1\n\nint *p2 = std::lower_bound(a, a + n, 2);\n// p2 指向 a 中第 5 个元素 a[4] = 2\n\nint *p3 = std::upper_bound(a, a + n, 2);\n// p3 指向 a 中第 7 个元素 a[6] = 5\n\nint *p4 = std::lower_bound(a, a + n, 8);\n// p4 = a + n，因为数组 a 中没有不小于 8 的元素，此时访问 *p4 会越界\n\nbool flag = std::binary_search(a, a + n, 3);\n// flag = false 因为数组 a 中没有 3\n```\n\n##### 交换\n使用 `swap` 函数交换两个变量的值。\n\n```cpp\nint a = -1, b = 1;\nstd::swap(a, b);\n\n// a = 1, b = -1\n```\n\n### 迭代器\n迭代器是用于访问 STL 容器中元素的一种数据类型，一般迭代器的声明如下：\n\n```cpp\nstd::CONTAINER<T>::iterator p;\n```\n\n上述代码声明了一个迭代器 `p`，其中 `CONTAINER` 是容器类型，可以是 `vector`、`set` 等，`T` 是容器中元素的类型。\n\n一般的，容器的 `begin()` 方法返回**首个元素**的迭代器， `end()` 方法返回**最后一个元素之后**的迭代器。这两个迭代器确定了一个包含容器内所有元素的**左闭右开区间** `[begin(), end())`。对于任何指向有效元素的迭代器都有其**不等于** `end()`，`end()` 并不指向任何一个元素，试图访问 `end()` 对应的元素是非法的。\n\n在使用 STL 提供的算法时，可以用迭代器表示一个区间，如：\n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n一些容器的迭代器可以支持**随机访问**，如指向 `vector[i]` 的迭代器为 `vector.begin() + i`，而另一些容器如 `set` 不支持这种用法。\n\n所有的迭代器都支持使用 `++` 和 `--` 运算符将迭代器加一或减一。\n\n迭代器的用法类似于指向数组元素的指针，对于迭代器 `p`，用 `*p` 得到迭代器对应的元素；如果该迭代器所对应的元素类型为结构体，则可以直接使用 `->` 访问其对应结构体中的元素。\n\n一般的，使用迭代器遍历容器类似于下述代码：\n\n```cpp\nfor (std::CONTAINER<T>::iterator p = C.begin(); p != C.end(); p++) {\n    std::cout << *p << std::endl;\n}\n```\n\n### 容器\n\n##### 数组 vector\nSTL 在头文件 `<vector>` 提供了一个**可变长**的数组 `vector`，它支持动态的插入、删除操作。\n\n以下代码声明了一个 `vector`，它的每个元素类型为 `int`，初始元素数量为 0。\n\n```cpp\nstd::vector<int> v;\n```\n\n以下代码声明了一个 `vector`，它的每个元素类型为 `int`，初始元素数量为 n。\n\n```cpp\nstd::vector<int> v(n);\n```\n\n`vector` 提供 `begin()` 和 `end()`，分别获取指向**第一个元素**和**最后一个元素之后**的迭代器。\n\n以下代码对 v 中的所有元素以升序排序：\n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n使用 `size()` 得到 `vector` 的元素数量，使用 `resize()` 重新指定 `vector` 的元素数量。\n\n分别使用 `push_back()` 和 `pop_back()` 在 `vector` 的**尾部**加入或删除元素，这两个过程的时间复杂度为$O(1)$。\n\n使用 `insert()` 在某个特定的位置插入一个元素，时间复杂度为$O(n)$。\n\n使用 `erase()` 删除某个位置的元素，时间复杂度为$O(n)$。\n\n```cpp\nstd::vector<int> v;\n// v.size() = 0\n\nv.push_back(23333);\n// v.size() = 1, v = { 23333 }\n\nv.insert(v.begin() + 0, 890);\n// v.size() = 2, v = { 890, 23333 }\n\nv.insert(v.begin() + 1, 12345);\n// v.size() = 3, v = { 890, 12345, 23333 }\n\nv.erase(v.begin() + 0);\n// v.size() = 2, v = { 12345, 23333 }\n\nfor (nt i = 0; i < v.size(); i++) {\n    printf(\"%d\\n\", v[i]);\n}\n// 依次输出 12345、23333\n\nv.pop_back();\n// v.size() = 1, v = { 12345 }\n```\n\n注意，在加入元素时，如果 `vector` 拥有的内存空间不足以存放欲加入的元素，则 `vector` 会申请一块新的内存，并将旧数据拷贝过去，这个过程通常花费 $O(n)$ 的时间。\n\n##### 集合 set\nSTL 在头文件 `<set>` 中提供了一个**有序集合** `set`，其中的元素全部是**唯一**的，并且插入进的元素自动按照升序排列，但 `set` 不支持通过下标定位某个元素，只能通过**迭代器**遍历。\n\n以下代码声明了一个 `int` 类型的集合。\n\n```cpp\nstd::set<int> s;\n```\n\n使用 `insert()` 在集合中加入一个元素，其时间复杂度为$O({\\log}n)$。\n\n使用 `erase()` 删除集合中**某个元素**或**某个位置的元素**，其时间复杂度均为$O({\\log}n)$。\n\n`set` 自身提供 `lower_bound()` 用于定位元素，其作用与前文中的同名函数类似，也可以使用 `find()` 来精确查找元素。\n\n遍历 `set` 只能使用**迭代器**。`set` 的迭代器为 `set<T>::iterator`，其中 `T` 为元素类型。\n\n```cpp\nstd::set<int> s;\n\ns.insert(23333);\ns.insert(23333); // 重复插入无效\ns.insert(66666);\ns.insert(890);\ns.insert(-1);\n// s.size() = 4, s = { -1, 890, 23333, 66666 }\n\ns.erase(66666);\n// s.size() = 3, s = { -1, 890, 23333 }\n\nstd::set<int>::iterator p1 = s.lower_bound(555);\n// *p1 = 890\n\nstd::set<int>::iterator p2 = s.find(555);\n// p2 = s.end()，因为未找到 555\n\ns.erase(p1);\n// s.size() = 2, s = { -1, 23333 }\n\nfor (std::set<int>::iterator p = s.begin(); p != s.end(); p++) {\n    printf(\"%d\\n\", *p);\n}\n// 依次输出 -1、23333\n```\n\n上述代码中运用的迭代器的方法在 STL 容器中较为常见。\n\n##### 字符串 string\nSTL 在头文件 `<string>` 中将一些与字符串有关的操作封装在了 `string` 内。\n\n使用 `cin` 和 `cout` 来输入、输出字符串。\n\n使用 `find()` 查找另一个字符串在该字符串中的出现位置，返回结果从 0 开始。\n\n使用 `c_str()` 获得 `string` 对应的 `const char *` 类型数据，可用于向 C 库函数传递。\n\n```cpp\nstd::string s = \"Menci\";\n\nint pos = s.find(\"23333\");\n// pos = string::npos，因为没有找到 23333\n\npos = s.find(\"ci\");\n// pos = 3，因为出现位置为第 4 个字符\n\nchar ch = s[0];\n// ch = 'M'\n\nstd::cout << s << std::endl;\nputs(s.c_str());\n// 输出两次 Menci\n```\n\n##### 队列 queue\nSTL 在头文件 `<queue>` 中提供了先入先出（FIFO）队列 `queue`。\n\n使用 `push()` 向队列中加入元素。\n\n使用 `front()` 获取队首元素（并不删除）。\n\n使用 `pop()` 删除队首元素。\n\n使用 `empty()` 判断队列是否为空。\n\n```cpp\nstd::queue<int> q;\n\nbool flag = q.empty();\n// flag = true，队列初始为空\n\nq.push(23333);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.front());\n    q.pop();\n}\n// 依次输出 23333，66666\n```\n\n##### 栈 stack\nSTL 在头文件 `<stack>` 提供了后入先出（LIFO）栈 `stack`。\n\n使用 `push()` 向栈中加入元素。\n\n使用 `top()` 获取栈顶元素（并不删除）。\n\n使用 `pop()` 删除栈顶元素。\n\n使用 `empty()` 判断栈是否为空。\n\n```cpp\nstd::stack<int> s;\n\nbool flag = s.empty();\n// flag = true，栈初始为空\n\ns.push(23333);\ns.push(66666);\n\nwhile (!s.empty()) {\n    printf(\"%d\\n\", s.top());\n    s.pop();\n}\n// 依次输出 66666，23333\n```\n\n##### 优先队列 priority_queue\nSTL 在头文件 `<queue>` 中提供优先队列 `priority_queue`，在任意时间都能取出队列中的**最大值**。\n\n使用 `push()` 向优先队列中加入元素，其时间复杂度为$O({\\log}n)$。\n\n使用 `top()` 获取优先队列中**最大**的元素（并不删除），其时间复杂度为$O(1)$。\n\n使用 `pop()` 删除优先队列中**最大**元素，其时间复杂度为$O({\\log}n)$。\n\n使用 `empty()` 判断优先队列是否为空。\n\n```cpp\nstd::priority_queue<int> q;\n\nbool flag = q.empty();\n// flag = true，优先队列初始为空\n\nq.push(23333);\nq.push(-1);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.top());\n    q.pop();\n}\n// 依次输出 66666，23333，-1\n```\n\n`priority_queue` 默认提供队列中的**最大值**，也可以以以下声明方式让 `priority_queue` 提供**最小值**。\n\n```cpp\nstd::priority_queue<T, std::vector<T>, std::greater<T> > q;\n```\n\n注意把三个 `T` 换成优先队列中元素的类型（如 `int`）；`std::greater<T>` 的右边要加一个空格，否则会被编译器误认为是 `>>` 右移运算符。","source":"_posts/stl-in-oi.md","raw":"title: STL 在 OI 中的应用\ncategories: OI\ntags: \n  - C++\n  - STL\npermalink: stl-in-oi\nid: 8\nupdated: '2016-02-17 10:35:37'\ndate: 2015-12-24 05:43:15\n---\n\n在 OI 竞赛中，可以使用的语言有 C++、C、Pascal，其中 C++ 最大的优势是，它本身提供了一个模板库 —— Standard Template Library（标准模板库），简称 STL。STL 包含一系列算法和容器等，合理地使用 STL，可以在提高编写代码的效率。NOI 系列比赛自 2011 年起允许 C++ 选手使用 STL，所以我们应该利用好 STL，发挥 C++ 语言的优势。\n\n<!-- more -->\n\n### 分类\n> STL 可分为容器（containers）、迭代器（iterators）、空间配置器（allocator）、配接器（adapters）、算法（algorithms）、仿函数（functors）六个部分。\n\n本文主要讲解容器、迭代器、算法，其他的几个部分在竞赛中很少使用到。\n\n### 命名空间\n命名空间（namespace）是 C++ 的一个特性，它被用于解决名称冲突，比如假设 Menci 和 aby890 都在自己的头文件里编写了一个 `work()` 函数，如果这两个函数我们都要用，则名称会产生冲突，但如果两人都将自己的函数写在单独的命名空间内，就成了 `Menci::work()` 和 `aby890::work()`，就不会冲突了。\n\nSTL 的所有内容都包含在 `std` 命名空间内。为什么命名空间不叫 `stl`？我也不知道。\n\n如果我们要调用 STL 中的 `sort` 函数（下文会有提到），要这样写：\n\n```cpp\nstd::sort(a, a + n);\n```\n\n我们也可以将 `std::sort` 这个函数“导入”到全局中，就可以直接 `sort(a, a + n)` 这样调用了。  \n使用 `using` 关键字来“导入”命名空间中的函数或类。\n\n```cpp\nusing std::sort;\n```\n\n也可以将整个命名空间导入全局，这样就可以直接访问命名空间中的所有内容，但更容易产生名称冲突（比如你可能会声明一个叫做 `max` 的变量，但它会覆盖 STL 中的 `max` 函数）。  \n使用 `using namespace` 来“导入”整个命名空间。\n\n```cpp\nusing namespace std;\n```\n\n### 算法\nSTL 中的算法主要包含在 `<algorithm>` 头文件中，这个文件名要记住，每天念一遍。\n\n##### 排序\nSTL 中提供一系列与排序有关的函数，其中最常用到的是 `sort` 和 `stable_sort`，`sort` 是不稳定的排序，它的期望时间复杂度为 $O(n {\\log} n)$，`stable_sort` 是稳定的排序，它的时间复杂度为 $O(n {\\log} n)$。\n\n`sort` 使用类似与快速排序的算法，在大多数情况下能获得最高的效率，`stable_sort` 使用多路归并排序算法，可以在稳定的前提下取得较高的效率。一般常用 `sort`。\n\n用法（以 `sort` 为例，`stable_sort` 相同）：\n\n对左闭右开区间 [l, r) 排序，使用 `sort(l, r)`。其中 l 和 r 是指向元素的**迭代器**，在了解**迭代器**之前，我们可以将其理解为指向元素的指针。\n\n注意这里的区间表示是一个**左闭右开区间**，STL 中经常会出现这种区间，如果我们要对一个数组 a 的前 n 个元素进行排序，则对应区间为 [a, a + n)，因为 a 指向数组的第一个元素（下标为 0），a + n 指向数组的第 n 个元素**之后**。\n\n`sort` 函数默认是升序排序，如果需要降序，可以通过自定义“比较函数”来实现。\n\n```cpp\nbool compare(int a, int b) {\n    return a > b;\n}\n\nstd::sort(a, a + n, &compare);\n```\n\n下面的代码演示了读入 n（n <= 100000）个数，并**降序**排序后输出。\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint n;\nint a[MAXN];\n\nbool compare(int a, int b) {\n    return a > b;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tstd::sort(a, a + n, &compare);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d\\n\", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n降序排序是**大于号**，升序排序是**小于号**（注意**不能**加等号变成大于等于、小于等于），如果不指定比较函数，默认为**升序**。\n\n也可以通过**重载运算符**或者定义**比较函数**的方法对结构体进行排序：\n\n```cpp\nstruct student_t {\n    unsigned int id;\n    long double score;\n \n    bool operator<(const student_t &other) const {\n        return score < other.score;\n    }\n} students[MAXN];\n \nbool compare(const student_t &student1, const student_t &student2) {\n    return student1.score < student2.score;\n}\n \nstd::sort(students, students + n, &compare);\n```\n\n写在结构体中的 `operator<` 即为重载运算符，这让我们的结构体支持小于号的比较操作。  \n结构体下面的 `compare` 是比较函数，**比较函数**和**重载运算符**只需要写一个就够了。\n\n注意两种写法中的 `const` 和 `&` 都不能省略。\n\n##### 去重\n\n使用 `unique` 函数来去除数组中的重复元素，其调用格式与 `sort` 类似，注意调用 `unique` 前必须保证数组是有序的（升序降序都可以）。\n\n```cpp\nstd::sort(a, a + n);\nstd::unique(a, a + n);\n```\n\n`unique` 函数返回去重后的数组的最后一个元素之后，一般通过用返回值减去首地址的方法获得不重复的元素数量：\n\n```cpp\nint count = std::unique(a, a + n) - a;\n```\n\n下面的代码演示了读入 n（n <= 100000）个数，并升序排序并去重后输出。\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n \nconst int MAXN = 100000;\n \nint n;\nint a[MAXN];\n \nint main() {\n    scanf(\"%d\", &n);\n \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n \n    std::sort(a, a + n);\n    int count = std::unique(a, a + n) - a;\n \n    for (int i = 0; i < count; i++) {\n        printf(\"%d\\n\", a[i]);\n    }\n \n    return 0;\n}\n```\n\n##### 较大、较小值\n\n使用 `max` 和 `min` 来取得两个数中较大或较小的。\n\n```cpp\nint a = -1, b = 890;\nx = std::max(a, b); // 结果为 890\ny = std::min(a, b); // 结果为 -1\n```\n\n##### 查找\n\nSTL 中常用的用于查找的函数有三个：`lower_bound`、`upper_bound`、`binary_search`，一般 `lower_bound` 最为常用。\n\n`lower_bound` 用于在一个升序序列中查找某个元素，并返回第一个**不小于**该元素的元素的迭代器，如果找不到，则返回指向序列中最后一个元素**之后**的迭代器。\n\n`upper_bound` 用于在一个升序序列中查找某个元素，并返回第一个**大于**该元素的元素的迭代器，如果找不到，则返回指向序列中最后一个元素**之后**的迭代器。\n\n`binary_search` 用于确定某个元素有没有在一个升序序列中出现过，返回 `true` 或 `false`。\n\n三个函数的时间复杂度均为$O({\\log}n)$。\n\n```cpp\nint a[8] = { -9, 5, -1, 2, 7, 1, -2, 2 }, n = 8;\n\nstd::sort(a, a + n);\n\n// a = { -9, -2, -1, 1, 2, 2, 5, 7 }\n\nint *p1 = std::lower_bound(a, a + n, 1);\n// p1 指向 a 中第 4 个元素 a[3] = 1\n\nint *p2 = std::lower_bound(a, a + n, 2);\n// p2 指向 a 中第 5 个元素 a[4] = 2\n\nint *p3 = std::upper_bound(a, a + n, 2);\n// p3 指向 a 中第 7 个元素 a[6] = 5\n\nint *p4 = std::lower_bound(a, a + n, 8);\n// p4 = a + n，因为数组 a 中没有不小于 8 的元素，此时访问 *p4 会越界\n\nbool flag = std::binary_search(a, a + n, 3);\n// flag = false 因为数组 a 中没有 3\n```\n\n##### 交换\n使用 `swap` 函数交换两个变量的值。\n\n```cpp\nint a = -1, b = 1;\nstd::swap(a, b);\n\n// a = 1, b = -1\n```\n\n### 迭代器\n迭代器是用于访问 STL 容器中元素的一种数据类型，一般迭代器的声明如下：\n\n```cpp\nstd::CONTAINER<T>::iterator p;\n```\n\n上述代码声明了一个迭代器 `p`，其中 `CONTAINER` 是容器类型，可以是 `vector`、`set` 等，`T` 是容器中元素的类型。\n\n一般的，容器的 `begin()` 方法返回**首个元素**的迭代器， `end()` 方法返回**最后一个元素之后**的迭代器。这两个迭代器确定了一个包含容器内所有元素的**左闭右开区间** `[begin(), end())`。对于任何指向有效元素的迭代器都有其**不等于** `end()`，`end()` 并不指向任何一个元素，试图访问 `end()` 对应的元素是非法的。\n\n在使用 STL 提供的算法时，可以用迭代器表示一个区间，如：\n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n一些容器的迭代器可以支持**随机访问**，如指向 `vector[i]` 的迭代器为 `vector.begin() + i`，而另一些容器如 `set` 不支持这种用法。\n\n所有的迭代器都支持使用 `++` 和 `--` 运算符将迭代器加一或减一。\n\n迭代器的用法类似于指向数组元素的指针，对于迭代器 `p`，用 `*p` 得到迭代器对应的元素；如果该迭代器所对应的元素类型为结构体，则可以直接使用 `->` 访问其对应结构体中的元素。\n\n一般的，使用迭代器遍历容器类似于下述代码：\n\n```cpp\nfor (std::CONTAINER<T>::iterator p = C.begin(); p != C.end(); p++) {\n    std::cout << *p << std::endl;\n}\n```\n\n### 容器\n\n##### 数组 vector\nSTL 在头文件 `<vector>` 提供了一个**可变长**的数组 `vector`，它支持动态的插入、删除操作。\n\n以下代码声明了一个 `vector`，它的每个元素类型为 `int`，初始元素数量为 0。\n\n```cpp\nstd::vector<int> v;\n```\n\n以下代码声明了一个 `vector`，它的每个元素类型为 `int`，初始元素数量为 n。\n\n```cpp\nstd::vector<int> v(n);\n```\n\n`vector` 提供 `begin()` 和 `end()`，分别获取指向**第一个元素**和**最后一个元素之后**的迭代器。\n\n以下代码对 v 中的所有元素以升序排序：\n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n使用 `size()` 得到 `vector` 的元素数量，使用 `resize()` 重新指定 `vector` 的元素数量。\n\n分别使用 `push_back()` 和 `pop_back()` 在 `vector` 的**尾部**加入或删除元素，这两个过程的时间复杂度为$O(1)$。\n\n使用 `insert()` 在某个特定的位置插入一个元素，时间复杂度为$O(n)$。\n\n使用 `erase()` 删除某个位置的元素，时间复杂度为$O(n)$。\n\n```cpp\nstd::vector<int> v;\n// v.size() = 0\n\nv.push_back(23333);\n// v.size() = 1, v = { 23333 }\n\nv.insert(v.begin() + 0, 890);\n// v.size() = 2, v = { 890, 23333 }\n\nv.insert(v.begin() + 1, 12345);\n// v.size() = 3, v = { 890, 12345, 23333 }\n\nv.erase(v.begin() + 0);\n// v.size() = 2, v = { 12345, 23333 }\n\nfor (nt i = 0; i < v.size(); i++) {\n    printf(\"%d\\n\", v[i]);\n}\n// 依次输出 12345、23333\n\nv.pop_back();\n// v.size() = 1, v = { 12345 }\n```\n\n注意，在加入元素时，如果 `vector` 拥有的内存空间不足以存放欲加入的元素，则 `vector` 会申请一块新的内存，并将旧数据拷贝过去，这个过程通常花费 $O(n)$ 的时间。\n\n##### 集合 set\nSTL 在头文件 `<set>` 中提供了一个**有序集合** `set`，其中的元素全部是**唯一**的，并且插入进的元素自动按照升序排列，但 `set` 不支持通过下标定位某个元素，只能通过**迭代器**遍历。\n\n以下代码声明了一个 `int` 类型的集合。\n\n```cpp\nstd::set<int> s;\n```\n\n使用 `insert()` 在集合中加入一个元素，其时间复杂度为$O({\\log}n)$。\n\n使用 `erase()` 删除集合中**某个元素**或**某个位置的元素**，其时间复杂度均为$O({\\log}n)$。\n\n`set` 自身提供 `lower_bound()` 用于定位元素，其作用与前文中的同名函数类似，也可以使用 `find()` 来精确查找元素。\n\n遍历 `set` 只能使用**迭代器**。`set` 的迭代器为 `set<T>::iterator`，其中 `T` 为元素类型。\n\n```cpp\nstd::set<int> s;\n\ns.insert(23333);\ns.insert(23333); // 重复插入无效\ns.insert(66666);\ns.insert(890);\ns.insert(-1);\n// s.size() = 4, s = { -1, 890, 23333, 66666 }\n\ns.erase(66666);\n// s.size() = 3, s = { -1, 890, 23333 }\n\nstd::set<int>::iterator p1 = s.lower_bound(555);\n// *p1 = 890\n\nstd::set<int>::iterator p2 = s.find(555);\n// p2 = s.end()，因为未找到 555\n\ns.erase(p1);\n// s.size() = 2, s = { -1, 23333 }\n\nfor (std::set<int>::iterator p = s.begin(); p != s.end(); p++) {\n    printf(\"%d\\n\", *p);\n}\n// 依次输出 -1、23333\n```\n\n上述代码中运用的迭代器的方法在 STL 容器中较为常见。\n\n##### 字符串 string\nSTL 在头文件 `<string>` 中将一些与字符串有关的操作封装在了 `string` 内。\n\n使用 `cin` 和 `cout` 来输入、输出字符串。\n\n使用 `find()` 查找另一个字符串在该字符串中的出现位置，返回结果从 0 开始。\n\n使用 `c_str()` 获得 `string` 对应的 `const char *` 类型数据，可用于向 C 库函数传递。\n\n```cpp\nstd::string s = \"Menci\";\n\nint pos = s.find(\"23333\");\n// pos = string::npos，因为没有找到 23333\n\npos = s.find(\"ci\");\n// pos = 3，因为出现位置为第 4 个字符\n\nchar ch = s[0];\n// ch = 'M'\n\nstd::cout << s << std::endl;\nputs(s.c_str());\n// 输出两次 Menci\n```\n\n##### 队列 queue\nSTL 在头文件 `<queue>` 中提供了先入先出（FIFO）队列 `queue`。\n\n使用 `push()` 向队列中加入元素。\n\n使用 `front()` 获取队首元素（并不删除）。\n\n使用 `pop()` 删除队首元素。\n\n使用 `empty()` 判断队列是否为空。\n\n```cpp\nstd::queue<int> q;\n\nbool flag = q.empty();\n// flag = true，队列初始为空\n\nq.push(23333);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.front());\n    q.pop();\n}\n// 依次输出 23333，66666\n```\n\n##### 栈 stack\nSTL 在头文件 `<stack>` 提供了后入先出（LIFO）栈 `stack`。\n\n使用 `push()` 向栈中加入元素。\n\n使用 `top()` 获取栈顶元素（并不删除）。\n\n使用 `pop()` 删除栈顶元素。\n\n使用 `empty()` 判断栈是否为空。\n\n```cpp\nstd::stack<int> s;\n\nbool flag = s.empty();\n// flag = true，栈初始为空\n\ns.push(23333);\ns.push(66666);\n\nwhile (!s.empty()) {\n    printf(\"%d\\n\", s.top());\n    s.pop();\n}\n// 依次输出 66666，23333\n```\n\n##### 优先队列 priority_queue\nSTL 在头文件 `<queue>` 中提供优先队列 `priority_queue`，在任意时间都能取出队列中的**最大值**。\n\n使用 `push()` 向优先队列中加入元素，其时间复杂度为$O({\\log}n)$。\n\n使用 `top()` 获取优先队列中**最大**的元素（并不删除），其时间复杂度为$O(1)$。\n\n使用 `pop()` 删除优先队列中**最大**元素，其时间复杂度为$O({\\log}n)$。\n\n使用 `empty()` 判断优先队列是否为空。\n\n```cpp\nstd::priority_queue<int> q;\n\nbool flag = q.empty();\n// flag = true，优先队列初始为空\n\nq.push(23333);\nq.push(-1);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.top());\n    q.pop();\n}\n// 依次输出 66666，23333，-1\n```\n\n`priority_queue` 默认提供队列中的**最大值**，也可以以以下声明方式让 `priority_queue` 提供**最小值**。\n\n```cpp\nstd::priority_queue<T, std::vector<T>, std::greater<T> > q;\n```\n\n注意把三个 `T` 换成优先队列中元素的类型（如 `int`）；`std::greater<T>` 的右边要加一个空格，否则会被编译器误认为是 `>>` 右移运算符。","slug":"stl-in-oi","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n2p003qofdkve54eii5"},{"title":"Splay 学习笔记（三）","date":"2016-01-19T12:02:00.000Z","_content":"\n在《Splay 学习笔记（一）》中，我们学会了利用 Splay 来维护二叉排序树，现在让我们来把我们的 Splay 变得更加优美。\n\n<!-- more -->\n\n### 结构体定义\n两个孩子用一个数组来存，0 表示左孩子，1 表示右孩子，不需要再编写函数来获得某个孩子的引用了。\n\n引入 `count` 成员，表示这个值共出现了几次，不再重复插入相同的值，效率可以得到提高，特别是求前趋后继，实现起来也会变得更加简单。\n```cpp\nenum Relation {\n\tL = 0, R = 1\n};\n\nstruct Node {\n\tNode *child[2], *parent, **root;\n\tT value;\n\tint size, count;\n}\n```\n\n### Splay 操作\n把之前的“旋转到某位置”改为“旋转直到某节点成为自己的父节点”，不需要二级指针了，也不需要判断如果参数为 `NULL` 那么转到根了。\n\n```cpp\nvoid splay(Node *targetParent = NULL) {\n\twhile (parent != targetParent) {\n\t\tif (parent->parent == targetParent) rotate();\n\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\telse rotate(), rotate();\n\t}\n}\n```\n\n### 节点的前趋 / 后继\n直接 `Splay` 后求即可，不需要多次迭代了。\n\n```cpp\nNode *pred() {\n\tsplay();\n\tNode *v = child[L];\n\twhile (v->child[R]) v = v->child[R];\n\treturn v;\n}\n\nNode *succ() {\n\tsplay();\n\tNode *v = child[R];\n\twhile (v->child[L]) v = v->child[L];\n\treturn v;\n}\n```\n\n### 选择\n选择第 `k` 小的元素时，需要把循环的条件改为**`k` 是否在 `[rank + 1, rank + count]`**的范围内，迭代到右子树时也要做相应的改动。\n\n```cpp\nNode *select(int k) {\n\tk++;\n\tNode *v = root;\n\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\tif (k < v->rank() + 1) {\n\t\t\tv = v->child[L];\n\t\t} else {\n\t\t\tk -= v->rank() + v->count;\n\t\t\tv = v->child[R];\n\t\t}\n\t}\n\tv->splay();\n\treturn v;\n}\n```\n\n### 完整代码（普通平衡树）\n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size, count;\n\n\t\tNode(Node *parent, const T &value, Node **root) : parent(parent), value(value), root(root), count(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + count;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tif (value < v->value) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\n\t\tif (!v) return NULL;\n\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->maintain();\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) {\n\t\t\t\ttarget = &parent->child[L];\n\t\t\t} else {\n\t\t\t\ttarget = &parent->child[R];\n\t\t\t}\n\t\t}\n\n\t\t*target = new Node(parent, value, &root);\n\t\t(*target)->splay();\n\n\t\treturn root;\n\t}\n\n\tvoid erase(const T &value) {\n\t\terase(find(value));\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count != 1) {\n\t\t\tv->splay();\n\t\t\tv->count--;\n\t\t\tv->maintain();\n\t\t\treturn;\n\t\t}\n\n\t\tNode *pred = v->pred();\n\t\tNode *succ = v->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint ans = v->rank();\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + v->count;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->pred()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->pred()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->succ()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->succ()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n};\n\nint n;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth) {\n\tif (v->child[Splay<int, INT_MAX>::L]) dfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d\\n\", v->value);\n\tif (v->child[Splay<int, INT_MAX>::R]) dfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint command, x;\n\t\tscanf(\"%d %d\", &command, &x);\n\t\tif (command == 1) {\n\t\t\tsplay.insert(x);\n\t\t} else if (command == 2) {\n\t\t\tsplay.erase(x);\n\t\t} else if (command == 3) {\n\t\t\tprintf(\"%d\\n\", splay.rank(x));\n\t\t} else if (command == 4) {\n\t\t\tprintf(\"%d\\n\", splay.select(x)->value);\n\t\t} else if (command == 5) {\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t} else if (command == 6) {\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/splay-notes-3.md","raw":"title: Splay 学习笔记（三）\ncategories: OI\ntags: \n  - Splay\n  - 高级数据结构\n  - 学习笔记\n  - 数据结构\n  - 算法模板\npermalink: splay-notes-3\ndate: 2016-01-19 20:02:00\n---\n\n在《Splay 学习笔记（一）》中，我们学会了利用 Splay 来维护二叉排序树，现在让我们来把我们的 Splay 变得更加优美。\n\n<!-- more -->\n\n### 结构体定义\n两个孩子用一个数组来存，0 表示左孩子，1 表示右孩子，不需要再编写函数来获得某个孩子的引用了。\n\n引入 `count` 成员，表示这个值共出现了几次，不再重复插入相同的值，效率可以得到提高，特别是求前趋后继，实现起来也会变得更加简单。\n```cpp\nenum Relation {\n\tL = 0, R = 1\n};\n\nstruct Node {\n\tNode *child[2], *parent, **root;\n\tT value;\n\tint size, count;\n}\n```\n\n### Splay 操作\n把之前的“旋转到某位置”改为“旋转直到某节点成为自己的父节点”，不需要二级指针了，也不需要判断如果参数为 `NULL` 那么转到根了。\n\n```cpp\nvoid splay(Node *targetParent = NULL) {\n\twhile (parent != targetParent) {\n\t\tif (parent->parent == targetParent) rotate();\n\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\telse rotate(), rotate();\n\t}\n}\n```\n\n### 节点的前趋 / 后继\n直接 `Splay` 后求即可，不需要多次迭代了。\n\n```cpp\nNode *pred() {\n\tsplay();\n\tNode *v = child[L];\n\twhile (v->child[R]) v = v->child[R];\n\treturn v;\n}\n\nNode *succ() {\n\tsplay();\n\tNode *v = child[R];\n\twhile (v->child[L]) v = v->child[L];\n\treturn v;\n}\n```\n\n### 选择\n选择第 `k` 小的元素时，需要把循环的条件改为**`k` 是否在 `[rank + 1, rank + count]`**的范围内，迭代到右子树时也要做相应的改动。\n\n```cpp\nNode *select(int k) {\n\tk++;\n\tNode *v = root;\n\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\tif (k < v->rank() + 1) {\n\t\t\tv = v->child[L];\n\t\t} else {\n\t\t\tk -= v->rank() + v->count;\n\t\t\tv = v->child[R];\n\t\t}\n\t}\n\tv->splay();\n\treturn v;\n}\n```\n\n### 完整代码（普通平衡树）\n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size, count;\n\n\t\tNode(Node *parent, const T &value, Node **root) : parent(parent), value(value), root(root), count(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + count;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tif (value < v->value) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\n\t\tif (!v) return NULL;\n\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->maintain();\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) {\n\t\t\t\ttarget = &parent->child[L];\n\t\t\t} else {\n\t\t\t\ttarget = &parent->child[R];\n\t\t\t}\n\t\t}\n\n\t\t*target = new Node(parent, value, &root);\n\t\t(*target)->splay();\n\n\t\treturn root;\n\t}\n\n\tvoid erase(const T &value) {\n\t\terase(find(value));\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count != 1) {\n\t\t\tv->splay();\n\t\t\tv->count--;\n\t\t\tv->maintain();\n\t\t\treturn;\n\t\t}\n\n\t\tNode *pred = v->pred();\n\t\tNode *succ = v->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint ans = v->rank();\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + v->count;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->pred()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->pred()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->succ()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->succ()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n};\n\nint n;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth) {\n\tif (v->child[Splay<int, INT_MAX>::L]) dfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d\\n\", v->value);\n\tif (v->child[Splay<int, INT_MAX>::R]) dfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint command, x;\n\t\tscanf(\"%d %d\", &command, &x);\n\t\tif (command == 1) {\n\t\t\tsplay.insert(x);\n\t\t} else if (command == 2) {\n\t\t\tsplay.erase(x);\n\t\t} else if (command == 3) {\n\t\t\tprintf(\"%d\\n\", splay.rank(x));\n\t\t} else if (command == 4) {\n\t\t\tprintf(\"%d\\n\", splay.select(x)->value);\n\t\t} else if (command == 5) {\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t} else if (command == 6) {\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"splay-notes-3","published":1,"updated":"2016-03-15T01:45:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n2t003wofdkd0h08gfw"},{"title":"Splay 学习笔记（二）","id":"7","updated":"2016-01-19T13:07:35.000Z","date":"2015-12-22T21:44:41.000Z","_content":"\n在 Splay 学习笔记（一）中，我们学会了用 Splay 维护二叉排序树，来实现了有序集合的查询 / 修改操作，接下来，我们来研究 Splay 在维护数列中的用途。\n\n<!-- more -->\n\n### 基本原理\n我们知道，Splay 可以在不改变二叉树的中序遍历的情况下对节点进行旋转，通常我们用 Splay 来维护二叉排序树，用 Splay 维护的二叉排序树支持**区间删除**操作，但我们也可以通过一个数列的中序遍历创建一棵 Splay，然后使用类似区间删除中选择区间的原理来处理区间问题。\n\n这里，我们使用 Splay 实现数列的区间反转，反转一段区间，就对应了二叉树中的反转其**中序遍历**，我们可以使用递归交换左右子树的方法来实现，类比线段树的区间操作，在这里也可以应用线段树中的 `lazy-tag` 思想，给区间打标记。\n\n```cpp\nstruct node_t {\n\tnode_t *lchild, *rchild, *parent, **root;\n\tT value;\n\tuint size;\n\tbool reversed;\n\tbool bound;\n}\n```\n\n其中 `reversed` 表示以该节点为根的 Splay（其中序序列）有没有被反转，`bound` 表示该节点是否为数列的边界（相当于原 Splay 二叉排序树中的 `MIN` 和 `MAX` 两个虚拟节点）。\n\n### 数列de构建\n我们通常使用一个数列（数组）来初始化 Splay，这里使用递归构造每个区间的方式实现。具体我们编写两个 `build()`，分别针对**整棵树**和**一个区间**。\n\n```cpp\nvoid build(const T *a, uint n) {\n\troot = build(a, 1, n, NULL);\n\n\tnode_t **lbound = &root, *lbound_parent = NULL;\n\twhile (*lbound) {\n\t\tlbound_parent = *lbound;\n\t\tlbound_parent->size++;\n\t\tlbound = &(*lbound)->lchild;\n\t}\n\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\tnode_t **rbound = &root, *rbound_parent = NULL;\n\twhile (*rbound) {\n\t\trbound_parent = *rbound;\n\t\trbound_parent->size++;\n\t\trbound = &(*rbound)->rchild;\n\t}\n\t*rbound = new node_t(rbound_parent, &root, 0, true);\n}\n\nnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\tif (l > r) {\n\t\treturn NULL;\n\t}\n\n\tuint mid = l + ((r - l) >> 1);\n\t\t\n\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\tif (l != r) {\n\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\tnode->maintain();\n\t}\n\n\treturn node;\n}\n```\n\n为了方便区间操作，我们在树的最左下端和最右下端分别创建一个虚拟节点，表示整棵树所表示的**开区间**的边界。\n\n注意递归构建时的区间计算，与线段树的**只有叶子节点表示单点，其它节点全部表示区间**不同，Splay 的每个节点都既表示**一个单点**，又表示**以该节点为根的 Splay 的所有节点构成的区间**，每个节点所代表的区间都会根据树的形态变化而变化，正因为如此，我们才可以通过 Splay 实现灵活的区间操作。\n\n### 标记de下放\n我们对区间操作的维护采用了类似线段树中 `lazy-tag` 的思想。同样，在 Splay 中，我们也需要在必要时对标记进行下放。\n\n```cpp\nnode_t *pushdown() {\n\tif (reversed) {\n\t\tstd::swap(lchild, rchild);\n\n\t\tif (lchild) {\n\t\t\tlchild->reversed ^= 1;\n\t\t}\n\n\t\tif (rchild) {\n\t\t\trchild->reversed ^= 1;\n\t\t}\n\n\t\treversed = false;\n\t}\n\n\treturn this;\n}\n```\n反转标记的下放非常简单，交换左右子树，然后将标记打到子树上（`^= 1` 这里使用位运算异或来实现取反）。\n\n### 单点de选择\n当我们需要查询数列中某个点的信息时，我们需要对单点进行 `select()` 操作，这恰好对应了原 Splay 中选择第 `k` 大的操作。\n\n```cpp\nnode_t *select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (k != node->pushdown()->lsize() + 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay();\n}\n```\n\n**注意**：`while` 循环判断条件中，调用 `node->lsize()` 取得其左子树大小前，一定要先将 `node` 的标记下放。**如果某个节点上的标记没有被下放，那么对其左、右孩子的访问都是非法的。**\n\n### 区间de选择\n为了实现区间操作，我们需要选择某个区间。注意这里的 `select()` 操作得到区间是指**代表该区间的节点**。为了准确的选择区间，我们需要对树的形态做一些调整。\n\n在 Splay 中选择一个开区间的步骤：\n\n1. 将区间的左端点 `Splay` 到**根**；\n2. 将区间的右端点 `Splay` 到**根的右子树**；\n3. 右端点的左子树即为要选择的区间。\n\n代码实现要注意**闭区间**到**开区间**的转化，同时，这里也体现出了两个虚拟节点带来的便利。\n\n```cpp\nnode_t *select(uint l, uint r) {\n\tnode_t *lbound = select(l - 1);\n\tnode_t *rbound = select(r + 1);\n\n\tlbound->splay();\n\trbound->splay(&lbound->rchild);\n\n\treturn rbound->lchild;\n}\n```\n\n### 区间de操作\n对区间进行操作时，我们只需要选择这段区间，并对所得的节点打上标记即可。\n\n以区间反转为例：\n\n```cpp\nvoid reverse(uint l, uint r) {\n\tnode_t *range = select(l, r);\n\trange->reversed ^= 1;\n}\n```\n\n### 结果de获取\n为了在结束时获取操作结果并输出，我们编写 `fetch()` 方法，将整棵树的中序序列复制到一个数组中。\n\n```C++\nvoid fetch(T *a) {\n\tdfs(a, root);\n}\n\nvoid dfs(T *&a, node_t *node) {\n\tif (node) {\n\t\tnode->pushdown();\n\n\t\tdfs(a, node->lchild);\n\n\t\tif (!node->bound) {\n\t\t\t*a++ = node->value;\n\t\t}\n\n\t\tdfs(a, node->rchild);\n\t}\n}\n```\n\n需要注意及时进行 `pushdown()` 操作和对边界的判断。\n\n### 注意事项\n需要注意的是，在访问每个节点之前，我们都需要保证树上没有**针对该节点**的标记（即从根节点到该节点的一整条链上没有标记），否则即为不可预料的非法访问。\n\n旋转，操作前先对父节点和自身执行 `pushdown()`，**然后再求 `relation()`**。\n\n```C++\nvoid rotate() {\n\tparent->pushdown();\n\tpushdown();\n\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n`Splay` 操作，每次循环开始时需要对父节点进行一次 `pushdown()`，因为接下来就要调用 `relation()`。\n\n```C++\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tparent->pushdown();\n\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\n}\n```\n\n还有上文提到过的单点选择 `select()` 和 `dfs()` 遍历，因为涉及到对子节点的访问，所以在访问前也需要 `pushdown()`。\n\n### 完整代码（Tyvj / BZOJ 文艺平衡树）\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\nconst uint MAXM = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T>\nstruct splay_t {\n\tstruct node_t {\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tT value;\n\t\tuint size;\n\t\tbool reversed;\n\t\tbool bound;\n\n\t\tnode_t(node_t *parent, node_t **root, const T &value, bool bound = false) : parent(parent), lchild(NULL), rchild(NULL), root(root), value(value), size(1), reversed(false), bound(bound) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tnode_t *pushdown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(lchild, rchild);\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tparent->pushdown();\n\t\t\tpushdown();\n\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tparent->pushdown();\n\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\t} *root;\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tvoid build(const T *a, uint n) {\n\t\troot = build(a, 1, n, NULL);\n\n\t\tnode_t **lbound = &root, *lbound_parent = NULL;\n\t\twhile (*lbound) {\n\t\t\tlbound_parent = *lbound;\n\t\t\tlbound_parent->size++;\n\t\t\tlbound = &(*lbound)->lchild;\n\t\t}\n\t\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\t\tnode_t **rbound = &root, *rbound_parent = NULL;\n\t\twhile (*rbound) {\n\t\t\trbound_parent = *rbound;\n\t\t\trbound_parent->size++;\n\t\t\trbound = &(*rbound)->rchild;\n\t\t}\n\t\t*rbound = new node_t(rbound_parent, &root, 0, true);\n\t}\n\n\tnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\t\tif (l > r) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tuint mid = l + ((r - l) >> 1);\n\t\t\n\t\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\t\tif (l != r) {\n\t\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\t\tnode->maintain();\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tnode_t *select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (k != node->pushdown()->lsize() + 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay();\n\t}\n\n\tnode_t *select(uint l, uint r) {\n\t\tnode_t *lbound = select(l - 1);\n\t\tnode_t *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(&lbound->rchild);\n\n\t\treturn rbound->lchild;\n\t}\n\n\tvoid reverse(uint l, uint r) {\n\t\tnode_t *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfs(a, root);\n\t}\n\n\tvoid dfs(T *&a, node_t *node) {\n\t\tif (node) {\n\t\t\tnode->pushdown();\n\n\t\t\tdfs(a, node->lchild);\n\n\t\t\tif (!node->bound) {\n\t\t\t\t*a++ = node->value;\n\t\t\t}\n\t\t\t\n\t\t\tdfs(a, node->rchild);\n\t\t}\n\t}\n};\n\nvoid dfs(splay_t<uint>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<uint>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n, m;\nsplay_t<uint> splay;\nuint a[MAXN];\n\nint main() {\n\tscanf(\"%u %u\", &n, &m);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\ta[i] = i + 1;\n\t}\n\n\tsplay.build(a, n);\n\n\tfor (uint i = 0; i < m; i++) {\n\t\tuint l, r;\n\t\tscanf(\"%u %u\", &l, &r);\n\t\tsplay.reverse(l, r);\n\t}\n\n\tsplay.fetch(a);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tprintf(\"%u \", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n### 总结\n学完了这些，对 Splay 维护数列的原理与实现也就基本了解了。其他的一些功能，比如区间最值，区间求和也都大同小异。有些区间操作使用线段树也可实现，但 Splay 的另一个优势在于，它可以动态地插入、删除节点，也就可以实现动态插入、删除区间，这是线段树所不具备的。","source":"_posts/splay-notes-2.md","raw":"title: Splay 学习笔记（二）\ncategories: OI\ntags: \n  - BZOJ\n  - Splay\n  - 学习笔记\n  - 数据结构\n  - 高级数据结构\npermalink: splay-notes-2\nid: 7\nupdated: '2016-01-19 21:07:35'\ndate: 2015-12-23 05:44:41\n---\n\n在 Splay 学习笔记（一）中，我们学会了用 Splay 维护二叉排序树，来实现了有序集合的查询 / 修改操作，接下来，我们来研究 Splay 在维护数列中的用途。\n\n<!-- more -->\n\n### 基本原理\n我们知道，Splay 可以在不改变二叉树的中序遍历的情况下对节点进行旋转，通常我们用 Splay 来维护二叉排序树，用 Splay 维护的二叉排序树支持**区间删除**操作，但我们也可以通过一个数列的中序遍历创建一棵 Splay，然后使用类似区间删除中选择区间的原理来处理区间问题。\n\n这里，我们使用 Splay 实现数列的区间反转，反转一段区间，就对应了二叉树中的反转其**中序遍历**，我们可以使用递归交换左右子树的方法来实现，类比线段树的区间操作，在这里也可以应用线段树中的 `lazy-tag` 思想，给区间打标记。\n\n```cpp\nstruct node_t {\n\tnode_t *lchild, *rchild, *parent, **root;\n\tT value;\n\tuint size;\n\tbool reversed;\n\tbool bound;\n}\n```\n\n其中 `reversed` 表示以该节点为根的 Splay（其中序序列）有没有被反转，`bound` 表示该节点是否为数列的边界（相当于原 Splay 二叉排序树中的 `MIN` 和 `MAX` 两个虚拟节点）。\n\n### 数列de构建\n我们通常使用一个数列（数组）来初始化 Splay，这里使用递归构造每个区间的方式实现。具体我们编写两个 `build()`，分别针对**整棵树**和**一个区间**。\n\n```cpp\nvoid build(const T *a, uint n) {\n\troot = build(a, 1, n, NULL);\n\n\tnode_t **lbound = &root, *lbound_parent = NULL;\n\twhile (*lbound) {\n\t\tlbound_parent = *lbound;\n\t\tlbound_parent->size++;\n\t\tlbound = &(*lbound)->lchild;\n\t}\n\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\tnode_t **rbound = &root, *rbound_parent = NULL;\n\twhile (*rbound) {\n\t\trbound_parent = *rbound;\n\t\trbound_parent->size++;\n\t\trbound = &(*rbound)->rchild;\n\t}\n\t*rbound = new node_t(rbound_parent, &root, 0, true);\n}\n\nnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\tif (l > r) {\n\t\treturn NULL;\n\t}\n\n\tuint mid = l + ((r - l) >> 1);\n\t\t\n\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\tif (l != r) {\n\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\tnode->maintain();\n\t}\n\n\treturn node;\n}\n```\n\n为了方便区间操作，我们在树的最左下端和最右下端分别创建一个虚拟节点，表示整棵树所表示的**开区间**的边界。\n\n注意递归构建时的区间计算，与线段树的**只有叶子节点表示单点，其它节点全部表示区间**不同，Splay 的每个节点都既表示**一个单点**，又表示**以该节点为根的 Splay 的所有节点构成的区间**，每个节点所代表的区间都会根据树的形态变化而变化，正因为如此，我们才可以通过 Splay 实现灵活的区间操作。\n\n### 标记de下放\n我们对区间操作的维护采用了类似线段树中 `lazy-tag` 的思想。同样，在 Splay 中，我们也需要在必要时对标记进行下放。\n\n```cpp\nnode_t *pushdown() {\n\tif (reversed) {\n\t\tstd::swap(lchild, rchild);\n\n\t\tif (lchild) {\n\t\t\tlchild->reversed ^= 1;\n\t\t}\n\n\t\tif (rchild) {\n\t\t\trchild->reversed ^= 1;\n\t\t}\n\n\t\treversed = false;\n\t}\n\n\treturn this;\n}\n```\n反转标记的下放非常简单，交换左右子树，然后将标记打到子树上（`^= 1` 这里使用位运算异或来实现取反）。\n\n### 单点de选择\n当我们需要查询数列中某个点的信息时，我们需要对单点进行 `select()` 操作，这恰好对应了原 Splay 中选择第 `k` 大的操作。\n\n```cpp\nnode_t *select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (k != node->pushdown()->lsize() + 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay();\n}\n```\n\n**注意**：`while` 循环判断条件中，调用 `node->lsize()` 取得其左子树大小前，一定要先将 `node` 的标记下放。**如果某个节点上的标记没有被下放，那么对其左、右孩子的访问都是非法的。**\n\n### 区间de选择\n为了实现区间操作，我们需要选择某个区间。注意这里的 `select()` 操作得到区间是指**代表该区间的节点**。为了准确的选择区间，我们需要对树的形态做一些调整。\n\n在 Splay 中选择一个开区间的步骤：\n\n1. 将区间的左端点 `Splay` 到**根**；\n2. 将区间的右端点 `Splay` 到**根的右子树**；\n3. 右端点的左子树即为要选择的区间。\n\n代码实现要注意**闭区间**到**开区间**的转化，同时，这里也体现出了两个虚拟节点带来的便利。\n\n```cpp\nnode_t *select(uint l, uint r) {\n\tnode_t *lbound = select(l - 1);\n\tnode_t *rbound = select(r + 1);\n\n\tlbound->splay();\n\trbound->splay(&lbound->rchild);\n\n\treturn rbound->lchild;\n}\n```\n\n### 区间de操作\n对区间进行操作时，我们只需要选择这段区间，并对所得的节点打上标记即可。\n\n以区间反转为例：\n\n```cpp\nvoid reverse(uint l, uint r) {\n\tnode_t *range = select(l, r);\n\trange->reversed ^= 1;\n}\n```\n\n### 结果de获取\n为了在结束时获取操作结果并输出，我们编写 `fetch()` 方法，将整棵树的中序序列复制到一个数组中。\n\n```C++\nvoid fetch(T *a) {\n\tdfs(a, root);\n}\n\nvoid dfs(T *&a, node_t *node) {\n\tif (node) {\n\t\tnode->pushdown();\n\n\t\tdfs(a, node->lchild);\n\n\t\tif (!node->bound) {\n\t\t\t*a++ = node->value;\n\t\t}\n\n\t\tdfs(a, node->rchild);\n\t}\n}\n```\n\n需要注意及时进行 `pushdown()` 操作和对边界的判断。\n\n### 注意事项\n需要注意的是，在访问每个节点之前，我们都需要保证树上没有**针对该节点**的标记（即从根节点到该节点的一整条链上没有标记），否则即为不可预料的非法访问。\n\n旋转，操作前先对父节点和自身执行 `pushdown()`，**然后再求 `relation()`**。\n\n```C++\nvoid rotate() {\n\tparent->pushdown();\n\tpushdown();\n\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n`Splay` 操作，每次循环开始时需要对父节点进行一次 `pushdown()`，因为接下来就要调用 `relation()`。\n\n```C++\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tparent->pushdown();\n\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\n}\n```\n\n还有上文提到过的单点选择 `select()` 和 `dfs()` 遍历，因为涉及到对子节点的访问，所以在访问前也需要 `pushdown()`。\n\n### 完整代码（Tyvj / BZOJ 文艺平衡树）\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\nconst uint MAXM = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T>\nstruct splay_t {\n\tstruct node_t {\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tT value;\n\t\tuint size;\n\t\tbool reversed;\n\t\tbool bound;\n\n\t\tnode_t(node_t *parent, node_t **root, const T &value, bool bound = false) : parent(parent), lchild(NULL), rchild(NULL), root(root), value(value), size(1), reversed(false), bound(bound) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tnode_t *pushdown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(lchild, rchild);\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tparent->pushdown();\n\t\t\tpushdown();\n\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tparent->pushdown();\n\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\t} *root;\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tvoid build(const T *a, uint n) {\n\t\troot = build(a, 1, n, NULL);\n\n\t\tnode_t **lbound = &root, *lbound_parent = NULL;\n\t\twhile (*lbound) {\n\t\t\tlbound_parent = *lbound;\n\t\t\tlbound_parent->size++;\n\t\t\tlbound = &(*lbound)->lchild;\n\t\t}\n\t\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\t\tnode_t **rbound = &root, *rbound_parent = NULL;\n\t\twhile (*rbound) {\n\t\t\trbound_parent = *rbound;\n\t\t\trbound_parent->size++;\n\t\t\trbound = &(*rbound)->rchild;\n\t\t}\n\t\t*rbound = new node_t(rbound_parent, &root, 0, true);\n\t}\n\n\tnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\t\tif (l > r) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tuint mid = l + ((r - l) >> 1);\n\t\t\n\t\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\t\tif (l != r) {\n\t\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\t\tnode->maintain();\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tnode_t *select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (k != node->pushdown()->lsize() + 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay();\n\t}\n\n\tnode_t *select(uint l, uint r) {\n\t\tnode_t *lbound = select(l - 1);\n\t\tnode_t *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(&lbound->rchild);\n\n\t\treturn rbound->lchild;\n\t}\n\n\tvoid reverse(uint l, uint r) {\n\t\tnode_t *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfs(a, root);\n\t}\n\n\tvoid dfs(T *&a, node_t *node) {\n\t\tif (node) {\n\t\t\tnode->pushdown();\n\n\t\t\tdfs(a, node->lchild);\n\n\t\t\tif (!node->bound) {\n\t\t\t\t*a++ = node->value;\n\t\t\t}\n\t\t\t\n\t\t\tdfs(a, node->rchild);\n\t\t}\n\t}\n};\n\nvoid dfs(splay_t<uint>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<uint>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n, m;\nsplay_t<uint> splay;\nuint a[MAXN];\n\nint main() {\n\tscanf(\"%u %u\", &n, &m);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\ta[i] = i + 1;\n\t}\n\n\tsplay.build(a, n);\n\n\tfor (uint i = 0; i < m; i++) {\n\t\tuint l, r;\n\t\tscanf(\"%u %u\", &l, &r);\n\t\tsplay.reverse(l, r);\n\t}\n\n\tsplay.fetch(a);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tprintf(\"%u \", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n### 总结\n学完了这些，对 Splay 维护数列的原理与实现也就基本了解了。其他的一些功能，比如区间最值，区间求和也都大同小异。有些区间操作使用线段树也可实现，但 Splay 的另一个优势在于，它可以动态地插入、删除节点，也就可以实现动态插入、删除区间，这是线段树所不具备的。","slug":"splay-notes-2","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n2z0044ofdkt82vlk52"},{"title":"Splay 学习笔记（一）","id":"6","updated":"2016-01-19T13:07:47.000Z","date":"2015-12-19T21:36:24.000Z","_content":"\n上周周四开始学 Splay，一边看《高级数据结构》，一边看 FireStorm 的《[Splay学习笔记](http://blog.csdn.net/farestorm/article/details/49153565)》，现在终于弄明白最基础的一部分了。\n\n<!-- more -->\n\n### Splay 是什么?\nSplay Tree（伸展树）是一种自平衡二叉排序树，可以在均摊$O({\\log} n)$的时间内完成基于 Splay（伸展）操作的修改与查询。\n\n### 基本结构\n根据定义，Splay 是一棵二叉树，它的左子树和右子树分别是一棵 Splay，并且存储的值满足左子树 < 根 < 右子树，以下为每个 Splay 节点的定义。\n\n```cpp\nstruct node_t {\n\tT value;\n\tnode_t *lchild, *rchild, *parent, **root;\n\tuint size;\n};\n```\n其中 `root` 表示指向**指向根节点的指针**的指针，这样做可以方便从任意一个节点找到整棵 Splay 的根节点，并修改它。`size` 表示以当前节点为根的 Splay 共有多少个节点（包括自身），有了 `size`，就可以轻松地实现选择和排名操作。\n\n### 准备\n为了方便各种复杂的操作，我们先为节点类 `node_t` 编写几个短小的方法，代码如下：\n```cpp\nnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n~node_t() {\n\tif (lchild) {\n\t\tdelete lchild;\n\t}\n\n\tif (rchild) {\n\t\tdelete rchild;\n\t}\n}\n\nnode_t *grandparent() {\n\treturn !parent ? NULL : parent->parent;\n}\n\nnode_t *&child(uint x) {\n\treturn !x ? lchild : rchild;\n}\n\nuint relation() {\n\treturn this == parent->lchild ? 0 : 1;\n}\n\nuint maintain() {\n\tsize = lsize() + rsize() + 1;\n}\n\nuint lsize() {\n\treturn lchild ? lchild->size : 0;\n}\n\nuint rsize() {\n\treturn rchild ? rchild->size : 0;\n}\n```\n这里在 `node_t` 的析构函数中递归释放所有内存，这在区间删除中可能耗时较长，如果内存不紧张，可以考虑不释放内存。\n\n为了旋转操作的方便，我们给每个节点设置一个“关系”属性，表示该节点与其父节点的关系，若该节点为左孩子，则“关系”为 `0`，反之则为 `1`。`relation()` 方法用来计算这个“关系”，而 `child()` 方法返回与该节点“关系”为 `x` 的子节点的**引用**。\n\n`maintain()` 方法则用来重新计算以该节点为根的 Splay 的大小，注意，为免去不必要的计算，假设两个子节点的大小是**已经计算好**的，不会再将其重新计算。\n\n### 旋转\n为了调换 Splay 中父节点与子节点的位置，我们实现 `rotate()` 方法，该方法在**保证以下三点**的情况下，将该节点向上移动一个位置：\n\n1. 整棵 Splay 的中序遍历不变；\n2. 受影响节点的 `size` 仍然有效；\n3. `*root` 总是指向整棵 Splay 的根。\n\n以左旋（若当前节点为父节点的左孩子）为例，旋转分为四个步骤：\n\n1. 将**祖父**节点与自身连接；\n2. 将自己的**右孩子**接到自己的父节点的**左孩子**的位置（替代自己）；\n3. 将父节点接到自己的**右孩子**的位置；\n4. 检查如果此时自身节点为根，则更新 `*root`。\n\n如图（图片来自 FireStorm 的《[Splay学习笔记](http://blog.csdn.net/farestorm/article/details/49153565)》）：\n![splay](splay-notes-1/splay.png)\n\n代码：\n```cpp\nvoid rotate() {\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n### Splay 操作\nSplay 规定，每访问一个节点后，都要强制将该节点旋转到根的位置，于是我们很容易想到使用一个循环，判断是否已经到达目标，若不是则旋转，但这种方法的出现的问题在于，一条单链在旋转后仍然是单链，而且每次操作的时间复杂度无法得到保证！\n\n所以我们需要 `Splay` 操作来进行更加“智能化”的旋转，`Splay` 操作的每一次循环分为三步：\n\n1. 如果父节点为目标位置，则向上旋转；\n2. 如果**当前节点与父节点的“关系”**和**父节点与祖父节点的“关系”相同**，则先旋转父节点，再旋转自身；\n3. 如果不满足以上条件，则将自身连续旋转两次。\n\n代码（省略旋转目标的旋转到根）：\n```cpp\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\t\n}\n```\n\n### 插入\n一棵二叉排序树最基础的操作就是插入。\n\n首先，设置一个变量 `target`，表示要插入到的位置，它被初始化为指向根节点，每次循环判断要插入的值大于或小于当前的 `target` 的值，并修改 `target` 为指向某个孩子，循环直到 `target` 指向一个 `NULL`，即可在此位置创建新节点。\n\n插入完成后，需要将新节点 `Splay` 到根的位置。\n\n代码：\n```cpp\nnode_t *insert(const T &value) {\n\tnode_t **target = &root, *parent = NULL;\n\n\twhile (*target) {\n\t\tparent = *target;\n\t\tparent->size++;\n\n\t\tif (value < (*target)->value) {\n\t\t\ttarget = &(*target)->lchild;\n\t\t} else {\n\t\t\ttarget = &(*target)->rchild;\n\t\t}\n\t}\n\n\t*target = new node_t(value, parent, &root);\n\treturn (*target)->splay();\n}\n```\n\n为了下文**删除**操作的方便，我们在每棵 Splay 构造时为其插入两个节点，分别表示无穷大和无穷小，树中其他节点的值都应该在这两个节点的值构成的**开区间**内。\n```cpp\nsplay_t() : root(NULL) {\n\tinsert(MIN);\n\tinsert(MAX);\n}\n```\n### 查找\n根据二叉排序树的有序性，我们可以很轻松的根据值查找到对应的节点，即从根开始查找，根据当前节点的值与要查找节点的值的大小关系，迭代到对应的子节点上，当当前节点的值等于要查找的值时即找到，若当前节点为 `NULL`，则说明查找失败。\n\n注意，当有多个相同值时，查找过程应该返回相同值中排名最靠前的，在此我们使用求找到节点的**前趋**，然后求其**后继**的方法（前趋和后继的求法见下文）。\n\n查找过程结束后，需要将找到的节点 `Splay` 到根。\n\n代码：\n```cpp\nnode_t *find(const T &value) {\n\tnode_t *node = root;\n\twhile (node && value != node->value) {\n\t\tif (value < node->value) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\tif (node) {\n\t\treturn node->pred()->succ()->splay();\n\t} else {\n\t\treturn NULL;\n\t}\n}\n```\n\n### 排名\n一个值在二叉排序树中的排名，即为该值在此二叉排序树的**中序遍历**中第一次出现的位置。\n\n在 Splay 中求排名非常简单，只要找到对应的节点，将其 `Splay` 到根，此时其左子树的 `size + 1` 即为所求的排名，而因为我们在初始化时多插入了一个“无穷小”节点，所以还要将 `1` 减去。\n\n一个有效数值的排名从 `1` 开始，因为表示“无穷小”的节点的排名为 `0`。\n\n代码：\n```cpp\nuint rank(const T &value) {\n\treturn find(value)->lsize();\n}\n```\n\n### 选择\n对应“排名”操作，二叉排序树有“选择”操作——返回此二叉排序树的**中序遍历**中的第 `k` 个元素。\n\n选择比排名要复杂一些，Splay 的选择过程和其他二叉排序树是相同的，我们通过以下几个步骤来实现：\n\n1. 初始化“当前节点”为根；\n2. 每次循环判断**以当前节点为根的 Splay 中**比该节点小的元素数量是否为 `k - 1`，如果是，则该节点即为要选择的节点；\n3. 如果 `k` 小于当前节点的排名，则迭代到左子树，否则，将 `k` 的值减小**当前节点的排名**后迭代到右子树（因为我们跳过的节点数等于**当前节点排名**）。\n\n选择过程结束后，将得到的节点 `Splay` 到根。\n\n代码：\n```cpp\nconst T &select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (node->lsize() != k - 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay()->value;\n}\n```\n\n### 节点的前趋 / 后继\n我们定义二叉排序树中一个节点的前趋为在此二叉排序树的中序遍历中最后一个数值**小于**该节点数值的节点，同理，一个节点的后继为在此二叉排序树的中序遍历中第一个数值**大于**该节点数值的节点。\n\n以节点的前趋为例，其在 Splay 中的实现为：\n\n1. 将欲求其前趋的节点 `Splay` 到根；\n2. 找到根节点**左子树**的**最右链**的**最下端**（后继则相反），该节点即为此二叉排序树的中序遍历中最后一个数值**小于等于**根节点数值的节点；\n3. 如果该节点的数值与欲求其前趋的节点的数值相等，则转到步骤 1，否则该节点即为所求的前趋。\n\n求出节点的前趋或后继后，将得到的节点 `Splay` 到根。\n\n代码：\n```cpp\nnode_t *pred() {\n\tnode_t *pred = this;\n\n\twhile (pred->value == this->value) {\n\t\tpred->splay();\n\t\tpred = pred->lchild;\n\n\t\twhile (pred->rchild) {\n\t\t\tpred = pred->rchild;\n\t\t}\n\t}\n\n\treturn pred->splay();\n}\n\nnode_t *succ() {\n\tnode_t *succ = this;\n\n\twhile (succ->value == this->value) {\n\t\tsucc->splay();\n\t\tsucc = succ->rchild;\n\n\t\twhile (succ->lchild) {\n\t\t\tsucc = succ->lchild;\n\t\t}\n\t}\n\n\treturn succ->splay();\n}\n```\n\n### 值的前趋 / 后继\n我们定义一个数 `x` 在一棵二叉排序树中的前趋为此二叉排序树中小于 `x` 的数中最大的数，同理，一个数 `x` 在一棵二叉排序树中的后继为此二叉排序树中大于 `x` 的数中最小的数。\n\n以值的前趋为例，其实现分为两种情况：\n\n1. 欲求前趋的值在此二叉排序树中，则找到该值对应的节点并求其前趋即可；\n2. 欲求前趋的值不在此二叉排序树中，我们将该值作为一个新节点插入此二叉排序树，用情况 1 的方法求得其前趋，然后将插入的节点删除即可（删除的方法见下文）。\n\n代码：\n```cpp\nconst T &pred(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->pred()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->pred()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n\nconst T &succ(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->succ()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->succ()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n```\n\n### 删除（单点 / 区间）\nSplay 支持两种删除操作：单点删除和区间删除。因为单点删除即为左右端点相同的区间删除，所以我们在此主要讨论区间删除。\n\nSplay 的区间删除实现并不难，但方法非常的巧妙（下文中提到的前趋、后继均为节点的前趋、后继）：\n\n1. 将左端点的前趋 `Splay` 到根；\n2. 将右端点的后继 `Splay` 到**根的右子树**；\n3. 删除**右端点的后继的左子树**；\n4. 分别重新计算右端点的后继、左端点的前趋的 `size`。\n\n代码：\n```cpp\nvoid erase(const T &value) {\n\tnode_t *node = find(value);\n\terase(node);\n}\n\nvoid erase(const T &l, const T &r) {\n\terase(find(l), find(r));\n}\n\nvoid erase(node_t *l, node_t *r = NULL) {\n\tif (!r) {\n\t\tr = l;\n\t}\n\n\tnode_t *pred = l->pred();\n\tnode_t *succ = r->succ();\n\n\tpred->splay();\n\tsucc->splay(&pred->rchild);\n\n\tdelete succ->lchild;\n\tsucc->lchild = NULL;\n\n\tsucc->maintain();\n\tpred->maintain();\n}\n```\n\n### 完整代码（Tyvj / BZOJ / CodeVS 普通平衡树）\n```cpp\n#include <cstdio>\n#include <climits>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T, T MIN, T MAX>\nstruct splay_t {\n\tstruct node_t {\n\t\tT value;\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tuint size;\n\n\t\tnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\n\t\t\tnode_t *pred() {\n\t\t\t\tnode_t *pred = this;\n\n\t\t\t\twhile (pred->value == this->value) {\n\t\t\t\t\tpred->splay();\n\t\t\t\t\tpred = pred->lchild;\n\n\t\t\t\t\twhile (pred->rchild) {\n\t\t\t\t\t\tpred = pred->rchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn pred->splay();\n\t\t\t}\n\n\t\t\tnode_t *succ() {\n\t\t\t\tnode_t *succ = this;\n\n\t\t\t\twhile (succ->value == this->value) {\n\t\t\t\t\tsucc->splay();\n\t\t\t\t\tsucc = succ->rchild;\n\n\t\t\t\t\twhile (succ->lchild) {\n\t\t\t\t\t\tsucc = succ->lchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn succ->splay();\n\t\t\t}\n\t} *root;\n\n\tsplay_t() : root(NULL) {\n\t\tinsert(MIN);\n\t\tinsert(MAX);\n\t}\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tnode_t *insert(const T &value) {\n\t\tnode_t **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\n\t\t\tif (value < (*target)->value) {\n\t\t\t\ttarget = &(*target)->lchild;\n\t\t\t} else {\n\t\t\t\ttarget = &(*target)->rchild;\n\t\t\t}\n\t\t}\n\n\t\t*target = new node_t(value, parent, &root);\n\t\treturn (*target)->splay();\n\t}\n\n\tnode_t *find(const T &value) {\n\t\tnode_t *node = root;\n\t\twhile (node && value != node->value) {\n\t\t\tif (value < node->value) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\tif (node) {\n\t\t\treturn node->pred()->succ()->splay();\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tuint rank(const T &value) {\n\t\treturn find(value)->lsize();\n\t}\n\n\tconst T &select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (node->lsize() != k - 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay()->value;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->pred()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->pred()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->succ()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->succ()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid erase(const T &value) {\n\t\tnode_t *node = find(value);\n\t\terase(node);\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\terase(find(l), find(r));\n\t}\n\n\tvoid erase(node_t *l, node_t *r = NULL) {\n\t\tif (!r) {\n\t\t\tr = l;\n\t\t}\n\n\t\tnode_t *pred = l->pred();\n\t\tnode_t *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(&pred->rchild);\n\n\t\tdelete succ->lchild;\n\t\tsucc->lchild = NULL;\n\n\t\tsucc->maintain();\n\t\tpred->maintain();\n\t}\n};\n\nvoid dfs(splay_t<int, INT_MIN, INT_MAX>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<int, INT_MIN, INT_MAX>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n;\nsplay_t<int, INT_MIN, INT_MAX> splay;\n\nint main() {\n\tscanf(\"%u\", &n);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tuint command;\n\t\tint x;\n\t\tscanf(\"%u %d\", &command, &x);\n\n\t\tswitch (command) {\n\t\tcase 1:\n\t\t\tsplay.insert(x);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tsplay.erase(x);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tprintf(\"%u\\n\", splay.rank(x));\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tprintf(\"%d\\n\", splay.select(x));\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/splay-notes-1.md","raw":"title: Splay 学习笔记（一）\ncategories: OI\ntags: \n  - BZOJ\n  - Splay\n  - 学习笔记\n  - 数据结构\n  - 高级数据结构\npermalink: splay-notes-1\nid: 6\nupdated: '2016-01-19 21:07:47'\ndate: 2015-12-20 05:36:24\n---\n\n上周周四开始学 Splay，一边看《高级数据结构》，一边看 FireStorm 的《[Splay学习笔记](http://blog.csdn.net/farestorm/article/details/49153565)》，现在终于弄明白最基础的一部分了。\n\n<!-- more -->\n\n### Splay 是什么?\nSplay Tree（伸展树）是一种自平衡二叉排序树，可以在均摊$O({\\log} n)$的时间内完成基于 Splay（伸展）操作的修改与查询。\n\n### 基本结构\n根据定义，Splay 是一棵二叉树，它的左子树和右子树分别是一棵 Splay，并且存储的值满足左子树 < 根 < 右子树，以下为每个 Splay 节点的定义。\n\n```cpp\nstruct node_t {\n\tT value;\n\tnode_t *lchild, *rchild, *parent, **root;\n\tuint size;\n};\n```\n其中 `root` 表示指向**指向根节点的指针**的指针，这样做可以方便从任意一个节点找到整棵 Splay 的根节点，并修改它。`size` 表示以当前节点为根的 Splay 共有多少个节点（包括自身），有了 `size`，就可以轻松地实现选择和排名操作。\n\n### 准备\n为了方便各种复杂的操作，我们先为节点类 `node_t` 编写几个短小的方法，代码如下：\n```cpp\nnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n~node_t() {\n\tif (lchild) {\n\t\tdelete lchild;\n\t}\n\n\tif (rchild) {\n\t\tdelete rchild;\n\t}\n}\n\nnode_t *grandparent() {\n\treturn !parent ? NULL : parent->parent;\n}\n\nnode_t *&child(uint x) {\n\treturn !x ? lchild : rchild;\n}\n\nuint relation() {\n\treturn this == parent->lchild ? 0 : 1;\n}\n\nuint maintain() {\n\tsize = lsize() + rsize() + 1;\n}\n\nuint lsize() {\n\treturn lchild ? lchild->size : 0;\n}\n\nuint rsize() {\n\treturn rchild ? rchild->size : 0;\n}\n```\n这里在 `node_t` 的析构函数中递归释放所有内存，这在区间删除中可能耗时较长，如果内存不紧张，可以考虑不释放内存。\n\n为了旋转操作的方便，我们给每个节点设置一个“关系”属性，表示该节点与其父节点的关系，若该节点为左孩子，则“关系”为 `0`，反之则为 `1`。`relation()` 方法用来计算这个“关系”，而 `child()` 方法返回与该节点“关系”为 `x` 的子节点的**引用**。\n\n`maintain()` 方法则用来重新计算以该节点为根的 Splay 的大小，注意，为免去不必要的计算，假设两个子节点的大小是**已经计算好**的，不会再将其重新计算。\n\n### 旋转\n为了调换 Splay 中父节点与子节点的位置，我们实现 `rotate()` 方法，该方法在**保证以下三点**的情况下，将该节点向上移动一个位置：\n\n1. 整棵 Splay 的中序遍历不变；\n2. 受影响节点的 `size` 仍然有效；\n3. `*root` 总是指向整棵 Splay 的根。\n\n以左旋（若当前节点为父节点的左孩子）为例，旋转分为四个步骤：\n\n1. 将**祖父**节点与自身连接；\n2. 将自己的**右孩子**接到自己的父节点的**左孩子**的位置（替代自己）；\n3. 将父节点接到自己的**右孩子**的位置；\n4. 检查如果此时自身节点为根，则更新 `*root`。\n\n如图（图片来自 FireStorm 的《[Splay学习笔记](http://blog.csdn.net/farestorm/article/details/49153565)》）：\n![splay](splay-notes-1/splay.png)\n\n代码：\n```cpp\nvoid rotate() {\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n### Splay 操作\nSplay 规定，每访问一个节点后，都要强制将该节点旋转到根的位置，于是我们很容易想到使用一个循环，判断是否已经到达目标，若不是则旋转，但这种方法的出现的问题在于，一条单链在旋转后仍然是单链，而且每次操作的时间复杂度无法得到保证！\n\n所以我们需要 `Splay` 操作来进行更加“智能化”的旋转，`Splay` 操作的每一次循环分为三步：\n\n1. 如果父节点为目标位置，则向上旋转；\n2. 如果**当前节点与父节点的“关系”**和**父节点与祖父节点的“关系”相同**，则先旋转父节点，再旋转自身；\n3. 如果不满足以上条件，则将自身连续旋转两次。\n\n代码（省略旋转目标的旋转到根）：\n```cpp\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\t\n}\n```\n\n### 插入\n一棵二叉排序树最基础的操作就是插入。\n\n首先，设置一个变量 `target`，表示要插入到的位置，它被初始化为指向根节点，每次循环判断要插入的值大于或小于当前的 `target` 的值，并修改 `target` 为指向某个孩子，循环直到 `target` 指向一个 `NULL`，即可在此位置创建新节点。\n\n插入完成后，需要将新节点 `Splay` 到根的位置。\n\n代码：\n```cpp\nnode_t *insert(const T &value) {\n\tnode_t **target = &root, *parent = NULL;\n\n\twhile (*target) {\n\t\tparent = *target;\n\t\tparent->size++;\n\n\t\tif (value < (*target)->value) {\n\t\t\ttarget = &(*target)->lchild;\n\t\t} else {\n\t\t\ttarget = &(*target)->rchild;\n\t\t}\n\t}\n\n\t*target = new node_t(value, parent, &root);\n\treturn (*target)->splay();\n}\n```\n\n为了下文**删除**操作的方便，我们在每棵 Splay 构造时为其插入两个节点，分别表示无穷大和无穷小，树中其他节点的值都应该在这两个节点的值构成的**开区间**内。\n```cpp\nsplay_t() : root(NULL) {\n\tinsert(MIN);\n\tinsert(MAX);\n}\n```\n### 查找\n根据二叉排序树的有序性，我们可以很轻松的根据值查找到对应的节点，即从根开始查找，根据当前节点的值与要查找节点的值的大小关系，迭代到对应的子节点上，当当前节点的值等于要查找的值时即找到，若当前节点为 `NULL`，则说明查找失败。\n\n注意，当有多个相同值时，查找过程应该返回相同值中排名最靠前的，在此我们使用求找到节点的**前趋**，然后求其**后继**的方法（前趋和后继的求法见下文）。\n\n查找过程结束后，需要将找到的节点 `Splay` 到根。\n\n代码：\n```cpp\nnode_t *find(const T &value) {\n\tnode_t *node = root;\n\twhile (node && value != node->value) {\n\t\tif (value < node->value) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\tif (node) {\n\t\treturn node->pred()->succ()->splay();\n\t} else {\n\t\treturn NULL;\n\t}\n}\n```\n\n### 排名\n一个值在二叉排序树中的排名，即为该值在此二叉排序树的**中序遍历**中第一次出现的位置。\n\n在 Splay 中求排名非常简单，只要找到对应的节点，将其 `Splay` 到根，此时其左子树的 `size + 1` 即为所求的排名，而因为我们在初始化时多插入了一个“无穷小”节点，所以还要将 `1` 减去。\n\n一个有效数值的排名从 `1` 开始，因为表示“无穷小”的节点的排名为 `0`。\n\n代码：\n```cpp\nuint rank(const T &value) {\n\treturn find(value)->lsize();\n}\n```\n\n### 选择\n对应“排名”操作，二叉排序树有“选择”操作——返回此二叉排序树的**中序遍历**中的第 `k` 个元素。\n\n选择比排名要复杂一些，Splay 的选择过程和其他二叉排序树是相同的，我们通过以下几个步骤来实现：\n\n1. 初始化“当前节点”为根；\n2. 每次循环判断**以当前节点为根的 Splay 中**比该节点小的元素数量是否为 `k - 1`，如果是，则该节点即为要选择的节点；\n3. 如果 `k` 小于当前节点的排名，则迭代到左子树，否则，将 `k` 的值减小**当前节点的排名**后迭代到右子树（因为我们跳过的节点数等于**当前节点排名**）。\n\n选择过程结束后，将得到的节点 `Splay` 到根。\n\n代码：\n```cpp\nconst T &select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (node->lsize() != k - 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay()->value;\n}\n```\n\n### 节点的前趋 / 后继\n我们定义二叉排序树中一个节点的前趋为在此二叉排序树的中序遍历中最后一个数值**小于**该节点数值的节点，同理，一个节点的后继为在此二叉排序树的中序遍历中第一个数值**大于**该节点数值的节点。\n\n以节点的前趋为例，其在 Splay 中的实现为：\n\n1. 将欲求其前趋的节点 `Splay` 到根；\n2. 找到根节点**左子树**的**最右链**的**最下端**（后继则相反），该节点即为此二叉排序树的中序遍历中最后一个数值**小于等于**根节点数值的节点；\n3. 如果该节点的数值与欲求其前趋的节点的数值相等，则转到步骤 1，否则该节点即为所求的前趋。\n\n求出节点的前趋或后继后，将得到的节点 `Splay` 到根。\n\n代码：\n```cpp\nnode_t *pred() {\n\tnode_t *pred = this;\n\n\twhile (pred->value == this->value) {\n\t\tpred->splay();\n\t\tpred = pred->lchild;\n\n\t\twhile (pred->rchild) {\n\t\t\tpred = pred->rchild;\n\t\t}\n\t}\n\n\treturn pred->splay();\n}\n\nnode_t *succ() {\n\tnode_t *succ = this;\n\n\twhile (succ->value == this->value) {\n\t\tsucc->splay();\n\t\tsucc = succ->rchild;\n\n\t\twhile (succ->lchild) {\n\t\t\tsucc = succ->lchild;\n\t\t}\n\t}\n\n\treturn succ->splay();\n}\n```\n\n### 值的前趋 / 后继\n我们定义一个数 `x` 在一棵二叉排序树中的前趋为此二叉排序树中小于 `x` 的数中最大的数，同理，一个数 `x` 在一棵二叉排序树中的后继为此二叉排序树中大于 `x` 的数中最小的数。\n\n以值的前趋为例，其实现分为两种情况：\n\n1. 欲求前趋的值在此二叉排序树中，则找到该值对应的节点并求其前趋即可；\n2. 欲求前趋的值不在此二叉排序树中，我们将该值作为一个新节点插入此二叉排序树，用情况 1 的方法求得其前趋，然后将插入的节点删除即可（删除的方法见下文）。\n\n代码：\n```cpp\nconst T &pred(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->pred()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->pred()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n\nconst T &succ(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->succ()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->succ()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n```\n\n### 删除（单点 / 区间）\nSplay 支持两种删除操作：单点删除和区间删除。因为单点删除即为左右端点相同的区间删除，所以我们在此主要讨论区间删除。\n\nSplay 的区间删除实现并不难，但方法非常的巧妙（下文中提到的前趋、后继均为节点的前趋、后继）：\n\n1. 将左端点的前趋 `Splay` 到根；\n2. 将右端点的后继 `Splay` 到**根的右子树**；\n3. 删除**右端点的后继的左子树**；\n4. 分别重新计算右端点的后继、左端点的前趋的 `size`。\n\n代码：\n```cpp\nvoid erase(const T &value) {\n\tnode_t *node = find(value);\n\terase(node);\n}\n\nvoid erase(const T &l, const T &r) {\n\terase(find(l), find(r));\n}\n\nvoid erase(node_t *l, node_t *r = NULL) {\n\tif (!r) {\n\t\tr = l;\n\t}\n\n\tnode_t *pred = l->pred();\n\tnode_t *succ = r->succ();\n\n\tpred->splay();\n\tsucc->splay(&pred->rchild);\n\n\tdelete succ->lchild;\n\tsucc->lchild = NULL;\n\n\tsucc->maintain();\n\tpred->maintain();\n}\n```\n\n### 完整代码（Tyvj / BZOJ / CodeVS 普通平衡树）\n```cpp\n#include <cstdio>\n#include <climits>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T, T MIN, T MAX>\nstruct splay_t {\n\tstruct node_t {\n\t\tT value;\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tuint size;\n\n\t\tnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\n\t\t\tnode_t *pred() {\n\t\t\t\tnode_t *pred = this;\n\n\t\t\t\twhile (pred->value == this->value) {\n\t\t\t\t\tpred->splay();\n\t\t\t\t\tpred = pred->lchild;\n\n\t\t\t\t\twhile (pred->rchild) {\n\t\t\t\t\t\tpred = pred->rchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn pred->splay();\n\t\t\t}\n\n\t\t\tnode_t *succ() {\n\t\t\t\tnode_t *succ = this;\n\n\t\t\t\twhile (succ->value == this->value) {\n\t\t\t\t\tsucc->splay();\n\t\t\t\t\tsucc = succ->rchild;\n\n\t\t\t\t\twhile (succ->lchild) {\n\t\t\t\t\t\tsucc = succ->lchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn succ->splay();\n\t\t\t}\n\t} *root;\n\n\tsplay_t() : root(NULL) {\n\t\tinsert(MIN);\n\t\tinsert(MAX);\n\t}\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tnode_t *insert(const T &value) {\n\t\tnode_t **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\n\t\t\tif (value < (*target)->value) {\n\t\t\t\ttarget = &(*target)->lchild;\n\t\t\t} else {\n\t\t\t\ttarget = &(*target)->rchild;\n\t\t\t}\n\t\t}\n\n\t\t*target = new node_t(value, parent, &root);\n\t\treturn (*target)->splay();\n\t}\n\n\tnode_t *find(const T &value) {\n\t\tnode_t *node = root;\n\t\twhile (node && value != node->value) {\n\t\t\tif (value < node->value) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\tif (node) {\n\t\t\treturn node->pred()->succ()->splay();\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tuint rank(const T &value) {\n\t\treturn find(value)->lsize();\n\t}\n\n\tconst T &select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (node->lsize() != k - 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay()->value;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->pred()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->pred()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->succ()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->succ()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid erase(const T &value) {\n\t\tnode_t *node = find(value);\n\t\terase(node);\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\terase(find(l), find(r));\n\t}\n\n\tvoid erase(node_t *l, node_t *r = NULL) {\n\t\tif (!r) {\n\t\t\tr = l;\n\t\t}\n\n\t\tnode_t *pred = l->pred();\n\t\tnode_t *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(&pred->rchild);\n\n\t\tdelete succ->lchild;\n\t\tsucc->lchild = NULL;\n\n\t\tsucc->maintain();\n\t\tpred->maintain();\n\t}\n};\n\nvoid dfs(splay_t<int, INT_MIN, INT_MAX>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<int, INT_MIN, INT_MAX>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n;\nsplay_t<int, INT_MIN, INT_MAX> splay;\n\nint main() {\n\tscanf(\"%u\", &n);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tuint command;\n\t\tint x;\n\t\tscanf(\"%u %d\", &command, &x);\n\n\t\tswitch (command) {\n\t\tcase 1:\n\t\t\tsplay.insert(x);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tsplay.erase(x);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tprintf(\"%u\\n\", splay.rank(x));\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tprintf(\"%d\\n\", splay.select(x));\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"splay-notes-1","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n39004cofdkwvpswn69"},{"title":"「SDOI2015」星际战争 - 网络流","date":"2016-02-29T07:42:11.000Z","_content":"\nY 军团一共派遣了 $ N $ 个巨型机器人进攻 X 军团的阵地，其中第 $ i $ 个巨型机器人的装甲值为 $ A_i $。当一个巨型机器人的装甲值减少到 0 或者以下时，这个巨型机器人就被摧毁了。X 军团有 $ M $ 个激光武器，其中第 $ i $ 个激光武器每秒可以削减一个巨型机器人 $ B_i $ 的装甲值。激光武器的攻击是连续的。这种激光武器非常奇怪，一个激光武器只能攻击一些特定的敌人。Y 军团需要知道 X 军团最少需要用多长时间才能将 Y 军团的所有巨型机器人摧毁。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 3993](http://www.lydsy.com/JudgeOnline/problem.php?id=3993)\n\n### 解题思路\n先二分一个时间，然后用网络流判定是否能在这段时间内打完。\n\n1. 从源点到每一个武器连一条边，容量为武器的威力 × 时间；\n2. 从每一个机器人向汇点连一条边，容量为该机器人的装甲值；\n3. 从每个武器向所有从该武器能攻击的机器人连一条边，容量为正无穷。\n\n嗯，说起来很容易对吧w ……\n\n然而答案是实数，实数二分倒没什么问题，要注意的是 Dinic 模板也要改成实数的。\n\n二分的范围不太好确定，既然题目明确有解，那就定上界为**用一个威力最小的武器打所有机器人所用时间**，反正不会错。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <cfloat>\n#include <algorithm>\n#include <queue>\n \nconst int MAXN = 50;\nconst int MAXM = 50;\nconst double EPS = 1e-4;\n \nstruct Node;\nstruct Edge;\n \nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n \nstruct Edge {\n\tNode *from, *to;\n\tdouble capacity, flow;\n\tEdge *next, *reversedEdge;\n \n\tEdge(Node *from, Node *to, double capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n \nint n, m, robot[MAXN], sumRobot, gun[MAXM], minGun = INT_MAX, attack[MAXM][MAXN];\n \ninline bool equal(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\n \nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n \n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n \n\t\ts->level = 1;\n\t\t \n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n \n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (!equal(e->capacity - e->flow, 0) && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\treturn false;\n\t}\n \n\tdouble findPath(Node *s, Node *t, double limit = DBL_MAX) {\n\t\tif (s == t) return limit;\n \n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && !equal(e->capacity - e->flow, 0)) {\n\t\t\t\tdouble flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\treturn 0;\n\t}\n \n\tdouble operator()(int s, int t, int n) {\n\t\tdouble ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tdouble flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n \n\t\treturn ans;\n\t}\n} dinic;\n \ninline void addEdge(int from, int to, double capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n \n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n \ninline void cleanUp(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n \ninline bool check(double time) {\n\tconst int s = 0, t = n + m + 1;\n \n\tfor (int i = 1; i <= m; i++) addEdge(s, i, gun[i - 1] * time);\n\tfor (int i = 1; i <= n; i++) addEdge(i + m, t, robot[i - 1]);\n \n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (attack[i - 1][j - 1] == 1) {\n\t\t\t\taddEdge(i, j + m, DBL_MAX);\n\t\t\t}\n\t\t}\n\t}\n \n\tdouble flow = dinic(s, t, n + m + 2);\n \n\tcleanUp(n + m + 2);\n \n\t//printf(\"%.3lf %d\\n\", flow, sumRobot);\n\treturn equal(flow, sumRobot);\n}\n \ninline double dichotomy() {\n\tdouble l = 0, r = ((double)sumRobot) / ((double)minGun);\n\twhile (r - l > EPS) {\n\t\tdouble mid = l + (r - l) / 2;\n\t\t//printf(\"mid = %.6lf\\n\", mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid;\n\t}\n \n\treturn l + (r - l) / 2;\n}\n \nint main() {\n\tscanf(\"%d %d\", &n, &m);\n \n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &robot[i]), sumRobot += robot[i];\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &gun[i]), minGun = std::min(minGun, gun[i]);\n \n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &attack[i][j]);\n\t\t}\n\t}\n \n\tprintf(\"%.6lf\\n\", dichotomy());\n \n\treturn 0;\n}\n```\n","source":"_posts/sdoi2015-war.md","raw":"title: 「SDOI2015」星际战争 - 网络流\ndate: 2016-02-29 15:42:11\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - Dinic\n  - 图论\n  - 网络流\n  - 二分答案\n  - 实数二分\npermalink: sdoi2015-war\n---\n\nY 军团一共派遣了 $ N $ 个巨型机器人进攻 X 军团的阵地，其中第 $ i $ 个巨型机器人的装甲值为 $ A_i $。当一个巨型机器人的装甲值减少到 0 或者以下时，这个巨型机器人就被摧毁了。X 军团有 $ M $ 个激光武器，其中第 $ i $ 个激光武器每秒可以削减一个巨型机器人 $ B_i $ 的装甲值。激光武器的攻击是连续的。这种激光武器非常奇怪，一个激光武器只能攻击一些特定的敌人。Y 军团需要知道 X 军团最少需要用多长时间才能将 Y 军团的所有巨型机器人摧毁。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 3993](http://www.lydsy.com/JudgeOnline/problem.php?id=3993)\n\n### 解题思路\n先二分一个时间，然后用网络流判定是否能在这段时间内打完。\n\n1. 从源点到每一个武器连一条边，容量为武器的威力 × 时间；\n2. 从每一个机器人向汇点连一条边，容量为该机器人的装甲值；\n3. 从每个武器向所有从该武器能攻击的机器人连一条边，容量为正无穷。\n\n嗯，说起来很容易对吧w ……\n\n然而答案是实数，实数二分倒没什么问题，要注意的是 Dinic 模板也要改成实数的。\n\n二分的范围不太好确定，既然题目明确有解，那就定上界为**用一个威力最小的武器打所有机器人所用时间**，反正不会错。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <cfloat>\n#include <algorithm>\n#include <queue>\n \nconst int MAXN = 50;\nconst int MAXM = 50;\nconst double EPS = 1e-4;\n \nstruct Node;\nstruct Edge;\n \nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n \nstruct Edge {\n\tNode *from, *to;\n\tdouble capacity, flow;\n\tEdge *next, *reversedEdge;\n \n\tEdge(Node *from, Node *to, double capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n \nint n, m, robot[MAXN], sumRobot, gun[MAXM], minGun = INT_MAX, attack[MAXM][MAXN];\n \ninline bool equal(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\n \nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n \n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n \n\t\ts->level = 1;\n\t\t \n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n \n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (!equal(e->capacity - e->flow, 0) && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\treturn false;\n\t}\n \n\tdouble findPath(Node *s, Node *t, double limit = DBL_MAX) {\n\t\tif (s == t) return limit;\n \n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && !equal(e->capacity - e->flow, 0)) {\n\t\t\t\tdouble flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\treturn 0;\n\t}\n \n\tdouble operator()(int s, int t, int n) {\n\t\tdouble ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tdouble flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n \n\t\treturn ans;\n\t}\n} dinic;\n \ninline void addEdge(int from, int to, double capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n \n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n \ninline void cleanUp(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n \ninline bool check(double time) {\n\tconst int s = 0, t = n + m + 1;\n \n\tfor (int i = 1; i <= m; i++) addEdge(s, i, gun[i - 1] * time);\n\tfor (int i = 1; i <= n; i++) addEdge(i + m, t, robot[i - 1]);\n \n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (attack[i - 1][j - 1] == 1) {\n\t\t\t\taddEdge(i, j + m, DBL_MAX);\n\t\t\t}\n\t\t}\n\t}\n \n\tdouble flow = dinic(s, t, n + m + 2);\n \n\tcleanUp(n + m + 2);\n \n\t//printf(\"%.3lf %d\\n\", flow, sumRobot);\n\treturn equal(flow, sumRobot);\n}\n \ninline double dichotomy() {\n\tdouble l = 0, r = ((double)sumRobot) / ((double)minGun);\n\twhile (r - l > EPS) {\n\t\tdouble mid = l + (r - l) / 2;\n\t\t//printf(\"mid = %.6lf\\n\", mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid;\n\t}\n \n\treturn l + (r - l) / 2;\n}\n \nint main() {\n\tscanf(\"%d %d\", &n, &m);\n \n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &robot[i]), sumRobot += robot[i];\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &gun[i]), minGun = std::min(minGun, gun[i]);\n \n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &attack[i][j]);\n\t\t}\n\t}\n \n\tprintf(\"%.6lf\\n\", dichotomy());\n \n\treturn 0;\n}\n```\n","slug":"sdoi2015-war","published":1,"updated":"2016-03-15T01:05:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n3o004jofdkvpb4tc4y"},{"title":"「SDOI2010」星际竞速 - 费用流","date":"2016-02-29T13:30:11.000Z","_content":"\n大赛要求车手们从一颗与这 $ N $ 颗行星之间没有任何航路的天体出发，访问这 $ N $ 颗行星每颗恰好一次。超能电驴有两种移动模式：高速航行模式和能力爆发模式。在高速航行模式下，超能电驴会沿星际航路高速航行。在能力爆发模式下，经过一段时间的定位之后，它能瞬间移动到任意一个行星。在使用高速航行模式的时候，只能由每个星球飞往引力比它大的星球，否则赛车就会发生爆炸。求完成比赛的最少时间。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 1927](http://www.lydsy.com/JudgeOnline/problem.php?id=1927)  \n[CodeVS 2313](http://codevs.cn/problem/2313/)\n\n### 解题思路\n求完成比赛的最少时间，很容易想到最短路，然而不确定起点终点而且恰好访问一次都不太适合最短路 …… 考虑网络流建模吧。\n\n刚开始想到的一个**错误**的解法：\n\n1. 把每个点拆成两个点，一个表示入另一个表示出，之间连一条容量为 1，费用为零的边；\n2. 从源点到每个入点连一条容量为 1 费用为零的边；\n3. 从每个出点到汇点连一条容量为 1 费用为零的边；\n4. 对于每个点，从它的出点到所有他所能到达的点的入点连一条容量为 1 费用为航行时间的边；\n5. 建立『中转站』，从每个点到中转站连一条容量为 1 费用为 0 的边；从中转站到每个点连一条容量为 1 费用为定位时间的边。\n\n求出最小费用最大流 …… 呃，答案就是零 ……\n\n很容易想出上面的模型是错的，因为它不能保证每个点都被访问过 —— 虽然它比较直观。\n\n再来分析一下题意，每个点都经过一次，有点类似路径覆盖，而路径覆盖中是没有边权的，考虑把边权加在费用上。\n\n一种**类似于路径覆盖**的建模方式：\n\n1. 把每个点拆成两个点，一个表示入另一个表示出；\n2. 从源点向每个入点连一条容量为 1 费用为零的边；\n3. 从每个出点向汇点连一条容量为 1 费用为零的边；\n4. 对于每个点，从它的出点到所有他所能到达的点的入点连一条容量为 1 费用为航行时间的边；\n5. 从源点向每个**出点**连一条容量为 1 费用为定位时间的边。\n\n这种建模思想抓住了题目中『每个点经过一次』的条件，避开了路径上的问题 —— 整个网络保证了到汇点边全部满流，也就对应了每个点被经过一次。\n\n处理『瞬间移动』的思路是，不考虑是从哪个星球移动过来，向哪里走 —— 因为从每个点向哪里走是由选择的边决定的（甚至可能瞬移到的点就是终点），只需要考虑，瞬移经过的点不需要再在其他路径上被经过，所以直接从源点连到某个点的出点就好啦。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 800;\nconst int MAXM = 15000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m;\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(s, i + n, 1, x);\n\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(i + n, t, 1, 0);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v + n, 1, w);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n * 2 + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2010-starrace.md","raw":"title: 「SDOI2010」星际竞速 - 费用流 \ndate: 2016-02-29 21:30:11\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - Edmonds-Karp\n  - 图论\n  - 网络流\n  - 费用流\npermalink: sdoi2010-starrace\n---\n\n大赛要求车手们从一颗与这 $ N $ 颗行星之间没有任何航路的天体出发，访问这 $ N $ 颗行星每颗恰好一次。超能电驴有两种移动模式：高速航行模式和能力爆发模式。在高速航行模式下，超能电驴会沿星际航路高速航行。在能力爆发模式下，经过一段时间的定位之后，它能瞬间移动到任意一个行星。在使用高速航行模式的时候，只能由每个星球飞往引力比它大的星球，否则赛车就会发生爆炸。求完成比赛的最少时间。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 1927](http://www.lydsy.com/JudgeOnline/problem.php?id=1927)  \n[CodeVS 2313](http://codevs.cn/problem/2313/)\n\n### 解题思路\n求完成比赛的最少时间，很容易想到最短路，然而不确定起点终点而且恰好访问一次都不太适合最短路 …… 考虑网络流建模吧。\n\n刚开始想到的一个**错误**的解法：\n\n1. 把每个点拆成两个点，一个表示入另一个表示出，之间连一条容量为 1，费用为零的边；\n2. 从源点到每个入点连一条容量为 1 费用为零的边；\n3. 从每个出点到汇点连一条容量为 1 费用为零的边；\n4. 对于每个点，从它的出点到所有他所能到达的点的入点连一条容量为 1 费用为航行时间的边；\n5. 建立『中转站』，从每个点到中转站连一条容量为 1 费用为 0 的边；从中转站到每个点连一条容量为 1 费用为定位时间的边。\n\n求出最小费用最大流 …… 呃，答案就是零 ……\n\n很容易想出上面的模型是错的，因为它不能保证每个点都被访问过 —— 虽然它比较直观。\n\n再来分析一下题意，每个点都经过一次，有点类似路径覆盖，而路径覆盖中是没有边权的，考虑把边权加在费用上。\n\n一种**类似于路径覆盖**的建模方式：\n\n1. 把每个点拆成两个点，一个表示入另一个表示出；\n2. 从源点向每个入点连一条容量为 1 费用为零的边；\n3. 从每个出点向汇点连一条容量为 1 费用为零的边；\n4. 对于每个点，从它的出点到所有他所能到达的点的入点连一条容量为 1 费用为航行时间的边；\n5. 从源点向每个**出点**连一条容量为 1 费用为定位时间的边。\n\n这种建模思想抓住了题目中『每个点经过一次』的条件，避开了路径上的问题 —— 整个网络保证了到汇点边全部满流，也就对应了每个点被经过一次。\n\n处理『瞬间移动』的思路是，不考虑是从哪个星球移动过来，向哪里走 —— 因为从每个点向哪里走是由选择的边决定的（甚至可能瞬移到的点就是终点），只需要考虑，瞬移经过的点不需要再在其他路径上被经过，所以直接从源点连到某个点的出点就好啦。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 800;\nconst int MAXM = 15000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m;\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(s, i + n, 1, x);\n\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(i + n, t, 1, 0);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v + n, 1, w);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n * 2 + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2010-starrace","published":1,"updated":"2016-03-15T01:05:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n3y004xofdkqackgp34"},{"title":"「SDOI2008」洞穴勘测 - Link-Cut Tree","date":"2016-03-15T12:06:34.000Z","_content":"\n如果监测到洞穴 $ u $ 和洞穴 $ v $ 之间出现了一条通道，终端机上会显示一条指令 `Connect u v`；如果监测到洞穴 $ u $ 和洞穴 $ v $ 之间的通道被毁，终端机上会显示一条指令 `Destroy u v`。辉辉希望能随时通过终端机发出指令 `Query u v`，向监测仪询问此时洞穴 $ u $ 和洞穴 $ v $ 是否连通。已知在第一条指令显示之前，洞穴群中没有任何通道存在。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 2049](http://www.lydsy.com/JudgeOnline/problem.php?id=2049)  \n[CodeVS 1839](http://codevs.cn/problem/1839/)\n\n### 解题思路\n最简单的 Link-Cut Tree 模板题。\n\n相当于能拆的并查集。\n\n### AC代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), reversed(false) {\n\t\t\tchild[0] = child[1] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\t\t\t\n\n\t\t\tNode *oldParent = parent;\n\t\t\tRelation r = relation();\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\t\t\toldParent->child[r] = child[r ^ 1];\n\n\t\t\toldParent->parent = this;\n\t\t\tchild[r ^ 1] = oldParent;\n\n\t\t\tstd::swap(pathParent, oldParent->pathParent);\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\t\tparent->pushDown(), pushDown();\n\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->pathParent, child[R]->parent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tNode *findRoot() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\tNode *v = this;\n\t\t\twhile (v->pushDown(), v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].child[R] = NULL;\n\t\tnodes[v - 1].parent = NULL;\n\t}\n\n\tNode *find(int u) {\n\t\treturn nodes[u - 1].findRoot();\n\t}\n} lct;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar command[sizeof(\"Connect\")];\n\t\tint u, v;\n\t\tscanf(\"%s %d %d\", command, &u, &v);\n\n\t\tif (command[0] == 'C') lct.link(u, v);\n\t\telse if (command[0] == 'D') lct.cut(u, v);\n\t\telse if (command[0] == 'Q') {\n\t\t\tif (lct.find(u) == lct.find(v)) puts(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n```\n","source":"_posts/sdoi2008-cave.md","raw":"title: 「SDOI2008」洞穴勘测 - Link-Cut Tree \ndate: 2016-03-15 20:06:34\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - CodeVS\n  - 数据结构\n  - 高级数据结构\n  - 动态树\n  - Link-Cut Tree\npermalink: sdoi2008-cave\n---\n\n如果监测到洞穴 $ u $ 和洞穴 $ v $ 之间出现了一条通道，终端机上会显示一条指令 `Connect u v`；如果监测到洞穴 $ u $ 和洞穴 $ v $ 之间的通道被毁，终端机上会显示一条指令 `Destroy u v`。辉辉希望能随时通过终端机发出指令 `Query u v`，向监测仪询问此时洞穴 $ u $ 和洞穴 $ v $ 是否连通。已知在第一条指令显示之前，洞穴群中没有任何通道存在。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 2049](http://www.lydsy.com/JudgeOnline/problem.php?id=2049)  \n[CodeVS 1839](http://codevs.cn/problem/1839/)\n\n### 解题思路\n最简单的 Link-Cut Tree 模板题。\n\n相当于能拆的并查集。\n\n### AC代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), reversed(false) {\n\t\t\tchild[0] = child[1] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\t\t\t\n\n\t\t\tNode *oldParent = parent;\n\t\t\tRelation r = relation();\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\t\t\toldParent->child[r] = child[r ^ 1];\n\n\t\t\toldParent->parent = this;\n\t\t\tchild[r ^ 1] = oldParent;\n\n\t\t\tstd::swap(pathParent, oldParent->pathParent);\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\t\tparent->pushDown(), pushDown();\n\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->pathParent, child[R]->parent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tNode *findRoot() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\tNode *v = this;\n\t\t\twhile (v->pushDown(), v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].child[R] = NULL;\n\t\tnodes[v - 1].parent = NULL;\n\t}\n\n\tNode *find(int u) {\n\t\treturn nodes[u - 1].findRoot();\n\t}\n} lct;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar command[sizeof(\"Connect\")];\n\t\tint u, v;\n\t\tscanf(\"%s %d %d\", command, &u, &v);\n\n\t\tif (command[0] == 'C') lct.link(u, v);\n\t\telse if (command[0] == 'D') lct.cut(u, v);\n\t\telse if (command[0] == 'Q') {\n\t\t\tif (lct.find(u) == lct.find(v)) puts(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n```\n","slug":"sdoi2008-cave","published":1,"updated":"2016-03-15T12:06:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n430057ofdkah54r4vc"},{"title":"「SCOI2015」情报传递 - 离线 + Link-Cut Tree","date":"2016-03-22T10:09:12.000Z","_content":"\n奈特公司有着庞大的情报网络。情报网络中共有 $ n $ 名情报员。每名情报员有若干名下线，除 1 名大头目外其余 $ n - 1 $ 名情报员有且仅有 1 名上线。每名情报员只能与自己的上、下线联系，同时，情报网络中任意两名情报员一定能够通过情报网络传递情报。\n奈特公司每天会派发以下两种任务中的一个任务：\n\n1. 搜集情报：指派 $ T $ 号情报员搜集情报；\n2. 传递情报：将一条情报从 $ X $ 号情报员传递给 $ Y $ 号情报员。\n\n情报员最初处于潜伏阶段，危险值为 0；一旦某个情报员开始搜集情报，他的危险值就会持续增加，每天增加 1 点危险值（开始搜集情报的当天危险值仍为 0，第 2 天危险值为 1，以此类推）。传递情报并不会使情报员的危险值增加。\n\n为了保证传递情报的过程相对安全，每条情报都有一个风险控制值 $ C $。公司认为，传递这条情报的所有情报员中，危险值大于 $ C $ 的情报员将对该条情报构成威胁。现在，奈特公司希望知道，对于每个传递情报任务，参与传递的情报员有多少个，其中对该条情报构成威胁的情报员有多少个。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 4448](http://www.lydsy.com/JudgeOnline/problem.php?id=4448)\n\n### 解题思路\n因为整个网络是一棵树，所以可以用一棵 Link-Cut Tree 来维护。\n\n前 30 分，无修改操作，直接求出两点距离。\n\n30 ~ 60 分，保证 $ C = 0 $，修改直接单点修改值为 1，查询直接查询有多少 1 即可。\n\n后 40 分，考虑到对于每个查询操作，只有距离它 $ C + 1 $ 天之前的修改操作对它有贡献，所以可以将操作离线，保证每次修改后直接处理查询即可。\n\n### AC代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tint value, sum, size;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), value(0), sum(0), size(1), reversed(false) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value, size = 1;\n\t\t\tif (child[L]) sum += child[L]->sum, size += child[L]->size;\n\t\t\tif (child[R]) sum += child[R]->sum, size += child[R]->size;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\t\t\toldParent->child[x] = child[x ^ 1];\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->parent, child[R]->pathParent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tpathParent->maintain();\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid query(int u, int v, int &size, int &sum) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[v - 1].splay();\n\t\tsize = nodes[v - 1].size;\n\t\tsum = nodes[v - 1].sum;\n\t}\n\n\tvoid update(int u, int value) {\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].value = value;\n\t\tnodes[u - 1].maintain();\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].splay();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n} lct;\n\nstruct Day {\n\tint id;\n\tint task;\n\tint u, v, c;\n\n\tbool operator<(const Day &other) const {\n\t\treturn c < other.c;\n\t}\n} days[MAXM];\n\nint n, m;\n\ninline void bfs() {\n\tstd::queue<Tree *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tTree *t = q.front();\n\t\tq.pop();\n\n\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\tc->depth = t->depth + 1;\n\t\t\tq.push(c);\n\t\t}\n\t}\n}\n\ninline void work() {\n\tfor (int i = 0; i < m; i++) {\n\t\tif (days[i].task == 2) lct.update(days[i].u, 1);\n\t\telse {\n\t\t\tint size, sum;\n\t\t\tlct.query(days[i].u, days[i].v, size, sum);\n\t\t\tprintf(\"%d %d\\n\", size, sum);\n\t\t}\n\t}\n}\n\nint main() {\n\t// freopen(\"message.in\", \"r\", stdin);\n\t// freopen(\"message.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint u;\n\t\tscanf(\"%d\", &u);\n\t\tif (u != 0) lct.link(u, i);\n\t}\n\n\tscanf(\"%d\", &m);\n\tbool flag1 = true, flag2 = true;\n\tfor (int i = 0; i < m; i++) {\n\t\tdays[i].id = i;\n\t\tscanf(\"%d\", &days[i].task);\n\t\tif (days[i].task == 2) scanf(\"%d\", &days[i].u), days[i].c = i;\n\t\telse {\n\t\t\tint tmp;\n\t\t\tscanf(\"%d %d %d\", &days[i].u, &days[i].v, &tmp);\n\t\t\tdays[i].c = i - tmp;\n\t\t}\n\t}\n\n\tstd::sort(days, days + m);\n\n\twork();\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-message.md","raw":"title: 「SCOI2015」情报传递 - 离线 + Link-Cut Tree\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 安师大附中集训\n  - 离线\n  - Link-Cut Tree\n  - 数据结构\n  - 高级数据结构\npermalink: scoi2015-message\ndate: 2016-03-22 18:09:12\n---\n\n奈特公司有着庞大的情报网络。情报网络中共有 $ n $ 名情报员。每名情报员有若干名下线，除 1 名大头目外其余 $ n - 1 $ 名情报员有且仅有 1 名上线。每名情报员只能与自己的上、下线联系，同时，情报网络中任意两名情报员一定能够通过情报网络传递情报。\n奈特公司每天会派发以下两种任务中的一个任务：\n\n1. 搜集情报：指派 $ T $ 号情报员搜集情报；\n2. 传递情报：将一条情报从 $ X $ 号情报员传递给 $ Y $ 号情报员。\n\n情报员最初处于潜伏阶段，危险值为 0；一旦某个情报员开始搜集情报，他的危险值就会持续增加，每天增加 1 点危险值（开始搜集情报的当天危险值仍为 0，第 2 天危险值为 1，以此类推）。传递情报并不会使情报员的危险值增加。\n\n为了保证传递情报的过程相对安全，每条情报都有一个风险控制值 $ C $。公司认为，传递这条情报的所有情报员中，危险值大于 $ C $ 的情报员将对该条情报构成威胁。现在，奈特公司希望知道，对于每个传递情报任务，参与传递的情报员有多少个，其中对该条情报构成威胁的情报员有多少个。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 4448](http://www.lydsy.com/JudgeOnline/problem.php?id=4448)\n\n### 解题思路\n因为整个网络是一棵树，所以可以用一棵 Link-Cut Tree 来维护。\n\n前 30 分，无修改操作，直接求出两点距离。\n\n30 ~ 60 分，保证 $ C = 0 $，修改直接单点修改值为 1，查询直接查询有多少 1 即可。\n\n后 40 分，考虑到对于每个查询操作，只有距离它 $ C + 1 $ 天之前的修改操作对它有贡献，所以可以将操作离线，保证每次修改后直接处理查询即可。\n\n### AC代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tint value, sum, size;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), value(0), sum(0), size(1), reversed(false) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value, size = 1;\n\t\t\tif (child[L]) sum += child[L]->sum, size += child[L]->size;\n\t\t\tif (child[R]) sum += child[R]->sum, size += child[R]->size;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\t\t\toldParent->child[x] = child[x ^ 1];\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->parent, child[R]->pathParent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tpathParent->maintain();\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid query(int u, int v, int &size, int &sum) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[v - 1].splay();\n\t\tsize = nodes[v - 1].size;\n\t\tsum = nodes[v - 1].sum;\n\t}\n\n\tvoid update(int u, int value) {\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].value = value;\n\t\tnodes[u - 1].maintain();\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].splay();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n} lct;\n\nstruct Day {\n\tint id;\n\tint task;\n\tint u, v, c;\n\n\tbool operator<(const Day &other) const {\n\t\treturn c < other.c;\n\t}\n} days[MAXM];\n\nint n, m;\n\ninline void bfs() {\n\tstd::queue<Tree *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tTree *t = q.front();\n\t\tq.pop();\n\n\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\tc->depth = t->depth + 1;\n\t\t\tq.push(c);\n\t\t}\n\t}\n}\n\ninline void work() {\n\tfor (int i = 0; i < m; i++) {\n\t\tif (days[i].task == 2) lct.update(days[i].u, 1);\n\t\telse {\n\t\t\tint size, sum;\n\t\t\tlct.query(days[i].u, days[i].v, size, sum);\n\t\t\tprintf(\"%d %d\\n\", size, sum);\n\t\t}\n\t}\n}\n\nint main() {\n\t// freopen(\"message.in\", \"r\", stdin);\n\t// freopen(\"message.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint u;\n\t\tscanf(\"%d\", &u);\n\t\tif (u != 0) lct.link(u, i);\n\t}\n\n\tscanf(\"%d\", &m);\n\tbool flag1 = true, flag2 = true;\n\tfor (int i = 0; i < m; i++) {\n\t\tdays[i].id = i;\n\t\tscanf(\"%d\", &days[i].task);\n\t\tif (days[i].task == 2) scanf(\"%d\", &days[i].u), days[i].c = i;\n\t\telse {\n\t\t\tint tmp;\n\t\t\tscanf(\"%d %d %d\", &days[i].u, &days[i].v, &tmp);\n\t\t\tdays[i].c = i - tmp;\n\t\t}\n\t}\n\n\tstd::sort(days, days + m);\n\n\twork();\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-message","published":1,"updated":"2016-03-22T10:10:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n4a005iofdkem946jkh"},{"title":"「SCOI2015」小凸玩矩阵 - 二分图匹配","date":"2016-03-22T09:56:34.000Z","_content":"\n小方给小凸一个 $ N * M $（$ N \\leq M $）的矩阵 $ A $，要求小秃从其中选出 $ N $个数，其中任意两个数字不能在同一行或同一列，现小凸想知道选出来的 $ N $ 个数中第 $ K $ 大的数字的最小值是多少。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 4443](http://www.lydsy.com/JudgeOnline/problem.php?id=4443)\n\n### 解题思路\n二分第 $ K $ 大的数是多少，然后建二分图，用行匹配列，检验匹配数是不是大于等于 $ N - K + 1 $。\n\n注意，是第 $ K $ 大，不是第 $ K $ 小！\n\n### AC代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 250;\nconst int MAXM = 250;\nconst int MAXK = 250;\nconst int CACHE_FIX = 3;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, k, a[MAXN + CACHE_FIX][MAXM], max;\n\nvoid cleanUp() {\n\tfor (int i = 0; i < n + m + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n\nbool check(int limit) {\n\tcleanUp();\n\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1);\n\tfor (int j = 1; j <= m; j++) addEdge(n + j, t, 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (a[i - 1][j - 1] <= limit) addEdge(i, n + j, 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\t// printf(\"%d\\n\", maxFlow);\n\treturn maxFlow >= n - k + 1;\n}\n\ninline int solve() {\n\tstatic int tmp[MAXN * MAXM];\n\tfor (int i = 0, c = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\ttmp[c++] = a[i][j];\n\t\t}\n\t}\n\tstd::sort(tmp, tmp + n * m);\n\n\tint *l = tmp, *r = std::unique(tmp, tmp + n * m) - 1;\n\twhile (l < r) {\n\t\tint *const mid = l + ((r - l) >> 1);\n\t\tif (check(*mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn *l;\n}\n\nint main() {\n\t// freopen(\"matrix.in\", \"r\", stdin);\n\t// freopen(\"matrix.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-matrix.md","raw":"title: 「SCOI2015」小凸玩矩阵 - 二分图匹配\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 安师大附中集训\n  - 二分答案\n  - 二分图匹配\n  - 网络流\n  - Dinic\npermalink: scoi2015-matrix\ndate: 2016-03-22 17:56:34\n---\n\n小方给小凸一个 $ N * M $（$ N \\leq M $）的矩阵 $ A $，要求小秃从其中选出 $ N $个数，其中任意两个数字不能在同一行或同一列，现小凸想知道选出来的 $ N $ 个数中第 $ K $ 大的数字的最小值是多少。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 4443](http://www.lydsy.com/JudgeOnline/problem.php?id=4443)\n\n### 解题思路\n二分第 $ K $ 大的数是多少，然后建二分图，用行匹配列，检验匹配数是不是大于等于 $ N - K + 1 $。\n\n注意，是第 $ K $ 大，不是第 $ K $ 小！\n\n### AC代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 250;\nconst int MAXM = 250;\nconst int MAXK = 250;\nconst int CACHE_FIX = 3;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, k, a[MAXN + CACHE_FIX][MAXM], max;\n\nvoid cleanUp() {\n\tfor (int i = 0; i < n + m + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n\nbool check(int limit) {\n\tcleanUp();\n\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1);\n\tfor (int j = 1; j <= m; j++) addEdge(n + j, t, 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (a[i - 1][j - 1] <= limit) addEdge(i, n + j, 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\t// printf(\"%d\\n\", maxFlow);\n\treturn maxFlow >= n - k + 1;\n}\n\ninline int solve() {\n\tstatic int tmp[MAXN * MAXM];\n\tfor (int i = 0, c = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\ttmp[c++] = a[i][j];\n\t\t}\n\t}\n\tstd::sort(tmp, tmp + n * m);\n\n\tint *l = tmp, *r = std::unique(tmp, tmp + n * m) - 1;\n\twhile (l < r) {\n\t\tint *const mid = l + ((r - l) >> 1);\n\t\tif (check(*mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn *l;\n}\n\nint main() {\n\t// freopen(\"matrix.in\", \"r\", stdin);\n\t// freopen(\"matrix.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-matrix","published":1,"updated":"2016-03-22T10:26:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n4m005tofdkkobiu8x8"},{"title":"「SCOI2015」国旗计划 - 贪心 + 倍增","date":"2016-03-22T10:25:14.000Z","_content":"\nA 国幅员辽阔，边境线上设有 $ M $ 个边防站，顺时针编号 $ 1 $ 至 $ M $。每名边防战士常驻两个边防站，并且善于在这两个边防站之间长途奔袭，我们称这两个边防站之间的路程是这个边防战士的奔袭区间。每名战士的奔袭区间都不会被其他战士的奔袭区间所包含。\n\n现在，局长希望知道，至少需要多少名战士，才能使得他们的奔袭区间覆盖全部的边境线。局长还希望知道对于每一名战士，在他必须参加国旗计划的前提下，至少需要多少名战士才能覆盖全部边境线。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 4444](http://www.lydsy.com/JudgeOnline/problem.php?id=4444)\n\n### 解题思路\n首先，明确一个贪心的思路：对于任何一个战士，选择他后要选择的下一个，一定是在他后面并且与他奔袭区间交集最小的（因为所有的区间完全覆盖并且没有相互包含）。\n\n把所有区间翻倍存储，以左端点排序。\n\n40 分：枚举每个战士，在他之后的所有战士中确定一个与他奔袭区间交集最小的，作为他的下一个（时间复杂度 $ O(n ^ 2) $）；然后对于每个询问从该战士开始不断找下一个战士，直到找回来为止；\n\n70 分：把找「下一个战士」的复杂度优化为 $ O(n \\log n) $，使用 `std::upper_bound`，用当前战士的区间右端点和其他区间的左端点比较，返回的结果 -1 即为要找的「下一个战士」。\n\n100 分：思考回答询问时的过程，每次线性地向后扫描做了很多重复的工作，考虑到无论从那个战士出发，经过的相同位置向后的路线都是相同的，所以可以先 $ O(n \\log n) $ 地预处理出一个稀疏表，用 $ next_{i, j} $ 表示战士 $ i $ 向后找 $ 2 ^ j $ 次所到达的战士，然后就可以 $ O(\\log n) $ 地回答每个询问了。\n\n### AC代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXLOGN = 18;\n\nstruct Fighter {\n\tint id, l, r, ans;\n\tFighter *next[MAXLOGN + 1];\n} fighters[MAXN * 2];\n\nint n, m, ans[MAXN];\n\nbool operator<(const Fighter &a, const Fighter &b) {\n\treturn a.l < b.l;\n}\n\nbool operator<(int r, const Fighter &a) {\n\treturn r < a.l;\n}\n\nint main() {\n\tfreopen(\"flag.in\", \"r\", stdin);\n\t// freopen(\"flag.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.id = i;\n\t\tscanf(\"%d %d\", &a.l, &a.r);\n\t\tif (a.l > a.r) a.r += m;\n\t\tfighters[i + n].l = a.l + m, fighters[i + n].r = a.r + m;\n\t}\n\n\tstd::sort(fighters, fighters + n * 2);\n\n\tfor (int i = 0; i < n * 2; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.next[0] = std::upper_bound(fighters, fighters + n * 2, a.r) - 1;\n\t}\n\n\tfor (int j = 1; (1 << j) <= n * 2; j++) {\n\t\tfor (int i = 0; i < n * 2; i++) {\n\t\t\tFighter &a = fighters[i];\n\t\t\tif (a.next[j - 1]) {\n\t\t\t\ta.next[j] = a.next[j - 1]->next[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter *p = &fighters[i];\n\t\tfor (int j = MAXLOGN; j >= 0; j--) {\n\t\t\tif (p->next[j] && p->next[j]->r < fighters[i].l + m) {\n\t\t\t\tans[fighters[i].id] += (1 << j);\n\t\t\t\tp = p->next[j];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", ans[i] + 2);\n\t}\n\tputchar('\\n');\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-flag.md","raw":"title: 「SCOI2015」国旗计划 - 贪心 + 倍增\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 安师大附中集训\n  - 贪心\n  - 倍增\npermalink: scoi2015-flag\ndate: 2016-03-22 18:25:14\n---\n\nA 国幅员辽阔，边境线上设有 $ M $ 个边防站，顺时针编号 $ 1 $ 至 $ M $。每名边防战士常驻两个边防站，并且善于在这两个边防站之间长途奔袭，我们称这两个边防站之间的路程是这个边防战士的奔袭区间。每名战士的奔袭区间都不会被其他战士的奔袭区间所包含。\n\n现在，局长希望知道，至少需要多少名战士，才能使得他们的奔袭区间覆盖全部的边境线。局长还希望知道对于每一名战士，在他必须参加国旗计划的前提下，至少需要多少名战士才能覆盖全部边境线。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 4444](http://www.lydsy.com/JudgeOnline/problem.php?id=4444)\n\n### 解题思路\n首先，明确一个贪心的思路：对于任何一个战士，选择他后要选择的下一个，一定是在他后面并且与他奔袭区间交集最小的（因为所有的区间完全覆盖并且没有相互包含）。\n\n把所有区间翻倍存储，以左端点排序。\n\n40 分：枚举每个战士，在他之后的所有战士中确定一个与他奔袭区间交集最小的，作为他的下一个（时间复杂度 $ O(n ^ 2) $）；然后对于每个询问从该战士开始不断找下一个战士，直到找回来为止；\n\n70 分：把找「下一个战士」的复杂度优化为 $ O(n \\log n) $，使用 `std::upper_bound`，用当前战士的区间右端点和其他区间的左端点比较，返回的结果 -1 即为要找的「下一个战士」。\n\n100 分：思考回答询问时的过程，每次线性地向后扫描做了很多重复的工作，考虑到无论从那个战士出发，经过的相同位置向后的路线都是相同的，所以可以先 $ O(n \\log n) $ 地预处理出一个稀疏表，用 $ next_{i, j} $ 表示战士 $ i $ 向后找 $ 2 ^ j $ 次所到达的战士，然后就可以 $ O(\\log n) $ 地回答每个询问了。\n\n### AC代码\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXLOGN = 18;\n\nstruct Fighter {\n\tint id, l, r, ans;\n\tFighter *next[MAXLOGN + 1];\n} fighters[MAXN * 2];\n\nint n, m, ans[MAXN];\n\nbool operator<(const Fighter &a, const Fighter &b) {\n\treturn a.l < b.l;\n}\n\nbool operator<(int r, const Fighter &a) {\n\treturn r < a.l;\n}\n\nint main() {\n\tfreopen(\"flag.in\", \"r\", stdin);\n\t// freopen(\"flag.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.id = i;\n\t\tscanf(\"%d %d\", &a.l, &a.r);\n\t\tif (a.l > a.r) a.r += m;\n\t\tfighters[i + n].l = a.l + m, fighters[i + n].r = a.r + m;\n\t}\n\n\tstd::sort(fighters, fighters + n * 2);\n\n\tfor (int i = 0; i < n * 2; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.next[0] = std::upper_bound(fighters, fighters + n * 2, a.r) - 1;\n\t}\n\n\tfor (int j = 1; (1 << j) <= n * 2; j++) {\n\t\tfor (int i = 0; i < n * 2; i++) {\n\t\t\tFighter &a = fighters[i];\n\t\t\tif (a.next[j - 1]) {\n\t\t\t\ta.next[j] = a.next[j - 1]->next[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter *p = &fighters[i];\n\t\tfor (int j = MAXLOGN; j >= 0; j--) {\n\t\t\tif (p->next[j] && p->next[j]->r < fighters[i].l + m) {\n\t\t\t\tans[fighters[i].id] += (1 << j);\n\t\t\t\tp = p->next[j];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", ans[i] + 2);\n\t}\n\tputchar('\\n');\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-flag","published":1,"updated":"2016-03-22T10:25:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n4t0063ofdk3bsbe60t"},{"title":"「SCOI2011」糖果 - 强联通分量 + 拓扑排序","date":"2016-03-04T13:32:23.000Z","_content":"\n幼儿园里有 $ N $ 个小朋友，老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。在分配糖果的时候，需要满足小朋友们的 $ K $ 个要求。幼儿园的糖果总是有限的，想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 2330](http://www.lydsy.com/JudgeOnline/problem.php?id=2330)\n\n### 解题思路\n在满足题目的要求下，最优解一定是：最少的一个，比别人多也只多一个。很容易想到用查分约束系统来做。\n\n然而刚学了 Tarjan 就想乱搞搞，做法是，把所有关系转化为小于等于和小于两种，先把小于等于的边全部加进去，跑一遍 Tarjan，然后缩点，此时一个强联通分量上的小朋友糖果数是相同的。\n\n把小于的边再加上，进行拓扑排序，如果有环说明无解。把小于等于的边权值置为 0，小于的边权值置为 1，入度为零的点距离置为 1。求出所有最长路，每个点距离乘以该点小朋友的数量的和即为答案。\n\n注意开 `long long`。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, inDegree, dist;\n\tbool visited, pushed, inStack;\n\tConnected *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} sccs[MAXN];\n\nstruct Condition {\n\tint x, u, v;\n} conditions[MAXK];\n\nint n, k;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\te->from->scc->v.firstEdge = new Edge(&e->from->scc->v, &e->to->scc->v, e->w);\n\t\t\t\te->to->scc->v.inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long topoSort(int count) {\n\tstd::queue<Node *> q;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.inDegree == 0) {\n\t\t\tsccs[i].v.dist = 1;\n\t\t\tq.push(&sccs[i].v);\n\t\t}\n\t}\n\n\tint x = count;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tx--;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist == 0 || e->to->dist < v->dist + e->w) e->to->dist = v->dist + e->w;\n\t\t\tif (--e->to->inDegree == 0) {\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x > 0) return -1;\n\telse {\n\t\tlong long ans = 0;\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tans += (long long)sccs[i].size * (long long)sccs[i].v.dist;\n\t\t}\n\n\t\treturn ans;\n\t}\n}\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < k; i++) {\n\t\tscanf(\"%d %d %d\", &conditions[i].x, &conditions[i].u, &conditions[i].v);\n\t\tconditions[i].u--, conditions[i].v--;\n\n\t\tif (conditions[i].x == 4) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 2;\n\t\t} else if (conditions[i].x == 3) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 5;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 1) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t\taddEdge(conditions[i].v, conditions[i].u, 0);\n\t\t} else if (conditions[i].x == 5) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t}\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 2) {\n\t\t\tNode *u = &nodes[conditions[i].u].scc->v, *v = &nodes[conditions[i].v].scc->v;\n\t\t\tu->firstEdge = new Edge(u, v, 1);\n\t\t\tv->inDegree++;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", topoSort(count));\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2011-candy.md","raw":"title: 「SCOI2011」糖果 - 强联通分量 + 拓扑排序\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 强联通分量\n  - Tarjan\n  - 缩点\n  - 拓扑排序\n  - 差分约束系统\npermalink: scoi2011-candy\ndate: 2016-03-04 21:32:23\n---\n\n幼儿园里有 $ N $ 个小朋友，老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。在分配糖果的时候，需要满足小朋友们的 $ K $ 个要求。幼儿园的糖果总是有限的，想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 2330](http://www.lydsy.com/JudgeOnline/problem.php?id=2330)\n\n### 解题思路\n在满足题目的要求下，最优解一定是：最少的一个，比别人多也只多一个。很容易想到用查分约束系统来做。\n\n然而刚学了 Tarjan 就想乱搞搞，做法是，把所有关系转化为小于等于和小于两种，先把小于等于的边全部加进去，跑一遍 Tarjan，然后缩点，此时一个强联通分量上的小朋友糖果数是相同的。\n\n把小于的边再加上，进行拓扑排序，如果有环说明无解。把小于等于的边权值置为 0，小于的边权值置为 1，入度为零的点距离置为 1。求出所有最长路，每个点距离乘以该点小朋友的数量的和即为答案。\n\n注意开 `long long`。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, inDegree, dist;\n\tbool visited, pushed, inStack;\n\tConnected *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} sccs[MAXN];\n\nstruct Condition {\n\tint x, u, v;\n} conditions[MAXK];\n\nint n, k;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\te->from->scc->v.firstEdge = new Edge(&e->from->scc->v, &e->to->scc->v, e->w);\n\t\t\t\te->to->scc->v.inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long topoSort(int count) {\n\tstd::queue<Node *> q;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.inDegree == 0) {\n\t\t\tsccs[i].v.dist = 1;\n\t\t\tq.push(&sccs[i].v);\n\t\t}\n\t}\n\n\tint x = count;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tx--;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist == 0 || e->to->dist < v->dist + e->w) e->to->dist = v->dist + e->w;\n\t\t\tif (--e->to->inDegree == 0) {\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x > 0) return -1;\n\telse {\n\t\tlong long ans = 0;\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tans += (long long)sccs[i].size * (long long)sccs[i].v.dist;\n\t\t}\n\n\t\treturn ans;\n\t}\n}\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < k; i++) {\n\t\tscanf(\"%d %d %d\", &conditions[i].x, &conditions[i].u, &conditions[i].v);\n\t\tconditions[i].u--, conditions[i].v--;\n\n\t\tif (conditions[i].x == 4) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 2;\n\t\t} else if (conditions[i].x == 3) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 5;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 1) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t\taddEdge(conditions[i].v, conditions[i].u, 0);\n\t\t} else if (conditions[i].x == 5) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t}\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 2) {\n\t\t\tNode *u = &nodes[conditions[i].u].scc->v, *v = &nodes[conditions[i].v].scc->v;\n\t\t\tu->firstEdge = new Edge(u, v, 1);\n\t\t\tv->inDegree++;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", topoSort(count));\n\n\treturn 0;\n}\n```\n","slug":"scoi2011-candy","published":1,"updated":"2016-03-15T01:05:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n4z006cofdk99g0xv7w"},{"title":"「SCOI2010」游戏 - 二分图匹配","date":"2016-03-07T01:43:18.000Z","_content":"\n在游戏里，他拥有很多的装备，每种装备都有两个属性，这些属性的值用 $ [1, 10000] $ 之间的数表示。当他使用某种装备时，他只能使用该装备的某一个属性。并且每种装备最多只能使用一次。 终极 BOSS 很奇怪，攻击他的装备所使用的属性值必须从 $ 1 $ 开始连续递增地攻击，才能对 BOSS 产生伤害。也就是说一开始的时候，只能使用某个属性值为 $ 1 $ 的装备攻击 BOSS，然后只能使用某个属性值为 $ 2 $ 的装备攻击 BOSS，然后只能使用某个属性值为 $ 3 $ 的装备攻击 BOSS …… 以此类推。他最多能连续攻击 BOSS 多少次？\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 1854](http://www.lydsy.com/JudgeOnline/problem.php?id=1854)\n\n### 解题思路\n看一下数据范围 $ N ≤ 1000000 $，如果枚举每件武器，肯定要 $ O(n) $ 的算法才能过，但又想不出 $ O(n) $ 的算法来 ……\n\n我们换一种思路，从属性值小到大，之间如果有一个数不能没有可用的武器，则不可能继续打出比这个数更大的属性值了。也就是说答案具有单调性，可以采用枚举答案并检验的方法。\n\n题目中并没有要求某个属性值要由特定的武器打出，所以说可以任意选择某个可用的武器来打出指定的属性值。\n\n从 $ 1 $ 开始，任选一个可打出 $ 1 $ 的武器并标记为使用过，枚举时如果发现能打出 $ X $ 的武器全部被用过了，就尝试将某一件属性值为 $ \\{X, Y\\} $ 武器标记为 $ X $，并寻找 $ Y $ 的替代（$ Y < X $），这样递归下去，直到某个属性值使用了一件没有被使用武器，则成功，否则失败。\n\n算法思想与『二分图匹配』中的匈牙利算法比较相似。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 1000000;\nconst int MAXX = 10000;\n\nstruct Gun {\n\tint x[2];\n\tint selected;\n\n\tGun() : selected(-1) {}\n\n\tvoid select(int x) {\n\t\tif (this->x[0] == x) selected = 0;\n\t\telse selected = 1;\n\t}\n} guns[MAXN];\n\nint n;\nstd::vector<int> gunID[MAXX];\n\ninline bool check(int x, int ignore = -1) {\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tGun &g = guns[*p];\n\t\tif (g.selected == -1) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tif (*p == ignore) continue;\n\n\t\tGun &g = guns[*p];\n\t\tif (check(g.x[g.selected ^ 1], *p)) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tGun &g = guns[i];\n\n\t\tscanf(\"%d %d\", &g.x[0], &g.x[1]), g.x[0]--, g.x[1]--;\n\n\t\tgunID[g.x[0]].push_back(i);\n\t\tgunID[g.x[1]].push_back(i);\n\t}\n\n\tint i;\n\tfor (i = 0; i < MAXX; i++) {\n\t\tif (!check(i)) break;\n\t}\n\n\tprintf(\"%d\\n\", i);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2010-game.md","raw":"title: 「SCOI2010」游戏 - 二分图匹配\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - 图论\n  - 二分图匹配\n  - 匈牙利算法\n  - 枚举答案\npermalink: scoi2010-game\ndate: 2016-03-07 09:43:18\n---\n\n在游戏里，他拥有很多的装备，每种装备都有两个属性，这些属性的值用 $ [1, 10000] $ 之间的数表示。当他使用某种装备时，他只能使用该装备的某一个属性。并且每种装备最多只能使用一次。 终极 BOSS 很奇怪，攻击他的装备所使用的属性值必须从 $ 1 $ 开始连续递增地攻击，才能对 BOSS 产生伤害。也就是说一开始的时候，只能使用某个属性值为 $ 1 $ 的装备攻击 BOSS，然后只能使用某个属性值为 $ 2 $ 的装备攻击 BOSS，然后只能使用某个属性值为 $ 3 $ 的装备攻击 BOSS …… 以此类推。他最多能连续攻击 BOSS 多少次？\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 1854](http://www.lydsy.com/JudgeOnline/problem.php?id=1854)\n\n### 解题思路\n看一下数据范围 $ N ≤ 1000000 $，如果枚举每件武器，肯定要 $ O(n) $ 的算法才能过，但又想不出 $ O(n) $ 的算法来 ……\n\n我们换一种思路，从属性值小到大，之间如果有一个数不能没有可用的武器，则不可能继续打出比这个数更大的属性值了。也就是说答案具有单调性，可以采用枚举答案并检验的方法。\n\n题目中并没有要求某个属性值要由特定的武器打出，所以说可以任意选择某个可用的武器来打出指定的属性值。\n\n从 $ 1 $ 开始，任选一个可打出 $ 1 $ 的武器并标记为使用过，枚举时如果发现能打出 $ X $ 的武器全部被用过了，就尝试将某一件属性值为 $ \\{X, Y\\} $ 武器标记为 $ X $，并寻找 $ Y $ 的替代（$ Y < X $），这样递归下去，直到某个属性值使用了一件没有被使用武器，则成功，否则失败。\n\n算法思想与『二分图匹配』中的匈牙利算法比较相似。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 1000000;\nconst int MAXX = 10000;\n\nstruct Gun {\n\tint x[2];\n\tint selected;\n\n\tGun() : selected(-1) {}\n\n\tvoid select(int x) {\n\t\tif (this->x[0] == x) selected = 0;\n\t\telse selected = 1;\n\t}\n} guns[MAXN];\n\nint n;\nstd::vector<int> gunID[MAXX];\n\ninline bool check(int x, int ignore = -1) {\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tGun &g = guns[*p];\n\t\tif (g.selected == -1) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tif (*p == ignore) continue;\n\n\t\tGun &g = guns[*p];\n\t\tif (check(g.x[g.selected ^ 1], *p)) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tGun &g = guns[i];\n\n\t\tscanf(\"%d %d\", &g.x[0], &g.x[1]), g.x[0]--, g.x[1]--;\n\n\t\tgunID[g.x[0]].push_back(i);\n\t\tgunID[g.x[1]].push_back(i);\n\t}\n\n\tint i;\n\tfor (i = 0; i < MAXX; i++) {\n\t\tif (!check(i)) break;\n\t}\n\n\tprintf(\"%d\\n\", i);\n\n\treturn 0;\n}\n```\n","slug":"scoi2010-game","published":1,"updated":"2016-03-15T01:05:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n54006nofdk746fzpi0"},{"title":"「SCOI2007」修车 - 费用流","date":"2016-03-09T01:52:35.000Z","_content":"\n同一时刻有 $ N $ 位车主带着他们的爱车来到了汽车维修中心。维修中心共有 $ M $ 位技术人员，不同的技术人员对不同的车进行维修所用的时间是不同的。现在需要安排这 $ M $ 位技术人员所维修的车及顺序，使得顾客平均等待的时间最小。\n\n顾客的等待时间是指从他把车送至维修中心到维修完毕所用的时间。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 1070](http://www.lydsy.com/JudgeOnline/problem.php?id=1070)  \n[CodeVS 2436](http://codevs.cn/problem/2436/)\n\n### 解题思路\n为每辆车建立点，为每个技术人员的**每一次修车**建立点。\n\n设第 $ i $ 个技术人员修第 $ j $ 辆车所用时间为 $ t_{i, j} $，第 $ i $ 辆车的点为 $ v_i $，第 $ i $ 个技术人员倒数第 $ k $ 次修车（此时有 $ k $ 个人在等待）的点为 $ v_{j, k} $（$ k {\\in} [1, n] $）。\n\n从源点向每辆车连边，容量为 1，费用为 0；从每个 $ v_i $ 向每个 $ v_{j, k} $ 连边，容量为 1，费用为 $ t_{i, j} * k $；从每个 $ v_{j, k} $ 向汇点连边，容量为 1，费用为 0。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 60;\nconst int MAXM = 9;\nconst int MAXT = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + MAXM * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), flow(0), capacity(capacity), cost(cost), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, time[MAXM][MAXN];\n\ninline int hash(int j, int k) {\n\treturn n + (j - 1) * n + k;\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &time[j][i]);\n\t\t}\n\t}\n\n\tconst int s = 0, t = n + n * m + 1;\n\t//printf(\"s = %d, t = %d\\n\", s, t);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t}\n\n\tfor (int j = 1; j <= m; j++) {\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\taddEdge(hash(j, k), t, 1, 0);\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t//printf(\"%d -> %d\\n\", i, hash(j, k));\n\t\t\t\taddEdge(i, hash(j, k), 1, time[j - 1][i - 1] * k);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n * m + 2, flow, cost);\n\n\tprintf(\"%.2lf\\n\", (double)cost / (double)n);\n\n\treturn 0;\n}\n```\n\n### 吐槽\n又一次把 $ n $、$ m $ 读入倒了 ……\n\n又一次敲错 EK 模板 ……\n\nhehe\n","source":"_posts/scoi2007-repair.md","raw":"title: 「SCOI2007」修车 - 费用流\ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - SCOI\n  - 图论\n  - 网络流\n  - 费用流\n  - Edmonds-Karp\npermalink: scoi2007-repair\ndate: 2016-03-09 09:52:35\n---\n\n同一时刻有 $ N $ 位车主带着他们的爱车来到了汽车维修中心。维修中心共有 $ M $ 位技术人员，不同的技术人员对不同的车进行维修所用的时间是不同的。现在需要安排这 $ M $ 位技术人员所维修的车及顺序，使得顾客平均等待的时间最小。\n\n顾客的等待时间是指从他把车送至维修中心到维修完毕所用的时间。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 1070](http://www.lydsy.com/JudgeOnline/problem.php?id=1070)  \n[CodeVS 2436](http://codevs.cn/problem/2436/)\n\n### 解题思路\n为每辆车建立点，为每个技术人员的**每一次修车**建立点。\n\n设第 $ i $ 个技术人员修第 $ j $ 辆车所用时间为 $ t_{i, j} $，第 $ i $ 辆车的点为 $ v_i $，第 $ i $ 个技术人员倒数第 $ k $ 次修车（此时有 $ k $ 个人在等待）的点为 $ v_{j, k} $（$ k {\\in} [1, n] $）。\n\n从源点向每辆车连边，容量为 1，费用为 0；从每个 $ v_i $ 向每个 $ v_{j, k} $ 连边，容量为 1，费用为 $ t_{i, j} * k $；从每个 $ v_{j, k} $ 向汇点连边，容量为 1，费用为 0。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 60;\nconst int MAXM = 9;\nconst int MAXT = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + MAXM * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), flow(0), capacity(capacity), cost(cost), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, time[MAXM][MAXN];\n\ninline int hash(int j, int k) {\n\treturn n + (j - 1) * n + k;\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &time[j][i]);\n\t\t}\n\t}\n\n\tconst int s = 0, t = n + n * m + 1;\n\t//printf(\"s = %d, t = %d\\n\", s, t);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t}\n\n\tfor (int j = 1; j <= m; j++) {\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\taddEdge(hash(j, k), t, 1, 0);\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t//printf(\"%d -> %d\\n\", i, hash(j, k));\n\t\t\t\taddEdge(i, hash(j, k), 1, time[j - 1][i - 1] * k);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n * m + 2, flow, cost);\n\n\tprintf(\"%.2lf\\n\", (double)cost / (double)n);\n\n\treturn 0;\n}\n```\n\n### 吐槽\n又一次把 $ n $、$ m $ 读入倒了 ……\n\n又一次敲错 EK 模板 ……\n\nhehe\n","slug":"scoi2007-repair","published":1,"updated":"2016-03-15T01:05:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n5d006xofdkdoje2n0r"},{"title":"「POJ 2728」Desert King - 01 分数规划","date":"2016-03-11T01:33:14.000Z","_content":"\n一个王国有 $ N $ 个城市，每个城市有坐标 $ (x, y) $ 和海拔 $ z $，在 $ N $ 个城市之间修水渠，要保证每个城市有水，水渠是水平的，每个城市的海拔不同，现在要求修单位长度的水渠的海拔高度差最小。\n\n<!-- more -->\n\n### 题目链接\n[POJ 2728](http://poj.org/problem?id=2728)\n\n### 解题思路\n最优比率生成树，01 分数规划，搞的不是很明白 …… Orz\n\nPS：果然我的代码自带大常数，搞了一早上不是 WA 就是 TLE，最后把编译器从 G++ 改为 VC++ 就 AC 了 ……\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int CACHE_FIX = 3;\nconst float EPS = 1e-4;\n\nstruct Node;\nstruct UndirectedEdge;\n\nstruct Node {\n\tint id;\n\tint x, y, z;\n\tbool inTree;\n\tUndirectedEdge *e;\n} nodes[MAXN];\n\nstruct UndirectedEdge {\n\tfloat benifit, cost;\n\tfloat w;\n\n\tUndirectedEdge(float benifit, float cost) : benifit(benifit), cost(cost) {}\n\tUndirectedEdge() {}\n} edges[MAXN + CACHE_FIX][MAXN];\n\nint n;\n\ninline float prim() {\n\tnodes[0].inTree = true;\n\tfor (int i = 1; i < n; i++) nodes[i].e = &edges[0][i], nodes[i].inTree = false;\n\n\tfloat ans = 0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tNode *v = NULL;\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && (v == NULL || nodes[i].e->w < v->e->w)) v = &nodes[i];\n\n\t\tans += v->e->w;\n\t\tv->e = NULL;\n\t\tv->inTree = true;\n\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && nodes[i].e->w > edges[i][v->id].w) nodes[i].e = &edges[i][v->id];\n\t}\n\n\treturn ans;\n}\n\ninline float test(float p) {\n\tfor (register int i = 0; i < n; i++) {\n\t\tfor (register int j = i + 1; j < n; j++) {\n\t\t\tedges[j][i].w = edges[i][j].w = edges[i][j].cost - edges[i][j].benifit * p;\n\t\t}\n\t}\n\n\tfloat result = prim();\n\t//printf(\"test(%lf) = %lf\\n\", p, result);\n\treturn result;\n}\n\ninline float solve(float sum) {\n\tregister float l = 0, r = sum;\n\t//while (r - l > EPS) {\n\tfor (int i = 0; i < 22; i++) {\n\t\tfloat mid = l + (r - l) / 2;\n\t\tif (test(mid) > 0) l = mid;\n\t\telse r = mid;\n\t}\n\n\treturn l + (r - l) / 2;\n}\n\ninline float sqr(float x) {\n\treturn x * x;\n}\n\ninline float distance(float x1, float x2, float y1, float y2) {\n\treturn sqrt(sqr(x1 - x2) + sqr(y1 - y2));\n}\n\nint main() {\n\twhile (scanf(\"%d\", &n) != EOF && n != 0) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].id = i;\n\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &nodes[i].x, &nodes[i].y, &nodes[i].z);\n\n\t\tfloat sum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tedges[j][i] = edges[i][j] = UndirectedEdge(distance(nodes[i].x, nodes[j].x, nodes[i].y, nodes[j].y), abs(nodes[i].z - nodes[j].z));\n\t\t\t\tsum += edges[i][j].benifit;\n\t\t\t}\n\t\t}\n\n\t\tfloat ans = solve(100);\n\t\tprintf(\"%.3f\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n\n### 数据生成器\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n\nconst int MAXN = 1000;\n\ninline int luckyRand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tconst int x = rand();\n\tsrand(x ^ ((time(NULL) << 16) | (clock() << 16 >> 16)) ^ MAGIC_NUMBER);\n\treturn (rand() ^ x ^ MAGIC_NUMBER) % (r - l + 1) + l;\n}\n\nint main() {\n\tconst int t = 3;\n\tconst int n = MAXN;\n\n\tfor (int i = 0; i < t; i++) {\n\t\tprintf(\"%d\\n\", n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), y = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), z = luckyRand(luckyRand(0, 10000), luckyRand(90000, 100000));\n\t\t\tprintf(\"%d %d %d\\n\", x, y, z);\n\t\t}\n\t}\n\n\tputs(\"0\");\n\n\treturn 0;\n}\n```\n","source":"_posts/poj-2728.md","raw":"title: 「POJ 2728」Desert King - 01 分数规划\ncategories: OI\ntags: \n  - POJ\n  - Prim\n  - 生成树\n  - 二分答案\n  - 实数二分\n  - 分数规划\npermalink: poj-2728\ndate: 2016-03-11 09:33:14\n---\n\n一个王国有 $ N $ 个城市，每个城市有坐标 $ (x, y) $ 和海拔 $ z $，在 $ N $ 个城市之间修水渠，要保证每个城市有水，水渠是水平的，每个城市的海拔不同，现在要求修单位长度的水渠的海拔高度差最小。\n\n<!-- more -->\n\n### 题目链接\n[POJ 2728](http://poj.org/problem?id=2728)\n\n### 解题思路\n最优比率生成树，01 分数规划，搞的不是很明白 …… Orz\n\nPS：果然我的代码自带大常数，搞了一早上不是 WA 就是 TLE，最后把编译器从 G++ 改为 VC++ 就 AC 了 ……\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int CACHE_FIX = 3;\nconst float EPS = 1e-4;\n\nstruct Node;\nstruct UndirectedEdge;\n\nstruct Node {\n\tint id;\n\tint x, y, z;\n\tbool inTree;\n\tUndirectedEdge *e;\n} nodes[MAXN];\n\nstruct UndirectedEdge {\n\tfloat benifit, cost;\n\tfloat w;\n\n\tUndirectedEdge(float benifit, float cost) : benifit(benifit), cost(cost) {}\n\tUndirectedEdge() {}\n} edges[MAXN + CACHE_FIX][MAXN];\n\nint n;\n\ninline float prim() {\n\tnodes[0].inTree = true;\n\tfor (int i = 1; i < n; i++) nodes[i].e = &edges[0][i], nodes[i].inTree = false;\n\n\tfloat ans = 0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tNode *v = NULL;\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && (v == NULL || nodes[i].e->w < v->e->w)) v = &nodes[i];\n\n\t\tans += v->e->w;\n\t\tv->e = NULL;\n\t\tv->inTree = true;\n\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && nodes[i].e->w > edges[i][v->id].w) nodes[i].e = &edges[i][v->id];\n\t}\n\n\treturn ans;\n}\n\ninline float test(float p) {\n\tfor (register int i = 0; i < n; i++) {\n\t\tfor (register int j = i + 1; j < n; j++) {\n\t\t\tedges[j][i].w = edges[i][j].w = edges[i][j].cost - edges[i][j].benifit * p;\n\t\t}\n\t}\n\n\tfloat result = prim();\n\t//printf(\"test(%lf) = %lf\\n\", p, result);\n\treturn result;\n}\n\ninline float solve(float sum) {\n\tregister float l = 0, r = sum;\n\t//while (r - l > EPS) {\n\tfor (int i = 0; i < 22; i++) {\n\t\tfloat mid = l + (r - l) / 2;\n\t\tif (test(mid) > 0) l = mid;\n\t\telse r = mid;\n\t}\n\n\treturn l + (r - l) / 2;\n}\n\ninline float sqr(float x) {\n\treturn x * x;\n}\n\ninline float distance(float x1, float x2, float y1, float y2) {\n\treturn sqrt(sqr(x1 - x2) + sqr(y1 - y2));\n}\n\nint main() {\n\twhile (scanf(\"%d\", &n) != EOF && n != 0) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].id = i;\n\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &nodes[i].x, &nodes[i].y, &nodes[i].z);\n\n\t\tfloat sum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tedges[j][i] = edges[i][j] = UndirectedEdge(distance(nodes[i].x, nodes[j].x, nodes[i].y, nodes[j].y), abs(nodes[i].z - nodes[j].z));\n\t\t\t\tsum += edges[i][j].benifit;\n\t\t\t}\n\t\t}\n\n\t\tfloat ans = solve(100);\n\t\tprintf(\"%.3f\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n\n### 数据生成器\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n\nconst int MAXN = 1000;\n\ninline int luckyRand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tconst int x = rand();\n\tsrand(x ^ ((time(NULL) << 16) | (clock() << 16 >> 16)) ^ MAGIC_NUMBER);\n\treturn (rand() ^ x ^ MAGIC_NUMBER) % (r - l + 1) + l;\n}\n\nint main() {\n\tconst int t = 3;\n\tconst int n = MAXN;\n\n\tfor (int i = 0; i < t; i++) {\n\t\tprintf(\"%d\\n\", n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), y = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), z = luckyRand(luckyRand(0, 10000), luckyRand(90000, 100000));\n\t\t\tprintf(\"%d %d %d\\n\", x, y, z);\n\t\t}\n\t}\n\n\tputs(\"0\");\n\n\treturn 0;\n}\n```\n","slug":"poj-2728","published":1,"updated":"2016-03-15T01:05:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n5m0076ofdkbbpr8wkg"},{"title":"「POJ 1737」Connected Graph - 组合数 + 计数原理 + 递推","date":"2016-03-14T04:12:45.000Z","_content":"\n给定 $ N $（$ N \\leq 50 $）个点，在平面上固定其位置，求这些点最多能组成多少个不同的无向连通图。\n\n<!-- more -->\n\n### 题目链接\n[POJ 1737](http://poj.org/problem?id=1737)\n\n### 解题思路\n统计连通图的方案数是困难的，但我们可以轻易地计算出用 N 个点组成任意图的方案数：因为 N 个点的**无向**图最多有 $ \\frac{N(N - 1)}{2} $ 条边，考虑每条边选或不选，则共有 $ 2 ^ {\\frac{N(N - 1)}{2}} $ 种不同的图。\n\n求出任意图的方案数后，只要再求出非连通图的方案数，就可以得到答案。考虑 $ N $ 个点组成的非连通图中的点 $ v $，它一定处于一个由 $ K $（$ 1 \\leq K \\leq N - 1 $）个点组成的**联通分量**中，点 $ v $ 确定后，组成这个联通分量还需要 $ K - 1 $ 个点，总方案数为 $ \\binom{N - 1}{K - 1} $；每个连通分量都是一个**连通图**，可以递归来求；考虑完一个联通分量，图的剩余部分（与该联通分量隔离的 $ N - K $ 个点）是一个任意图，也可以递归来求。\n\n设 $ n $ 个点组成连通图的方案数为 $ f(n) $、组成非联通图的方案数为 $ g(n) $、组成任意图的方案数为 $ h(n) $，则递归计算 $ f(n) $ 的公式为：\n\n$$\n\\begin{align}\n& f(n) = h(n) - g(n) \\\\\n& g(n) = \\sum\\limits_{k = 1}^{n - 1}\\binom{n - 1}{k - 1} * f(k) * h(n - k) \\\\\n& h(n) = 2 ^ {\\frac{n(n - 1)}{2}} \\\\\n\\end{align}\n$$\n\n需要使用高精度。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 50;\n\nstruct BigInt;\nBigInt &countConnectedGraphs(int n);\nBigInt &countNonConnectedGraphs(int n);\ninline BigInt &countAllGraphs(int n);\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), x.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++){\n\t\t\tcombo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n\t\t}\n\t}\n}\n\ninline BigInt &C(int n, int k) {\n\treturn combo[n][k];\n}\n\nBigInt &countConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tans = countAllGraphs(n) - countNonConnectedGraphs(n);\n\n\treturn ans;\n}\n\nBigInt &countNonConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tfor (int k = 1; k <= n - 1; k++) {\n\t\tans += C(n - 1, k - 1) * countConnectedGraphs(k) * countAllGraphs(n - k);\n\t}\n\n\treturn ans;\n}\n\ninline BigInt &countAllGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tBigInt x = 2;\n\tint t = n * (n - 1) / 2;\n\tfor (ans = 1; t; t >>= 1, x = x * x) {\n\t\tif (t & 1) ans = ans * x;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tfor (int n; ~scanf(\"%d\", &n) && n > 0; ) {\n\t\tstd::cout << countConnectedGraphs(n) << std::endl;\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/poj-1737.md","raw":"title: 「POJ 1737」Connected Graph - 组合数 + 计数原理 + 递推\ncategories: OI\ntags: \n  - POJ\n  - 递推\n  - 高精度\n  - 组合数\n  - 计数原理\n  - 数学\npermalink: poj-1737\ndate: 2016-03-14 12:12:45\n---\n\n给定 $ N $（$ N \\leq 50 $）个点，在平面上固定其位置，求这些点最多能组成多少个不同的无向连通图。\n\n<!-- more -->\n\n### 题目链接\n[POJ 1737](http://poj.org/problem?id=1737)\n\n### 解题思路\n统计连通图的方案数是困难的，但我们可以轻易地计算出用 N 个点组成任意图的方案数：因为 N 个点的**无向**图最多有 $ \\frac{N(N - 1)}{2} $ 条边，考虑每条边选或不选，则共有 $ 2 ^ {\\frac{N(N - 1)}{2}} $ 种不同的图。\n\n求出任意图的方案数后，只要再求出非连通图的方案数，就可以得到答案。考虑 $ N $ 个点组成的非连通图中的点 $ v $，它一定处于一个由 $ K $（$ 1 \\leq K \\leq N - 1 $）个点组成的**联通分量**中，点 $ v $ 确定后，组成这个联通分量还需要 $ K - 1 $ 个点，总方案数为 $ \\binom{N - 1}{K - 1} $；每个连通分量都是一个**连通图**，可以递归来求；考虑完一个联通分量，图的剩余部分（与该联通分量隔离的 $ N - K $ 个点）是一个任意图，也可以递归来求。\n\n设 $ n $ 个点组成连通图的方案数为 $ f(n) $、组成非联通图的方案数为 $ g(n) $、组成任意图的方案数为 $ h(n) $，则递归计算 $ f(n) $ 的公式为：\n\n$$\n\\begin{align}\n& f(n) = h(n) - g(n) \\\\\n& g(n) = \\sum\\limits_{k = 1}^{n - 1}\\binom{n - 1}{k - 1} * f(k) * h(n - k) \\\\\n& h(n) = 2 ^ {\\frac{n(n - 1)}{2}} \\\\\n\\end{align}\n$$\n\n需要使用高精度。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 50;\n\nstruct BigInt;\nBigInt &countConnectedGraphs(int n);\nBigInt &countNonConnectedGraphs(int n);\ninline BigInt &countAllGraphs(int n);\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), x.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++){\n\t\t\tcombo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n\t\t}\n\t}\n}\n\ninline BigInt &C(int n, int k) {\n\treturn combo[n][k];\n}\n\nBigInt &countConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tans = countAllGraphs(n) - countNonConnectedGraphs(n);\n\n\treturn ans;\n}\n\nBigInt &countNonConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tfor (int k = 1; k <= n - 1; k++) {\n\t\tans += C(n - 1, k - 1) * countConnectedGraphs(k) * countAllGraphs(n - k);\n\t}\n\n\treturn ans;\n}\n\ninline BigInt &countAllGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tBigInt x = 2;\n\tint t = n * (n - 1) / 2;\n\tfor (ans = 1; t; t >>= 1, x = x * x) {\n\t\tif (t & 1) ans = ans * x;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tfor (int n; ~scanf(\"%d\", &n) && n > 0; ) {\n\t\tstd::cout << countConnectedGraphs(n) << std::endl;\n\t}\n\n\treturn 0;\n}\n```\n","slug":"poj-1737","published":1,"updated":"2016-03-15T09:11:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n5s007iofdk8h8d8esq"},{"title":"OS X 日常必备软件","date":"2016-03-13T15:00:14.000Z","_content":"\n这些「必备软件」是我日常必备的，不一定适合每一个人，需要者自取。有一部分是跨平台的，在 GNU/Linux 或 Windows 下也可用。\n\n<!-- more -->\n\n## 系统类\n### Karabiner\nWebsite：[https://pqrs.org/osx/karabiner/](https://pqrs.org/osx/karabiner/)  \nGithub：[https://github.com/tekezo/Karabiner](https://github.com/tekezo/Karabiner)  \nHomebrew：`brew cask install karabiner`  \nLicense：Public Domain  \nPlatform：OS X\n\n![Karabiner](osx-softwares/karabiner.png)\n\n一个用来增强键盘的小工具，对黑苹果很有用，可以把键盘左上角的那个键「§」「±」映射为「`」「~」，还可以把 Home、End 键映射为到行首、行尾，满足之前在 Linux 上的使用习惯。\n\n### Virtualbox\nWebsite：[https://www.virtualbox.org/](https://www.virtualbox.org/)  \nHomebrew：`brew cask install virtualbox`  \nLicense：GNU GPL v2  \nPlatform：OS X、GNU/Linux、Windows\n\n![Virtualbox](osx-softwares/virtualbox.png)\n\n一款跨平台虚拟机软件，体积比较小，平常用这个开着 Archlinux，需要的时候 SSH 连进去。感觉比 Parallels Desktop 好用一些，上手起来也比较容易吧。\n\n## 工具类\n### Flashlight\nWebsite：[http://flashlight.nateparrott.com/](http://flashlight.nateparrott.com/)  \nGithub：[https://github.com/nate-parrott/Flashlight](https://github.com/nate-parrott/Flashlight)  \nHomebrew：`brew cask install flashlight`  \nLicense：MIT && GNU GPL v2  \nPlatform：OS X\n\n![Flashlight 配置面板](osx-softwares/flashlight.png)\n\nSpotlight 的增强工具，有很多便捷的命令可以安装，在 OS X Yosemite 10.10.5 下需要手动配置 SIMBL 注入，比较麻烦，好像到了 El Captian 就用不了了 ……\n\n### ShadowSocksX\nGithub：[https://github.com/shadowsocks/shadowsocks-iOS](https://github.com/shadowsocks/shadowsocks-iOS)  \nHomebrew：`brew cask install shadowsocksx`  \nLicense：GNU GPL v3  \nPlatform：OS X\n\n![ShadowSocksX](osx-softwares/shadowsocksx.png)\n\nOS X 的图形界面 ShadowSocks 客户端，可以方便的配置、切换服务器。\n\n### File Roller\nWebsite：[http://fileroller.xx51.net/fileroller/index_zh_CN.html](http://fileroller.xx51.net/fileroller/index_zh_CN.html)  \nGithub：[https://github.com/wkt/file-roller-osx](https://github.com/wkt/file-roller-osx)  \nLicense：GNU GPL v2  \nPlatform：OS X、GNU/Linux\n\n![File Roller](osx-softwares/fileroller.png)\n\nLinux 下 GNOME 的归档管理器，被人强行移植到 OS X 上来 …… 无奈 OS X 连个归档管理器都不自带 …… 原来是不资磁 Retina 的，强行开了 Retina 图标就这样了 …… 嗯，能用就行对吧，拖拽什么的还是资磁的。\n\n### Go2Shell\nWebsite：[http://zipzapmac.com/Go2Shell](http://zipzapmac.com/Go2Shell)  \nHomebrew：`brew cask install go2shell`  \nLicense：Free  \nPlatform：OS X\n\n![Go2Shell](osx-softwares/go2shell.png)\n\n一个按钮在 Finder 中打开命令行，而且图标 >_< 很萌！\n\n### TeamViewer\nWebsite：[http://www.teamviewer.com/](http://www.teamviewer.com/)  \nHomebrew：`brew cask install teamviewer`  \nLicense：Free  \nPlatform：OS X、GNU/Linux、Windows\n\n![TeamViewer](osx-softwares/teamviewer.png)\n\n最好用的远程控制软件没有之一。\n\n## 常用类\n### MacVim\nWebsite：[https://macvim-dev.github.io/macvim/](https://macvim-dev.github.io/macvim/)  \nGithub：[https://github.com/macvim-dev/macvim](https://github.com/macvim-dev/macvim)  \nHomebrew：`brew cask install macvim`  \nLicense：Vim License  \nPlatform：OS X\n\n![MacVim](osx-softwares/macvim.png)\n\nOS X 下的 Vim 图形界面，相对 GVim 的好处是背景可以透明、支持多标签页。\n\n### MacDown\nWebsite：[http://macdown.uranusjr.com/](http://macdown.uranusjr.com/)  \nGithub：[https://github.com/uranusjr/macdown](https://github.com/uranusjr/macdown)  \nHomebrew：`brew cask install macdown`  \nLicense：MIT  \nPlatform：OS X\n\n![MacDown](osx-softwares/macdown.png)\n\n一款 Markdown 编辑器，比那些在线的 Web App 好用，界面比较萌、比较简洁，兼容性也不错。\n\n### FeelUOwn\nGithub：[https://github.com/cosven/FeelUOwn](https://github.com/cosven/FeelUOwn)  \nLicense：GNU GPL v3  \nPlatform：OS X、GNU/Linux\n\n![FeelUOwn](osx-softwares/feeluown.png)\n\n网易云音乐客户端，比较轻量，能听歌但好像也只能听歌 ……\n\n### GIMP\nWebsite：[https://www.gimp.org/](https://www.gimp.org/)  \nGithub：[https://github.com/GNOME/gimp](https://github.com/GNOME/gimp)  \nHomebrew：`brew cask install gimp`  \nLicense：GNU GPL v3  \nPlatform：OS X、GNU/Linux、Windows\n\n![GIMP](osx-softwares/gimp.png)\n\n专业的图像处理软件，虽然我不那么专业，平常用来剪剪图搞搞模糊还是挺资磁的。只是 Gtk+ 的图形界面在 OS X 下表现不是很好，非原生界面感觉怪怪的 ……\n\n### LibreOffice\nWebsite：[https://www.libreoffice.org/](https://www.libreoffice.org/)  \nGithub：[https://github.com/LibreOffice](https://github.com/LibreOffice)  \nHomebrew：`brew cask install libreoffice`  \nLicense：Mozilla Public License v2.0  \nPlatform：OS X、GNU/Linux、Windows\n\n![LibreOffice Writer](osx-softwares/libreoffice-writer.png)\n\n文档处理软件，它的 Writer 和 Calc 比较好用，Impress 不如 PowerPoint 好用。一般除了做幻灯片之外不需要开 MS Office。\n\n### VLC\nWebsite：[http://www.videolan.org/vlc/](http://www.videolan.org/vlc/)  \nGithub：[https://github.com/videolan/vlc](https://github.com/videolan/vlc)  \nHomebrew：`brew cask install vlc`  \nLicense：GNU GPL v2  \nPlatform：OS X、GNU/Linux、Windows\n\n![VLC](osx-softwares/vlc.png)\n\n用过最好用的视频播放器，基本上常见不常见的格式都能打开。\n","source":"_posts/osx-softwares.md","raw":"title: OS X 日常必备软件\ncategories: Geek\ntags:\n  - OS X\n  - 软件\npermalink: osx-softwares\ndate: 2016-03-13 23:00:14\n---\n\n这些「必备软件」是我日常必备的，不一定适合每一个人，需要者自取。有一部分是跨平台的，在 GNU/Linux 或 Windows 下也可用。\n\n<!-- more -->\n\n## 系统类\n### Karabiner\nWebsite：[https://pqrs.org/osx/karabiner/](https://pqrs.org/osx/karabiner/)  \nGithub：[https://github.com/tekezo/Karabiner](https://github.com/tekezo/Karabiner)  \nHomebrew：`brew cask install karabiner`  \nLicense：Public Domain  \nPlatform：OS X\n\n![Karabiner](osx-softwares/karabiner.png)\n\n一个用来增强键盘的小工具，对黑苹果很有用，可以把键盘左上角的那个键「§」「±」映射为「`」「~」，还可以把 Home、End 键映射为到行首、行尾，满足之前在 Linux 上的使用习惯。\n\n### Virtualbox\nWebsite：[https://www.virtualbox.org/](https://www.virtualbox.org/)  \nHomebrew：`brew cask install virtualbox`  \nLicense：GNU GPL v2  \nPlatform：OS X、GNU/Linux、Windows\n\n![Virtualbox](osx-softwares/virtualbox.png)\n\n一款跨平台虚拟机软件，体积比较小，平常用这个开着 Archlinux，需要的时候 SSH 连进去。感觉比 Parallels Desktop 好用一些，上手起来也比较容易吧。\n\n## 工具类\n### Flashlight\nWebsite：[http://flashlight.nateparrott.com/](http://flashlight.nateparrott.com/)  \nGithub：[https://github.com/nate-parrott/Flashlight](https://github.com/nate-parrott/Flashlight)  \nHomebrew：`brew cask install flashlight`  \nLicense：MIT && GNU GPL v2  \nPlatform：OS X\n\n![Flashlight 配置面板](osx-softwares/flashlight.png)\n\nSpotlight 的增强工具，有很多便捷的命令可以安装，在 OS X Yosemite 10.10.5 下需要手动配置 SIMBL 注入，比较麻烦，好像到了 El Captian 就用不了了 ……\n\n### ShadowSocksX\nGithub：[https://github.com/shadowsocks/shadowsocks-iOS](https://github.com/shadowsocks/shadowsocks-iOS)  \nHomebrew：`brew cask install shadowsocksx`  \nLicense：GNU GPL v3  \nPlatform：OS X\n\n![ShadowSocksX](osx-softwares/shadowsocksx.png)\n\nOS X 的图形界面 ShadowSocks 客户端，可以方便的配置、切换服务器。\n\n### File Roller\nWebsite：[http://fileroller.xx51.net/fileroller/index_zh_CN.html](http://fileroller.xx51.net/fileroller/index_zh_CN.html)  \nGithub：[https://github.com/wkt/file-roller-osx](https://github.com/wkt/file-roller-osx)  \nLicense：GNU GPL v2  \nPlatform：OS X、GNU/Linux\n\n![File Roller](osx-softwares/fileroller.png)\n\nLinux 下 GNOME 的归档管理器，被人强行移植到 OS X 上来 …… 无奈 OS X 连个归档管理器都不自带 …… 原来是不资磁 Retina 的，强行开了 Retina 图标就这样了 …… 嗯，能用就行对吧，拖拽什么的还是资磁的。\n\n### Go2Shell\nWebsite：[http://zipzapmac.com/Go2Shell](http://zipzapmac.com/Go2Shell)  \nHomebrew：`brew cask install go2shell`  \nLicense：Free  \nPlatform：OS X\n\n![Go2Shell](osx-softwares/go2shell.png)\n\n一个按钮在 Finder 中打开命令行，而且图标 >_< 很萌！\n\n### TeamViewer\nWebsite：[http://www.teamviewer.com/](http://www.teamviewer.com/)  \nHomebrew：`brew cask install teamviewer`  \nLicense：Free  \nPlatform：OS X、GNU/Linux、Windows\n\n![TeamViewer](osx-softwares/teamviewer.png)\n\n最好用的远程控制软件没有之一。\n\n## 常用类\n### MacVim\nWebsite：[https://macvim-dev.github.io/macvim/](https://macvim-dev.github.io/macvim/)  \nGithub：[https://github.com/macvim-dev/macvim](https://github.com/macvim-dev/macvim)  \nHomebrew：`brew cask install macvim`  \nLicense：Vim License  \nPlatform：OS X\n\n![MacVim](osx-softwares/macvim.png)\n\nOS X 下的 Vim 图形界面，相对 GVim 的好处是背景可以透明、支持多标签页。\n\n### MacDown\nWebsite：[http://macdown.uranusjr.com/](http://macdown.uranusjr.com/)  \nGithub：[https://github.com/uranusjr/macdown](https://github.com/uranusjr/macdown)  \nHomebrew：`brew cask install macdown`  \nLicense：MIT  \nPlatform：OS X\n\n![MacDown](osx-softwares/macdown.png)\n\n一款 Markdown 编辑器，比那些在线的 Web App 好用，界面比较萌、比较简洁，兼容性也不错。\n\n### FeelUOwn\nGithub：[https://github.com/cosven/FeelUOwn](https://github.com/cosven/FeelUOwn)  \nLicense：GNU GPL v3  \nPlatform：OS X、GNU/Linux\n\n![FeelUOwn](osx-softwares/feeluown.png)\n\n网易云音乐客户端，比较轻量，能听歌但好像也只能听歌 ……\n\n### GIMP\nWebsite：[https://www.gimp.org/](https://www.gimp.org/)  \nGithub：[https://github.com/GNOME/gimp](https://github.com/GNOME/gimp)  \nHomebrew：`brew cask install gimp`  \nLicense：GNU GPL v3  \nPlatform：OS X、GNU/Linux、Windows\n\n![GIMP](osx-softwares/gimp.png)\n\n专业的图像处理软件，虽然我不那么专业，平常用来剪剪图搞搞模糊还是挺资磁的。只是 Gtk+ 的图形界面在 OS X 下表现不是很好，非原生界面感觉怪怪的 ……\n\n### LibreOffice\nWebsite：[https://www.libreoffice.org/](https://www.libreoffice.org/)  \nGithub：[https://github.com/LibreOffice](https://github.com/LibreOffice)  \nHomebrew：`brew cask install libreoffice`  \nLicense：Mozilla Public License v2.0  \nPlatform：OS X、GNU/Linux、Windows\n\n![LibreOffice Writer](osx-softwares/libreoffice-writer.png)\n\n文档处理软件，它的 Writer 和 Calc 比较好用，Impress 不如 PowerPoint 好用。一般除了做幻灯片之外不需要开 MS Office。\n\n### VLC\nWebsite：[http://www.videolan.org/vlc/](http://www.videolan.org/vlc/)  \nGithub：[https://github.com/videolan/vlc](https://github.com/videolan/vlc)  \nHomebrew：`brew cask install vlc`  \nLicense：GNU GPL v2  \nPlatform：OS X、GNU/Linux、Windows\n\n![VLC](osx-softwares/vlc.png)\n\n用过最好用的视频播放器，基本上常见不常见的格式都能打开。\n","slug":"osx-softwares","published":1,"updated":"2016-03-15T01:05:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n5v007qofdk0d96lic9"},{"title":"OS X 使用自定义分辨率开启 Retina（HiDPI）支持","date":"2016-03-16T02:50:45.000Z","_content":"\n有些电脑的显示器虽然是『高分辨率』，但像素的细腻程度仍然不及 Apple 的 Retina 显示器（用四个实际像素点渲染一个逻辑像素点）。比如我的显示器在 Ubuntu 下设置缩放 1.25 倍得到的体验最佳，但在黑苹果 OS X 系统中是不能开启非两倍的 HiDPI 的，一个解决方案是以较高的分辨率开启两倍 HiDPI，再让渲染时缩放回显示器的实际分辨率。\n\n需要注意的是，这种解决方案并不完美 —— 这样会使字体失去一部分次像素渲染效果，不支持 Retina 的应用程序显示效果极差，并且图形性能有较大损失。\n\n<!-- more -->\n\n### 需要的工具\n* Xcode 或其他 plist 编辑器\n\n有人说需要 IORegExplorer、SwitchResX，其实都是在找麻烦 ……\n\n### 获取硬件信息\n获取显示器的 `DisplayVendorID`、`DisplayProductID`、`IODisplayEDID` 和 `IODisplayPrefsKey`：\n\n```bash\nioreg -l | grep DisplayVendorID\n#     | |   | |         \"DisplayVendorID\" = 1711\nioreg -l | grep DisplayProductID\n#    | |   | |         \"DisplayProductID\" = 4413\nioreg -l | grep IODisplayEDID\n#    | |   | |         \"IODisplayEDID\" = <00ffffffffffff0006af3d110000000003170104951f11780287e5a456509e260d505400000001010101010101010101010101010101143780b87038244010103e0035ad100000180000000f0000000000000000000000000020000000fe0041554f0a202020202020202020000000fe004231343048414e30312e31200a00a1>\nioreg -l | grep IODisplayPrefsKey\n#    | |   | |         \"IODisplayPrefsKey\" = \"IOService:/AppleACPIPlatformExpert/PCI0@0/AppleACPIPCI/GFX0@2/AppleIntelFramebuffer@0/display0/AppleDisplay-6af-113d\"\n```\n\n记下这些数据，待会用得到。\n\n### 创建配置文件\n我的 `IODisplayPrefsKey` 最后一段是：\n\n```plain\nAppleDisplay-6af-113d\n```\n\n创建配置文件夹及文件：\n\n```bash\nmkdir DisplayVendorID-6af\nnano DisplayVendorID-6af/DisplayProductID-113d.plist\n```\n\n把其中的 `6af` 和 `113d` 替换为你的 `IODisplayPrefsKey` 中的数字，并在 `nano` 中粘贴以下内容（我的模板）：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>DisplayProductName</key>\n\t<string>Menci&apos;s Display &gt;_&lt;</string>\n\t<key>DisplayProductID</key>\n\t<integer>26609</integer>\n\t<key>DisplayVendorID</key>\n\t<integer>14499</integer>\n\t<key>IODisplayEDID</key>\n\t<data>AP///////wAGrz0RAAAAAAMXAQSVHxF4AoflpFZQniYNUFQAAAABAQEBAQEBAQEBAQEBAQEBFDeAuHA4JEAQED4ANa0QAAAYAAAADwAAAAAAAAAAAAAAAAAgAAAA/gBBVU8KICAgICAgICAgAAAA/gBCMTQwSEFOMDEuMSAKAKE=</data>\n\t<key>scale-resolutions</key>\n\t<array>\n\t\t<data>AAAKAAAABaAAAAAB</data>\n\t\t<data>AAAFVgAAAwAAAAAB</data>\n\t\t<data>AAAKrAAABgAAAAAB</data>\n\t</array>\n</dict>\n</plist>\n```\n\n`Control + O` 回车保存，`Control + X` 退出。\n\n### 编辑配置文件\n用 plist 编辑器打开 `DisplayProductID-XXXX.plist` 文件：\n\n![plist 编辑](/Users/Menci/Hexo/source/_posts/osx-enable-retina/plist-edit.png)\n\n把 `DisplayVendorID`、`DisplayProductID`、`IODisplayEDID` 修改为第一步记下的值，`DisplayProductName` 可以随意修改。\n\n展开 `scale-resolutions`，这里面就是我们的自定义分辨率，格式如下（所有数字均为十六进制）：\n\n```plain\n<横向分辨率 纵向分辨率 1>\n```\n\n比如我要添加一个 `1366 × 768 (HiDPI)` 选项，则要先乘以二，得到 `2732 × 1536`，然后转换为十六进制（可以用系统自带的 `Calculator.app`）填入，即：\n\n```plain\n<00000aac 00000600 00000001>\n```\n\n填好后保存退出。\n\n### 应用配置文件\n将配置文件复制到系统目录下，并去掉 `.plist` 后缀：\n\n```bash\ncd DisplayVendorID-6af\nmv DisplayProductID-113d.plist DisplayProductID-113d\nsudo cp -r . /System/Library/Displays/Overrides/\n```\n\n开启系统分辨率缩放支持：\n\n```bash\nsudo defaults write /Library/Preferences/com.apple.windowserver DisplayResolutionEnabled -bool YES;\n```\n\n重启后在显示器设置中选择『缩放』，就可以看到自定义的分辨率了。\n","source":"_posts/osx-enable-retina.md","raw":"title: OS X 使用自定义分辨率开启 Retina（HiDPI）支持\ncategories: Geek\ntags:\n  - OS X\n  - HiDPI\npermalink: osx-enable-retina\ndate: 2016-03-16 10:50:45\n---\n\n有些电脑的显示器虽然是『高分辨率』，但像素的细腻程度仍然不及 Apple 的 Retina 显示器（用四个实际像素点渲染一个逻辑像素点）。比如我的显示器在 Ubuntu 下设置缩放 1.25 倍得到的体验最佳，但在黑苹果 OS X 系统中是不能开启非两倍的 HiDPI 的，一个解决方案是以较高的分辨率开启两倍 HiDPI，再让渲染时缩放回显示器的实际分辨率。\n\n需要注意的是，这种解决方案并不完美 —— 这样会使字体失去一部分次像素渲染效果，不支持 Retina 的应用程序显示效果极差，并且图形性能有较大损失。\n\n<!-- more -->\n\n### 需要的工具\n* Xcode 或其他 plist 编辑器\n\n有人说需要 IORegExplorer、SwitchResX，其实都是在找麻烦 ……\n\n### 获取硬件信息\n获取显示器的 `DisplayVendorID`、`DisplayProductID`、`IODisplayEDID` 和 `IODisplayPrefsKey`：\n\n```bash\nioreg -l | grep DisplayVendorID\n#     | |   | |         \"DisplayVendorID\" = 1711\nioreg -l | grep DisplayProductID\n#    | |   | |         \"DisplayProductID\" = 4413\nioreg -l | grep IODisplayEDID\n#    | |   | |         \"IODisplayEDID\" = <00ffffffffffff0006af3d110000000003170104951f11780287e5a456509e260d505400000001010101010101010101010101010101143780b87038244010103e0035ad100000180000000f0000000000000000000000000020000000fe0041554f0a202020202020202020000000fe004231343048414e30312e31200a00a1>\nioreg -l | grep IODisplayPrefsKey\n#    | |   | |         \"IODisplayPrefsKey\" = \"IOService:/AppleACPIPlatformExpert/PCI0@0/AppleACPIPCI/GFX0@2/AppleIntelFramebuffer@0/display0/AppleDisplay-6af-113d\"\n```\n\n记下这些数据，待会用得到。\n\n### 创建配置文件\n我的 `IODisplayPrefsKey` 最后一段是：\n\n```plain\nAppleDisplay-6af-113d\n```\n\n创建配置文件夹及文件：\n\n```bash\nmkdir DisplayVendorID-6af\nnano DisplayVendorID-6af/DisplayProductID-113d.plist\n```\n\n把其中的 `6af` 和 `113d` 替换为你的 `IODisplayPrefsKey` 中的数字，并在 `nano` 中粘贴以下内容（我的模板）：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>DisplayProductName</key>\n\t<string>Menci&apos;s Display &gt;_&lt;</string>\n\t<key>DisplayProductID</key>\n\t<integer>26609</integer>\n\t<key>DisplayVendorID</key>\n\t<integer>14499</integer>\n\t<key>IODisplayEDID</key>\n\t<data>AP///////wAGrz0RAAAAAAMXAQSVHxF4AoflpFZQniYNUFQAAAABAQEBAQEBAQEBAQEBAQEBFDeAuHA4JEAQED4ANa0QAAAYAAAADwAAAAAAAAAAAAAAAAAgAAAA/gBBVU8KICAgICAgICAgAAAA/gBCMTQwSEFOMDEuMSAKAKE=</data>\n\t<key>scale-resolutions</key>\n\t<array>\n\t\t<data>AAAKAAAABaAAAAAB</data>\n\t\t<data>AAAFVgAAAwAAAAAB</data>\n\t\t<data>AAAKrAAABgAAAAAB</data>\n\t</array>\n</dict>\n</plist>\n```\n\n`Control + O` 回车保存，`Control + X` 退出。\n\n### 编辑配置文件\n用 plist 编辑器打开 `DisplayProductID-XXXX.plist` 文件：\n\n![plist 编辑](/Users/Menci/Hexo/source/_posts/osx-enable-retina/plist-edit.png)\n\n把 `DisplayVendorID`、`DisplayProductID`、`IODisplayEDID` 修改为第一步记下的值，`DisplayProductName` 可以随意修改。\n\n展开 `scale-resolutions`，这里面就是我们的自定义分辨率，格式如下（所有数字均为十六进制）：\n\n```plain\n<横向分辨率 纵向分辨率 1>\n```\n\n比如我要添加一个 `1366 × 768 (HiDPI)` 选项，则要先乘以二，得到 `2732 × 1536`，然后转换为十六进制（可以用系统自带的 `Calculator.app`）填入，即：\n\n```plain\n<00000aac 00000600 00000001>\n```\n\n填好后保存退出。\n\n### 应用配置文件\n将配置文件复制到系统目录下，并去掉 `.plist` 后缀：\n\n```bash\ncd DisplayVendorID-6af\nmv DisplayProductID-113d.plist DisplayProductID-113d\nsudo cp -r . /System/Library/Displays/Overrides/\n```\n\n开启系统分辨率缩放支持：\n\n```bash\nsudo defaults write /Library/Preferences/com.apple.windowserver DisplayResolutionEnabled -bool YES;\n```\n\n重启后在显示器设置中选择『缩放』，就可以看到自定义的分辨率了。\n","slug":"osx-enable-retina","published":1,"updated":"2016-03-16T02:50:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n7e007vofdkbk3nuv9a"},{"title":"数论学习笔记（一）","date":"2016-01-19T13:48:24.000Z","_content":"\n数论是 OI 中很重要的一部分，然而我基本上都不会，所以从现在开始我要学数论！\n\n<!-- more -->\n\n### 欧几里得\n算是 OI 中数论最基本的了吧，求两个数的最大公约数。\n\n$$ \\gcd(a,b)=\\cases{ a & b = 0 \\\\ \\gcd(b,a \\ {\\rm mod} \\ b) & b ≠ 0 } $$\n\n```cpp\nint gcd(int a, int b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n```\n\n顺便求两个数的最小公倍数。\n\n$$ {\\rm lcm}(a,b)=\\frac{a*b}{\\gcd(a,b)} $$\n\n写程序时先除后乘防炸。\n\n```cpp\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\n```\n\n### 扩展欧几里得\n扩展欧几里得 `exgcd` 可以在求出 $\\gcd(a,b)$ 的同时求出二元一次不定方程 $ax+by=\\gcd(a,b)$的一组整数解。\n\n举个栗子，求 $\\gcd(47,30)$ 时，得到以下式子。\n\n$$\n\\begin{align*}\n& 47=30*1+17 \\\\\n& 30=17*1+13 \\\\\n& 17=13*1+4  \\\\\n& 13=4*3+1   \\\\\n\\end{align*}\n$$\n\n把余数移到左边\n\n$$\n\\begin{align*}\n& 17=47+30*(-1) \\\\\n& 13=30+17*(-1) \\\\\n& 4=17+13*(-1)  \\\\\n& 1=13+4*(-3)   \\\\\n\\end{align*}\n$$\n\n从 $\\gcd(47,30)=1$ 开始，将四个式子依次带入，得\n\n$$\n\\begin{align*}\n& \\gcd(47,30)             \\\\\n& =1                      \\\\\n& =13*1+4*(-3)            \\\\\n& =13*1+[17+13*(-1)]*(-3) \\\\\n& =13*4+17*(-3)           \\\\\n& =17*3+13*4              \\\\\n& =17*3+[30+17*(-1)]*4    \\\\\n& =17*(-7)+30*4           \\\\\n& =30*4+17*(-7)           \\\\\n& =30*4+[47+30*(-1)]*(-7) \\\\\n& =30*11+47*(-7)          \\\\\n& =47*(-7)+30*11          \\\\\n\\end{align*}\n$$\n\n解得 $x=-7,y=11$。\n\n由上述式子可观察到，每次辗转交换了 `x` 和 `y`，并将 `y` 减去了原 `x` 与辗转相除所得商的乘积。\n\n```cpp\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n```\n\n### Eratosthenes 筛法\n在筛选之前，先认为每个数都是素数。枚举所有数，如果这个数是素数，那么筛掉这个数的所有倍数，标记它们为“不是素数”。\n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * 2; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n两个优化：\n1. 第二层循环可以从 $i^2$ 开始，因为对于每个小于 $i$ 的数 $i'$，$i*i'$ 都已经在第 $i'$ 次循环筛掉了。\n2. 枚举 $[2,\\sqrt{n}]$ 的素数即可，因为对于每个合数 $p>\\sqrt{n}$，则必有素数 $k$ 满足 $p=k*k'$ 且 $k< \\sqrt{n}$，所以 $p$ 会在第 $k$ 次循环被筛掉。\n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tint m = floor(sqrt(n + 0.5));\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * i; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n### 欧拉函数\n根据唯一分解定理，任何一个正整数 $n$ 都可以写成 $k$ 个素数的幂的积的形式，其中第 $i$ 个素数的指数为 $a_i$。即：\n\n$$ n={\\prod_{i=1}^{k}} \\ {p_i}^{a_i} $$\n\n根据容斥原理，从总数 $n$ 中先减去每个 $p_i$ 的倍数，再把多减的补回来，再把多补的减回来 …… 最终得到公式\n\n$$ \\phi(n)={\\sum_{S{\\subseteq}\\{p_1,p_2,\\ldots,p_k\\}}{(-1)^{|S|}} *  {\\frac{n}{ {\\prod_{ {p_i}{\\in}S} } \\ p_i }}} $$\n\n把求和和容斥原理的应用全部展开之后就是\n\n$$ \\phi(n)=n*\\prod_{i=1}^{k} (1 - \\frac{1}{p_i}) $$\n\n程序实现就是先令结果为 $n$，每次把结果除掉一个 $p$ 再乘上 $p-1$。嗯，不是很好理解 ……\n\n对于给定的 $n$，用类似筛法的思想枚举素数，每次找到一个素数后把它的倍数全部筛掉。\n\n```cpp\nint phi() {\n\tint m = floor(sqrt(n + 0.5)), ans = n;\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (n % i == 0) {\n\t\t\tans = ans / i * (i - 1);\n\t\t\twhile (n % i == 0) n /= i;\n\t\t}\n\t}\n\n\tif (n != 1) ans = ans / n * (n - 1); // 前面没筛干净的\n\treturn ans;\n}\n```\n\n未完待续 ……\n","source":"_posts/number-theory-notes-1.md","raw":"title: 数论学习笔记（一）\ncategories: OI\ntags: \n  - 数学\n  - 数论\n  - 学习笔记\n  - 算法模板  \npermalink: number-theory-notes-1\ndate: 2016-01-19 21:48:24\n---\n\n数论是 OI 中很重要的一部分，然而我基本上都不会，所以从现在开始我要学数论！\n\n<!-- more -->\n\n### 欧几里得\n算是 OI 中数论最基本的了吧，求两个数的最大公约数。\n\n$$ \\gcd(a,b)=\\cases{ a & b = 0 \\\\ \\gcd(b,a \\ {\\rm mod} \\ b) & b ≠ 0 } $$\n\n```cpp\nint gcd(int a, int b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n```\n\n顺便求两个数的最小公倍数。\n\n$$ {\\rm lcm}(a,b)=\\frac{a*b}{\\gcd(a,b)} $$\n\n写程序时先除后乘防炸。\n\n```cpp\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\n```\n\n### 扩展欧几里得\n扩展欧几里得 `exgcd` 可以在求出 $\\gcd(a,b)$ 的同时求出二元一次不定方程 $ax+by=\\gcd(a,b)$的一组整数解。\n\n举个栗子，求 $\\gcd(47,30)$ 时，得到以下式子。\n\n$$\n\\begin{align*}\n& 47=30*1+17 \\\\\n& 30=17*1+13 \\\\\n& 17=13*1+4  \\\\\n& 13=4*3+1   \\\\\n\\end{align*}\n$$\n\n把余数移到左边\n\n$$\n\\begin{align*}\n& 17=47+30*(-1) \\\\\n& 13=30+17*(-1) \\\\\n& 4=17+13*(-1)  \\\\\n& 1=13+4*(-3)   \\\\\n\\end{align*}\n$$\n\n从 $\\gcd(47,30)=1$ 开始，将四个式子依次带入，得\n\n$$\n\\begin{align*}\n& \\gcd(47,30)             \\\\\n& =1                      \\\\\n& =13*1+4*(-3)            \\\\\n& =13*1+[17+13*(-1)]*(-3) \\\\\n& =13*4+17*(-3)           \\\\\n& =17*3+13*4              \\\\\n& =17*3+[30+17*(-1)]*4    \\\\\n& =17*(-7)+30*4           \\\\\n& =30*4+17*(-7)           \\\\\n& =30*4+[47+30*(-1)]*(-7) \\\\\n& =30*11+47*(-7)          \\\\\n& =47*(-7)+30*11          \\\\\n\\end{align*}\n$$\n\n解得 $x=-7,y=11$。\n\n由上述式子可观察到，每次辗转交换了 `x` 和 `y`，并将 `y` 减去了原 `x` 与辗转相除所得商的乘积。\n\n```cpp\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n```\n\n### Eratosthenes 筛法\n在筛选之前，先认为每个数都是素数。枚举所有数，如果这个数是素数，那么筛掉这个数的所有倍数，标记它们为“不是素数”。\n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * 2; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n两个优化：\n1. 第二层循环可以从 $i^2$ 开始，因为对于每个小于 $i$ 的数 $i'$，$i*i'$ 都已经在第 $i'$ 次循环筛掉了。\n2. 枚举 $[2,\\sqrt{n}]$ 的素数即可，因为对于每个合数 $p>\\sqrt{n}$，则必有素数 $k$ 满足 $p=k*k'$ 且 $k< \\sqrt{n}$，所以 $p$ 会在第 $k$ 次循环被筛掉。\n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tint m = floor(sqrt(n + 0.5));\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * i; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n### 欧拉函数\n根据唯一分解定理，任何一个正整数 $n$ 都可以写成 $k$ 个素数的幂的积的形式，其中第 $i$ 个素数的指数为 $a_i$。即：\n\n$$ n={\\prod_{i=1}^{k}} \\ {p_i}^{a_i} $$\n\n根据容斥原理，从总数 $n$ 中先减去每个 $p_i$ 的倍数，再把多减的补回来，再把多补的减回来 …… 最终得到公式\n\n$$ \\phi(n)={\\sum_{S{\\subseteq}\\{p_1,p_2,\\ldots,p_k\\}}{(-1)^{|S|}} *  {\\frac{n}{ {\\prod_{ {p_i}{\\in}S} } \\ p_i }}} $$\n\n把求和和容斥原理的应用全部展开之后就是\n\n$$ \\phi(n)=n*\\prod_{i=1}^{k} (1 - \\frac{1}{p_i}) $$\n\n程序实现就是先令结果为 $n$，每次把结果除掉一个 $p$ 再乘上 $p-1$。嗯，不是很好理解 ……\n\n对于给定的 $n$，用类似筛法的思想枚举素数，每次找到一个素数后把它的倍数全部筛掉。\n\n```cpp\nint phi() {\n\tint m = floor(sqrt(n + 0.5)), ans = n;\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (n % i == 0) {\n\t\t\tans = ans / i * (i - 1);\n\t\t\twhile (n % i == 0) n /= i;\n\t\t}\n\t}\n\n\tif (n != 1) ans = ans / n * (n - 1); // 前面没筛干净的\n\treturn ans;\n}\n```\n\n未完待续 ……\n","slug":"number-theory-notes-1","published":1,"updated":"2016-03-15T09:17:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n7k0080ofdk5wzt5y3g"},{"title":"「NOIP2012」同余方程 - 扩展欧几里得","date":"2016-01-19T13:20:19.000Z","_content":"\n求关于 `x` 同余方程 $ax ≡ 1 ({\\rm mod} \\ b)$的最小正整数解。 \n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1200](http://codevs.cn/problem/1200/)  \n[Tyvj 2074](http://tyvj.cn/p/2074)\n\n### 解题思路\n扩展欧几里得裸题，注意求最小正整数解，求出来 `x` 要模一次 `b`，然后加上 `b` 再模一次。\n\n### AC代码\n```cpp\n#include <cstdio>\n\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nint main() {\n\tint a, b, g, x, y;\n\tscanf(\"%d %d\", &a, &b);\n\texgcd(a, b, g, x, y);\n\tx = ((x % b) + b) % b;\n\tprintf(\"%d\\n\", x);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2012-mod.md","raw":"title: 「NOIP2012」同余方程 - 扩展欧几里得\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - Tyvj\n  - 数论\n  - EXGCD\n  - 乘法逆元\npermalink: noip2012-mod\ndate: 2016-01-19 21:20:19\n---\n\n求关于 `x` 同余方程 $ax ≡ 1 ({\\rm mod} \\ b)$的最小正整数解。 \n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1200](http://codevs.cn/problem/1200/)  \n[Tyvj 2074](http://tyvj.cn/p/2074)\n\n### 解题思路\n扩展欧几里得裸题，注意求最小正整数解，求出来 `x` 要模一次 `b`，然后加上 `b` 再模一次。\n\n### AC代码\n```cpp\n#include <cstdio>\n\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nint main() {\n\tint a, b, g, x, y;\n\tscanf(\"%d %d\", &a, &b);\n\texgcd(a, b, g, x, y);\n\tx = ((x % b) + b) % b;\n\tprintf(\"%d\\n\", x);\n\n\treturn 0;\n}\n```\n","slug":"noip2012-mod","published":1,"updated":"2016-03-15T01:50:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n7n0086ofdkd0zwwssk"},{"title":"「NOIP2010」关押罪犯 - 二分图染色","id":"54","updated":"2016-02-19T08:06:06.000Z","date":"2016-02-19T08:00:26.000Z","_content":"\nS 城现有两座监狱，一共关押着 `N` 名罪犯，编号分别为 `1 ~ N`，我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。每年每一对有仇恨的罪犯会发生一次冲突。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力。那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小，求这个最小值是多少？\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1069](http://codevs.cn/problem/1069/)  \n[Tyvj 1043](http://tyvj.cn/p/1403)  \n[洛谷 1525](http://www.luogu.org/problem/show?pid=1525)\n\n### 解题思路\n因为要求最小值，所以考虑二分答案。当我们二分一个答案 `x` 后，只需要考虑怒气值大于 `x` 的成对罪犯了，这时候对整张图进行二分图染色，如果能被染色成为二分图，则这个答案合法。\n\n二分图染色：把每个未标记的节点标记为任意一种颜色，对其进行一次 BFS，每一次扩展把未被染色的节点标记为与自身相反的颜色，如果发现扩展出去的节点的颜色与自身相同，则染色失败。\n\n时间复杂度为 $ O(n{log}n) $，理论上来说可以过 100% 的数据，然而 Tyvj 的评测机太烂竟然 TLE 了一个点。\n\n有神犇说可以用并查集，然而我太弱不会 …… qwq\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 20000;\nconst int MAXM = 100000;\n\nenum Color {\n\tNone = 0,\n\tRed = 2000,\n\tBlue = 5280\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tColor color;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nint n, m, max;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline Color getReveseColor(Color c) {\n\treturn c == Red ? Blue : Red;\n}\n\ninline bool bfs(Node *start, int limit) {\n\n\treturn true;\n}\n\ninline bool check(int limit) {\n\tfor (int i = 0; i < n; i++) nodes[i].color = None;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].color == None) {\n\t\t\tnodes[i].color = Red;\n\n\t\t\tstd::queue<Node *> q;\n\t\t\tq.push(&nodes[i]);\n\n\t\t\twhile (!q.empty()) {\n\t\t\t\tNode *v = q.front();\n\t\t\t\tq.pop();\n\n\t\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\t\tif (e->w < limit) continue;\n\n\t\t\t\t\tif (e->to->color == None) {\n\t\t\t\t\t\te->to->color = getReveseColor(v->color);\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t} else if (e->to->color == v->color) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\ninline int solve() {\n\tint l = 1, r = max;\n\twhile (l < r) {\n\t\tint mid = (l & r) + ((l ^ r) >> 1);\n\t\t//printf(\"[%d, %d] with `mid` = %d\\n\", l, r, mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l - 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t\tmax = std::max(max, w);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}\n```","source":"_posts/noip2010-prison.md","raw":"title: 「NOIP2010」关押罪犯 - 二分图染色\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - Vijos\n  - 洛谷\n  - 图论\n  - 二分答案\n  - 二分图染色\npermalink: noip2010-prison\nid: 54\nupdated: '2016-02-19 16:06:06'\ndate: 2016-02-19 16:00:26\n---\n\nS 城现有两座监狱，一共关押着 `N` 名罪犯，编号分别为 `1 ~ N`，我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。每年每一对有仇恨的罪犯会发生一次冲突。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力。那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小，求这个最小值是多少？\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1069](http://codevs.cn/problem/1069/)  \n[Tyvj 1043](http://tyvj.cn/p/1403)  \n[洛谷 1525](http://www.luogu.org/problem/show?pid=1525)\n\n### 解题思路\n因为要求最小值，所以考虑二分答案。当我们二分一个答案 `x` 后，只需要考虑怒气值大于 `x` 的成对罪犯了，这时候对整张图进行二分图染色，如果能被染色成为二分图，则这个答案合法。\n\n二分图染色：把每个未标记的节点标记为任意一种颜色，对其进行一次 BFS，每一次扩展把未被染色的节点标记为与自身相反的颜色，如果发现扩展出去的节点的颜色与自身相同，则染色失败。\n\n时间复杂度为 $ O(n{log}n) $，理论上来说可以过 100% 的数据，然而 Tyvj 的评测机太烂竟然 TLE 了一个点。\n\n有神犇说可以用并查集，然而我太弱不会 …… qwq\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 20000;\nconst int MAXM = 100000;\n\nenum Color {\n\tNone = 0,\n\tRed = 2000,\n\tBlue = 5280\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tColor color;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nint n, m, max;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline Color getReveseColor(Color c) {\n\treturn c == Red ? Blue : Red;\n}\n\ninline bool bfs(Node *start, int limit) {\n\n\treturn true;\n}\n\ninline bool check(int limit) {\n\tfor (int i = 0; i < n; i++) nodes[i].color = None;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].color == None) {\n\t\t\tnodes[i].color = Red;\n\n\t\t\tstd::queue<Node *> q;\n\t\t\tq.push(&nodes[i]);\n\n\t\t\twhile (!q.empty()) {\n\t\t\t\tNode *v = q.front();\n\t\t\t\tq.pop();\n\n\t\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\t\tif (e->w < limit) continue;\n\n\t\t\t\t\tif (e->to->color == None) {\n\t\t\t\t\t\te->to->color = getReveseColor(v->color);\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t} else if (e->to->color == v->color) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\ninline int solve() {\n\tint l = 1, r = max;\n\twhile (l < r) {\n\t\tint mid = (l & r) + ((l ^ r) >> 1);\n\t\t//printf(\"[%d, %d] with `mid` = %d\\n\", l, r, mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l - 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t\tmax = std::max(max, w);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}\n```","slug":"noip2010-prison","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n7r008gofdknmpeypaw"},{"title":"「NOIP2006」能量项链 - 区间DP","id":"19","updated":"2016-01-19T13:04:41.000Z","date":"2016-01-12T21:19:28.000Z","_content":"\n在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为m，尾标记为r，后一颗能量珠的头标记为r，尾标记为n，则聚合后释放的能量为$m*r*n$（Mars单位），新产生的珠子的头标记为m，尾标记为n。\n需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1154](http://codevs.cn/problem/1154/)  \n[Tyvj 1056](http://tyvj.cn/p/1056)\n\n### 解题思路\n首先，项链是一个环，枚举断点给它拆开。\n\n区间DP，用 $a[i]$ 表示第 `i` 颗珠子的头标记（即第 `i + 1` 颗珠子的尾标记），用 $f[i][j]$ 表示第 `i` 到第 `j` 颗珠子聚合成一颗后释放能量的最大值，枚举 `k`，自 `k` 处断开后，无论左右两段如何聚合，两段分别聚合成的两个珠子的标记值是不变的，即状态转移方程为：\n\n$$f[i][j]=\\max\\{f[i][k]+f[k+1][j]+a[i]*a[k+1]*a[j+1],k{\\in}[i,j-1]\\}$$\n\n边界条件为：\n\n$$f[i][j]=\\cases{0 & i=j \\\\ a[i]*a[j]*a[j+1] & j=i+1}$$\n\n注意代码编写时，访问最后一颗珠子的尾标记时，会越界，可以通过将下标对珠子总数取模的方法解决，因为最后一颗珠子的尾标记等于第一颗珠子的头标记。\n\n总时间复杂度为 $O(n^4)$，刚好解决 $n=100$ 的最大测试点 TvT。\n\n调试可费了大功夫，详见**注释掉的代码**。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\nconst int MAXN = 100;\n\nint n, a[MAXN];\n\nint ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == j) return 0;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j - i == 1) ans[i - 1][j - 1] = a[i - 1] * a[j - 1] * a[(j + 1 - 1) % (n)];\n\t\telse {\n\t\t\tans[i - 1][j - 1] = 0;\n\t\t\tint p = a[i - 1] * a[(j + 1 - 1) % (n)];\n\t\t\tint m = -1;\n\t\t\tfor (int k = i; k <= j - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = std::max(ans[i - 1][j - 1], search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)]);\n\t\t\t\t/*if (search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)] > ans[i - 1][j - 1]) {\n\t\t\t\t\tans[i - 1][j - 1] = search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)];\n\t\t\t\t\tm = k;\n\t\t\t\t}*/\n\t\t\t}\n\t\t\t//printf(\"%d %d %d\\n\", i, (m + 1), (j + 1));\n\t\t\t//printf(\"from k = %d, %d * %d * %d, \", m, a[i - 1], a[(m + 1 - 1) % (n - 1)], a[(j + 1 - 1) % (n - 1)]);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\t\ta[n - 1] = first;\n\n\t\tmemset(calced, 0, sizeof(calced));\n\t\t/*for (int i = 0; i < n; i++) {\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tputchar('\\n');*/\n\t\tans = std::max(ans, search(1, n));\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/noip2006-energy.md","raw":"title: 「NOIP2006」能量项链 - 区间DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - NOIP\n  - Tyvj\n  - 区间DP\npermalink: noip2006-energy\nid: 19\nupdated: '2016-01-19 21:04:41'\ndate: 2016-01-13 05:19:28\n---\n\n在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为m，尾标记为r，后一颗能量珠的头标记为r，尾标记为n，则聚合后释放的能量为$m*r*n$（Mars单位），新产生的珠子的头标记为m，尾标记为n。\n需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1154](http://codevs.cn/problem/1154/)  \n[Tyvj 1056](http://tyvj.cn/p/1056)\n\n### 解题思路\n首先，项链是一个环，枚举断点给它拆开。\n\n区间DP，用 $a[i]$ 表示第 `i` 颗珠子的头标记（即第 `i + 1` 颗珠子的尾标记），用 $f[i][j]$ 表示第 `i` 到第 `j` 颗珠子聚合成一颗后释放能量的最大值，枚举 `k`，自 `k` 处断开后，无论左右两段如何聚合，两段分别聚合成的两个珠子的标记值是不变的，即状态转移方程为：\n\n$$f[i][j]=\\max\\{f[i][k]+f[k+1][j]+a[i]*a[k+1]*a[j+1],k{\\in}[i,j-1]\\}$$\n\n边界条件为：\n\n$$f[i][j]=\\cases{0 & i=j \\\\ a[i]*a[j]*a[j+1] & j=i+1}$$\n\n注意代码编写时，访问最后一颗珠子的尾标记时，会越界，可以通过将下标对珠子总数取模的方法解决，因为最后一颗珠子的尾标记等于第一颗珠子的头标记。\n\n总时间复杂度为 $O(n^4)$，刚好解决 $n=100$ 的最大测试点 TvT。\n\n调试可费了大功夫，详见**注释掉的代码**。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\nconst int MAXN = 100;\n\nint n, a[MAXN];\n\nint ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == j) return 0;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j - i == 1) ans[i - 1][j - 1] = a[i - 1] * a[j - 1] * a[(j + 1 - 1) % (n)];\n\t\telse {\n\t\t\tans[i - 1][j - 1] = 0;\n\t\t\tint p = a[i - 1] * a[(j + 1 - 1) % (n)];\n\t\t\tint m = -1;\n\t\t\tfor (int k = i; k <= j - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = std::max(ans[i - 1][j - 1], search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)]);\n\t\t\t\t/*if (search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)] > ans[i - 1][j - 1]) {\n\t\t\t\t\tans[i - 1][j - 1] = search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)];\n\t\t\t\t\tm = k;\n\t\t\t\t}*/\n\t\t\t}\n\t\t\t//printf(\"%d %d %d\\n\", i, (m + 1), (j + 1));\n\t\t\t//printf(\"from k = %d, %d * %d * %d, \", m, a[i - 1], a[(m + 1 - 1) % (n - 1)], a[(j + 1 - 1) % (n - 1)]);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\t\ta[n - 1] = first;\n\n\t\tmemset(calced, 0, sizeof(calced));\n\t\t/*for (int i = 0; i < n; i++) {\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tputchar('\\n');*/\n\t\tans = std::max(ans, search(1, n));\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"noip2006-energy","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n7z008sofdkzy7a7cn0"},{"title":"「NOIP2006」金明的预算方案 - 背包DP + 树形DP","id":"25","updated":"2016-01-19T13:02:58.000Z","date":"2016-01-16T22:11:03.000Z","_content":"\n金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的。\n\n如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1155](http://codevs.cn/problem/1155/)  \n[Tyvj 1057](http://tyvj.cn/p/1057)  \n[洛谷 1064](http://www.luogu.org/problem/show?pid=1064)  \n[Vijos 1313](https://vijos.org/p/1313?pid=1313)\n\n### 解题思路\n其实题挺水的，直接枚举选哪个附件就好，但学了树形 DP 就要写一写嘛。\n\n首先，我们有一个 01 背包的方程：\n\n$$ f[v] = \\max(f[v],f[v-c[i]]+w[i]) $$\n\n对某个节点求解时，先对每一个子物品递归求解，然后进行一次 01 背包，得到一个由该物品及其附属物品组成的泛化物品组，然后一级一级地传到最顶层。\n\n设置一个价值与费用均为 `0` 的虚拟节点并将其作为所有无依赖的物品的父节点，求解 `0` 即为最终结果。\n\n更具体的讲解详见《背包九讲》。~~我太弱了讲不明白呢。~~\n\nPS：有个“坑”就是题目中的背包容量太大太大了，是妥妥的要 TLE 的（只能过前五个），但是因为背包容量和每件物品的体积都是 `10` 的倍数，所以读入数据后直接除以 `10` 就好。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 60;\nconst int MAXV = 3200;\n\nint n, V;\n\nstruct Tree {\n\tTree *children, *next;\n\tint c, w;\n\tint f[MAXV + 1];\n\n\tTree() {}\n\tTree(Tree *parent, int c, int w) : next(parent->children), c(c), w(w) {\n\t\tmemset(f, 0, sizeof(f));\n\t}\n\n\tvoid solve() {\n\t\tfor (int v = V; v >= c; v--) f[v] = w;\n\t\tfor (Tree *t = children; t; t = t->next) {\n\t\t\tt->solve();\n\t\t\tfor (int v = V - c; v >= t->c; v--) {\n\t\t\t\tfor (int i = t->c; i <= std::min(V - c, v + c); i++) {\n\t\t\t\t\tf[v + c] = std::max(f[v + c], f[v + c - i] + t->f[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} trees[MAXN + 1];\n\ninline void addTree(int id, int parent, int c, int w) {\n\ttrees[parent].children = new (&trees[id]) Tree(&trees[parent], c, w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &V, &n);\n\tV /= 10;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, p, q;\n\t\tscanf(\"%d %d %d\", &c, &p, &q);\n\n\t\taddTree(i + 1, q, c / 10, c * p);\n\t}\n\n\ttrees[0].solve();\n\n\tprintf(\"%d\\n\", trees[0].f[V]);\n\n\treturn 0;\n}\n```","source":"_posts/noip2006-budget.md","raw":"title: 「NOIP2006」金明的预算方案 - 背包DP + 树形DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - Tyvj\n  - Vijos\n  - 树形DP\n  - 洛谷\n  - 背包DP\npermalink: noip2006-budget\nid: 25\nupdated: '2016-01-19 21:02:58'\ndate: 2016-01-17 06:11:03\n---\n\n金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的。\n\n如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有0个、1个或2个附件。附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是10元的整数倍）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1155](http://codevs.cn/problem/1155/)  \n[Tyvj 1057](http://tyvj.cn/p/1057)  \n[洛谷 1064](http://www.luogu.org/problem/show?pid=1064)  \n[Vijos 1313](https://vijos.org/p/1313?pid=1313)\n\n### 解题思路\n其实题挺水的，直接枚举选哪个附件就好，但学了树形 DP 就要写一写嘛。\n\n首先，我们有一个 01 背包的方程：\n\n$$ f[v] = \\max(f[v],f[v-c[i]]+w[i]) $$\n\n对某个节点求解时，先对每一个子物品递归求解，然后进行一次 01 背包，得到一个由该物品及其附属物品组成的泛化物品组，然后一级一级地传到最顶层。\n\n设置一个价值与费用均为 `0` 的虚拟节点并将其作为所有无依赖的物品的父节点，求解 `0` 即为最终结果。\n\n更具体的讲解详见《背包九讲》。~~我太弱了讲不明白呢。~~\n\nPS：有个“坑”就是题目中的背包容量太大太大了，是妥妥的要 TLE 的（只能过前五个），但是因为背包容量和每件物品的体积都是 `10` 的倍数，所以读入数据后直接除以 `10` 就好。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 60;\nconst int MAXV = 3200;\n\nint n, V;\n\nstruct Tree {\n\tTree *children, *next;\n\tint c, w;\n\tint f[MAXV + 1];\n\n\tTree() {}\n\tTree(Tree *parent, int c, int w) : next(parent->children), c(c), w(w) {\n\t\tmemset(f, 0, sizeof(f));\n\t}\n\n\tvoid solve() {\n\t\tfor (int v = V; v >= c; v--) f[v] = w;\n\t\tfor (Tree *t = children; t; t = t->next) {\n\t\t\tt->solve();\n\t\t\tfor (int v = V - c; v >= t->c; v--) {\n\t\t\t\tfor (int i = t->c; i <= std::min(V - c, v + c); i++) {\n\t\t\t\t\tf[v + c] = std::max(f[v + c], f[v + c - i] + t->f[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} trees[MAXN + 1];\n\ninline void addTree(int id, int parent, int c, int w) {\n\ttrees[parent].children = new (&trees[id]) Tree(&trees[parent], c, w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &V, &n);\n\tV /= 10;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, p, q;\n\t\tscanf(\"%d %d %d\", &c, &p, &q);\n\n\t\taddTree(i + 1, q, c / 10, c * p);\n\t}\n\n\ttrees[0].solve();\n\n\tprintf(\"%d\\n\", trees[0].f[V]);\n\n\treturn 0;\n}\n```","slug":"noip2006-budget","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n82008zofdkxpdyslf1"},{"title":"「NOIP2003」数字游戏 - 划分DP","id":"20","updated":"2016-01-19T13:04:15.000Z","date":"2016-01-13T20:23:38.000Z","_content":"\n在你面前有一圈整数（一共 `n`（≤ 50）个），你要按顺序将其分为 `m`（≤ 9）个部分，各部分内的数字相加，相加所得的 `m` 个结果对 10 取模后再相乘，最终得到一个数 `k`。游戏的要求是使你所得的 `k` 最大或者最小。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1085](http://codevs.cn/problem/1085/)  \n[Tyvj 1901](http://tyvj.cn/p/1901)  \n[洛谷 1043](http://www.luogu.org/problem/show?pid=1043)\n\n### 解题思路\n又是一道划分 DP，不过坑挺多的 …… 一是枚举断点，二是注意**负数对 `10` 取模后的结果是正数**。\n\n以最大值为例，以“分的部分”的数量划分阶段，用 $ f[i][j] $ 表示前 `i` 个数划分为 `j` 个部分所得的最大值，状态转移方程为：\n\n$$ f[i][j] = \\max\\{f[k][j-1]* (({\\sum_{x=k+1}^{i}a[x]}) \\ {\\rm mod} \\ 10),k{\\in}[j-1,i-1]\\} $$\n\n边界条件为：\n\n$$ f[i][1] = ({\\sum_{x=1}^i{a[x]}}) \\ {\\rm mod} \\ 10 $$\n\n求和可以用前缀和来维护，但是注意**枚举每个断点都必须重新初始化前缀和**。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <typeinfo>\n#include <algorithm>\n\ntypedef const int &(*Extreme)(const int &, const int &);\n\nconst int MAXN = 50;\nconst int MAXM = 9;\n\nint n, m, a[MAXN], prefixSum[MAXN];\nint ans[MAXN][MAXM];\nbool calced[MAXN][MAXM];\n\ninline int mod10(int x) {\n\treturn ((x % 10) + 10) % 10;\n}\n\ninline void initPrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 1; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn mod10(i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1]);\n}\n\nint search(int i, int j, Extreme extreme) {\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j == 1) ans[i - 1][j - 1] = sum(1, i);\n\t\telse {\n\t\t\tfor (int k = j - 1; k <= i - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = extreme(ans[i - 1][j - 1], search(k, j - 1, extreme) * sum(k + 1, i));\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\ninline void work(int &ansMin, int &ansMax) {\n\t/*for (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", a[i]);\n\t}\n\tputchar('\\n');*/\n\n\tinitPrefixSum();\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MIN, calced[i][j] = false;\n\t\t}\n\t}\n\n\tansMax = std::max(ansMax, search(n, m, std::max));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MAX, calced[i][j] = false;\n\t\t}\n\t}\n\tansMin = std::min(ansMin, search(n, m, std::min));\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ansMin = INT_MAX, ansMax = INT_MIN;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\n\t\ta[n - 1] = first;\n\n\t\twork(ansMin, ansMax);\n\t}\n\n\tprintf(\"%d\\n%d\\n\", ansMin, ansMax);\n\n\treturn 0;\n}\n```","source":"_posts/noip2003-game.md","raw":"title: 「NOIP2003」数字游戏 - 划分DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - NOIP\n  - 划分DP\n  - 洛谷\n  - Tyvj\npermalink: noip2003-game\nid: 20\nupdated: '2016-01-19 21:04:15'\ndate: 2016-01-14 04:23:38\n---\n\n在你面前有一圈整数（一共 `n`（≤ 50）个），你要按顺序将其分为 `m`（≤ 9）个部分，各部分内的数字相加，相加所得的 `m` 个结果对 10 取模后再相乘，最终得到一个数 `k`。游戏的要求是使你所得的 `k` 最大或者最小。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1085](http://codevs.cn/problem/1085/)  \n[Tyvj 1901](http://tyvj.cn/p/1901)  \n[洛谷 1043](http://www.luogu.org/problem/show?pid=1043)\n\n### 解题思路\n又是一道划分 DP，不过坑挺多的 …… 一是枚举断点，二是注意**负数对 `10` 取模后的结果是正数**。\n\n以最大值为例，以“分的部分”的数量划分阶段，用 $ f[i][j] $ 表示前 `i` 个数划分为 `j` 个部分所得的最大值，状态转移方程为：\n\n$$ f[i][j] = \\max\\{f[k][j-1]* (({\\sum_{x=k+1}^{i}a[x]}) \\ {\\rm mod} \\ 10),k{\\in}[j-1,i-1]\\} $$\n\n边界条件为：\n\n$$ f[i][1] = ({\\sum_{x=1}^i{a[x]}}) \\ {\\rm mod} \\ 10 $$\n\n求和可以用前缀和来维护，但是注意**枚举每个断点都必须重新初始化前缀和**。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <typeinfo>\n#include <algorithm>\n\ntypedef const int &(*Extreme)(const int &, const int &);\n\nconst int MAXN = 50;\nconst int MAXM = 9;\n\nint n, m, a[MAXN], prefixSum[MAXN];\nint ans[MAXN][MAXM];\nbool calced[MAXN][MAXM];\n\ninline int mod10(int x) {\n\treturn ((x % 10) + 10) % 10;\n}\n\ninline void initPrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 1; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn mod10(i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1]);\n}\n\nint search(int i, int j, Extreme extreme) {\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j == 1) ans[i - 1][j - 1] = sum(1, i);\n\t\telse {\n\t\t\tfor (int k = j - 1; k <= i - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = extreme(ans[i - 1][j - 1], search(k, j - 1, extreme) * sum(k + 1, i));\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\ninline void work(int &ansMin, int &ansMax) {\n\t/*for (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", a[i]);\n\t}\n\tputchar('\\n');*/\n\n\tinitPrefixSum();\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MIN, calced[i][j] = false;\n\t\t}\n\t}\n\n\tansMax = std::max(ansMax, search(n, m, std::max));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MAX, calced[i][j] = false;\n\t\t}\n\t}\n\tansMin = std::min(ansMin, search(n, m, std::min));\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ansMin = INT_MAX, ansMax = INT_MIN;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\n\t\ta[n - 1] = first;\n\n\t\twork(ansMin, ansMax);\n\t}\n\n\tprintf(\"%d\\n%d\\n\", ansMin, ansMax);\n\n\treturn 0;\n}\n```","slug":"noip2003-game","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n860099ofdkl4vtequb"},{"title":"「NOIP2000」乘积最大 - 划分DP","id":"16","updated":"2016-01-19T13:05:38.000Z","date":"2016-01-08T21:10:45.000Z","_content":"\n在一个长度为 `N`（<= 400）的数字字符串中加上 `K`（<= 6）个乘号，使所得表达式值最大。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1017](http://codevs.cn/problem/1017/)\n\n### 解题思路\n考虑划分 DP，以加入的乘号数量作为划分阶段，用 `f[n][k]` 表示原数字前 `n` 位中加入 `k` 个乘号所得表达式的最大值，预处理出 `a[i][j]` 表示原数字第 `i` 位到第 `j` 位组成的数字，则转移方程为：\n\n$$ f[n][k] = {\\max}\\{f[i][k - 1] * a[i + 1][n],i{\\in}[k,n)\\} $$\n\n因为数据较水，所以使用 `long long` 即可，无需高精。\n\n### AC代码\n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 40;\nconst int MAXK = 6;\n\nint n, k;\nchar num[MAXN + 1];\nlong long a[MAXN][MAXN], ans[MAXN][MAXK];\nbool calced[MAXN][MAXK];\n\ninline void preProcess() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i <= j) {\n\t\t\t\tfor (int k = i; k <= j; k++) {\n\t\t\t\t\ta[i][j] *= 10;\n\t\t\t\t\ta[i][j] += (num[k] - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long search(int n, int k) {\n\tif (k == 0) return a[0][n - 1];\n\n\tif (!calced[n - 1][k - 1]) {\n\t\tfor (int i = k; i < n; i++) {\n\t\t\tans[n - 1][k - 1] = std::max(ans[n - 1][k - 1], search(i, k - 1) * a[i + 1 - 1][n - 1]);\n\t\t}\n\t\t\n\t\tcalced[n - 1][k - 1] = true;\n\t}\n\n\treturn ans[n - 1][k - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\\n%s\", &n, &k, num);\n\tpreProcess();\n\n\tprintf(\"%lld\\n\", search(n, k));\n\treturn 0;\n}\n```","source":"_posts/noip2000-cheng-ji-zui-da.md","raw":"title: 「NOIP2000」乘积最大 - 划分DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - NOIP\n  - 划分DP\npermalink: noip2000-cheng-ji-zui-da\nid: 16\nupdated: '2016-01-19 21:05:38'\ndate: 2016-01-09 05:10:45\n---\n\n在一个长度为 `N`（<= 400）的数字字符串中加上 `K`（<= 6）个乘号，使所得表达式值最大。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1017](http://codevs.cn/problem/1017/)\n\n### 解题思路\n考虑划分 DP，以加入的乘号数量作为划分阶段，用 `f[n][k]` 表示原数字前 `n` 位中加入 `k` 个乘号所得表达式的最大值，预处理出 `a[i][j]` 表示原数字第 `i` 位到第 `j` 位组成的数字，则转移方程为：\n\n$$ f[n][k] = {\\max}\\{f[i][k - 1] * a[i + 1][n],i{\\in}[k,n)\\} $$\n\n因为数据较水，所以使用 `long long` 即可，无需高精。\n\n### AC代码\n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 40;\nconst int MAXK = 6;\n\nint n, k;\nchar num[MAXN + 1];\nlong long a[MAXN][MAXN], ans[MAXN][MAXK];\nbool calced[MAXN][MAXK];\n\ninline void preProcess() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i <= j) {\n\t\t\t\tfor (int k = i; k <= j; k++) {\n\t\t\t\t\ta[i][j] *= 10;\n\t\t\t\t\ta[i][j] += (num[k] - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long search(int n, int k) {\n\tif (k == 0) return a[0][n - 1];\n\n\tif (!calced[n - 1][k - 1]) {\n\t\tfor (int i = k; i < n; i++) {\n\t\t\tans[n - 1][k - 1] = std::max(ans[n - 1][k - 1], search(i, k - 1) * a[i + 1 - 1][n - 1]);\n\t\t}\n\t\t\n\t\tcalced[n - 1][k - 1] = true;\n\t}\n\n\treturn ans[n - 1][k - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\\n%s\", &n, &k, num);\n\tpreProcess();\n\n\tprintf(\"%lld\\n\", search(n, k));\n\treturn 0;\n}\n```","slug":"noip2000-cheng-ji-zui-da","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n89009hofdk872x6hof"},{"title":"「NOI2015」程序自动分析 - 离散化 + 并查集","id":"34","updated":"2016-01-21T13:36:13.000Z","date":"2016-01-21T13:32:49.000Z","_content":"\n给定 `n` 个形如$x_i=x_j$或$x_i≠x_j$的变量相等 / 不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 4600](http://codevs.cn/problem/4600/)  \n[BZOJ 4195](http://www.lydsy.com/JudgeOnline/problem.php?id=4195)\n\n### 解题思路\n首先，`x` 的值很大，我们要把它离散化掉。\n\n然后用一个并查集，要离线做，先把相等的都并掉，然后枚举所有不相等的，如果某一对被并了说明不成立。\n\n一定不要用 `std::map`！！！可以自己写哈希表或者用 `std::tr1::unordered_map`。\n\n### AC代码\n#### 手写哈希表\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <new>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar preAlloc[SIZE * sizeof(T)];\n\tT *curr;\n\tT *recycle[SIZE];\n\tint i;\n\n\tvoid init() {\n\t\tcurr = (T *)preAlloc;\n\t\ti = -1;\n\t}\n\n\tT *alloc() {\n\t\tif (curr != (T *)preAlloc + SIZE) return curr++;\n\t\telse return recycle[i++];\n\t}\n\n\tvoid free(T *p) {\n\t\trecycle[++i] = p;\n\t}\n};\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstruct Node {\n\t\tint key;\n\t\tT value;\n\t\tNode *next;\n\n\t\tNode(int key, const T &value, Node *next) : key(key), value(value), next(next) {}\n\t} *list[HASH_SIZE];\n\tMemoryPool<Node, SIZE> pool;\n\n\tvoid init() {\n\t\tpool.init();\n\t\tmemset(list, 0, sizeof(list));\n\t}\n\n\tint hash(int x) {\n\t\treturn (unsigned int)((x << 16) | (x >> 16)) % HASH_SIZE;\n\t}\n\n\tT &operator[](int key) {\n\t\tint i = hash(key);\n\t\tfor (Node *v = list[i]; v; v = v->next) {\n\t\t\tif (v->key == key) return v->value;\n\t\t}\n\t\tlist[i] = new(pool.alloc()) Node(key, DEFAULT, list[i]);\n\t\treturn list[i]->value;\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n\n#### STL\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <tr1/unordered_map>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstd::tr1::unordered_map<int, T> map;\n\n\tvoid init() {\n\t\tmap.clear();\n\t}\n\n\tT &operator[](int key) {\n\t\tif (map.count(key) == 0) map[key] = -1;\n\t\treturn map[key];\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n\n### 吐槽\n写这道题时共出了一下几条沙茶错误：\n\n1. 忘记离线；\n2. 并查集初始化太小；\n3. 内存池类模板参数填错；\n4. 多组数据忘记初始化；\n5. 用了很奇怪的哈希方法，TLE。\n","source":"_posts/noi2015-prog.md","raw":"title: 「NOI2015」程序自动分析 - 离散化 + 并查集\ncategories: OI\ntags: \n  - NOI\n  - 离散化\n  - 并查集\n  - 哈希\n  - map\npermalink: noi2015-prog\nid: 34\nupdated: '2016-01-21 21:36:13'\ndate: 2016-01-21 21:32:49\n---\n\n给定 `n` 个形如$x_i=x_j$或$x_i≠x_j$的变量相等 / 不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 4600](http://codevs.cn/problem/4600/)  \n[BZOJ 4195](http://www.lydsy.com/JudgeOnline/problem.php?id=4195)\n\n### 解题思路\n首先，`x` 的值很大，我们要把它离散化掉。\n\n然后用一个并查集，要离线做，先把相等的都并掉，然后枚举所有不相等的，如果某一对被并了说明不成立。\n\n一定不要用 `std::map`！！！可以自己写哈希表或者用 `std::tr1::unordered_map`。\n\n### AC代码\n#### 手写哈希表\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <new>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar preAlloc[SIZE * sizeof(T)];\n\tT *curr;\n\tT *recycle[SIZE];\n\tint i;\n\n\tvoid init() {\n\t\tcurr = (T *)preAlloc;\n\t\ti = -1;\n\t}\n\n\tT *alloc() {\n\t\tif (curr != (T *)preAlloc + SIZE) return curr++;\n\t\telse return recycle[i++];\n\t}\n\n\tvoid free(T *p) {\n\t\trecycle[++i] = p;\n\t}\n};\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstruct Node {\n\t\tint key;\n\t\tT value;\n\t\tNode *next;\n\n\t\tNode(int key, const T &value, Node *next) : key(key), value(value), next(next) {}\n\t} *list[HASH_SIZE];\n\tMemoryPool<Node, SIZE> pool;\n\n\tvoid init() {\n\t\tpool.init();\n\t\tmemset(list, 0, sizeof(list));\n\t}\n\n\tint hash(int x) {\n\t\treturn (unsigned int)((x << 16) | (x >> 16)) % HASH_SIZE;\n\t}\n\n\tT &operator[](int key) {\n\t\tint i = hash(key);\n\t\tfor (Node *v = list[i]; v; v = v->next) {\n\t\t\tif (v->key == key) return v->value;\n\t\t}\n\t\tlist[i] = new(pool.alloc()) Node(key, DEFAULT, list[i]);\n\t\treturn list[i]->value;\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n\n#### STL\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <tr1/unordered_map>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstd::tr1::unordered_map<int, T> map;\n\n\tvoid init() {\n\t\tmap.clear();\n\t}\n\n\tT &operator[](int key) {\n\t\tif (map.count(key) == 0) map[key] = -1;\n\t\treturn map[key];\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n\n### 吐槽\n写这道题时共出了一下几条沙茶错误：\n\n1. 忘记离线；\n2. 并查集初始化太小；\n3. 内存池类模板参数填错；\n4. 多组数据忘记初始化；\n5. 用了很奇怪的哈希方法，TLE。\n","slug":"noi2015-prog","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n8d009nofdkbxfcca59"},{"title":"「NOI2015」软件包管理器 - 树链剖分","id":"35","updated":"2016-01-29T00:22:32.000Z","date":"2016-01-23T02:10:12.000Z","_content":"\n你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包 A 依赖软件包 B，那么安装软件包 A 以前，必须先安装软件包 B。同时，如果想要卸载软件包 B，则必须卸载软件包A。现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除 0 号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而 0 号软件包不依赖任何一个软件包。依赖关系不存在环，当然也不会有一个软件包依赖自己。用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 4621](http://codevs.cn/problem/4621/)  \n[BZOJ 4196](http://www.lydsy.com/JudgeOnline/problem.php?id=4196)\n\n### 解题思路\n首先，两种操作抽象为树上询问与修改：\n\n1. 询问某节点到根的一条链上有多少个节点打了标记；\n2. 将某节点到根的一条链上所有节点打上标记；\n3. 询问某节点的整棵子树上有多少个节点打了标记；\n4. 将某节点的整棵子树上所有节点打上标记。\n\n对于前两种，普通的树链剖分就可以了，但是对于后两种，我们还需要维护一个 DFS 序。DFS 序和轻重路径划分的维护看起来是有冲突的，实际上只要按照 DFS 的方式连接路径，并且在 DFS 时先遍历重链连接的子树，同时记录 DFS 序，这样得到的 DFS 序中，同一条路径是连续的，同一棵子树也是连续的。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\n\nstruct Tree;\nstruct SegmentTree;\nstruct Path;\n\nstruct SegmentTree {\n\tenum LazyTag {\n\t\tCover = 1,\n\t\tNull = 0,\n\t\tUncover = -1\n\t};\n\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tLazyTag lazy;\n\t\tbool covered;\n\t\tint count;\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy != Null) {\n\t\t\t\tif (lazy == Cover) {\n\t\t\t\t\tif (lchild) lchild->cover(true);\n\t\t\t\t\tif (rchild) rchild->cover(true);\n\t\t\t\t} else {\n\t\t\t\t\tif (lchild) lchild->cover(false);\n\t\t\t\t\tif (rchild) rchild->cover(false);\n\t\t\t\t}\n\n\t\t\t\tlazy = Null;\n\t\t\t}\n\t\t}\n\n\t\tvoid cover(bool flag) {\n\t\t\tif (flag) count = r - l + 1, covered = true, lazy = Cover;\n\t\t\telse count = 0, covered = false, lazy = Uncover;\n\t\t}\n\n\t\tvoid cover(int l, int r, bool flag) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) cover(flag);\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tcount = 0;\n\t\t\t\tif (lchild) lchild->cover(l, r, flag), count += lchild->count;\n\t\t\t\tif (rchild) rchild->cover(l, r, flag), count += rchild->count;\n\t\t\t}\n\t\t}\n\n\t\tint query(int l, int r) {\n\t\t\tif (l > this->r || r < this->l) return 0;\n\t\t\telse if (l <= this->l && r >= this->r) return count;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\treturn (lchild ? lchild->query(l, r) : 0) + (rchild ? rchild->query(l, r) : 0);\n\t\t\t}\n\t\t}\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), covered(false), count(0), lazy(Null) {}\n\t} *root;\n\n\tstatic Node *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tint query(int l, int r) {\n\t\treturn root->query(l, r);\n\t}\n\n\tvoid cover(int l, int r, bool flag) {\n\t\troot->cover(l, r, flag);\n\t}\n};\n\nstruct Path {\n\tTree *top;\n\n\tPath(Tree *top) : top(top) {}\n};\n\nstruct Tree {\n\tPath *path;\n\tTree *parent, *children, *next;\n\n\tTree *maxSizeChild;\n\tint size, pos, posEnd;\n\tbool visited;\n\n\tTree() : children(NULL) {}\n\tTree(Tree *parent) : parent(parent), next(parent->children), path(NULL), maxSizeChild(NULL), size(1) {}\n} trees[MAXN + 1];\n\nint n, q;\nTree *dfsOrder[MAXN + 1];\nSegmentTree *segment;\n\ninline void addEdge(int parent, int child) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent]);\n}\n\ninline void cutTree(Tree *root) {\n\tstd::stack<Tree *> s;\n\ts.push(root);\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\ts.push(c);\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) {\n\t\t\t\t\tt->maxSizeChild = c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\tint i = 0;\n\ts.push(root);\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tdfsOrder[t->pos = i++] = t;\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\n\t\t\tif (t == root || t != t->parent->maxSizeChild) {\n\t\t\t\tt->path = new Path(t);\n\t\t\t} else {\n\t\t\t\tt->path = t->parent->path;\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tt->posEnd = i - 1;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = new SegmentTree(0, n - 1);\n}\n\nint install(Tree *t) {\n\tint ans = 0;\n\twhile (t) {\n\t\tans += (t->pos - t->path->top->pos + 1) - segment->query(t->path->top->pos, t->pos);\n\t\tsegment->cover(t->path->top->pos, t->pos, true);\n\t\tt = t->path->top->parent;\n\t}\n\n\treturn ans;\n}\n\nint uninstall(Tree *t) {\n\tint ans = segment->query(t->pos, t->posEnd);\n\tsegment->cover(t->pos, t->posEnd, false);\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d\", &p);\n\n\t\taddEdge(p, i);\n\t}\n\n\tcutTree(&trees[0]);\n\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tchar command[9 + 1];\n\t\tint u;\n\t\tscanf(\"%s %d\", command, &u);\n\n\t\tif (command[0] == 'i') {\n\t\t\tprintf(\"%d\\n\", install(&trees[u]));\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", uninstall(&trees[u]));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noi2015-manager.md","raw":"title: 「NOI2015」软件包管理器 - 树链剖分\ncategories: OI\ntags: \n  - NOI\n  - CodeVS\n  - BZOJ\n  - 树链剖分\n  - 数据结构\n  - 高级数据结构\npermalink: noi2015-manager\nid: 35\nupdated: '2016-01-29 08:22:32'\ndate: 2016-01-23 10:10:12\n---\n\n你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包 A 依赖软件包 B，那么安装软件包 A 以前，必须先安装软件包 B。同时，如果想要卸载软件包 B，则必须卸载软件包A。现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除 0 号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而 0 号软件包不依赖任何一个软件包。依赖关系不存在环，当然也不会有一个软件包依赖自己。用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 4621](http://codevs.cn/problem/4621/)  \n[BZOJ 4196](http://www.lydsy.com/JudgeOnline/problem.php?id=4196)\n\n### 解题思路\n首先，两种操作抽象为树上询问与修改：\n\n1. 询问某节点到根的一条链上有多少个节点打了标记；\n2. 将某节点到根的一条链上所有节点打上标记；\n3. 询问某节点的整棵子树上有多少个节点打了标记；\n4. 将某节点的整棵子树上所有节点打上标记。\n\n对于前两种，普通的树链剖分就可以了，但是对于后两种，我们还需要维护一个 DFS 序。DFS 序和轻重路径划分的维护看起来是有冲突的，实际上只要按照 DFS 的方式连接路径，并且在 DFS 时先遍历重链连接的子树，同时记录 DFS 序，这样得到的 DFS 序中，同一条路径是连续的，同一棵子树也是连续的。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\n\nstruct Tree;\nstruct SegmentTree;\nstruct Path;\n\nstruct SegmentTree {\n\tenum LazyTag {\n\t\tCover = 1,\n\t\tNull = 0,\n\t\tUncover = -1\n\t};\n\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tLazyTag lazy;\n\t\tbool covered;\n\t\tint count;\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy != Null) {\n\t\t\t\tif (lazy == Cover) {\n\t\t\t\t\tif (lchild) lchild->cover(true);\n\t\t\t\t\tif (rchild) rchild->cover(true);\n\t\t\t\t} else {\n\t\t\t\t\tif (lchild) lchild->cover(false);\n\t\t\t\t\tif (rchild) rchild->cover(false);\n\t\t\t\t}\n\n\t\t\t\tlazy = Null;\n\t\t\t}\n\t\t}\n\n\t\tvoid cover(bool flag) {\n\t\t\tif (flag) count = r - l + 1, covered = true, lazy = Cover;\n\t\t\telse count = 0, covered = false, lazy = Uncover;\n\t\t}\n\n\t\tvoid cover(int l, int r, bool flag) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) cover(flag);\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tcount = 0;\n\t\t\t\tif (lchild) lchild->cover(l, r, flag), count += lchild->count;\n\t\t\t\tif (rchild) rchild->cover(l, r, flag), count += rchild->count;\n\t\t\t}\n\t\t}\n\n\t\tint query(int l, int r) {\n\t\t\tif (l > this->r || r < this->l) return 0;\n\t\t\telse if (l <= this->l && r >= this->r) return count;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\treturn (lchild ? lchild->query(l, r) : 0) + (rchild ? rchild->query(l, r) : 0);\n\t\t\t}\n\t\t}\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), covered(false), count(0), lazy(Null) {}\n\t} *root;\n\n\tstatic Node *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tint query(int l, int r) {\n\t\treturn root->query(l, r);\n\t}\n\n\tvoid cover(int l, int r, bool flag) {\n\t\troot->cover(l, r, flag);\n\t}\n};\n\nstruct Path {\n\tTree *top;\n\n\tPath(Tree *top) : top(top) {}\n};\n\nstruct Tree {\n\tPath *path;\n\tTree *parent, *children, *next;\n\n\tTree *maxSizeChild;\n\tint size, pos, posEnd;\n\tbool visited;\n\n\tTree() : children(NULL) {}\n\tTree(Tree *parent) : parent(parent), next(parent->children), path(NULL), maxSizeChild(NULL), size(1) {}\n} trees[MAXN + 1];\n\nint n, q;\nTree *dfsOrder[MAXN + 1];\nSegmentTree *segment;\n\ninline void addEdge(int parent, int child) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent]);\n}\n\ninline void cutTree(Tree *root) {\n\tstd::stack<Tree *> s;\n\ts.push(root);\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\ts.push(c);\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) {\n\t\t\t\t\tt->maxSizeChild = c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\tint i = 0;\n\ts.push(root);\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tdfsOrder[t->pos = i++] = t;\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\n\t\t\tif (t == root || t != t->parent->maxSizeChild) {\n\t\t\t\tt->path = new Path(t);\n\t\t\t} else {\n\t\t\t\tt->path = t->parent->path;\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tt->posEnd = i - 1;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = new SegmentTree(0, n - 1);\n}\n\nint install(Tree *t) {\n\tint ans = 0;\n\twhile (t) {\n\t\tans += (t->pos - t->path->top->pos + 1) - segment->query(t->path->top->pos, t->pos);\n\t\tsegment->cover(t->path->top->pos, t->pos, true);\n\t\tt = t->path->top->parent;\n\t}\n\n\treturn ans;\n}\n\nint uninstall(Tree *t) {\n\tint ans = segment->query(t->pos, t->posEnd);\n\tsegment->cover(t->pos, t->posEnd, false);\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d\", &p);\n\n\t\taddEdge(p, i);\n\t}\n\n\tcutTree(&trees[0]);\n\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tchar command[9 + 1];\n\t\tint u;\n\t\tscanf(\"%s %d\", command, &u);\n\n\t\tif (command[0] == 'i') {\n\t\t\tprintf(\"%d\\n\", install(&trees[u]));\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", uninstall(&trees[u]));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"noi2015-manager","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n8j009zofdk20ri6pxq"},{"title":"「NOI2006」最大获利 - 最大权闭合子图","date":"2016-03-10T11:33:42.000Z","_content":"\n在前期市场调查和站址勘测之后，公司得到了一共 $ N $ 个可以作为通讯信号中转站的地址，建立第 $ i $ 个通讯中转站需要的成本为 $ Pi $（$ 1 ≤ i ≤ N $）。另外公司调查得出了所有期望中的用户群，一共 $ M $ 个。关于第 $ i $ 个用户群的信息概括为 $ Ai $, $ Bi $ 和 $ Ci $：这些用户会使用中转站 $ Ai $ 和中转站 $ Bi $ 进行通讯，公司可以获益 $ Ci $。（$ 1 ≤ i ≤ M $，$ 1 ≤ Ai $，$ Bi ≤ N $）公司可以有选择的建立一些中转站（投入成本），为一些用户提供服务并获得收益（获益之和）。那么如何选择最终建立的中转站才能让公司的净获利最大呢？\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1789](http://codevs.cn/problem/1789/)  \n[BZOJ 1497](http://www.lydsy.com/JudgeOnline/problem.php?id=1497)\n\n### 解题思路\n裸的最大权闭合子图，用最小割。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 5000;\nconst int MAXM = 50000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->flow < e->capacity) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->flow < e->capacity) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, a[MAXN];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint sum = 0;\n\tfor (int i = n + 1; i <= n + m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\n\t\tsum += c;\n\t\taddEdge(s, i, c);\n\n\t\taddEdge(i, a, INT_MAX);\n\t\taddEdge(i, b, INT_MAX);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2006-profit.md","raw":"title: 「NOI2006」最大获利 - 最大权闭合子图\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - CodeVS\n  - 图论\n  - 网络流\n  - 最小割\n  - 最大权闭合子图\n  - Dinic\npermalink: noi2006-profit\ndate: 2016-03-10 19:33:42\n---\n\n在前期市场调查和站址勘测之后，公司得到了一共 $ N $ 个可以作为通讯信号中转站的地址，建立第 $ i $ 个通讯中转站需要的成本为 $ Pi $（$ 1 ≤ i ≤ N $）。另外公司调查得出了所有期望中的用户群，一共 $ M $ 个。关于第 $ i $ 个用户群的信息概括为 $ Ai $, $ Bi $ 和 $ Ci $：这些用户会使用中转站 $ Ai $ 和中转站 $ Bi $ 进行通讯，公司可以获益 $ Ci $。（$ 1 ≤ i ≤ M $，$ 1 ≤ Ai $，$ Bi ≤ N $）公司可以有选择的建立一些中转站（投入成本），为一些用户提供服务并获得收益（获益之和）。那么如何选择最终建立的中转站才能让公司的净获利最大呢？\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1789](http://codevs.cn/problem/1789/)  \n[BZOJ 1497](http://www.lydsy.com/JudgeOnline/problem.php?id=1497)\n\n### 解题思路\n裸的最大权闭合子图，用最小割。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 5000;\nconst int MAXM = 50000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->flow < e->capacity) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->flow < e->capacity) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, a[MAXN];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint sum = 0;\n\tfor (int i = n + 1; i <= n + m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\n\t\tsum += c;\n\t\taddEdge(s, i, c);\n\n\t\taddEdge(i, a, INT_MAX);\n\t\taddEdge(i, b, INT_MAX);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"noi2006-profit","published":1,"updated":"2016-03-15T01:05:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n8o00a7ofdkhbtjoso3"},{"title":"「NOI2004」郁闷的出纳员 - Splay","id":"37","updated":"2016-01-24T15:11:06.000Z","date":"2016-01-24T15:09:03.000Z","_content":"\n工资的频繁调整很让员工反感，尤其是集体扣除工资的时候，一旦某位员工发现自己的工资已经低于了合同规定的工资下界，他就会立刻气愤地离开公司，并且再也不会回来了。每位员工的工资下界都是统一规定的。每当一个人离开公司，我就要从电脑中把他的工资档案删去，同样，每当公司招聘了一位新员工，我就得为他新建一个工资档案。老板经常到我这边来询问工资情况，现在工资第 `k` 多的员工拿多少工资。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 1503](http://www.lydsy.com/JudgeOnline/problem.php?id=1503)  \n[CodeVS 1286](http://codevs.cn/problem/1286/)\n\n### 解题思路\n这是道 Splay 入门题，多思考思考还是挺容易的。\n\n唯一的难点貌似在同时修改工资，这时候只要像维护数列那样弄一个标记，然后向下传就好咯。扣工资时直接删掉 $[-{\\infty}+1,min-1]$ 范围内的节点就好。\n\n还有统计离开公司人数，一开始还在想删除时用了辅助节点，不知道该怎么算，一想才知道，直接看整棵树的大小变了多少嘛！\n\n第四次敲 Splay，在从临沂经西安到成都的飞机上用了一个小时。\n\n### AC 代码\n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 200100;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, lazy;\n\t\tint size, count;\n\n\t\tNode(Node *parent, Node **root, const T &value) : parent(parent), root(root), value(value), size(1), count(1), lazy(0) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->update(lazy);\n\t\t\t\tif (child[R]) child[R]->update(lazy);\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\t\t\tsize = count;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\t\t}\n\n\t\tvoid update(const T &value) {\n\t\t\tif (this->value != INF && this->value != -INF) this->value += value;\n\t\t\tthis->lazy += value;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tpushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tparent->pushDown(), pushDown();\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tv->pushDown();\n\t\t\tif (value < v->value) v = v->child[L];\n\t\t\telse v = v->child[R];\n\t\t}\n\n\t\tif (v) v->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->size++;\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->pushDown();\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) target = &parent->child[L];\n\t\t\telse target = &parent->child[R];\n\t\t}\n\n\t\t*target = new Node(parent, &root, value);\n\t\t(*target)->splay();\n\t\treturn root;\n\t}\n\n\tconst T &select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (v->pushDown(), !(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + v->count, v = v->child[R];\n\t\t}\n\t\tv->splay();\n\t\treturn v->value;\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count > 1) v->count--;\n\t\telse erase(v, v);\n\t}\n\n\tvoid erase(Node *l, Node *r) {\n\t\tNode *pred = l->pred();\n\t\tNode *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\tNode *vl = find(l), *vr = find(r);\n\t\tif (!vl) vl = insert(l);\n\t\tif (!vr) vr = insert(r);\n\t\terase(vl, vr);\n\t}\n\n\tvoid update(const T &value) {\n\t\troot->update(value);\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint result = v->rank();\n\t\t\terase(v);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint n, min, deletedCount;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth = 0) {\n\tif (!v) return;\n\tv->pushDown();\n\tdfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d\\n\", v->value);\n\tdfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\ninline void print() {\n\tdfs(splay.root);\n\tputs(\"----------------------\");\n}\n\ninline bool isValid(char c) {\n\treturn c == 'I' || c == 'A' || c == 'S' || c == 'F';\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &min);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tchar c;\n\t\tint k;\n\t\twhile (!isValid(c = getchar()));\n\t\tscanf(\"%d\", &k);\n\t\t//printf(\"{ command: '%c', k: '%d' }\\n\", c, k);\n\t\tif (c == 'I') {\n\t\t\tif (k >= min) splay.insert(k);\n\t\t} else if (c == 'A') {\n\t\t\tsplay.update(k);\n\t\t} else if (c == 'S') {\n\t\t\tsplay.update(-k);\n\t\t\tint oldSize = splay.size();\n\t\t\tsplay.erase(-INT_MAX + 1, min - 1);\n\t\t\tdeletedCount += oldSize - Splay.size();\n\t\t} else if (c == 'F') {\n\t\t\tif (k < 1 || k > splay.size()) puts(\"-1\");\n\t\t\telse printf(\"%d\\n\", splay.select(splay.size() - k + 1));\n\t\t}\n\n\t\t//print();\n\t}\n\n\tprintf(\"%d\\n\", deletedCount);\n\n\treturn 0;\n}\n```","source":"_posts/noi2004-cashier.md","raw":"title: 「NOI2004」郁闷的出纳员 - Splay\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - CodeVS\n  - Splay\n  - 高级数据结构\n  - 数据结构\npermalink: noi2004-cashier\nid: 37\nupdated: '2016-01-24 23:11:06'\ndate: 2016-01-24 23:09:03\n---\n\n工资的频繁调整很让员工反感，尤其是集体扣除工资的时候，一旦某位员工发现自己的工资已经低于了合同规定的工资下界，他就会立刻气愤地离开公司，并且再也不会回来了。每位员工的工资下界都是统一规定的。每当一个人离开公司，我就要从电脑中把他的工资档案删去，同样，每当公司招聘了一位新员工，我就得为他新建一个工资档案。老板经常到我这边来询问工资情况，现在工资第 `k` 多的员工拿多少工资。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 1503](http://www.lydsy.com/JudgeOnline/problem.php?id=1503)  \n[CodeVS 1286](http://codevs.cn/problem/1286/)\n\n### 解题思路\n这是道 Splay 入门题，多思考思考还是挺容易的。\n\n唯一的难点貌似在同时修改工资，这时候只要像维护数列那样弄一个标记，然后向下传就好咯。扣工资时直接删掉 $[-{\\infty}+1,min-1]$ 范围内的节点就好。\n\n还有统计离开公司人数，一开始还在想删除时用了辅助节点，不知道该怎么算，一想才知道，直接看整棵树的大小变了多少嘛！\n\n第四次敲 Splay，在从临沂经西安到成都的飞机上用了一个小时。\n\n### AC 代码\n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 200100;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, lazy;\n\t\tint size, count;\n\n\t\tNode(Node *parent, Node **root, const T &value) : parent(parent), root(root), value(value), size(1), count(1), lazy(0) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->update(lazy);\n\t\t\t\tif (child[R]) child[R]->update(lazy);\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\t\t\tsize = count;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\t\t}\n\n\t\tvoid update(const T &value) {\n\t\t\tif (this->value != INF && this->value != -INF) this->value += value;\n\t\t\tthis->lazy += value;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tpushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tparent->pushDown(), pushDown();\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tv->pushDown();\n\t\t\tif (value < v->value) v = v->child[L];\n\t\t\telse v = v->child[R];\n\t\t}\n\n\t\tif (v) v->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->size++;\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->pushDown();\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) target = &parent->child[L];\n\t\t\telse target = &parent->child[R];\n\t\t}\n\n\t\t*target = new Node(parent, &root, value);\n\t\t(*target)->splay();\n\t\treturn root;\n\t}\n\n\tconst T &select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (v->pushDown(), !(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + v->count, v = v->child[R];\n\t\t}\n\t\tv->splay();\n\t\treturn v->value;\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count > 1) v->count--;\n\t\telse erase(v, v);\n\t}\n\n\tvoid erase(Node *l, Node *r) {\n\t\tNode *pred = l->pred();\n\t\tNode *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\tNode *vl = find(l), *vr = find(r);\n\t\tif (!vl) vl = insert(l);\n\t\tif (!vr) vr = insert(r);\n\t\terase(vl, vr);\n\t}\n\n\tvoid update(const T &value) {\n\t\troot->update(value);\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint result = v->rank();\n\t\t\terase(v);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint n, min, deletedCount;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth = 0) {\n\tif (!v) return;\n\tv->pushDown();\n\tdfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d\\n\", v->value);\n\tdfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\ninline void print() {\n\tdfs(splay.root);\n\tputs(\"----------------------\");\n}\n\ninline bool isValid(char c) {\n\treturn c == 'I' || c == 'A' || c == 'S' || c == 'F';\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &min);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tchar c;\n\t\tint k;\n\t\twhile (!isValid(c = getchar()));\n\t\tscanf(\"%d\", &k);\n\t\t//printf(\"{ command: '%c', k: '%d' }\\n\", c, k);\n\t\tif (c == 'I') {\n\t\t\tif (k >= min) splay.insert(k);\n\t\t} else if (c == 'A') {\n\t\t\tsplay.update(k);\n\t\t} else if (c == 'S') {\n\t\t\tsplay.update(-k);\n\t\t\tint oldSize = splay.size();\n\t\t\tsplay.erase(-INT_MAX + 1, min - 1);\n\t\t\tdeletedCount += oldSize - Splay.size();\n\t\t} else if (c == 'F') {\n\t\t\tif (k < 1 || k > splay.size()) puts(\"-1\");\n\t\t\telse printf(\"%d\\n\", splay.select(splay.size() - k + 1));\n\t\t}\n\n\t\t//print();\n\t}\n\n\tprintf(\"%d\\n\", deletedCount);\n\n\treturn 0;\n}\n```","slug":"noi2004-cashier","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n8t00ajofdkqu23xlbn"},{"title":"「NOI2003」文本编辑器 - Splay","date":"2016-03-06T11:49:35.000Z","_content":"\n|        操作名称        | 输入文件中的格式 | 功能 |\n|:----------------------:|:----------------:| ---- |\n| $ {\\rm MOVE}(k) $      | `Move k`         | 将光标移动到第 $ k $ 个字符之后，如果 $ k=0 $，将光标移到文本第一个字符之前 |\n| $ {\\rm INSERT}(n, s) $ | `Insert n S`     | 在光标后插入长度为 $ n $ 的字符串 $ s $，光标位置不变，$ n ≥ 1 $ |\n| $ {\\rm DELETE}(n) $    | `Delete n`       | 删除光标后的 $ n $ 个字符，光标位置不变，$ n ≥ 1 $ |\n| $ {\\rm GET}(n) $       | `Get n`          | 输出光标后的 $ n $ 个字符，光标位置不变，$ n ≥ 1 $ |\n| $ {\\rm PREV}() $       | `Prev`           | 光标前移一个字符\n| $ {\\rm NEXT}() $       | `Next`           | 光标后移一个字符\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 1507](http://www.lydsy.com/JudgeOnline/problem.php?id=1507)\n\n### 解题思路\n块状链表太鬼畜辣！还是 Splay 比较好写好调w\n\n一点小技巧，插入的时候可以照着选择区间的方法选出一段空白区间，然后 `build` 出一棵子树给接上去，可以少一个 $ \\log $。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nconst int MAXM = 50000 + 4000 + 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), size(1), bound(bound) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\t//if (child[L]) child[L]->maintain();\n\t\t\t//if (child[R]) child[R]->maintain();\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent){\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\n\t\t*v = new Node(parent, 0, &root, true);\n\t}\n\n\tNode *build(const T *a, int l, int r, Node *parent = NULL) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tv->child[L] = build(a, l, mid - 1, v);\n\t\tv->child[R] = build(a, mid + 1, r, v);\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\t//printf(\"select(%d) in size = %d\\n\", k, root->size);\n\t\tNode *v = root;\n\t\twhile (v->maintain(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *&select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid insert(const T *a, int n, int pos) {\n\t\tNode *&v = select(pos + 1, pos);\n\t\tv = build(a, 1, n, root->child[R]);\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid erase(int l, int r) {\n\t\tNode *&v = select(l, r);\n\t\tdelete v;\n\t\tv = NULL;\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid fetch(T *a, int l, int r) {\n\t\tint i = 0;\n\t\tdfs(select(l, r), a, i);\n\t}\n\n\tvoid dfs(Node *v, T *a, int &i) {\n\t\tif (!v) return;\n\t\tdfs(v->child[L], a, i);\n\t\ta[i++] = v->value;\n\t\tdfs(v->child[R], a, i);\n\t}\n};\n\nint t, pos;\nSplay<char> splay;\n\ninline bool isValid(char ch) {\n\treturn ch >= 32 && ch <= 126;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\tstatic std::vector<char> buffers;\n\tfor (int i = 0; i < t; i++) {\n\t\tchar command[sizeof(\"Insert\")];\n\t\tscanf(\"%s\", command);\n\n\t\tif (command[0] == 'M') {\n\t\t\tscanf(\"%d\", &pos);\n\t\t} else if (command[0] == 'I') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.reserve(n);\n\n\t\t\tchar ch;\n\t\t\tfor (int i = 0; i < n; ) {\n\t\t\t\tif (isValid(ch = getchar())) {\n\t\t\t\t\tbuffers.push_back(ch);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsplay.insert(buffers.data(), n, pos);\n\t\t} else if (command[0] == 'D') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\t\t\tsplay.erase(pos + 1, pos + n);\n\t\t} else if (command[0] == 'G') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.resize(n + 1);\n\n\t\t\tsplay.fetch(const_cast<char *>(buffers.data()), pos + 1, pos + n);\n\t\t\tbuffers[n] = '\\0';\n\n\t\t\tprintf(\"%s\\n\", buffers.data());\n\t\t} else if (command[0] == 'P') pos--;\n\t\telse if (command[0] == 'N') pos++;\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2003-editor.md","raw":"title: 「NOI2003」文本编辑器 - Splay\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - Splay\n  - 高级数据结构\n  - 数据结构\npermalink: noi2003-editor\ndate: 2016-03-06 19:49:35\n---\n\n|        操作名称        | 输入文件中的格式 | 功能 |\n|:----------------------:|:----------------:| ---- |\n| $ {\\rm MOVE}(k) $      | `Move k`         | 将光标移动到第 $ k $ 个字符之后，如果 $ k=0 $，将光标移到文本第一个字符之前 |\n| $ {\\rm INSERT}(n, s) $ | `Insert n S`     | 在光标后插入长度为 $ n $ 的字符串 $ s $，光标位置不变，$ n ≥ 1 $ |\n| $ {\\rm DELETE}(n) $    | `Delete n`       | 删除光标后的 $ n $ 个字符，光标位置不变，$ n ≥ 1 $ |\n| $ {\\rm GET}(n) $       | `Get n`          | 输出光标后的 $ n $ 个字符，光标位置不变，$ n ≥ 1 $ |\n| $ {\\rm PREV}() $       | `Prev`           | 光标前移一个字符\n| $ {\\rm NEXT}() $       | `Next`           | 光标后移一个字符\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 1507](http://www.lydsy.com/JudgeOnline/problem.php?id=1507)\n\n### 解题思路\n块状链表太鬼畜辣！还是 Splay 比较好写好调w\n\n一点小技巧，插入的时候可以照着选择区间的方法选出一段空白区间，然后 `build` 出一棵子树给接上去，可以少一个 $ \\log $。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nconst int MAXM = 50000 + 4000 + 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), size(1), bound(bound) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\t//if (child[L]) child[L]->maintain();\n\t\t\t//if (child[R]) child[R]->maintain();\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent){\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\n\t\t*v = new Node(parent, 0, &root, true);\n\t}\n\n\tNode *build(const T *a, int l, int r, Node *parent = NULL) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tv->child[L] = build(a, l, mid - 1, v);\n\t\tv->child[R] = build(a, mid + 1, r, v);\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\t//printf(\"select(%d) in size = %d\\n\", k, root->size);\n\t\tNode *v = root;\n\t\twhile (v->maintain(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *&select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid insert(const T *a, int n, int pos) {\n\t\tNode *&v = select(pos + 1, pos);\n\t\tv = build(a, 1, n, root->child[R]);\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid erase(int l, int r) {\n\t\tNode *&v = select(l, r);\n\t\tdelete v;\n\t\tv = NULL;\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid fetch(T *a, int l, int r) {\n\t\tint i = 0;\n\t\tdfs(select(l, r), a, i);\n\t}\n\n\tvoid dfs(Node *v, T *a, int &i) {\n\t\tif (!v) return;\n\t\tdfs(v->child[L], a, i);\n\t\ta[i++] = v->value;\n\t\tdfs(v->child[R], a, i);\n\t}\n};\n\nint t, pos;\nSplay<char> splay;\n\ninline bool isValid(char ch) {\n\treturn ch >= 32 && ch <= 126;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\tstatic std::vector<char> buffers;\n\tfor (int i = 0; i < t; i++) {\n\t\tchar command[sizeof(\"Insert\")];\n\t\tscanf(\"%s\", command);\n\n\t\tif (command[0] == 'M') {\n\t\t\tscanf(\"%d\", &pos);\n\t\t} else if (command[0] == 'I') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.reserve(n);\n\n\t\t\tchar ch;\n\t\t\tfor (int i = 0; i < n; ) {\n\t\t\t\tif (isValid(ch = getchar())) {\n\t\t\t\t\tbuffers.push_back(ch);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsplay.insert(buffers.data(), n, pos);\n\t\t} else if (command[0] == 'D') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\t\t\tsplay.erase(pos + 1, pos + n);\n\t\t} else if (command[0] == 'G') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.resize(n + 1);\n\n\t\t\tsplay.fetch(const_cast<char *>(buffers.data()), pos + 1, pos + n);\n\t\t\tbuffers[n] = '\\0';\n\n\t\t\tprintf(\"%s\\n\", buffers.data());\n\t\t} else if (command[0] == 'P') pos--;\n\t\telse if (command[0] == 'N') pos++;\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noi2003-editor","published":1,"updated":"2016-03-15T01:05:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n8z00arofdkxl8fylib"},{"title":"「NOI2002」银河英雄传说 - 并查集","id":"2","updated":"2016-01-19T13:08:24.000Z","date":"2015-11-22T17:14:53.000Z","_content":"\n有 30000 个元素，初始时每个元素以单独的队列形式存在，支持一下两种操作：\n\n1.动态合并两条队列，将 `x` 元素所在队列首合并在 `y` 元素所在队列尾；  \n2.查询 `x` 与 `y` 是否在同一条队列中，若是，查询 `x` 与 `y` 间隔元素数量。\n\n共 500,000 次操作。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1540](http://codevs.cn/problem/1540/)\n\n### 解题思路\n由「查询」操作，考虑到使用并查集。用并查集维护两个元素是否在同一队列中，可以对查询是否在同一队列中作出回答。  \n考虑将并查集扩展，维护每一个元素**所在队列**的队首和队尾。\n\n```cpp\nunsigned int find_head(unsigned int x) {\n\treturn head[x] == x ? x : find_head(head[x]);\n}\n\nunsigned int find_tail(unsigned int x) {\n\treturn tail[x] == x ? x : find_tail(tail[x]);\n}\n\nvoid merge(unsigned int x, unsigned int y) {\n\tunsigned int head_x = find_head(x);\n\tunsigned int tail_y = find_tail(y);\n\thead[head_x] = tail_y;\n\ttail[tail_y] = head_x;\n}\n```\n然后就是查询间隔数量，这里采用前缀和的方式。\n```cpp\nunsigned int sum(unsigned int x, unsigned int y) {\n\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n}\n```\n`pre(x)` 的计算方法，根据合并时对 `head` 数组进行的修改，可得 `find_head(x)` 的迭代次数即为 `x` 到 `x` 所在队队首的元素数量。\n```cpp\nunsigned int pre(unsigned int x) {\n\tregister unsigned int result = 0;\n\t\n\twhile (head[x] != x) {\n\t\tresult++;\n\t\tx = head[x];\n\t}\n\treturn result;\n}\n```\n使用这种方式维护并查集，不能对并查集使用路径压缩的优化，故整个算法时间复杂度为 $O(nm)$。  \n所以 …… Boom！  \n\n解决方法：在进行路径压缩的同时，维护每一个 `x` 到 `head[x]` 的「距离」 `prefix[x]`。  \n在 `find(x)` 或者 `pre(x)` 每一次迭代时，进行路径压缩，并把 `prefix[x]` 加上 `pre(head[x])`，即**队列中在 `x` 元素之前的元素的「前缀和」**。  \n\n注意：  \n 1.**当迭代到根节点下时，不能对 `prefix[x]` 做修改。**  \n 2.队首元素，即**满足 `head[x] == x` 的元素**的前缀和应总是0。  \n\n```cpp\nunsigned int find_head(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn x;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); // 处理 prefix[] 数组\n\t\t}\n\n\t\thead[x] = find_head(head[x]); // 路径压缩\n\t}\n\n\treturn head[x];\n}\n\nunsigned int pre(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn prefix[x] = 0;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); // 处理 prefix[] 数组\n\t\t}\n\t\thead[x] = find_head(head[x]); // 路径压缩\n\t}\n\n\treturn prefix[x];\n}\n```\n### AC 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 30000;\nconst unsigned int MAXM = 500000;\n\nunsigned int m;\n\nstruct unionfind {\n\tunsigned int head[MAXN], tail[MAXN], prefix[MAXN];\n\n\tvoid init(unsigned int n) {\n\t\tfor (unsigned int i = 0; i < n; i++) {\n\t\t\thead[i] = i;\n\t\t\ttail[i] = i;\n\t\t}\n\t}\n\n\tunsigned int find_head(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn x;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\n\t\treturn head[x];\n\t}\n\n\tunsigned int find_tail(unsigned int x) {\n\t\treturn tail[x] == x ? x : tail[x] = find_tail(tail[x]);\n\t}\n\n\tunsigned int pre(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn prefix[x] = 0;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\t\t\n\t\treturn prefix[x];\n\t}\n\n\tunsigned int sum(unsigned int x, unsigned int y) {\n\t\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n\t}\n\n\tvoid merge(unsigned int x, unsigned int y) {\n\t\tunsigned int head_x = find_head(x);\n\t\tunsigned int tail_y = find_tail(y);\n\t\thead[head_x] = tail_y;\n\t\ttail[tail_y] = head_x;\n\t\tprefix[head_x] = 1;\n\t}\n} uf;\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\ninline bool iscommand(char ch) {\n\treturn ch == 'C' || ch == 'M';\n}\n\nint main() {\n\tread(m);\n\n\tuf.init(MAXN);\n\tfor (unsigned int i = 0; i < m; i++) {\n\t\tregister char command;\n\t\tregister unsigned int x, y;\n\n\t\twhile (!iscommand(command = getchar()));\n\t\tread(x), read(y);\n\t\tx--, y--;\n\n\t\tif (command == 'M') {\n\t\t\tuf.merge(x, y);\n\t\t} else {\n\t\t\tif (uf.find_head(x) == uf.find_head(y)) {\n\t\t\t\tprintf(\"%u\\n\", uf.sum(x, y));\n\t\t\t} else {\n\t\t\t\tputs(\"-1\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n### 吐槽\n这是当年 NOI2002 的一道水（大雾）题。  \n刚开始学并查集的时候尝试做过这题，然后 …… 然后就没有然后了。  \n今天突然想起这题，就用了一个小时把它 A 掉了。","source":"_posts/noi2002-galaxy.md","raw":"title: 「NOI2002」银河英雄传说 - 并查集\ncategories: OI\ntags: \n  - CodeVS\n  - NOI\n  - 并查集\npermalink: noi2002-galaxy\nid: 2\nupdated: '2016-01-19 21:08:24'\ndate: 2015-11-23 01:14:53\n---\n\n有 30000 个元素，初始时每个元素以单独的队列形式存在，支持一下两种操作：\n\n1.动态合并两条队列，将 `x` 元素所在队列首合并在 `y` 元素所在队列尾；  \n2.查询 `x` 与 `y` 是否在同一条队列中，若是，查询 `x` 与 `y` 间隔元素数量。\n\n共 500,000 次操作。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1540](http://codevs.cn/problem/1540/)\n\n### 解题思路\n由「查询」操作，考虑到使用并查集。用并查集维护两个元素是否在同一队列中，可以对查询是否在同一队列中作出回答。  \n考虑将并查集扩展，维护每一个元素**所在队列**的队首和队尾。\n\n```cpp\nunsigned int find_head(unsigned int x) {\n\treturn head[x] == x ? x : find_head(head[x]);\n}\n\nunsigned int find_tail(unsigned int x) {\n\treturn tail[x] == x ? x : find_tail(tail[x]);\n}\n\nvoid merge(unsigned int x, unsigned int y) {\n\tunsigned int head_x = find_head(x);\n\tunsigned int tail_y = find_tail(y);\n\thead[head_x] = tail_y;\n\ttail[tail_y] = head_x;\n}\n```\n然后就是查询间隔数量，这里采用前缀和的方式。\n```cpp\nunsigned int sum(unsigned int x, unsigned int y) {\n\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n}\n```\n`pre(x)` 的计算方法，根据合并时对 `head` 数组进行的修改，可得 `find_head(x)` 的迭代次数即为 `x` 到 `x` 所在队队首的元素数量。\n```cpp\nunsigned int pre(unsigned int x) {\n\tregister unsigned int result = 0;\n\t\n\twhile (head[x] != x) {\n\t\tresult++;\n\t\tx = head[x];\n\t}\n\treturn result;\n}\n```\n使用这种方式维护并查集，不能对并查集使用路径压缩的优化，故整个算法时间复杂度为 $O(nm)$。  \n所以 …… Boom！  \n\n解决方法：在进行路径压缩的同时，维护每一个 `x` 到 `head[x]` 的「距离」 `prefix[x]`。  \n在 `find(x)` 或者 `pre(x)` 每一次迭代时，进行路径压缩，并把 `prefix[x]` 加上 `pre(head[x])`，即**队列中在 `x` 元素之前的元素的「前缀和」**。  \n\n注意：  \n 1.**当迭代到根节点下时，不能对 `prefix[x]` 做修改。**  \n 2.队首元素，即**满足 `head[x] == x` 的元素**的前缀和应总是0。  \n\n```cpp\nunsigned int find_head(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn x;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); // 处理 prefix[] 数组\n\t\t}\n\n\t\thead[x] = find_head(head[x]); // 路径压缩\n\t}\n\n\treturn head[x];\n}\n\nunsigned int pre(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn prefix[x] = 0;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); // 处理 prefix[] 数组\n\t\t}\n\t\thead[x] = find_head(head[x]); // 路径压缩\n\t}\n\n\treturn prefix[x];\n}\n```\n### AC 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 30000;\nconst unsigned int MAXM = 500000;\n\nunsigned int m;\n\nstruct unionfind {\n\tunsigned int head[MAXN], tail[MAXN], prefix[MAXN];\n\n\tvoid init(unsigned int n) {\n\t\tfor (unsigned int i = 0; i < n; i++) {\n\t\t\thead[i] = i;\n\t\t\ttail[i] = i;\n\t\t}\n\t}\n\n\tunsigned int find_head(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn x;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\n\t\treturn head[x];\n\t}\n\n\tunsigned int find_tail(unsigned int x) {\n\t\treturn tail[x] == x ? x : tail[x] = find_tail(tail[x]);\n\t}\n\n\tunsigned int pre(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn prefix[x] = 0;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\t\t\n\t\treturn prefix[x];\n\t}\n\n\tunsigned int sum(unsigned int x, unsigned int y) {\n\t\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n\t}\n\n\tvoid merge(unsigned int x, unsigned int y) {\n\t\tunsigned int head_x = find_head(x);\n\t\tunsigned int tail_y = find_tail(y);\n\t\thead[head_x] = tail_y;\n\t\ttail[tail_y] = head_x;\n\t\tprefix[head_x] = 1;\n\t}\n} uf;\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\ninline bool iscommand(char ch) {\n\treturn ch == 'C' || ch == 'M';\n}\n\nint main() {\n\tread(m);\n\n\tuf.init(MAXN);\n\tfor (unsigned int i = 0; i < m; i++) {\n\t\tregister char command;\n\t\tregister unsigned int x, y;\n\n\t\twhile (!iscommand(command = getchar()));\n\t\tread(x), read(y);\n\t\tx--, y--;\n\n\t\tif (command == 'M') {\n\t\t\tuf.merge(x, y);\n\t\t} else {\n\t\t\tif (uf.find_head(x) == uf.find_head(y)) {\n\t\t\t\tprintf(\"%u\\n\", uf.sum(x, y));\n\t\t\t} else {\n\t\t\t\tputs(\"-1\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n### 吐槽\n这是当年 NOI2002 的一道水（大雾）题。  \n刚开始学并查集的时候尝试做过这题，然后 …… 然后就没有然后了。  \n今天突然想起这题，就用了一个小时把它 A 掉了。","slug":"noi2002-galaxy","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n9300ayofdkdklijg72"},{"title":"单调队列学习笔记","date":"2016-01-14T21:44:45.000Z","_content":"\n单调队列，就是单调的队列，通常用来解决滑动窗口的最值问题，可以应用到 DP 的优化上。一个单调队列中的元素总是单调递增（或递减）的。\n\n<!-- more -->\n\n### 滑动窗口\n例：有一个队列，每次从队尾加入一个元素，或从队首删除一个元素，并在任何时刻求整个队列的最大值。\n\n一个很直接的想法是使用优先队列 `priority_queue` 即堆，堆可以在 $O(1)$ 的时间内求出最大值，但每次加入或删除时需要 $O({\\log}n)$ 的时间完成堆的调整，但是用了堆后就不能按照进队的顺序出队了！这时候你可以大胆地写一个平衡树或者 `set`——如果你不怕多出来的 $\\log$ 和平衡树常数带来的 TLE 的话。\n\n单调队列就是解决这类问题的数据结构，我们用一个辅助队列，使该队列的首元素总是原队列的最大值，这样就可以 $O(1)$ 地求出队列的最大值了。\n\n### 维护单调队列\n现有需要维护最大值的队列 `Q`，和辅助队列 `M`，设计算法使任何时刻时 `M` 队首元素都是当前 `Q` 的最大值。\n\n每次在 `Q` 的队尾加入元素 `x` 时，也将其加入到 `M` 中，从 `M` 的队尾向前遍历，将遍历到的所有 **小于等 `x` 的元素**全部删除，因为它们在 `x` 之前被加入到队列中，在 `x` 出队前它们就已经都出队了，即**在 `x` 出队前这些元素不可能成为队列中的最大值**。\n\n每次在 `Q` 的队首删除元素时，将要删除的元素与 `M` 的队首元素比较，如果该元素与 `M` 队首元素相等，即**该元素为执行删除操作前队列的最大值**，则同时也要将 `M` 的队首元素删除，使原 `Q` 的次小值成为 `M` 的队首元素，保证 `M` 的队首元素是删除操作后 `Q` 中最大的元素。\n\n### 应用\n状态转移方程形如 $f[x]=\\max\\{g(k)\\}+w[x]$ 的动态规划可以使用单调队列来优化。\n\n### 实现\n因为同时要从队列的两端添加、删除，所以要使用 `deque` 实现，而不是 `queue`。\n```cpp\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n```\n","source":"_posts/monotone-queue-notes.md","raw":"title: 单调队列学习笔记\ncategories: OI\ntags: \n  - 单调队列\n  - 学习笔记\n  - 数据结构\n  - 高级数据结构\n  - 算法模板  \npermalink: monotone-queue-notes\ndate: 2016-01-15 05:44:45\n---\n\n单调队列，就是单调的队列，通常用来解决滑动窗口的最值问题，可以应用到 DP 的优化上。一个单调队列中的元素总是单调递增（或递减）的。\n\n<!-- more -->\n\n### 滑动窗口\n例：有一个队列，每次从队尾加入一个元素，或从队首删除一个元素，并在任何时刻求整个队列的最大值。\n\n一个很直接的想法是使用优先队列 `priority_queue` 即堆，堆可以在 $O(1)$ 的时间内求出最大值，但每次加入或删除时需要 $O({\\log}n)$ 的时间完成堆的调整，但是用了堆后就不能按照进队的顺序出队了！这时候你可以大胆地写一个平衡树或者 `set`——如果你不怕多出来的 $\\log$ 和平衡树常数带来的 TLE 的话。\n\n单调队列就是解决这类问题的数据结构，我们用一个辅助队列，使该队列的首元素总是原队列的最大值，这样就可以 $O(1)$ 地求出队列的最大值了。\n\n### 维护单调队列\n现有需要维护最大值的队列 `Q`，和辅助队列 `M`，设计算法使任何时刻时 `M` 队首元素都是当前 `Q` 的最大值。\n\n每次在 `Q` 的队尾加入元素 `x` 时，也将其加入到 `M` 中，从 `M` 的队尾向前遍历，将遍历到的所有 **小于等 `x` 的元素**全部删除，因为它们在 `x` 之前被加入到队列中，在 `x` 出队前它们就已经都出队了，即**在 `x` 出队前这些元素不可能成为队列中的最大值**。\n\n每次在 `Q` 的队首删除元素时，将要删除的元素与 `M` 的队首元素比较，如果该元素与 `M` 队首元素相等，即**该元素为执行删除操作前队列的最大值**，则同时也要将 `M` 的队首元素删除，使原 `Q` 的次小值成为 `M` 的队首元素，保证 `M` 的队首元素是删除操作后 `Q` 中最大的元素。\n\n### 应用\n状态转移方程形如 $f[x]=\\max\\{g(k)\\}+w[x]$ 的动态规划可以使用单调队列来优化。\n\n### 实现\n因为同时要从队列的两端添加、删除，所以要使用 `deque` 实现，而不是 `queue`。\n```cpp\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n```\n","slug":"monotone-queue-notes","published":1,"updated":"2016-03-15T01:47:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n9500b3ofdky4bojlzy"},{"title":"最小生成树 && 次小生成树","date":"2016-01-01T22:08:50.000Z","_content":"\n最近回顾了一下图论中的最小生成树算法，又学习了神奇（个卵）的“次小生成树”的算法。\n\n总体来说，图论里面的东西还是挺灵活的嘛 ~\n\n<!-- more -->\n\n### 最小生成树\n\n#### Kruskal 算法\n对所有边进行排序，用**并查集**维护连通性，从小到大枚举边，判断当前边的起止点是否在同一连通块中，若不是，则加入这条边，否则放弃这条边。\n\n图结构需要以边集数组储存。\n\n时间复杂度为 $O(m{\\log}m)$（其中 `m` 为边数）。\n\n据说适用于稀疏图。\n\n```cpp\nstruct UndirectedEdge {\n\tint u, v, w;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n#### Prim 算法\nPrim 算法相对于 Kruskal 算法而言有一定难度，它把所有的点分为两个集合：在最小生成树中和不在最小生成树中，每次找到一条连接两个集合的**权值最小**的边，将它添加到最小生成树中。\n\n对于 Prim 算法，可以考虑类似于 Dijkstra 单源最短路算法的堆优化，即设置一个优先队列，初始时将从源点（可任取）出发的边加进优先队列中，每次从优先队列中不断弹出权值最小的边，直至得到一条边连接两个集合，则将这条边添加到最小生成树中，然后将这条边的出点的所有出边加入优先队列中。\n\n图结构需要以邻接表储存。\n\n使用优先队列的时间复杂度为 $O(m{\\log}n)$（其中 `n` 为结点数，`m` 为边数）。  \n不使用任何优化的时间复杂度为 $O(n^2)$（其中 `n` 为结点数）。\n\n据说适用于稠密图。\n\n```C++\nstruct Node {\n\tEdge *edges;\n\tbool visited;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\tbool used;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges), used(false) {}\n\n\tstruct Compare {\n\t\tbool operator()(Edge *a, Edge *b) const {\n\t\t\treturn a->w > b->w;\n\t\t}\n\t};\n};\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int prim() {\n\tstd::priority_queue<Edge *, vector<Edge *>, Edge::Compare> q;\n\tint sum = 0;\n\tNode *node = &nodes[0];\n\tnode->visited = true;\n\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\tq.push(edge);\n\t}\n\n\tint count = 0;\n\twhile (!q.empty()) {\n\t\tEdge *minEdge = q.top();\n\t\tq.pop();\n\t\tif (minEdge->to->visited) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsum += minEdge->w;\n\t\tminEdge->used = true;\n\t\tminEdge->to->visited = true;\n\t\tcount++;\n\n\t\tif (count == n - 1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (Edge *edge = minEdge->to->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\tq.push(edge);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n### 次小生成树\n一个图的次小生成树，是指**异于该图的最小生成树**的**边权和最小**的生成树。\n\n注意，这里的次小生成树是**非严格**次小，即可能存在一个图，其最小生成树与次小生成树的边权和相等。\n\n#### 算法\n不难得出，次小生成树可以由最小生成树更换一条边得到。\n\n首先构造原图的最小生成树，然后枚举每一条**不在最小生成树中**的边 `(u, v, w)`，尝试将这条边加入生成树，因为直接加入边会产生环，所以我们需要在加边之前删去最小生成树上 `u` 到 `v` 的路径上**权值最大**的边。在枚举每一条边时我们都会得到一棵生成树，这些生成树中边权和最小的即为要求的次小生成树。\n\n需要在构造最小生成树时将完整的树结构构造出来，并且使用树上倍增算法查询两点间边权值最大的值。\n\n#### 代码（POJ 1679）\n题目链接：[POJ 1679](http://poj.org/problem?id=1679)\n\n题目要求判断最小生成树的唯一性。求出该图的非严格次小生成树，与最小生成树的权值和作比较即可。\n\n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXT = 20;\nconst int MAXN = 100;\nconst int MAXM = MAXN * (MAXN - 1) / 2;\nconst int MAXLOGN = 7;\n\nstruct UndirectedEdge {\n\tint u, v, w;\n\tbool used;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w), used(false) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tint id;\n\tint depth;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nstruct SparseTable {\n\tNode *target;\n\tint max;\n} f[MAXN][MAXLOGN + 1];\n\nint t, n, m, logn;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\t\t\tedges[i].used = true;\n\t\t\taddEdge(edges[i].u, edges[i].v, edges[i].w);\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\ninline int log(int x) {\n\tint i = 0;\n\twhile ((1 << i) <= x) {\n\t\ti++;\n\t}\n\n\treturn i;\n}\n\ninline void makeST() {\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].id = i;\n\t}\n\n\tf[0][0].target = &nodes[0];\n\tf[0][0].max = 0;\n\n\tnodes[0].depth = 1;\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->depth == 0) {\n\t\t\t\tedge->to->depth = node->depth + 1;\n\t\t\t\tq.push(edge->to);\n\t\t\t\tf[edge->to->id][0].target = node;\n\t\t\t\tf[edge->to->id][0].max = edge->w;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int j = 1; j <= logn; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i][j].target = f[f[i][j - 1].target->id][j - 1].target;\n\t\t\tf[i][j].max = std::max(f[i][j - 1].max, f[f[i][j - 1].target->id][j - 1].max);\n\t\t}\n\t}\n}\n\ninline int queryMax(int u, int v) {\n\tNode *a = &nodes[u], *b = &nodes[v];\n\n\tif (a->depth < b->depth) {\n\t\tstd::swap(a, b);\n\t}\n\n\tint max = 0;\n\n\tif (a->depth != b->depth) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target->depth >= b->depth) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (a != b) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target != f[b->id][i].target) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\tmax = std::max(max, f[b->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t\tb = f[b->id][i].target;\n\t\t\t}\n\t\t}\n\n\t\tmax = std::max(max, f[a->id][0].max);\n\t\tmax = std::max(max, f[b->id][0].max);\n\t}\n\n\treturn max;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\twhile (~scanf(\"%d %d\", &n, &m)) {\n\t\tlogn = log(n);\n\t\tmemset(edges, 0, sizeof(edges));\n\t\tmemset(nodes, 0, sizeof(nodes));\n\t\tmemset(f, 0, sizeof(f));\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u, v, w;\n\t\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\t\tu--, v--;\n\n\t\t\tedges[i] = UndirectedEdge(u, v, w);\n\t\t}\n\n\t\tint sum = kruskal();\n\t\tmakeST();\n\n\t\tint ans = int_MAX;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (!edges[i].used) {\n\t\t\t\tans = std::min(ans, sum - queryMax(edges[i].u, edges[i].v) + edges[i].w);\n\t\t\t}\n\t\t}\n\n\t\tif (sum == ans) {\n\t\t\tputs(\"Not Unique!\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", sum);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/minimum-spanning-tree-notes.md","raw":"title: '最小生成树 && 次小生成树'\ncategories: OI\ntags: \n  - Kruskal\n  - POJ\n  - Prim\n  - 倍增\n  - 图论\n  - 学习笔记\n  - 并查集\n  - 最小生成树\n  - 算法模板  \npermalink: minimum-spanning-tree-notes\ndate: 2016-01-02 06:08:50\n---\n\n最近回顾了一下图论中的最小生成树算法，又学习了神奇（个卵）的“次小生成树”的算法。\n\n总体来说，图论里面的东西还是挺灵活的嘛 ~\n\n<!-- more -->\n\n### 最小生成树\n\n#### Kruskal 算法\n对所有边进行排序，用**并查集**维护连通性，从小到大枚举边，判断当前边的起止点是否在同一连通块中，若不是，则加入这条边，否则放弃这条边。\n\n图结构需要以边集数组储存。\n\n时间复杂度为 $O(m{\\log}m)$（其中 `m` 为边数）。\n\n据说适用于稀疏图。\n\n```cpp\nstruct UndirectedEdge {\n\tint u, v, w;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n#### Prim 算法\nPrim 算法相对于 Kruskal 算法而言有一定难度，它把所有的点分为两个集合：在最小生成树中和不在最小生成树中，每次找到一条连接两个集合的**权值最小**的边，将它添加到最小生成树中。\n\n对于 Prim 算法，可以考虑类似于 Dijkstra 单源最短路算法的堆优化，即设置一个优先队列，初始时将从源点（可任取）出发的边加进优先队列中，每次从优先队列中不断弹出权值最小的边，直至得到一条边连接两个集合，则将这条边添加到最小生成树中，然后将这条边的出点的所有出边加入优先队列中。\n\n图结构需要以邻接表储存。\n\n使用优先队列的时间复杂度为 $O(m{\\log}n)$（其中 `n` 为结点数，`m` 为边数）。  \n不使用任何优化的时间复杂度为 $O(n^2)$（其中 `n` 为结点数）。\n\n据说适用于稠密图。\n\n```C++\nstruct Node {\n\tEdge *edges;\n\tbool visited;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\tbool used;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges), used(false) {}\n\n\tstruct Compare {\n\t\tbool operator()(Edge *a, Edge *b) const {\n\t\t\treturn a->w > b->w;\n\t\t}\n\t};\n};\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int prim() {\n\tstd::priority_queue<Edge *, vector<Edge *>, Edge::Compare> q;\n\tint sum = 0;\n\tNode *node = &nodes[0];\n\tnode->visited = true;\n\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\tq.push(edge);\n\t}\n\n\tint count = 0;\n\twhile (!q.empty()) {\n\t\tEdge *minEdge = q.top();\n\t\tq.pop();\n\t\tif (minEdge->to->visited) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsum += minEdge->w;\n\t\tminEdge->used = true;\n\t\tminEdge->to->visited = true;\n\t\tcount++;\n\n\t\tif (count == n - 1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (Edge *edge = minEdge->to->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\tq.push(edge);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n### 次小生成树\n一个图的次小生成树，是指**异于该图的最小生成树**的**边权和最小**的生成树。\n\n注意，这里的次小生成树是**非严格**次小，即可能存在一个图，其最小生成树与次小生成树的边权和相等。\n\n#### 算法\n不难得出，次小生成树可以由最小生成树更换一条边得到。\n\n首先构造原图的最小生成树，然后枚举每一条**不在最小生成树中**的边 `(u, v, w)`，尝试将这条边加入生成树，因为直接加入边会产生环，所以我们需要在加边之前删去最小生成树上 `u` 到 `v` 的路径上**权值最大**的边。在枚举每一条边时我们都会得到一棵生成树，这些生成树中边权和最小的即为要求的次小生成树。\n\n需要在构造最小生成树时将完整的树结构构造出来，并且使用树上倍增算法查询两点间边权值最大的值。\n\n#### 代码（POJ 1679）\n题目链接：[POJ 1679](http://poj.org/problem?id=1679)\n\n题目要求判断最小生成树的唯一性。求出该图的非严格次小生成树，与最小生成树的权值和作比较即可。\n\n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXT = 20;\nconst int MAXN = 100;\nconst int MAXM = MAXN * (MAXN - 1) / 2;\nconst int MAXLOGN = 7;\n\nstruct UndirectedEdge {\n\tint u, v, w;\n\tbool used;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w), used(false) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tint id;\n\tint depth;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nstruct SparseTable {\n\tNode *target;\n\tint max;\n} f[MAXN][MAXLOGN + 1];\n\nint t, n, m, logn;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\t\t\tedges[i].used = true;\n\t\t\taddEdge(edges[i].u, edges[i].v, edges[i].w);\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\ninline int log(int x) {\n\tint i = 0;\n\twhile ((1 << i) <= x) {\n\t\ti++;\n\t}\n\n\treturn i;\n}\n\ninline void makeST() {\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].id = i;\n\t}\n\n\tf[0][0].target = &nodes[0];\n\tf[0][0].max = 0;\n\n\tnodes[0].depth = 1;\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->depth == 0) {\n\t\t\t\tedge->to->depth = node->depth + 1;\n\t\t\t\tq.push(edge->to);\n\t\t\t\tf[edge->to->id][0].target = node;\n\t\t\t\tf[edge->to->id][0].max = edge->w;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int j = 1; j <= logn; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i][j].target = f[f[i][j - 1].target->id][j - 1].target;\n\t\t\tf[i][j].max = std::max(f[i][j - 1].max, f[f[i][j - 1].target->id][j - 1].max);\n\t\t}\n\t}\n}\n\ninline int queryMax(int u, int v) {\n\tNode *a = &nodes[u], *b = &nodes[v];\n\n\tif (a->depth < b->depth) {\n\t\tstd::swap(a, b);\n\t}\n\n\tint max = 0;\n\n\tif (a->depth != b->depth) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target->depth >= b->depth) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (a != b) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target != f[b->id][i].target) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\tmax = std::max(max, f[b->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t\tb = f[b->id][i].target;\n\t\t\t}\n\t\t}\n\n\t\tmax = std::max(max, f[a->id][0].max);\n\t\tmax = std::max(max, f[b->id][0].max);\n\t}\n\n\treturn max;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\twhile (~scanf(\"%d %d\", &n, &m)) {\n\t\tlogn = log(n);\n\t\tmemset(edges, 0, sizeof(edges));\n\t\tmemset(nodes, 0, sizeof(nodes));\n\t\tmemset(f, 0, sizeof(f));\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u, v, w;\n\t\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\t\tu--, v--;\n\n\t\t\tedges[i] = UndirectedEdge(u, v, w);\n\t\t}\n\n\t\tint sum = kruskal();\n\t\tmakeST();\n\n\t\tint ans = int_MAX;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (!edges[i].used) {\n\t\t\t\tans = std::min(ans, sum - queryMax(edges[i].u, edges[i].v) + edges[i].w);\n\t\t\t}\n\t\t}\n\n\t\tif (sum == ans) {\n\t\t\tputs(\"Not Unique!\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", sum);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"minimum-spanning-tree-notes","published":1,"updated":"2016-03-15T01:47:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n9900bbofdk5fo61rso"},{"title":"自动将 LaTex 代码转义为 Markdown 格式的小程序","id":"39","updated":"2016-01-27T05:28:28.000Z","date":"2016-01-24T15:43:18.000Z","_content":"\n### 项目地址\nhttps://github.com/Menci/markdown-latex-helper\n\n### 功能\n写文章时经常用 LaTex 来写公式，因为这样可以通过 MathJax 来方便地渲染。\n\n但是 LaTex 代码中的一些符号（如 `*` 和 `~`）会与 Markdown 语法冲突。于是，就有了这个小程序，它可以自动把文档中的 LaTex 代码转义为 Markdown 的格式。\n\n<!-- more -->\n\n使用前\n```latex\n\\phi(n)={\\sum_{S{\\subseteq}\\{p_1,p_2,\\ldots,p_k\\}}{(-1)^{|S|}} * {\\frac{n}{ {\\prod_{ {p_i}{\\in}S} } \\ p_i }}}\n```\n\n使用后\n```latex\n\\\\phi\\(n\\)=\\{\\\\sum\\_\\{S\\{\\\\subseteq\\}\\\\\\{p\\_1\\,p\\_2\\,\\\\ldots\\,p\\_k\\\\\\}\\}\\{\\(\\-1\\)^\\{|S|\\}\\} \\*  \\{\\\\frac\\{n\\}\\{ \\{\\\\prod\\_\\{ \\{p\\_i\\}\\{\\\\in\\}S\\} \\} \\\\ p\\_i \\}\\}\\}\n```\n\n### 编译与使用\n```bash\n$ clang++ markdown-latex-helper.cpp -o markdown-latex-helper -std=c++11\n```\n\n`clang++` 可以换成你喜欢的编译器，注意 `-std=c++11` 不能省。\n\n```bash\n$ markdown-latex-helper < infile.md > outfile.md\n```\n\n使用的时候要通过命令行，暂时没有图形界面。","source":"_posts/markdown-latex-helper.md","raw":"title: 自动将 LaTex 代码转义为 Markdown 格式的小程序\ncategories: Geek\ntags: \n  - Markdown\n  - LaTex\n  - GitHub\npermalink: markdown-latex-helper\nid: 39\nupdated: '2016-01-27 13:28:28'\ndate: 2016-01-24 23:43:18\n---\n\n### 项目地址\nhttps://github.com/Menci/markdown-latex-helper\n\n### 功能\n写文章时经常用 LaTex 来写公式，因为这样可以通过 MathJax 来方便地渲染。\n\n但是 LaTex 代码中的一些符号（如 `*` 和 `~`）会与 Markdown 语法冲突。于是，就有了这个小程序，它可以自动把文档中的 LaTex 代码转义为 Markdown 的格式。\n\n<!-- more -->\n\n使用前\n```latex\n\\phi(n)={\\sum_{S{\\subseteq}\\{p_1,p_2,\\ldots,p_k\\}}{(-1)^{|S|}} * {\\frac{n}{ {\\prod_{ {p_i}{\\in}S} } \\ p_i }}}\n```\n\n使用后\n```latex\n\\\\phi\\(n\\)=\\{\\\\sum\\_\\{S\\{\\\\subseteq\\}\\\\\\{p\\_1\\,p\\_2\\,\\\\ldots\\,p\\_k\\\\\\}\\}\\{\\(\\-1\\)^\\{|S|\\}\\} \\*  \\{\\\\frac\\{n\\}\\{ \\{\\\\prod\\_\\{ \\{p\\_i\\}\\{\\\\in\\}S\\} \\} \\\\ p\\_i \\}\\}\\}\n```\n\n### 编译与使用\n```bash\n$ clang++ markdown-latex-helper.cpp -o markdown-latex-helper -std=c++11\n```\n\n`clang++` 可以换成你喜欢的编译器，注意 `-std=c++11` 不能省。\n\n```bash\n$ markdown-latex-helper < infile.md > outfile.md\n```\n\n使用的时候要通过命令行，暂时没有图形界面。","slug":"markdown-latex-helper","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n9e00boofdk7yuks0bd"},{"title":"Link-Cut Tree 学习笔记","date":"2016-01-19T12:50:40.000Z","_content":"\nLink-Cut Tree 是一种用来维护动态森林连通性的数据结构，适用于动态树问题。它采用类似树链剖分的轻重边路径剖分，把树边分为实边和虚边，并用 Splay 来维护每一条实路径。Link-Cut Tree 的基本操作复杂度为均摊 $O({\\log}n)$，但常数因子较大，一般效率会低于树链剖分。\n\n<!-- more -->\n\n### 定义\n一棵 Link-Cut Tree 上的边分为两种：实边和虚边。每一种边都是有向的，由子节点指向父节点。首尾相连的实边组成的不可延伸的链叫做路径。路径中**深度最大**的节点称为路径头部，**深度最小**的节点称为路径尾部。\n\n将每一条路径上的节点按照深度排序，得到一个序列，用 Splay 来维护这个序列。\n\n每一条链对应着一棵 Splay，每棵 Splay 的根节点有一个成员 `Path Parent`，表示该 Splay 维护的路径的尾部的节点的**父节点**，整棵树的根节点所对应的 Splay 节点的 `Path Parent` 为空；其他节点（不是其所在 Splay 的根节点的节点）的 `Path Parent` 也为空。\n\n`value` 用于维护点权，`sum` 和 `max` 是根据题目要求维护的链上的区间信息。`reversed` 表示以该节点为根的 Splay 有没有被翻转。\n\n```cpp\nstruct Node {\n\tNode *child[2], *parent, *pathParent;\n\tT value, sum, max;\n\tbool reversed;\n}\n```\n### 操作\nLink-Cut Tree 支持以下几种基本操作：\n\n1. `Access(u)`，“访问”某个节点 `u`，被“访问”过的节点会与根节点之间以路径相连，并且该节点为路径头部（最下端）；\n2. `Evert(u)`，将某个节点 `u` 置为其所在树的根节点，该操作等价于把该节点到根节点所经过的所有边方向取反；\n3. `Link(u, v)`，将某两个节点 `u` 和 `v` 连接，执行操作后 `u` 成为 `v` 的父节点；\n4. `Cut(u, v)`，将某两个节点 `u` 和 `v` 分离，执行操作后 `v` 及其子节点组成单独的一棵树；\n5. `FindRoot(u)`，查找某个节点 `u` 所在树的根节点；\n6. `MakeTree()`，向森林中种植一棵新的树。\n\n### `Access` 操作\n#### `Expose` 操作\n在实现 `Access` 操作前，我们先来实现 `Expose` 操作，它的作用是将当前节点置为其所在路径的头部节点，即切断自该节点向下的部分路径。\n\n1. 将该节点 `Splay` 到其所在 Splay 的根节点；\n2. 如果该节点有右孩子，那么断开其与其右孩子的连接。\n\n不要忘了各种标记的下放和值的维护。\n\n```cpp\nvoid expose() {\n\tsplay();\n\tpushDown();\n\tif (child[R]) {\n\t\tchild[R]->parent = NULL;\n\t\tchild[R]->pathParent = this;\n\t\tchild[R] = NULL;\n\t\tmaintain();\n\t}\n}\n```\n#### `Splice` 操作\n接下来，我们来实现 `Splice` 操作，它的作用是将**当前节点**所在的路径与**其尾部节点的父节点**所在的路径合并，即实现了路径的向上延长。\n\n1. 将该节点 `Splay` 到其所在 Splay 的根节点；\n2. 如果该节点没有 `Path Parent`，那么说明该节点所在路径中包含根节点，即 `Splice` 操作失败。\n3. 对该节点的 `Path Parent` 执行 `Expose` 操作，将其原有的路径断开；\n4. 将该节点连接到其 `Path Parent` 的右孩子上，并将 `Path Parent` 置为空。\n\n```cpp\nbool splice() {\n\tsplay();\n\tif (!pathParent) return false;\n\n\tpathParent->expose();\n\tpathParent->child[R] = this;\n\tparent = pathParent;\n\tpathParent = NULL;\n\tparent->maintain();\n\n\treturn true;\n}\n```\n\n#### `Access` 操作\n有了 `Expose` 和 `Splice`，`Access` 就简单多了，`Expose` 后执行 `Splice` 直到失败即可。\n\n```cpp\nvoid access() {\n\texpose();\n\twhile (splice());\n}\n```\n\n### `Evert` 操作\n首先执行 `Access`，将该节点与根节点之间用一条完整的路径连接，然后翻转这条路径即可。\n\n```cpp\nvoid evert() {\n\taccess();\n\tsplay();\n\treversed ^= 1;\n}\n```\n\n### `Link` 操作\n将节点 `v` 置为其所在树的根，然后将其 `Path Parent` 置为节点 `u` 即可。\n\n```cpp\nvoid link(int u, int v) {\n\tnodes[v - 1]->evert();\n\tnodes[v - 1]->pathParent = nodes[u - 1];\n}\n```\n\n### `Cut` 操作\n`Cut` 操作稍微复杂一点：\n\n1. 将节点 `u` 置为其所在树的根节点，以保证 `v` 是 `u` 的子节点；\n2. 对 `v` 执行 `Access` 操作，将 `v` 与 `u` 之间用一条完整的路径连接；\n3. 对 `v` 执行 `Splay` 操作，将 `v` 置于**其所在 Splay 的根节点**；\n4. 将 `v` 与其左子树分离，即将路径断开。\n\n```cpp\nvoid cut(int u, int v) {\n\tnodes[u - 1]->evert();\n\tnodes[v - 1]->access();\n\tnodes[v - 1]->splay();\n\tnodes[v - 1]->pushDown();\n\tnodes[v - 1]->child[L]->parent = NULL;\n\tnodes[v - 1]->child[L] = NULL;\n\tnodes[v - 1]->maintain();\n}\n```\n\n### `Query` 和 `Update` 操作\n以 `QueryMax(u, v)` 查询两个点之间的点权最大值为例。首先在 `Node` 结构体中存储 `max` 成员，并在 `Maintain()` 中维护它。\n\n首先，如果需要查询某个点到根节点之间的点权最大值，只需先访问这个节点，即 `Access(u)`，然后对该节点执行 `Splay` 操作，将其置为其所在 Splay 的根节点，此时 `u` 的 `max` 存储的值即为 `u` 到其所在树的根节点的路径上的点权最大值。\n\n如果要查询任意两点间的点权最大值，只需要先对其中一个节点执行 `Evert` 操作，将其置为树根，就可以转化为上述情况进行处理。\n\n```cpp\nconst T &Node::queryMax() {\n\taccess();\n\tsplay();\n\treturn max;\n}\n\nconst T &queryMax(int u, int v) {\n\tnodes[u - 1]->evert();\n\treturn nodes[v - 1]->queryMax();\n}\n```\n\n要修改某个点的点权值，只需要对该节点执行 `Splay` 操作，将其置为其所在 Splay 的根节点，然后直接修改即可，这样可以避免修改时标记的向上传递。\n\n```cpp\nvoid update(int u, const T &value) {\n\tnodes[u - 1]->splay();\n\tnodes[u - 1]->value = value;\n\tnodes[u - 1]->maintain();\n}\n```\n\n### `MakeTree` 操作\n直接新建节点就可以。\n\n```cpp\nvoid makeTree(int u, const T &value) {\n\tnodes[u - 1] = new Node(value);\n}\n```\n\n### 其他操作 & 注意事项\n1. 进行 `Splay` 和 `Rotate` 时，要注意标记的传递；\n2. `Rotate` 时，需要将自己的 `Path Parent` 与父节点的 `Path Parent` 互换，以保证 `Path Parent` 成员的有效值总在一棵 Splay 的根节点上。\n\n```cpp\nvoid pushDown() {\n\tif (reversed) {\n\t\tstd::swap(child[L], child[R]);\n\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\treversed = false;\n\t}\n}\n\nvoid maintain() {\n\tsum = value;\n\tif (child[L]) sum += child[L]->sum;\n\tif (child[R]) sum += child[R]->sum;\n\n\tmax = value;\n\tif (child[L]) max = std::max(max, child[L]->max);\n\tif (child[R]) max = std::max(max, child[R]->max);\n}\n\nvoid rotate() {\n\tif (parent->parent) parent->parent->pushDown();\n\tparent->pushDown(), pushDown();\n\tstd::swap(pathParent, parent->pathParent);\n\n\tRelation x = relation();\n\tNode *oldParent = parent;\n\n\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\tparent = oldParent->parent;\n\n\toldParent->child[x] = child[x ^ 1];\n\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\tchild[x ^ 1] = oldParent;\n\toldParent->parent = this;\n\n\toldParent->maintain(), maintain();\n}\n\nvoid splay() {\n\twhile (parent) {\n\t\tif (!parent->parent) rotate();\n\t\telse {\n\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\telse rotate(), rotate();\n\t\t}\n\t}\n}\n```\n\n### 完整代码（树的统计）\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 30000;\n\nvoid print(void *p);\n\ntemplate <typename T>\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tT value, sum, max;\n\t\tbool reversed;\n\n\t\tNode(const T &value) : reversed(false), value(value), sum(value), max(value), parent(NULL), pathParent(NULL) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (child[L]) sum += child[L]->sum;\n\t\t\tif (child[R]) sum += child[R]->sum;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent) {\n\t\t\t\tif (!parent->parent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tpushDown();\n\t\t\tif (child[R]) {\n\t\t\t\tchild[R]->parent = NULL;\n\t\t\t\tchild[R]->pathParent = this;\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tparent = pathParent;\n\t\t\tpathParent = NULL;\n\t\t\tparent->maintain();\n\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tconst T &querySum() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn sum;\n\t\t}\n\n\t\tconst T &queryMax() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn max;\n\t\t}\n\t};\n\n\tNode *nodes[MAXN];\n\n\tvoid makeTree(int u, const T &value) {\n\t\tnodes[u - 1] = new Node(value);\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1]->evert();\n\t\tnodes[v - 1]->pathParent = nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\tnodes[v - 1]->access();\n\t\tnodes[v - 1]->splay();\n\t\tnodes[v - 1]->pushDown();\n\t\tnodes[v - 1]->child[L]->parent = NULL;\n\t\tnodes[v - 1]->child[L] = NULL;\n\t\tnodes[v - 1]->maintain();\n\t}\n\n\tconst T &querySum(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->querySum();\n\t}\n\n\tconst T &queryMax(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->queryMax();\n\t}\n\n\tvoid update(int u, const T &value) {\n\t\tnodes[u - 1]->splay();\n\t\tnodes[u - 1]->value = value;\n\t\tnodes[u - 1]->maintain();\n\t}\n};\n\nstruct UndirectedEdge {\n\tint u, v;\n\n\tUndirectedEdge() {}\n\n\tUndirectedEdge(int u, int v) : u(u), v(v) {}\n} edges[MAXN - 1];\n\nint n, q;\nLinkCutTree<int> lct;\n\nvoid dfs(LinkCutTree<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[LinkCutTree<int>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d, max = %d, sum = %d\\n\", v->value, v->max, v->sum);\n\tdfs(v->child[LinkCutTree<int>::R], depth + 1);\n}\n\nvoid print(void *p) {\n\tdfs((LinkCutTree<int>::Node *)p, 0);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tedges[i] = UndirectedEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint value;\n\t\tscanf(\"%d\", &value);\n\t\tlct.makeTree(i, value);\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tlct.link(edges[i].u, edges[i].v);\n\t}\n\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; i++) {\n\t\tchar str[6 + 1];\n\t\tscanf(\"%s\", str);\n\t\tif (str[1] == 'H') {\n\t\t\tint u, t;\n\t\t\tscanf(\"%d %d\", &u, &t);\n\t\t\tlct.update(u, t);\n\t\t} else if (str[1] == 'M') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.queryMax(u, v));\n\t\t} else if (str[1] == 'S') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.querySum(u, v));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/link-cut-tree-notes.md","raw":"title: Link-Cut Tree 学习笔记\ncategories: OI\ntags: \n  - Link-Cut Tree\n  - 动态树\n  - Splay\n  - 数据结构\n  - 高级数据结构\n  - 算法模板  \npermalink: link-cut-tree-notes\ndate: 2016-01-19 20:50:40\n---\n\nLink-Cut Tree 是一种用来维护动态森林连通性的数据结构，适用于动态树问题。它采用类似树链剖分的轻重边路径剖分，把树边分为实边和虚边，并用 Splay 来维护每一条实路径。Link-Cut Tree 的基本操作复杂度为均摊 $O({\\log}n)$，但常数因子较大，一般效率会低于树链剖分。\n\n<!-- more -->\n\n### 定义\n一棵 Link-Cut Tree 上的边分为两种：实边和虚边。每一种边都是有向的，由子节点指向父节点。首尾相连的实边组成的不可延伸的链叫做路径。路径中**深度最大**的节点称为路径头部，**深度最小**的节点称为路径尾部。\n\n将每一条路径上的节点按照深度排序，得到一个序列，用 Splay 来维护这个序列。\n\n每一条链对应着一棵 Splay，每棵 Splay 的根节点有一个成员 `Path Parent`，表示该 Splay 维护的路径的尾部的节点的**父节点**，整棵树的根节点所对应的 Splay 节点的 `Path Parent` 为空；其他节点（不是其所在 Splay 的根节点的节点）的 `Path Parent` 也为空。\n\n`value` 用于维护点权，`sum` 和 `max` 是根据题目要求维护的链上的区间信息。`reversed` 表示以该节点为根的 Splay 有没有被翻转。\n\n```cpp\nstruct Node {\n\tNode *child[2], *parent, *pathParent;\n\tT value, sum, max;\n\tbool reversed;\n}\n```\n### 操作\nLink-Cut Tree 支持以下几种基本操作：\n\n1. `Access(u)`，“访问”某个节点 `u`，被“访问”过的节点会与根节点之间以路径相连，并且该节点为路径头部（最下端）；\n2. `Evert(u)`，将某个节点 `u` 置为其所在树的根节点，该操作等价于把该节点到根节点所经过的所有边方向取反；\n3. `Link(u, v)`，将某两个节点 `u` 和 `v` 连接，执行操作后 `u` 成为 `v` 的父节点；\n4. `Cut(u, v)`，将某两个节点 `u` 和 `v` 分离，执行操作后 `v` 及其子节点组成单独的一棵树；\n5. `FindRoot(u)`，查找某个节点 `u` 所在树的根节点；\n6. `MakeTree()`，向森林中种植一棵新的树。\n\n### `Access` 操作\n#### `Expose` 操作\n在实现 `Access` 操作前，我们先来实现 `Expose` 操作，它的作用是将当前节点置为其所在路径的头部节点，即切断自该节点向下的部分路径。\n\n1. 将该节点 `Splay` 到其所在 Splay 的根节点；\n2. 如果该节点有右孩子，那么断开其与其右孩子的连接。\n\n不要忘了各种标记的下放和值的维护。\n\n```cpp\nvoid expose() {\n\tsplay();\n\tpushDown();\n\tif (child[R]) {\n\t\tchild[R]->parent = NULL;\n\t\tchild[R]->pathParent = this;\n\t\tchild[R] = NULL;\n\t\tmaintain();\n\t}\n}\n```\n#### `Splice` 操作\n接下来，我们来实现 `Splice` 操作，它的作用是将**当前节点**所在的路径与**其尾部节点的父节点**所在的路径合并，即实现了路径的向上延长。\n\n1. 将该节点 `Splay` 到其所在 Splay 的根节点；\n2. 如果该节点没有 `Path Parent`，那么说明该节点所在路径中包含根节点，即 `Splice` 操作失败。\n3. 对该节点的 `Path Parent` 执行 `Expose` 操作，将其原有的路径断开；\n4. 将该节点连接到其 `Path Parent` 的右孩子上，并将 `Path Parent` 置为空。\n\n```cpp\nbool splice() {\n\tsplay();\n\tif (!pathParent) return false;\n\n\tpathParent->expose();\n\tpathParent->child[R] = this;\n\tparent = pathParent;\n\tpathParent = NULL;\n\tparent->maintain();\n\n\treturn true;\n}\n```\n\n#### `Access` 操作\n有了 `Expose` 和 `Splice`，`Access` 就简单多了，`Expose` 后执行 `Splice` 直到失败即可。\n\n```cpp\nvoid access() {\n\texpose();\n\twhile (splice());\n}\n```\n\n### `Evert` 操作\n首先执行 `Access`，将该节点与根节点之间用一条完整的路径连接，然后翻转这条路径即可。\n\n```cpp\nvoid evert() {\n\taccess();\n\tsplay();\n\treversed ^= 1;\n}\n```\n\n### `Link` 操作\n将节点 `v` 置为其所在树的根，然后将其 `Path Parent` 置为节点 `u` 即可。\n\n```cpp\nvoid link(int u, int v) {\n\tnodes[v - 1]->evert();\n\tnodes[v - 1]->pathParent = nodes[u - 1];\n}\n```\n\n### `Cut` 操作\n`Cut` 操作稍微复杂一点：\n\n1. 将节点 `u` 置为其所在树的根节点，以保证 `v` 是 `u` 的子节点；\n2. 对 `v` 执行 `Access` 操作，将 `v` 与 `u` 之间用一条完整的路径连接；\n3. 对 `v` 执行 `Splay` 操作，将 `v` 置于**其所在 Splay 的根节点**；\n4. 将 `v` 与其左子树分离，即将路径断开。\n\n```cpp\nvoid cut(int u, int v) {\n\tnodes[u - 1]->evert();\n\tnodes[v - 1]->access();\n\tnodes[v - 1]->splay();\n\tnodes[v - 1]->pushDown();\n\tnodes[v - 1]->child[L]->parent = NULL;\n\tnodes[v - 1]->child[L] = NULL;\n\tnodes[v - 1]->maintain();\n}\n```\n\n### `Query` 和 `Update` 操作\n以 `QueryMax(u, v)` 查询两个点之间的点权最大值为例。首先在 `Node` 结构体中存储 `max` 成员，并在 `Maintain()` 中维护它。\n\n首先，如果需要查询某个点到根节点之间的点权最大值，只需先访问这个节点，即 `Access(u)`，然后对该节点执行 `Splay` 操作，将其置为其所在 Splay 的根节点，此时 `u` 的 `max` 存储的值即为 `u` 到其所在树的根节点的路径上的点权最大值。\n\n如果要查询任意两点间的点权最大值，只需要先对其中一个节点执行 `Evert` 操作，将其置为树根，就可以转化为上述情况进行处理。\n\n```cpp\nconst T &Node::queryMax() {\n\taccess();\n\tsplay();\n\treturn max;\n}\n\nconst T &queryMax(int u, int v) {\n\tnodes[u - 1]->evert();\n\treturn nodes[v - 1]->queryMax();\n}\n```\n\n要修改某个点的点权值，只需要对该节点执行 `Splay` 操作，将其置为其所在 Splay 的根节点，然后直接修改即可，这样可以避免修改时标记的向上传递。\n\n```cpp\nvoid update(int u, const T &value) {\n\tnodes[u - 1]->splay();\n\tnodes[u - 1]->value = value;\n\tnodes[u - 1]->maintain();\n}\n```\n\n### `MakeTree` 操作\n直接新建节点就可以。\n\n```cpp\nvoid makeTree(int u, const T &value) {\n\tnodes[u - 1] = new Node(value);\n}\n```\n\n### 其他操作 & 注意事项\n1. 进行 `Splay` 和 `Rotate` 时，要注意标记的传递；\n2. `Rotate` 时，需要将自己的 `Path Parent` 与父节点的 `Path Parent` 互换，以保证 `Path Parent` 成员的有效值总在一棵 Splay 的根节点上。\n\n```cpp\nvoid pushDown() {\n\tif (reversed) {\n\t\tstd::swap(child[L], child[R]);\n\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\treversed = false;\n\t}\n}\n\nvoid maintain() {\n\tsum = value;\n\tif (child[L]) sum += child[L]->sum;\n\tif (child[R]) sum += child[R]->sum;\n\n\tmax = value;\n\tif (child[L]) max = std::max(max, child[L]->max);\n\tif (child[R]) max = std::max(max, child[R]->max);\n}\n\nvoid rotate() {\n\tif (parent->parent) parent->parent->pushDown();\n\tparent->pushDown(), pushDown();\n\tstd::swap(pathParent, parent->pathParent);\n\n\tRelation x = relation();\n\tNode *oldParent = parent;\n\n\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\tparent = oldParent->parent;\n\n\toldParent->child[x] = child[x ^ 1];\n\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\tchild[x ^ 1] = oldParent;\n\toldParent->parent = this;\n\n\toldParent->maintain(), maintain();\n}\n\nvoid splay() {\n\twhile (parent) {\n\t\tif (!parent->parent) rotate();\n\t\telse {\n\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\telse rotate(), rotate();\n\t\t}\n\t}\n}\n```\n\n### 完整代码（树的统计）\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 30000;\n\nvoid print(void *p);\n\ntemplate <typename T>\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tT value, sum, max;\n\t\tbool reversed;\n\n\t\tNode(const T &value) : reversed(false), value(value), sum(value), max(value), parent(NULL), pathParent(NULL) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (child[L]) sum += child[L]->sum;\n\t\t\tif (child[R]) sum += child[R]->sum;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent) {\n\t\t\t\tif (!parent->parent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tpushDown();\n\t\t\tif (child[R]) {\n\t\t\t\tchild[R]->parent = NULL;\n\t\t\t\tchild[R]->pathParent = this;\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tparent = pathParent;\n\t\t\tpathParent = NULL;\n\t\t\tparent->maintain();\n\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tconst T &querySum() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn sum;\n\t\t}\n\n\t\tconst T &queryMax() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn max;\n\t\t}\n\t};\n\n\tNode *nodes[MAXN];\n\n\tvoid makeTree(int u, const T &value) {\n\t\tnodes[u - 1] = new Node(value);\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1]->evert();\n\t\tnodes[v - 1]->pathParent = nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\tnodes[v - 1]->access();\n\t\tnodes[v - 1]->splay();\n\t\tnodes[v - 1]->pushDown();\n\t\tnodes[v - 1]->child[L]->parent = NULL;\n\t\tnodes[v - 1]->child[L] = NULL;\n\t\tnodes[v - 1]->maintain();\n\t}\n\n\tconst T &querySum(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->querySum();\n\t}\n\n\tconst T &queryMax(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->queryMax();\n\t}\n\n\tvoid update(int u, const T &value) {\n\t\tnodes[u - 1]->splay();\n\t\tnodes[u - 1]->value = value;\n\t\tnodes[u - 1]->maintain();\n\t}\n};\n\nstruct UndirectedEdge {\n\tint u, v;\n\n\tUndirectedEdge() {}\n\n\tUndirectedEdge(int u, int v) : u(u), v(v) {}\n} edges[MAXN - 1];\n\nint n, q;\nLinkCutTree<int> lct;\n\nvoid dfs(LinkCutTree<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[LinkCutTree<int>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d, max = %d, sum = %d\\n\", v->value, v->max, v->sum);\n\tdfs(v->child[LinkCutTree<int>::R], depth + 1);\n}\n\nvoid print(void *p) {\n\tdfs((LinkCutTree<int>::Node *)p, 0);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tedges[i] = UndirectedEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint value;\n\t\tscanf(\"%d\", &value);\n\t\tlct.makeTree(i, value);\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tlct.link(edges[i].u, edges[i].v);\n\t}\n\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; i++) {\n\t\tchar str[6 + 1];\n\t\tscanf(\"%s\", str);\n\t\tif (str[1] == 'H') {\n\t\t\tint u, t;\n\t\t\tscanf(\"%d %d\", &u, &t);\n\t\t\tlct.update(u, t);\n\t\t} else if (str[1] == 'M') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.queryMax(u, v));\n\t\t} else if (str[1] == 'S') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.querySum(u, v));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"link-cut-tree-notes","published":1,"updated":"2016-03-15T12:10:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n9i00bwofdklf65k2pt"},{"title":"KMP 学习笔记","date":"2015-12-29T20:19:36.000Z","_content":"\nKMP（Knuth-Morris-Pratt）是算法竞赛中常用的字符串匹配算法之一，它可以有效地利用失配信息来使得匹配全过程中不回溯，从而在线性时间内完成匹配。\n\n<!-- more -->\n\n### 原理\n设模式串 `pattern` 为 `\"utqqutnu\"`，目标串 `target` 为 `\"utqlwutqqutnu`\"，使用朴素算法进行匹配时（`\"-\"` 表示匹配成功，`\"|\"` 表示在此字符失配）：\n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n首先，将两串首部对齐，逐个字符匹配，可见在字符 `'l'` 处失配，按照朴素算法的思想，我们需要把模式串右移一个字符，然后再从模式串首部开始匹配，即：\n\n```\nutqqutlwutqqutnu\n |\n utqqutnu\n```\n\n这时发现从第一个字符起就不匹配，还要继续右移 ……\n\n但是，似乎有一种更好的策略：我们可以直接把模式串的开头对齐目标串的 `\"ut\"` 处，就可以一次跳过几个字符，并且模式串无需回溯：\n\n```\nutqqutlwutqqutnu\n    --|\n    utqqutnu\n```\n\n而接下来这次失配后，本来需要将模式串与 `'t'` 对齐，但事实上并不需要，将模式串直接与 `'l'` 对齐即可。\n\n```\nutqqutlwutqqutnu\n      |\n      utqqutnu\n```\n\nKMP 算法就是利用了失配后的**部分匹配**信息来选择模式串的移动方式，尽可能地避免无用的匹配。\n\n### 失配信息de利用\n通过上述例子我们可以观察到，如果**部分匹配**的串有对称的**前后缀**，则我们可以直接将**模式串**中**部分匹配串**的前缀与**目标串**中**部分匹配串**的后缀对齐，如：\n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n例子中的部分匹配串为 `\"utqqut\"`，有对称的前后缀 `\"ut\"`，则可以直接将目标串的第二个 `\"ut\"` 与模式串的第一个 `\"ut\"` 对齐。\n\n再来看这个例子，模式串为 `\"ttitty\"`，目标串为 `\"ttittitty\"`\n\n```\nttittittypoi\n-----|\nttitty\n```\n\n此时的部分匹配串为 `\"ttitt\"`，它有两个对称的前后缀，分别是 `\"tt\"` 和 `\"t\"`，我们会想，以 `\"t\"` 对齐，可以移动更长的距离，事实上呢？\n\n```\nttittittypoi\n    -|\n    ttitty\n```\n\n在模式串第二个 `'t'` 处失配后，继续匹配，最终结果是匹配失败。\n\n然而，如果我们以 `\"tt\"` 对齐，则有：\n\n```\nttittittypoi\n   ------\n   ttitty\n```\n\n结果是匹配成功。\n\n这个例子告诉我们，当部分匹配串有多个对称前后缀时，需要选择**最长的**，以保证匹配结果的正确。\n\n### 失配信息de推导\n事实上，KMP 算法利用的**失配信息**是与目标串无关的，它仅与模式串有关，我们可以用递推的方法在线性的时间内求出模式串的**每个可能的部分匹配串（即所有前缀）**前缀的失配信息。\n\n我们定义 `next` 数组是一个长度等于模式串长度的数组，它的第 `i` 个成员代表以模式串前 `i` 个字符作为部分匹配串时，部分匹配串的**最长对称前后缀**长度。\n\n```\n      | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8\ntarget| u | t | q | q | u | t | n | u\nnext  | 0 | 0 | 0 | 0 | 1 | 2 | 0 | 1\n```\n\n推导 `next[i]` 的方法如下：\n\n1. 如果 `next[i - 1]` 不为 0，且第 `i` 个字符与第 `next[i - 1] +　１` 个字符相同，则 `next[i]` 即为 `next[i - 1] + 1`；\n2. 如果 `next[i - 1]` 为 0，且第 `i` 个字符与首个字符相同，则 `next[i] = 1`，否则 `next[i] = 0`；\n3. 难点：如果 `next[i - 1]` 不为 0，且第 `i` 个字符与第 `next[i - 1] +　１` 个字符**不同**，则继续对比第 `i` 个字符与 `next[next[i - 1] + 1]` 个字符，一直向前找直到匹配或者找到了 0。\n\n如模式串：*agct*agc**a**gct*agct*\n\n加粗的 `'a'` 与最后一个 `'t'` 不匹配，此时向前找找到 `\"agctagc\"` 的最后一个 `'c'` 的**对称位置的后一个字符**，发现是 `'t'`，则找到前后的 `\"agct\"` 是一个对称的前后缀。\n\n### 匹配de方法\n有了 `next` 数组，匹配就简单多了，只要根据以下三种情况对应处理即可：\n\n1. 如果当前字符匹配，则继续匹配下一个字符；\n2. 如果当前在**模式串的首字符处**不匹配，则直接将模式串右移一个字符；\n3. 否则移动模式串，使**模式串**中**部分匹配串**的前缀与**目标串**中**部分匹配串**的后缀对齐。\n\n### 完整代码（CodeVS 1204）\n因为 C++ 中数组从 `0` 开始，所以有些地方与上文中的表示不同。\n\n```cpp\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <string>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::string;\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100;\n\ninline size_t KMP(const string &target, const string &pattern) {\n\tuint next[MAXN] = { 0 };\n\n\tnext[0] = 0;\n\tfor (uint i = 1; i < pattern.length(); i++) {\n\t\tuint k = next[i - 1];\n\t\tchar ch = pattern[i];\n\n\t\twhile (k && pattern[k] != ch) {\n\t\t\tk = next[k - 1];\n\t\t}\n\n\t\tif (pattern[k] == ch) {\n\t\t\tnext[i] = k + 1;\n\t\t} else {\n\t\t\tnext[i] = 0;\n\t\t}\n\t}\n\n\tfor (uint i = 0; i < pattern.length(); i++) {\n\t\tcout << next[i] << endl;\n\t}\n\n\tuint i = 0, j = 0;\n\twhile (i < target.length() && j < pattern.length()) {\n\t\tif (target[i] == pattern[j]) {\n\t\t\ti++, j++;\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tj = next[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (j == pattern.length()) {\n\t\treturn i - j;\n\t} else {\n\t\treturn string::npos;\n\t}\n}\n\nint main() {\n\tstring target, pattern;\n\tcin >> target >> pattern;\n\tcout << KMP(target, pattern) << endl;\n\treturn 0;\n}\n```\n","source":"_posts/kmp-notes.md","raw":"title: KMP 学习笔记\ncategories: OI\ntags: \n  - CodeVS\n  - KMP\n  - 字符串\n  - 学习笔记\n  - 算法模板  \npermalink: kmp-notes\ndate: 2015-12-30 04:19:36\n---\n\nKMP（Knuth-Morris-Pratt）是算法竞赛中常用的字符串匹配算法之一，它可以有效地利用失配信息来使得匹配全过程中不回溯，从而在线性时间内完成匹配。\n\n<!-- more -->\n\n### 原理\n设模式串 `pattern` 为 `\"utqqutnu\"`，目标串 `target` 为 `\"utqlwutqqutnu`\"，使用朴素算法进行匹配时（`\"-\"` 表示匹配成功，`\"|\"` 表示在此字符失配）：\n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n首先，将两串首部对齐，逐个字符匹配，可见在字符 `'l'` 处失配，按照朴素算法的思想，我们需要把模式串右移一个字符，然后再从模式串首部开始匹配，即：\n\n```\nutqqutlwutqqutnu\n |\n utqqutnu\n```\n\n这时发现从第一个字符起就不匹配，还要继续右移 ……\n\n但是，似乎有一种更好的策略：我们可以直接把模式串的开头对齐目标串的 `\"ut\"` 处，就可以一次跳过几个字符，并且模式串无需回溯：\n\n```\nutqqutlwutqqutnu\n    --|\n    utqqutnu\n```\n\n而接下来这次失配后，本来需要将模式串与 `'t'` 对齐，但事实上并不需要，将模式串直接与 `'l'` 对齐即可。\n\n```\nutqqutlwutqqutnu\n      |\n      utqqutnu\n```\n\nKMP 算法就是利用了失配后的**部分匹配**信息来选择模式串的移动方式，尽可能地避免无用的匹配。\n\n### 失配信息de利用\n通过上述例子我们可以观察到，如果**部分匹配**的串有对称的**前后缀**，则我们可以直接将**模式串**中**部分匹配串**的前缀与**目标串**中**部分匹配串**的后缀对齐，如：\n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n例子中的部分匹配串为 `\"utqqut\"`，有对称的前后缀 `\"ut\"`，则可以直接将目标串的第二个 `\"ut\"` 与模式串的第一个 `\"ut\"` 对齐。\n\n再来看这个例子，模式串为 `\"ttitty\"`，目标串为 `\"ttittitty\"`\n\n```\nttittittypoi\n-----|\nttitty\n```\n\n此时的部分匹配串为 `\"ttitt\"`，它有两个对称的前后缀，分别是 `\"tt\"` 和 `\"t\"`，我们会想，以 `\"t\"` 对齐，可以移动更长的距离，事实上呢？\n\n```\nttittittypoi\n    -|\n    ttitty\n```\n\n在模式串第二个 `'t'` 处失配后，继续匹配，最终结果是匹配失败。\n\n然而，如果我们以 `\"tt\"` 对齐，则有：\n\n```\nttittittypoi\n   ------\n   ttitty\n```\n\n结果是匹配成功。\n\n这个例子告诉我们，当部分匹配串有多个对称前后缀时，需要选择**最长的**，以保证匹配结果的正确。\n\n### 失配信息de推导\n事实上，KMP 算法利用的**失配信息**是与目标串无关的，它仅与模式串有关，我们可以用递推的方法在线性的时间内求出模式串的**每个可能的部分匹配串（即所有前缀）**前缀的失配信息。\n\n我们定义 `next` 数组是一个长度等于模式串长度的数组，它的第 `i` 个成员代表以模式串前 `i` 个字符作为部分匹配串时，部分匹配串的**最长对称前后缀**长度。\n\n```\n      | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8\ntarget| u | t | q | q | u | t | n | u\nnext  | 0 | 0 | 0 | 0 | 1 | 2 | 0 | 1\n```\n\n推导 `next[i]` 的方法如下：\n\n1. 如果 `next[i - 1]` 不为 0，且第 `i` 个字符与第 `next[i - 1] +　１` 个字符相同，则 `next[i]` 即为 `next[i - 1] + 1`；\n2. 如果 `next[i - 1]` 为 0，且第 `i` 个字符与首个字符相同，则 `next[i] = 1`，否则 `next[i] = 0`；\n3. 难点：如果 `next[i - 1]` 不为 0，且第 `i` 个字符与第 `next[i - 1] +　１` 个字符**不同**，则继续对比第 `i` 个字符与 `next[next[i - 1] + 1]` 个字符，一直向前找直到匹配或者找到了 0。\n\n如模式串：*agct*agc**a**gct*agct*\n\n加粗的 `'a'` 与最后一个 `'t'` 不匹配，此时向前找找到 `\"agctagc\"` 的最后一个 `'c'` 的**对称位置的后一个字符**，发现是 `'t'`，则找到前后的 `\"agct\"` 是一个对称的前后缀。\n\n### 匹配de方法\n有了 `next` 数组，匹配就简单多了，只要根据以下三种情况对应处理即可：\n\n1. 如果当前字符匹配，则继续匹配下一个字符；\n2. 如果当前在**模式串的首字符处**不匹配，则直接将模式串右移一个字符；\n3. 否则移动模式串，使**模式串**中**部分匹配串**的前缀与**目标串**中**部分匹配串**的后缀对齐。\n\n### 完整代码（CodeVS 1204）\n因为 C++ 中数组从 `0` 开始，所以有些地方与上文中的表示不同。\n\n```cpp\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <string>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::string;\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100;\n\ninline size_t KMP(const string &target, const string &pattern) {\n\tuint next[MAXN] = { 0 };\n\n\tnext[0] = 0;\n\tfor (uint i = 1; i < pattern.length(); i++) {\n\t\tuint k = next[i - 1];\n\t\tchar ch = pattern[i];\n\n\t\twhile (k && pattern[k] != ch) {\n\t\t\tk = next[k - 1];\n\t\t}\n\n\t\tif (pattern[k] == ch) {\n\t\t\tnext[i] = k + 1;\n\t\t} else {\n\t\t\tnext[i] = 0;\n\t\t}\n\t}\n\n\tfor (uint i = 0; i < pattern.length(); i++) {\n\t\tcout << next[i] << endl;\n\t}\n\n\tuint i = 0, j = 0;\n\twhile (i < target.length() && j < pattern.length()) {\n\t\tif (target[i] == pattern[j]) {\n\t\t\ti++, j++;\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tj = next[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (j == pattern.length()) {\n\t\treturn i - j;\n\t} else {\n\t\treturn string::npos;\n\t}\n}\n\nint main() {\n\tstring target, pattern;\n\tcin >> target >> pattern;\n\tcout << KMP(target, pattern) << endl;\n\treturn 0;\n}\n```\n","slug":"kmp-notes","published":1,"updated":"2016-03-15T01:47:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n9m00c4ofdkgdhx66oa"},{"title":"「JSOI2008」最大数 - Splay","id":"56","updated":"2016-02-20T02:13:55.000Z","date":"2016-02-20T02:11:00.000Z","_content":"\n现在请求你维护一个数列，要求提供以下两种操作：\n\n1. 查询操作。  \n   语法：`Q L`  \n   功能：查询当前数列中末尾 `L` 个数中的最大的数，并输出这个数的值。  \n   限制：`L` 不超过当前数列的长度。\n2. 插入操作。\n   语法：`A n`  \n   功能：将 `n` 加上 `t`，其中 `t` 是最近一次查询操作的答案（如果还未执行过查询操作，则 `t = 0`)，并将所得结果对一个固定的常数 `D` 取模，将所得答案插入到数列的末尾。  \n   限制：`n` 是非负整数并且在长整范围内。\n\n注意：初始时数列是空的，没有一个数。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 1012](http://www.lydsy.com/JudgeOnline/problem.php?id=1012)\n\n### 解题思路\nSplay 裸题不用说了吧 ……\n\n话说开一棵大线段树也资磁吧？\n\n敲个 Splay 练练代码能力，结果折腾了俩小时，这段时间代码能力急剧下降啊！qwq\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXM = 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *parent, *child[2], **root;\n\t\tint value, max;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), bound(bound), size(1) {}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t\tmax = value;\n\t\t\tif (child[L] && !child[L]->bound) max = std::max(max, child[L]->max);\n\t\t\tif (child[R] && !child[R]->bound) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation r = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[r] = child[r ^ 1];\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\n\t\t\tchild[r ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid print(int depth = 0) {\n\t\t\tif (child[L]) child[L]->print(depth + 1);\n\t\t\tfor (int i = 0; i < depth; i++) putchar(' ');\n\t\t\t//printf(\"%d\\n\", value);\n\t\t\tif (child[R]) child[R]->print(depth + 1);\n\t\t}\n\t} *root;\n\n\tSplay() {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tvoid print() {\n\t\troot->print();\n\t\tputs(\"---------------------------\");\n\t}\n\n\tvoid buildBound(Relation r) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[r];\n\t\t}\n\n\t\t*v = new Node(parent, r == L ? -1 : 1, &root, true);\n\t}\n\n\tvoid append(const T &value) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tif (parent->bound && parent->value == 1) v = &parent->child[L];\n\t\t\telse v = &parent->child[R];\n\t\t}\n\n\t\t*v = new Node(parent, value, &root);\n\t\t//print();\n\t\t(*v)->splay();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (k != v->rank() + 1) {\n\t\t\t//printf(\"select(k = %d) in [%d] - { size = %d, rank = %d }\\n\", k, v->value, v->size, v->rank());\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *pred = select(l)->pred();\n\t\tNode *succ = select(r)->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(root);\n\t\treturn succ->child[L];\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\treturn select(l, r)->max;\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint m, p, lastAns;\nSplay<int> splay;\n\ninline char isVaild(char ch) {\n\treturn ch == 'A' || ch == 'Q';\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &p);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar cmd;\n\t\twhile (!isVaild(cmd = getchar()));\n\t\t//printf(\"cmd('%c')\\n\", cmd);\n\n\t\tif (cmd == 'A') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tsplay.append((n + lastAns) % p);\n\t\t} else {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n\n\t\t\tprintf(\"%d\\n\", lastAns = splay.queryMax(splay.size() - l + 1, splay.size()));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2008-maxnumber.md","raw":"title: 「JSOI2008」最大数 - Splay\ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - Splay\n  - 数据结构\n  - 高级数据结构\npermalink: jsoi2008-maxnumber\nid: 56\nupdated: '2016-02-20 10:13:55'\ndate: 2016-02-20 10:11:00\n---\n\n现在请求你维护一个数列，要求提供以下两种操作：\n\n1. 查询操作。  \n   语法：`Q L`  \n   功能：查询当前数列中末尾 `L` 个数中的最大的数，并输出这个数的值。  \n   限制：`L` 不超过当前数列的长度。\n2. 插入操作。\n   语法：`A n`  \n   功能：将 `n` 加上 `t`，其中 `t` 是最近一次查询操作的答案（如果还未执行过查询操作，则 `t = 0`)，并将所得结果对一个固定的常数 `D` 取模，将所得答案插入到数列的末尾。  \n   限制：`n` 是非负整数并且在长整范围内。\n\n注意：初始时数列是空的，没有一个数。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 1012](http://www.lydsy.com/JudgeOnline/problem.php?id=1012)\n\n### 解题思路\nSplay 裸题不用说了吧 ……\n\n话说开一棵大线段树也资磁吧？\n\n敲个 Splay 练练代码能力，结果折腾了俩小时，这段时间代码能力急剧下降啊！qwq\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXM = 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *parent, *child[2], **root;\n\t\tint value, max;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), bound(bound), size(1) {}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t\tmax = value;\n\t\t\tif (child[L] && !child[L]->bound) max = std::max(max, child[L]->max);\n\t\t\tif (child[R] && !child[R]->bound) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation r = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[r] = child[r ^ 1];\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\n\t\t\tchild[r ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid print(int depth = 0) {\n\t\t\tif (child[L]) child[L]->print(depth + 1);\n\t\t\tfor (int i = 0; i < depth; i++) putchar(' ');\n\t\t\t//printf(\"%d\\n\", value);\n\t\t\tif (child[R]) child[R]->print(depth + 1);\n\t\t}\n\t} *root;\n\n\tSplay() {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tvoid print() {\n\t\troot->print();\n\t\tputs(\"---------------------------\");\n\t}\n\n\tvoid buildBound(Relation r) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[r];\n\t\t}\n\n\t\t*v = new Node(parent, r == L ? -1 : 1, &root, true);\n\t}\n\n\tvoid append(const T &value) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tif (parent->bound && parent->value == 1) v = &parent->child[L];\n\t\t\telse v = &parent->child[R];\n\t\t}\n\n\t\t*v = new Node(parent, value, &root);\n\t\t//print();\n\t\t(*v)->splay();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (k != v->rank() + 1) {\n\t\t\t//printf(\"select(k = %d) in [%d] - { size = %d, rank = %d }\\n\", k, v->value, v->size, v->rank());\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *pred = select(l)->pred();\n\t\tNode *succ = select(r)->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(root);\n\t\treturn succ->child[L];\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\treturn select(l, r)->max;\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint m, p, lastAns;\nSplay<int> splay;\n\ninline char isVaild(char ch) {\n\treturn ch == 'A' || ch == 'Q';\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &p);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar cmd;\n\t\twhile (!isVaild(cmd = getchar()));\n\t\t//printf(\"cmd('%c')\\n\", cmd);\n\n\t\tif (cmd == 'A') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tsplay.append((n + lastAns) % p);\n\t\t} else {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n\n\t\t\tprintf(\"%d\\n\", lastAns = splay.queryMax(splay.size() - l + 1, splay.size()));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"jsoi2008-maxnumber","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n9q00cdofdkkf4zassw"},{"title":"「HNOI2004」宠物收养所 - set","id":"5","updated":"2016-01-19T13:08:01.000Z","date":"2015-12-15T21:14:20.000Z","_content":"\n有 `N`（<= 80000）个宠物或领养者，每个宠物或者领养者有一个特点值 `a`，每次当宠物或领养者到来时，从已有的当中匹配一个与其特点值相差最小（且特点值较小）的并删除，计算所有的领养特点值差的总和。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1285](http://codevs.cn/problem/1285/)  \n[BZOJ 1208](http://www.lydsy.com/JudgeOnline/problem.php?id=1208)  \n[Tyvj 1852](http://tyvj.cn/p/1852)\n\n### 解题思路\n匹配相差最小的元素，很容易联想到复杂度为$O({\\log} n)$的二分查找，但是题目要求动态插入删除，考虑使用 STL 中的 set。\n\n为宠物和领养者各维护一个 set，每当有新的到来时，从另一个 set 中 `lower_bound` 找出**第一个大于等于**该特点值的元素，该元素的上一个即为**第一个小于**该特点值的元素，取二者与新加入的特点值相差较小的即可。\n\n### AC 代码\n```cpp\n#include <cstdio>\n#include <set>\n#include <algorithm>\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nconst unsigned int MAXN = 80000;\nconst unsigned int p = 1000000;\n\nstd::set<unsigned int> pets, owners;\nunsigned int n, ans;\n\ninline unsigned int diff(unsigned int x, unsigned int y) {\n\treturn std::max(x, y) - std::min(x, y);\n}\n\ninline void add(unsigned int x, unsigned int y) {\n\tans = (ans + (diff(x, y) % p)) % p;\n}\n\ninline void solve(std::set<unsigned int> &set, unsigned int x) {\n\tif (set.size() == 1) {\n\t\tadd(x, *set.begin());\n\t\tset.clear();\n\t} else {\n\t\tstd::set<unsigned int>::const_iterator r = set.lower_bound(x);\n\n\t\tif (r == set.begin()) {\n\t\t\tadd(x, *r);\n\t\t\tset.erase(r);\n\t\t} else {\n\t\t\tstd::set<unsigned int>::const_iterator l = --set.lower_bound(x);\n\n\t\t\tif (r == set.end() || diff(x, *l) <= diff(x, *r)) {\n\t\t\t\tadd(x, *l);\n\t\t\t\tset.erase(l);\n\t\t\t} else {\n\t\t\t\tadd(x, *r);\n\t\t\t\tset.erase(r);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tread(n);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tregister unsigned int type, x;\n\t\tread(type), read(x);\n\n\t\tif (type == 0) { // pet\n\t\t\tif (owners.empty()) {\n\t\t\t\tpets.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(owners, x);\n\t\t\t}\n\t\t} else { // owner\n\t\t\tif (pets.empty()) {\n\t\t\t\towners.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(pets, x);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/hnoi2004-pet.md","raw":"title: 「HNOI2004」宠物收养所 - set\ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - HNOI\n  - set\n  - STL\npermalink: hnoi2004-pet\nid: 5\nupdated: '2016-01-19 21:08:01'\ndate: 2015-12-16 05:14:20\n---\n\n有 `N`（<= 80000）个宠物或领养者，每个宠物或者领养者有一个特点值 `a`，每次当宠物或领养者到来时，从已有的当中匹配一个与其特点值相差最小（且特点值较小）的并删除，计算所有的领养特点值差的总和。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1285](http://codevs.cn/problem/1285/)  \n[BZOJ 1208](http://www.lydsy.com/JudgeOnline/problem.php?id=1208)  \n[Tyvj 1852](http://tyvj.cn/p/1852)\n\n### 解题思路\n匹配相差最小的元素，很容易联想到复杂度为$O({\\log} n)$的二分查找，但是题目要求动态插入删除，考虑使用 STL 中的 set。\n\n为宠物和领养者各维护一个 set，每当有新的到来时，从另一个 set 中 `lower_bound` 找出**第一个大于等于**该特点值的元素，该元素的上一个即为**第一个小于**该特点值的元素，取二者与新加入的特点值相差较小的即可。\n\n### AC 代码\n```cpp\n#include <cstdio>\n#include <set>\n#include <algorithm>\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nconst unsigned int MAXN = 80000;\nconst unsigned int p = 1000000;\n\nstd::set<unsigned int> pets, owners;\nunsigned int n, ans;\n\ninline unsigned int diff(unsigned int x, unsigned int y) {\n\treturn std::max(x, y) - std::min(x, y);\n}\n\ninline void add(unsigned int x, unsigned int y) {\n\tans = (ans + (diff(x, y) % p)) % p;\n}\n\ninline void solve(std::set<unsigned int> &set, unsigned int x) {\n\tif (set.size() == 1) {\n\t\tadd(x, *set.begin());\n\t\tset.clear();\n\t} else {\n\t\tstd::set<unsigned int>::const_iterator r = set.lower_bound(x);\n\n\t\tif (r == set.begin()) {\n\t\t\tadd(x, *r);\n\t\t\tset.erase(r);\n\t\t} else {\n\t\t\tstd::set<unsigned int>::const_iterator l = --set.lower_bound(x);\n\n\t\t\tif (r == set.end() || diff(x, *l) <= diff(x, *r)) {\n\t\t\t\tadd(x, *l);\n\t\t\t\tset.erase(l);\n\t\t\t} else {\n\t\t\t\tadd(x, *r);\n\t\t\t\tset.erase(r);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tread(n);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tregister unsigned int type, x;\n\t\tread(type), read(x);\n\n\t\tif (type == 0) { // pet\n\t\t\tif (owners.empty()) {\n\t\t\t\tpets.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(owners, x);\n\t\t\t}\n\t\t} else { // owner\n\t\t\tif (pets.empty()) {\n\t\t\t\towners.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(pets, x);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"hnoi2004-pet","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n9t00clofdkpfj3uoeo"},{"title":"「HAOI2006」受欢迎的牛 - 强联通分量","date":"2016-03-04T13:28:17.000Z","_content":"\n每一头牛的愿望就是变成一头最受欢迎的牛。现在有 $ N $ 头牛，给你 $ M $ 对整数 $ (A,B) $，表示牛 $ A $ 认为牛 $ B $ 受欢迎。 这种关系是具有传递性的，如果 $ A $ 认为 $ B $ 受欢迎，$ B $ 认为 $ C $ 受欢迎，那么牛 $ A $ 也认为牛 $ C $ 受欢迎。你的任务是求出有多少头牛被所有的牛认为是受欢迎的。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 1051](http://www.lydsy.com/JudgeOnline/problem.php?id=1051)\n\n### 解题思路\n求出强联通分量，缩点，然后判断是不是只有一个出度为零的点，如果是输出它的大小。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 10000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) {\n\t\t\t\t\ts.push(e->to);\n\t\t\t\t\te->to->pushed = true;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t} else if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\tConnected *popular = contract(count);\n\n\tif (!popular) puts(\"-1\");\n\telse printf(\"%d\\n\", popular->size);\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2006-cow.md","raw":"title: 「HAOI2006」受欢迎的牛 - 强联通分量\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - 强联通分量\n  - Tarjan\n  - 缩点\npermalink: haoi2006-cow\ndate: 2016-03-04 21:28:17\n---\n\n每一头牛的愿望就是变成一头最受欢迎的牛。现在有 $ N $ 头牛，给你 $ M $ 对整数 $ (A,B) $，表示牛 $ A $ 认为牛 $ B $ 受欢迎。 这种关系是具有传递性的，如果 $ A $ 认为 $ B $ 受欢迎，$ B $ 认为 $ C $ 受欢迎，那么牛 $ A $ 也认为牛 $ C $ 受欢迎。你的任务是求出有多少头牛被所有的牛认为是受欢迎的。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 1051](http://www.lydsy.com/JudgeOnline/problem.php?id=1051)\n\n### 解题思路\n求出强联通分量，缩点，然后判断是不是只有一个出度为零的点，如果是输出它的大小。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 10000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) {\n\t\t\t\t\ts.push(e->to);\n\t\t\t\t\te->to->pushed = true;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t} else if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\tConnected *popular = contract(count);\n\n\tif (!popular) puts(\"-1\");\n\telse printf(\"%d\\n\", popular->size);\n\n\treturn 0;\n}\n```\n","slug":"haoi2006-cow","published":1,"updated":"2016-03-15T01:05:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4n9y00cuofdk0nbpk236"},{"title":"GDB 入门教程","id":"41","updated":"2016-02-05T02:59:41.000Z","date":"2016-02-05T02:58:07.000Z","_content":"\nGDB（GNU Debugger）是 GNU 计划中的标准调试器，可以在 UNIX、Linux 和 Windows 下运行，支持多种语言（如 C、C++、Pascal 等）程序的调试。\n\n<!-- more -->\n\n### 安装\n#### Linux\n在 Ubuntu 及其衍生版本下，使用 `apt` 安装 GDB。\n```bash\nsudo apt-get install gdb\n```\n另外，NOI Linux 也中有预装的 GDB。\n\n在 RHEL/Fedora/Archlinux 下，使用其各自的包管理器来安装 GDB。\n```bash\nsudo yum install gdb  # RHEL\nsudo dnf install gdb  # Fedora\nsudo pacman -S gdb    # Archlinux\n```\n\n#### Windows\n在 Windows 下，可选择 Cygwin/MSYS2 环境，也需使用其各自的包管理器来安装 GDB，但通常使用更加轻量的 MinGW 工具集。\n\n一般地，Dev-C++ 安装时会配带 MinGW，我们可以在其 `bin` 目录下找到 `gdb.exe`，为了方便，我们通常将 `bin` 目录的路径添加进 `PATH` 环境变量中，这样我们就可以直接在 `cmd` 中执行 `gdb` 命令。\n\n### 启动\n在控制台中输入 `gdb` 命令（Windows 系统有时需要手动配置环境变量），启动 GDB：\n```bash\ngdb\n```\n在 GDB 中，用 `file` 命令指定需要被调试的程序：\n```bash\n(gdb) file test\n```\n或者，也可以直接在启动 GDB 的时候指定需要被调试的程序：\n```bash\ngdb test\n```\n其中 `test` 为被调试的程序的可执行文件名。\n\n需要注意的是，被 GDB 调试的程序，**在编译时需要加上 `-g` 选项，表示在生成的可执行文件中包含调试信息**。\n```bash\ng++ test.cpp -o test -g\nfpc test.cpp -g\n```\nGDB 启动时的提示大概是酱紫的：\n```bash\nMenci@Menci-Laptop:~$ gdb\nGNU gdb (Ubuntu 7.10-1ubuntu2) 7.10\nCopyright (C) 2015 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\".\n(gdb) \n```\n\n### 运行\n使用 `run`（简写为 `r`）命令运行被调试的程序。\n```bash\n(gdb) run\n```\n之后可以像直接运行程序一样输入数据并获得输出，程序正常退出时，会得到类似于以下的提示：\n```bash\n[Inferior 1 (process 52800) exited with code 1]\n```\n如果程序出现运行时错误（Runtime Error，RE），则会有一下提示，此时程序中断（以访问无效内存为例）：\n```bash\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000000000400598 in main () at test.cpp:6\n6\t\taby[8999999999990] = 1;\n```\n其中 `SIGSEGV` 表示程序中断的信号，后面跟着解释文本“Segmentation fault”，即“段错误”。中间一行是程序中断所在函数及其调用参数，下面一行是程序中断所在行的代码，开头 `6` 为行号。\n\n出现这种情况时，我们可以使用各种调试命令对其进行调♂试。\n\n### 退出\n使用 `quit`（简写为 `q`）命令退出。\n\n如果程序正常运行结束，则 `q` 命令会成功退出 GDB，否则我们将会收到类似如下的提示：\n```bash\n(gdb) q\nA debugging session is active.\n\n\tInferior 1 [process 52800] will be killed.\n\nQuit anyway? (y or n) \n```\n这时候输入 `y` 后回车，可以强制杀死被调试的进行并退出 GDB。\n\n### 断点\n使用 `break`（简写为 `b`）命令设置断点，后跟一个行号或者函数名，之后程序会在执行到该行时中断。\n```bash\n(gdb) b 9\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n```bash\n(gdb) b main\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n`break` 命令也可以在断点位置后跟一个条件，仅当该条件为真时程序中断。\n```cpp\n#include <cstdio>\n\nint main() {\n\tint a;\n\tscanf(\"%d\", &a);\n\tprintf(\"%dn\", a);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6 if a == 528\n```\n使用 `r` 运行程序，当你输入 `528` 时，程序中断，否则程序继续运行。\n\nPascal 在设置条件断点时会有所不同，如这里的 `==` 需要改为 `=`。\n\n### 控制\n使用 `continue`（简写为 `c`）命令使中断的程序继续运行。\n\n注意，这里“中断的程序”指的是**通过断点中断**的程序，而不是**运行时错误**而中断的，如果我们强制让一个运行时错误的程序继续运行 …… 你猜它会怎样 ……\n\n使用 `step`（简写为 `s`）命令使中断的程序执行一行，如果该行有函数调用，程序将跟踪进入函数，在函数体的第一行中断。\n```cpp\nint foo() {\n\treturn 2333;\n}\n\nint main() {\n\tfoo();\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) s\nfoo () at test.cpp:2\n2\t\treturn 2333;\n```\n或者，你想让我用 Pascal 来演示一下的话，是酱紫的：\n```pascal\nProgram Test;\nFunction Foo(): Longint;\nBegin\n        Exit(2333);\nEnd;\nBegin\n        Foo();\nEnd.\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) s\nFOO () at test.pas:4\n4\t\tExit(2333);\n```\n使用 `next`（简写为 `n`）命令使中断的程序执行一行，如果该行有函数调用，程序将**不**跟踪进入函数，直接在下一行中断。\n\n源程序不变，执行效果如下：\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) n\n7\t\treturn 0;\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) n\n8\tEnd.\n```\n\n### 监视\n在 GDB 中，可以对表达式的值进行监视。\n\n使用 `print`（简写为 `p`）命令输出一个表达式的值，这里的表达式可以只是一个变量，也可以是包含了多个函数调用的复杂表达式。\n\n来看这个经典的 A + B 问题：\n```cpp\n#include <cstdio>\n\nint main() {\n\tint a, b;\n\tscanf(\"%d %d\", &a, &b);\n\tprintf(\"%dn\", a + b);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x400642: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n233 2333\n\nBreakpoint 1, main () at test.cpp:6\n6\t\tprintf(\"%dn\", a + b);\n(gdb) p a\n$1 = 233\n(gdb) p b\n$2 = 2333\n```\n使用 `display`（简写为 `disp`）命令持续监视某个表达式的值。\n```cpp\n#include <cstdio>\n\nint doSomething(int x) {\n\treturn x * 10;\n}\n\nint main() {\n\tint n = 10;\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"i = %dn\", i);\n\t}\n\treturn 0;\n}\n```\n```bash\n(gdb) b 10\nBreakpoint 1 at 0x400603: file test.cpp, line 10.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n(gdb) disp doSomething(i)\n1: doSomething(i) = 0\n(gdb) n\ni = 0\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 0\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 10\n(gdb) n\ni = 1\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 10\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 20\n(gdb) n\ni = 2\n```\n在 GDB 7.0 之后的版本，可以直接使用 `p` 命令输出 STL 容器的内容。\n\n### 栈\n在函数调用时，系统栈会储存函数的调用信息，使用 `backtrace`（简写为 `bt`）命令查看调用栈。\n\n为了方便演示，我们写一个使系统栈溢出的函数来演示。\n```cpp\nint fac(int x) {\n\tif (x == 0) return 1;\n\telse return x * fac(x - 1);\n}\n\nint main() {\n\tint x = fac(1000000000);\n\treturn 0;\n}\n```\n```bash\n(gdb) r\nStarting program: /home/Menci/test \n\nProgram received signal SIGSEGV, Segmentation fault.\n0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n3\t\telse return x * fac(x - 1);\n(gdb) bt\n#0  0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n#1  0x00000000004005aa in fac (x=999737954) at test.cpp:3\n#2  0x00000000004005aa in fac (x=999737955) at test.cpp:3\n#3  0x00000000004005aa in fac (x=999737956) at test.cpp:3\n#4  0x00000000004005aa in fac (x=999737957) at test.cpp:3\n#5  0x00000000004005aa in fac (x=999737958) at test.cpp:3\n```\n（以上省略 272043 行）\n\n`bt` 命令可以看到函数的调用信息，同时调用参数、调用位置（行号）也会被显示。\n\n使用 `frame` 命令切换正在调试的函数上下文。\n```cpp\nint a(int x) {\n\treturn x - 4;\n}\n\nint b(int x) {\n\treturn a(x * 3);\n}\n\nint c(int x) {\n\treturn b(x + 10);\n}\n\nint d(int x) {\n\treturn c(x / 2);\n}\n\nint main() {\n\tint x = d(4);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 2\nBreakpoint 1 at 0x400577: file test.cpp, line 2.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, a (x=36) at test.cpp:2\n2\t\treturn x - 4;\n(gdb) bt\n#0  a (x=36) at test.cpp:2\n#1  0x00000000004005a7 in b (x=12) at test.cpp:6\n#2  0x00000000004005c9 in c (x=2) at test.cpp:10\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n#4  0x0000000000400619 in main () at test.cpp:18\n(gdb) frame 3\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n14\t\treturn c(x / 2);\n(gdb) p x\n$1 = 4\n```\n从例子中我们看到，`frame 3` 命令使当前上下文切换到了 `d(x)` 函数中，此时 `p x` 输出的值为 `4`，与我们调用时所传递的值相同。\n\n`frame` 命令在调试在 STL 中崩溃的程序时有很大作用，我们需要切换到自己的函数的上下文中，而不是对 STL 进行调试。\n\n### 查看代码\n使用 `list`（简写为 `l`）命令查看部分代码，后跟一个行号，表示查看从该行开始若干行的代码。\n\n```bash\n(gdb) l 1\n1\tint a(int x) {\n2\t\treturn x - 4;\n3\t}\n4\t\n5\tint b(int x) {\n6\t\treturn a(x * 3);\n7\t}\n8\t\n9\tint c(int x) {\n10\t\treturn b(x + 10);\n```\n","source":"_posts/gnu-debugger.md","raw":"title: GDB 入门教程\ncategories: OI\ntags: \n  - GDB\n  - 调试\n  - C++\npermalink: gnu-debugger\nid: 41\nupdated: '2016-02-05 10:59:41'\ndate: 2016-02-05 10:58:07\n---\n\nGDB（GNU Debugger）是 GNU 计划中的标准调试器，可以在 UNIX、Linux 和 Windows 下运行，支持多种语言（如 C、C++、Pascal 等）程序的调试。\n\n<!-- more -->\n\n### 安装\n#### Linux\n在 Ubuntu 及其衍生版本下，使用 `apt` 安装 GDB。\n```bash\nsudo apt-get install gdb\n```\n另外，NOI Linux 也中有预装的 GDB。\n\n在 RHEL/Fedora/Archlinux 下，使用其各自的包管理器来安装 GDB。\n```bash\nsudo yum install gdb  # RHEL\nsudo dnf install gdb  # Fedora\nsudo pacman -S gdb    # Archlinux\n```\n\n#### Windows\n在 Windows 下，可选择 Cygwin/MSYS2 环境，也需使用其各自的包管理器来安装 GDB，但通常使用更加轻量的 MinGW 工具集。\n\n一般地，Dev-C++ 安装时会配带 MinGW，我们可以在其 `bin` 目录下找到 `gdb.exe`，为了方便，我们通常将 `bin` 目录的路径添加进 `PATH` 环境变量中，这样我们就可以直接在 `cmd` 中执行 `gdb` 命令。\n\n### 启动\n在控制台中输入 `gdb` 命令（Windows 系统有时需要手动配置环境变量），启动 GDB：\n```bash\ngdb\n```\n在 GDB 中，用 `file` 命令指定需要被调试的程序：\n```bash\n(gdb) file test\n```\n或者，也可以直接在启动 GDB 的时候指定需要被调试的程序：\n```bash\ngdb test\n```\n其中 `test` 为被调试的程序的可执行文件名。\n\n需要注意的是，被 GDB 调试的程序，**在编译时需要加上 `-g` 选项，表示在生成的可执行文件中包含调试信息**。\n```bash\ng++ test.cpp -o test -g\nfpc test.cpp -g\n```\nGDB 启动时的提示大概是酱紫的：\n```bash\nMenci@Menci-Laptop:~$ gdb\nGNU gdb (Ubuntu 7.10-1ubuntu2) 7.10\nCopyright (C) 2015 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\".\n(gdb) \n```\n\n### 运行\n使用 `run`（简写为 `r`）命令运行被调试的程序。\n```bash\n(gdb) run\n```\n之后可以像直接运行程序一样输入数据并获得输出，程序正常退出时，会得到类似于以下的提示：\n```bash\n[Inferior 1 (process 52800) exited with code 1]\n```\n如果程序出现运行时错误（Runtime Error，RE），则会有一下提示，此时程序中断（以访问无效内存为例）：\n```bash\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000000000400598 in main () at test.cpp:6\n6\t\taby[8999999999990] = 1;\n```\n其中 `SIGSEGV` 表示程序中断的信号，后面跟着解释文本“Segmentation fault”，即“段错误”。中间一行是程序中断所在函数及其调用参数，下面一行是程序中断所在行的代码，开头 `6` 为行号。\n\n出现这种情况时，我们可以使用各种调试命令对其进行调♂试。\n\n### 退出\n使用 `quit`（简写为 `q`）命令退出。\n\n如果程序正常运行结束，则 `q` 命令会成功退出 GDB，否则我们将会收到类似如下的提示：\n```bash\n(gdb) q\nA debugging session is active.\n\n\tInferior 1 [process 52800] will be killed.\n\nQuit anyway? (y or n) \n```\n这时候输入 `y` 后回车，可以强制杀死被调试的进行并退出 GDB。\n\n### 断点\n使用 `break`（简写为 `b`）命令设置断点，后跟一个行号或者函数名，之后程序会在执行到该行时中断。\n```bash\n(gdb) b 9\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n```bash\n(gdb) b main\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n`break` 命令也可以在断点位置后跟一个条件，仅当该条件为真时程序中断。\n```cpp\n#include <cstdio>\n\nint main() {\n\tint a;\n\tscanf(\"%d\", &a);\n\tprintf(\"%dn\", a);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6 if a == 528\n```\n使用 `r` 运行程序，当你输入 `528` 时，程序中断，否则程序继续运行。\n\nPascal 在设置条件断点时会有所不同，如这里的 `==` 需要改为 `=`。\n\n### 控制\n使用 `continue`（简写为 `c`）命令使中断的程序继续运行。\n\n注意，这里“中断的程序”指的是**通过断点中断**的程序，而不是**运行时错误**而中断的，如果我们强制让一个运行时错误的程序继续运行 …… 你猜它会怎样 ……\n\n使用 `step`（简写为 `s`）命令使中断的程序执行一行，如果该行有函数调用，程序将跟踪进入函数，在函数体的第一行中断。\n```cpp\nint foo() {\n\treturn 2333;\n}\n\nint main() {\n\tfoo();\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) s\nfoo () at test.cpp:2\n2\t\treturn 2333;\n```\n或者，你想让我用 Pascal 来演示一下的话，是酱紫的：\n```pascal\nProgram Test;\nFunction Foo(): Longint;\nBegin\n        Exit(2333);\nEnd;\nBegin\n        Foo();\nEnd.\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) s\nFOO () at test.pas:4\n4\t\tExit(2333);\n```\n使用 `next`（简写为 `n`）命令使中断的程序执行一行，如果该行有函数调用，程序将**不**跟踪进入函数，直接在下一行中断。\n\n源程序不变，执行效果如下：\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) n\n7\t\treturn 0;\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) n\n8\tEnd.\n```\n\n### 监视\n在 GDB 中，可以对表达式的值进行监视。\n\n使用 `print`（简写为 `p`）命令输出一个表达式的值，这里的表达式可以只是一个变量，也可以是包含了多个函数调用的复杂表达式。\n\n来看这个经典的 A + B 问题：\n```cpp\n#include <cstdio>\n\nint main() {\n\tint a, b;\n\tscanf(\"%d %d\", &a, &b);\n\tprintf(\"%dn\", a + b);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x400642: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n233 2333\n\nBreakpoint 1, main () at test.cpp:6\n6\t\tprintf(\"%dn\", a + b);\n(gdb) p a\n$1 = 233\n(gdb) p b\n$2 = 2333\n```\n使用 `display`（简写为 `disp`）命令持续监视某个表达式的值。\n```cpp\n#include <cstdio>\n\nint doSomething(int x) {\n\treturn x * 10;\n}\n\nint main() {\n\tint n = 10;\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"i = %dn\", i);\n\t}\n\treturn 0;\n}\n```\n```bash\n(gdb) b 10\nBreakpoint 1 at 0x400603: file test.cpp, line 10.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n(gdb) disp doSomething(i)\n1: doSomething(i) = 0\n(gdb) n\ni = 0\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 0\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 10\n(gdb) n\ni = 1\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 10\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 20\n(gdb) n\ni = 2\n```\n在 GDB 7.0 之后的版本，可以直接使用 `p` 命令输出 STL 容器的内容。\n\n### 栈\n在函数调用时，系统栈会储存函数的调用信息，使用 `backtrace`（简写为 `bt`）命令查看调用栈。\n\n为了方便演示，我们写一个使系统栈溢出的函数来演示。\n```cpp\nint fac(int x) {\n\tif (x == 0) return 1;\n\telse return x * fac(x - 1);\n}\n\nint main() {\n\tint x = fac(1000000000);\n\treturn 0;\n}\n```\n```bash\n(gdb) r\nStarting program: /home/Menci/test \n\nProgram received signal SIGSEGV, Segmentation fault.\n0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n3\t\telse return x * fac(x - 1);\n(gdb) bt\n#0  0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n#1  0x00000000004005aa in fac (x=999737954) at test.cpp:3\n#2  0x00000000004005aa in fac (x=999737955) at test.cpp:3\n#3  0x00000000004005aa in fac (x=999737956) at test.cpp:3\n#4  0x00000000004005aa in fac (x=999737957) at test.cpp:3\n#5  0x00000000004005aa in fac (x=999737958) at test.cpp:3\n```\n（以上省略 272043 行）\n\n`bt` 命令可以看到函数的调用信息，同时调用参数、调用位置（行号）也会被显示。\n\n使用 `frame` 命令切换正在调试的函数上下文。\n```cpp\nint a(int x) {\n\treturn x - 4;\n}\n\nint b(int x) {\n\treturn a(x * 3);\n}\n\nint c(int x) {\n\treturn b(x + 10);\n}\n\nint d(int x) {\n\treturn c(x / 2);\n}\n\nint main() {\n\tint x = d(4);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 2\nBreakpoint 1 at 0x400577: file test.cpp, line 2.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, a (x=36) at test.cpp:2\n2\t\treturn x - 4;\n(gdb) bt\n#0  a (x=36) at test.cpp:2\n#1  0x00000000004005a7 in b (x=12) at test.cpp:6\n#2  0x00000000004005c9 in c (x=2) at test.cpp:10\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n#4  0x0000000000400619 in main () at test.cpp:18\n(gdb) frame 3\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n14\t\treturn c(x / 2);\n(gdb) p x\n$1 = 4\n```\n从例子中我们看到，`frame 3` 命令使当前上下文切换到了 `d(x)` 函数中，此时 `p x` 输出的值为 `4`，与我们调用时所传递的值相同。\n\n`frame` 命令在调试在 STL 中崩溃的程序时有很大作用，我们需要切换到自己的函数的上下文中，而不是对 STL 进行调试。\n\n### 查看代码\n使用 `list`（简写为 `l`）命令查看部分代码，后跟一个行号，表示查看从该行开始若干行的代码。\n\n```bash\n(gdb) l 1\n1\tint a(int x) {\n2\t\treturn x - 4;\n3\t}\n4\t\n5\tint b(int x) {\n6\t\treturn a(x * 3);\n7\t}\n8\t\n9\tint c(int x) {\n10\t\treturn b(x + 10);\n```\n","slug":"gnu-debugger","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4na200d2ofdkmomcpjl5"},{"title":"Edmonds-Karp 费用流学习笔记","date":"2016-02-19T09:04:38.000Z","_content":"\n有一类网络流问题，最大流并不唯一，而每一条边都有一个单位流量的费用，最优解的目标是保证流量最大的前提下使总费用最小。单纯的最大流可以使用 Edmonds-Karp 算法求解，但这个算法不够优，最常用的是 Dinic 算法。但 Edmonds-Karp 确是最小费用流问题最常用的算法。\n\n<!-- more -->\n\n### 定义\n费用（`cost`）：单位流量流过一条边需要支付的费用，算法的目标是使总流量最大的前提下总费用最小。\n\n其他的定义和 Dinic 中基本相同，但 Edmonds-Karp 中没有『层次』和『层次图』的概念。\n\nEdmonds-Karp 的反向边的费用是原边的费用相反数。\n\n### 算法\n1. 在残量网络中以『费用』为距离，沿着未满流边找出一条从源点到汇点的最短路，并进行增广。\n2. 增广时将总费用加上**汇点的距离** × **增广流量**。\n3. 无法找到增广路时算法结束，此时已找出网络的最小费用最大流。\n\n找最短路时，一般使用 Bellman-Ford 算法，因为网络中一般都会存在负权边，而不可能有负环——当有负环时，最小费用最大流不存在。\n\nEdmonds-Karp 基于一个事实：如果当前费用是在当前流量下的最小费用，那么以最小费用增广之后的费用也为增广后的流量下的最小费用。不断增广找到的就是最小费用最大流。\n\n### 代码实现\n```cpp\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), cost(cost), flow(0), next(from->firstEdge) {}\n};\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Node *v = t; v != s; v = v->inEdge->from) {\n\t\t\tv->inEdge->flow += t->flow;\n\t\t\tv->inEdge->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tcost += t->dist * t->flow;\n\t\tflow += t->flow;\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n```\n","source":"_posts/edmonds-karp-notes.md","raw":"title: Edmonds-Karp 费用流学习笔记\ncategories: OI\ntags: \n  - 图论\n  - 网络流\n  - 费用流\n  - Edmonds-Karp\n  - 学习笔记\n  - 算法模板  \npermalink: edmonds-karp-notes\ndate: 2016-02-19 17:04:38\n---\n\n有一类网络流问题，最大流并不唯一，而每一条边都有一个单位流量的费用，最优解的目标是保证流量最大的前提下使总费用最小。单纯的最大流可以使用 Edmonds-Karp 算法求解，但这个算法不够优，最常用的是 Dinic 算法。但 Edmonds-Karp 确是最小费用流问题最常用的算法。\n\n<!-- more -->\n\n### 定义\n费用（`cost`）：单位流量流过一条边需要支付的费用，算法的目标是使总流量最大的前提下总费用最小。\n\n其他的定义和 Dinic 中基本相同，但 Edmonds-Karp 中没有『层次』和『层次图』的概念。\n\nEdmonds-Karp 的反向边的费用是原边的费用相反数。\n\n### 算法\n1. 在残量网络中以『费用』为距离，沿着未满流边找出一条从源点到汇点的最短路，并进行增广。\n2. 增广时将总费用加上**汇点的距离** × **增广流量**。\n3. 无法找到增广路时算法结束，此时已找出网络的最小费用最大流。\n\n找最短路时，一般使用 Bellman-Ford 算法，因为网络中一般都会存在负权边，而不可能有负环——当有负环时，最小费用最大流不存在。\n\nEdmonds-Karp 基于一个事实：如果当前费用是在当前流量下的最小费用，那么以最小费用增广之后的费用也为增广后的流量下的最小费用。不断增广找到的就是最小费用最大流。\n\n### 代码实现\n```cpp\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), cost(cost), flow(0), next(from->firstEdge) {}\n};\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Node *v = t; v != s; v = v->inEdge->from) {\n\t\t\tv->inEdge->flow += t->flow;\n\t\t\tv->inEdge->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tcost += t->dist * t->flow;\n\t\tflow += t->flow;\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n```\n","slug":"edmonds-karp-notes","published":1,"updated":"2016-03-15T01:46:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4na700d9ofdk0qnx4cda"},{"title":"Dinic 学习笔记","date":"2016-02-03T10:57:59.000Z","_content":"\nDinic 算法是一种对于网络流问题的增广路算法，它通过对残量网络进行分层，并在层次图上寻找增广路的方式，实现了在$ O(n^2m) $的时间内求出网络的最大流。\n\n<!-- more -->\n\n### 定义\n* 容量：`capacity(e)` 表示一条有向边 `e(u, v)` 的最大允许的流量。\n\n* 流量：`flow(e)` 表示一条有向边 `e(u, v)` 总容量中已被占用的流量。\n\n* 剩余容量：即 `capacity(e) - flow(e)`，表示当前时刻某条有向边 `e(u, v)` 总流量中未被占用的部分。\n\n* 反向边：原图中每一条有向边在残量网络中都有对应的反向边，反向边的容量为 0，容量的变化与原边相反；『反向边』的概念是相对的，即一条边的反向边的反向边是它本身。\n\n* 残量网络：在原图的基础之上，添加每条边对应的反向边，并储存每条边的当前流量。残量网络会在算法进行的过程中被修改。\n\n* 增广路（augmenting path）：残量网络中从源点到汇点的一条路径，增广路上所有边中最小的剩余流量为**增广流量**。\n\n* 增广（augmenting）：在残量网络中寻找一条增广路，并将增广路上所有边的流量加上**增广流量**的过程。\n\n* 层次： `level(u)` 表示节点 `u` 在层次图中与源点的距离。\n\n* 层次图：在原残量网络中按照每个节点的层次来分层，只保留**相邻两层**的节点的图，**满载（即流量等于容量）的边不存在于层次图中**。\n\n### 算法\n1. 遍历残量网络，建立层次图；\n2. 在层次图上寻找任意一条增广路，进行增广，并将答案加上增广流量；\n3. 重复 `(2)`，直至层次图中不存在增广路，回到 `(1)` 重新建立层次图；\n4. 直到层次图无法建立，则当前流量即为最大流量。\n\n每次建立层次图后都可以进行多次增广，无法增广时重新建立层次图，此时的层次图不再包含之前进行增广后满载的边。无法建立层次图时，说明源点到汇点的任意一条简单路径中，都至少有一条边满载，这也在直观上验证了最小割最大流定理。\n\n### 优化\nDinic 有一个常见的优化——当前弧优化。\n\n该优化基于一个显而易见的事实，每次建立层次图后，如果在某一次增广前，某个点有一条边增广过了，则这条边在当前的层次图中不会再用到了，即下一次 DFS 这个点的时候直接可以从这条边的下一条边开始。\n\n### 代码实现\n```cpp\nstruct Node {\n\tstruct Edge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), next(from->firstEdge), flow(0) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0, nodes[i].currentEdge = nodes[i].firstEdge;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n```\n","source":"_posts/dinic-notes.md","raw":"title: Dinic 学习笔记\ncategories: OI\ntags: \n  - 学习笔记\n  - 图论\n  - 网络流\n  - Dinic\n  - 算法模板  \npermalink: dinic-notes\ndate: 2016-02-03 18:57:59\n---\n\nDinic 算法是一种对于网络流问题的增广路算法，它通过对残量网络进行分层，并在层次图上寻找增广路的方式，实现了在$ O(n^2m) $的时间内求出网络的最大流。\n\n<!-- more -->\n\n### 定义\n* 容量：`capacity(e)` 表示一条有向边 `e(u, v)` 的最大允许的流量。\n\n* 流量：`flow(e)` 表示一条有向边 `e(u, v)` 总容量中已被占用的流量。\n\n* 剩余容量：即 `capacity(e) - flow(e)`，表示当前时刻某条有向边 `e(u, v)` 总流量中未被占用的部分。\n\n* 反向边：原图中每一条有向边在残量网络中都有对应的反向边，反向边的容量为 0，容量的变化与原边相反；『反向边』的概念是相对的，即一条边的反向边的反向边是它本身。\n\n* 残量网络：在原图的基础之上，添加每条边对应的反向边，并储存每条边的当前流量。残量网络会在算法进行的过程中被修改。\n\n* 增广路（augmenting path）：残量网络中从源点到汇点的一条路径，增广路上所有边中最小的剩余流量为**增广流量**。\n\n* 增广（augmenting）：在残量网络中寻找一条增广路，并将增广路上所有边的流量加上**增广流量**的过程。\n\n* 层次： `level(u)` 表示节点 `u` 在层次图中与源点的距离。\n\n* 层次图：在原残量网络中按照每个节点的层次来分层，只保留**相邻两层**的节点的图，**满载（即流量等于容量）的边不存在于层次图中**。\n\n### 算法\n1. 遍历残量网络，建立层次图；\n2. 在层次图上寻找任意一条增广路，进行增广，并将答案加上增广流量；\n3. 重复 `(2)`，直至层次图中不存在增广路，回到 `(1)` 重新建立层次图；\n4. 直到层次图无法建立，则当前流量即为最大流量。\n\n每次建立层次图后都可以进行多次增广，无法增广时重新建立层次图，此时的层次图不再包含之前进行增广后满载的边。无法建立层次图时，说明源点到汇点的任意一条简单路径中，都至少有一条边满载，这也在直观上验证了最小割最大流定理。\n\n### 优化\nDinic 有一个常见的优化——当前弧优化。\n\n该优化基于一个显而易见的事实，每次建立层次图后，如果在某一次增广前，某个点有一条边增广过了，则这条边在当前的层次图中不会再用到了，即下一次 DFS 这个点的时候直接可以从这条边的下一条边开始。\n\n### 代码实现\n```cpp\nstruct Node {\n\tstruct Edge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), next(from->firstEdge), flow(0) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0, nodes[i].currentEdge = nodes[i].firstEdge;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n```\n","slug":"dinic-notes","published":1,"updated":"2016-03-15T01:46:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nad00dhofdke14lfqsb"},{"title":"树链剖分学习笔记","date":"2015-12-27T14:48:11.000Z","_content":"\n树链剖分，就是把一棵树咔嚓咔嚓剖成一堆不相交的链，然后在链上结合搞基数据结构进行各种查询或者修改操作。\n\n<!-- more -->\n\n### 题目：树的统计\n[CodeVS 2460](http://codevs.cn/problem/2460/)  \n[BZOJ 1036](http://www.lydsy.com/JudgeOnline/problem.php?id=1036)  \n\n给出一棵树，每个点有一个可修改的点权，每次查询两点之间**所有点**的点权和或点权最大值。\n\n### 基本思想\n![CutTree](cut-tree-notes/cutTree.png)\n\n把整棵树划分成许多条**链**，使每个节点都在唯一的链上，对每一条链维护一棵**线段树**，把在树上的操作转移到线段树上。\n\n具体剖的话，这里采用**轻重边路径剖分**的方式，剖最大子树，这样可以保证整棵树上的轻边和链的数量都不超过 $O({\\log}n)$。\n\n### 定义\n```cpp\nstruct Tree {\n\tstruct Path *path;\n\tTree *parent, *children, *maxSizeChild, *next;\n\tuint size, depth, maxDepth, pos;\n\tint w;\n\n\tbool visited;\n\n\tTree() {}\n\tTree(Tree *parent) : parent(parent), depth(!parent ? 0 : parent->depth + 1), next(!parent ? NULL : parent->children), path(NULL), w(0), children(NULL), maxSizeChild(NULL) {}\n} treeNodes[MAXN], *root;\n\nstruct Path {\n\tSegmentTree *segmentTree;\n\tTree *top;\n\n\tPath(struct Tree *top, uint count) : top(top), segmentTree(new SegmentTree(0, count - 1)) {}\n};\n```\n\n对于每个节点，`depth` 表示这个节点的深度（即到整棵树的根的距离），`size` 表示以这个节点为根的树的大小（即节点总数），`maxSizeChild` 表示该节点的最大子树，`maxDepth` 表示自当前节点向下沿着 `maxSizeChild` 走，走到的最大深度，即链的最底端节点的深度。\n\n每个节点都在一条链上，我们把这些链叫做路径（Path），每条路径的最顶端点（深度最小的）称为链顶节点 `top`，并且为路径上的所有节点维护一棵线段树，而每个节点的 `pos` 表示自己在自己的路径上的编号。\n\n### 剖分\n剖分的过程主要由两次搜索组成，首先，我们来一遍 `DFS`，求出每个节点的 `maxSizeChild` 和 `maxDepth`。\n\n```cpp\nstack<Tree *> s;\n\ns.push(root);\nwhile (!s.empty()) {\n\tTree *tree = s.top();\n\tif (tree->visited) {\n\t\ttree->size = 1;\n\t\ttree->maxDepth = tree->depth;\n\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\ttree->size += child->size;\n\t\t\tif (tree->maxSizeChild == NULL || tree->maxSizeChild->size < child->size) {\n\t\t\t\ttree->maxSizeChild = child;\n\t\t\t\ttree->maxDepth = child->maxDepth;\n\t\t\t}\n\t\t}\n\n\t\ts.pop();\n\t} else {\n\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\ts.push(child);\n\t\t}\n\n\t\ttree->visited = true;\n\t}\n}\n```\n\n然后，我们用第二遍搜索来把每一条链连接起来，`DFS` 和 `BFS` 都可以，因为 `BFS` 好写就用 `BFS` 吧 ……\n\n对于每个节点，如果它是根或它不是父节点的 `maxDepthChild`，则我们创建一条从该节点开始的链，否则该节点所在链即为父节点所在链。\n\n```cpp\nqueue<Tree *> q;\n\nq.push(root);\nwhile (!q.empty()) {\n\tTree *tree = q.front();\n\tq.pop();\n\n\tif (tree == root || tree != tree->parent->maxSizeChild) {\n\t\ttree->path = new Path(tree, tree->maxDepth - tree->depth + 1);\n\t\ttree->pos = 0;\n\t} else {\n\t\ttree->path = tree->parent->path;\n\t\ttree->pos = tree->parent->pos + 1;\n\t}\n\n\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\tq.push(child);\n\t}\n}\n```\n\n最后，在线段树上更新每个点的权值：\n\n```cpp\nfor (uint i = 0; i < n; i++) {\n\ttreeNodes[i].path->segmentTree->update(treeNodes[i].pos, treeNodes[i].w);\n}\n```\n\n### 修改\n修改某个点的权值，只需要在该节点所在链上的线段树中更新即可。\n\n```cpp\ninline void update(uint x, uint w) {\n\ttreeNodes[x].path->segmentTree->update(treeNodes[x].pos, w);\n}\n```\n\n### 查询\n查询两个点 `[u, v]` 之间的点权和（或点权极值）的思路如下：\n\n1. 如果 `u` 与 `v` 不同一条链上，则使二者中**所在链链顶节点**深度最小的一个跳到**所在链链顶节点**的父节点位置，继续回到 1；\n2. 如果 `u` 与 `v` 在同一条链上，则直接从线段树中查询。\n\n```cpp\ninline int querySum(uint u, uint v) {\n\tint result = 0;\n\tTree *a = &treeNodes[u], *b = &treeNodes[v];\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) {\n\t\t\tswap(a, b);\n\t\t}\n\n\t\tresult += a->path->segmentTree->querySum(0, a->pos);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) {\n\t\tswap(a, b);\n\t}\n\n\tresult += a->path->segmentTree->querySum(a->pos, b->pos);\n\treturn result;\n}\n```\n\n### 附：无根树转有根树\n为了剖分时更容易一些，我们可以把读入的无根树转化成有根树，这样搜索的时候方便点，当然常数也会大一些 ……\n\n```cpp\ninline void convert() {\n\tqueue<Node *> q;\n\troot = &treeNodes[0];\n\tnew (root) Tree(NULL);\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tnode->visited = true;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\ttreeNodes[node->id].children = new (&treeNodes[edge->to->id]) Tree(&treeNodes[node->id]);\n\t\t\t\tq.push(edge->to);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### 附：线段树\n我们使用线段树来维护每一条链，这里只用到了单点修改，也可以换成树状数组或者 zkw 线段树。\n\n```cpp\nstruct SegmentTree {\n\tstruct Node {\n\t\tstruct Node *lchild, *rchild;\n\t\tuint l, r;\n\t\tint sum, max;\n\n\t\tNode(uint l, uint r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), sum(0), max(0) {}\n\n\t\tvoid update(uint x, int value) {\n\t\t\tif (x > r || x < l) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (x == l && x == r) {\n\t\t\t\tsum = max = value;\n\t\t\t} else {\n\t\t\t\tmax = INT_MIN, sum = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, lchild->max);\n\t\t\t\t\tsum += lchild->sum;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, rchild->max);\n\t\t\t\t\tsum += rchild->sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint querySum(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn sum;\n\t\t\t} else {\n\t\t\t\tint result = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult += lchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult += rchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tint queryMax(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn INT_MIN;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn max;\n\t\t\t} else {\n\t\t\t\tint result = INT_MIN;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult = std::max(result, lchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult = std::max(result, rchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(uint l, uint r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(uint l, uint r) {\n\t\tif (r < l) {\n\t\t\treturn NULL;\n\t\t} else if (r == l) {\n\t\t\treturn new Node(l, r, NULL, NULL);\n\t\t} else {\n\t\t\tuint mid = (l + ((r - l) >> 1));\n\t\t\treturn new Node(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n\n\tvoid update(uint x, int value) {\n\t\troot->update(x, value);\n\t}\n\n\tint querySum(uint l, uint r) {\n\t\treturn root->querySum(l, r);\n\t}\n\n\tint queryMax(uint l, uint r) {\n\t\treturn root->queryMax(l, r);\n\t}\n};\n```\n### 完整代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing std::queue;\nusing std::stack;\nusing std::swap;\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 30000;\n\nstruct Node {\n\tstruct Edge *edges;\n\tuint id;\n\tbool visited;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, Edge *next) : from(from), to(to), next(next) {}\n};\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tstruct Node *lchild, *rchild;\n\t\tuint l, r;\n\t\tint sum, max;\n\n\t\tNode(uint l, uint r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), sum(0), max(0) {}\n\n\t\tvoid update(uint x, int value) {\n\t\t\tif (x > r || x < l) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (x == l && x == r) {\n\t\t\t\tsum = max = value;\n\t\t\t} else {\n\t\t\t\tmax = INT_MIN, sum = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, lchild->max);\n\t\t\t\t\tsum += lchild->sum;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, rchild->max);\n\t\t\t\t\tsum += rchild->sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint querySum(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn sum;\n\t\t\t} else {\n\t\t\t\tint result = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult += lchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult += rchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tint queryMax(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn INT_MIN;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn max;\n\t\t\t} else {\n\t\t\t\tint result = INT_MIN;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult = std::max(result, lchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult = std::max(result, rchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(uint l, uint r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(uint l, uint r) {\n\t\tif (r < l) {\n\t\t\treturn NULL;\n\t\t} else if (r == l) {\n\t\t\treturn new Node(l, r, NULL, NULL);\n\t\t} else {\n\t\t\tuint mid = (l + ((r - l) >> 1));\n\t\t\treturn new Node(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n\n\tvoid update(uint x, int value) {\n\t\troot->update(x, value);\n\t}\n\n\tint querySum(uint l, uint r) {\n\t\treturn root->querySum(l, r);\n\t}\n\n\tint queryMax(uint l, uint r) {\n\t\treturn root->queryMax(l, r);\n\t}\n};\n\nstruct Tree {\n\tstruct Path *path;\n\tTree *parent, *children, *maxSizeChild, *next;\n\tuint size, depth, maxDepth, pos;\n\tint w;\n\n\tbool visited;\n\n\tTree() {}\n\tTree(Tree *parent) : parent(parent), depth(!parent ? 0 : parent->depth + 1), next(!parent ? NULL : parent->children), path(NULL), w(0), children(NULL), maxSizeChild(NULL) {}\n} treeNodes[MAXN], *root;\n\nstruct Path {\n\tSegmentTree *segmentTree;\n\tTree *top;\n\n\tPath(struct Tree *top, uint count) : top(top), segmentTree(new SegmentTree(0, count - 1)) {}\n};\n\nuint n, q;\n\ninline void addEdge(uint a, uint b) {\n\tnodes[a].edges = new Edge(&nodes[a], &nodes[b], nodes[a].edges);\n\tnodes[b].edges = new Edge(&nodes[b], &nodes[a], nodes[b].edges);\n}\n\ninline void convert() {\n\tqueue<Node *> q;\n\troot = &treeNodes[0];\n\tnew (root) Tree(NULL);\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tnode->visited = true;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\ttreeNodes[node->id].children = new (&treeNodes[edge->to->id]) Tree(&treeNodes[node->id]);\n\t\t\t\tq.push(edge->to);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void cut() {\n\tstack<Tree *> s;\n\n\ts.push(root);\n\twhile (!s.empty()) {\n\t\tTree *tree = s.top();\n\t\tif (tree->visited) {\n\t\t\ttree->size = 1;\n\t\t\ttree->maxDepth = tree->depth;\n\t\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\t\ttree->size += child->size;\n\t\t\t\tif (tree->maxSizeChild == NULL || tree->maxSizeChild->size < child->size) {\n\t\t\t\t\ttree->maxSizeChild = child;\n\t\t\t\t\ttree->maxDepth = child->maxDepth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t} else {\n\t\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\t\ts.push(child);\n\t\t\t}\n\n\t\t\ttree->visited = true;\n\t\t}\n\t}\n\nqueue<Tree *> q;\n\nq.push(root);\nwhile (!q.empty()) {\n\tTree *tree = q.front();\n\tq.pop();\n\n\tif (tree == root || tree != tree->parent->maxSizeChild) {\n\t\ttree->path = new Path(tree, tree->maxDepth - tree->depth + 1);\n\t\ttree->pos = 0;\n\t} else {\n\t\ttree->path = tree->parent->path;\n\t\ttree->pos = tree->parent->pos + 1;\n\t}\n\n\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\tq.push(child);\n\t}\n}\n\n\tfor (uint i = 0; i < n; i++) {\n\t\ttreeNodes[i].path->segmentTree->update(treeNodes[i].pos, treeNodes[i].w);\n\t}\n}\n\ninline void update(uint x, uint w) {\n\ttreeNodes[x].w = w;\n\ttreeNodes[x].path->segmentTree->update(treeNodes[x].pos, w);\n}\n\ninline int querySum(uint u, uint v) {\n\tint result = 0;\n\tTree *a = &treeNodes[u], *b = &treeNodes[v];\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) {\n\t\t\tswap(a, b);\n\t\t}\n\n\t\tresult += a->path->segmentTree->querySum(0, a->pos);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) {\n\t\tswap(a, b);\n\t}\n\n\tresult += a->path->segmentTree->querySum(a->pos, b->pos);\n\treturn result;\n}\n\ninline int queryMax(uint u, uint v) {\n\tint result = INT_MIN;\n\tTree *a = &treeNodes[u], *b = &treeNodes[v];\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) {\n\t\t\tswap(a, b);\n\t\t}\n\n\t\tresult = std::max(result, a->path->segmentTree->queryMax(0, a->pos));\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) {\n\t\tswap(a, b);\n\t}\n\n\tresult = std::max(result, a->path->segmentTree->queryMax(a->pos, b->pos));\n\treturn result;\n}\n\nint main() {\n\tscanf(\"%u\", &n);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tnodes[i].id = i;\n\t}\n\n\tfor (uint i = 0; i < n - 1; i++) {\n\t\tuint a, b;\n\t\tscanf(\"%u %u\", &a, &b);\n\t\ta--, b--;\n\n\t\taddEdge(a, b);\n\t}\n\n\tconvert();\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tuint w;\n\t\tscanf(\"%u\", &w);\n\t\ttreeNodes[i].w = w;\n\t}\n\n\tcut();\n\n\tscanf(\"%u\", &q);\n\n\tfor (uint i = 0; i < q; i++) {\n\t\tchar command[6 + 1];\n\t\tscanf(\"%s\", command);\n\t\tif (command[1] == 'H') { // CHANGE\n\t\t\tuint x;\n\t\t\tint w;\n\t\t\tscanf(\"%u %d\", &x, &w);\n\t\t\tx--;\n\n\t\t\tupdate(x, w);\n\t\t} else {\n\t\t\tuint u, v;\n\t\t\tscanf(\"%u %u\", &u, &v);\n\t\t\tu--, v--;\n\n\t\t\tif (command[1] == 'M') { // QMAX\n\t\t\t\tprintf(\"%d\\n\", queryMax(u, v));\n\t\t\t} else { // QSUM\n\t\t\t\tprintf(\"%d\\n\", querySum(u, v));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/cut-tree-notes.md","raw":"title: 树链剖分学习笔记\ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - 数据结构\n  - 树链剖分\n  - 高级数据结构\n  - 算法模板  \npermalink: cut-tree-notes\ndate: 2015-12-27 22:48:11\n---\n\n树链剖分，就是把一棵树咔嚓咔嚓剖成一堆不相交的链，然后在链上结合搞基数据结构进行各种查询或者修改操作。\n\n<!-- more -->\n\n### 题目：树的统计\n[CodeVS 2460](http://codevs.cn/problem/2460/)  \n[BZOJ 1036](http://www.lydsy.com/JudgeOnline/problem.php?id=1036)  \n\n给出一棵树，每个点有一个可修改的点权，每次查询两点之间**所有点**的点权和或点权最大值。\n\n### 基本思想\n![CutTree](cut-tree-notes/cutTree.png)\n\n把整棵树划分成许多条**链**，使每个节点都在唯一的链上，对每一条链维护一棵**线段树**，把在树上的操作转移到线段树上。\n\n具体剖的话，这里采用**轻重边路径剖分**的方式，剖最大子树，这样可以保证整棵树上的轻边和链的数量都不超过 $O({\\log}n)$。\n\n### 定义\n```cpp\nstruct Tree {\n\tstruct Path *path;\n\tTree *parent, *children, *maxSizeChild, *next;\n\tuint size, depth, maxDepth, pos;\n\tint w;\n\n\tbool visited;\n\n\tTree() {}\n\tTree(Tree *parent) : parent(parent), depth(!parent ? 0 : parent->depth + 1), next(!parent ? NULL : parent->children), path(NULL), w(0), children(NULL), maxSizeChild(NULL) {}\n} treeNodes[MAXN], *root;\n\nstruct Path {\n\tSegmentTree *segmentTree;\n\tTree *top;\n\n\tPath(struct Tree *top, uint count) : top(top), segmentTree(new SegmentTree(0, count - 1)) {}\n};\n```\n\n对于每个节点，`depth` 表示这个节点的深度（即到整棵树的根的距离），`size` 表示以这个节点为根的树的大小（即节点总数），`maxSizeChild` 表示该节点的最大子树，`maxDepth` 表示自当前节点向下沿着 `maxSizeChild` 走，走到的最大深度，即链的最底端节点的深度。\n\n每个节点都在一条链上，我们把这些链叫做路径（Path），每条路径的最顶端点（深度最小的）称为链顶节点 `top`，并且为路径上的所有节点维护一棵线段树，而每个节点的 `pos` 表示自己在自己的路径上的编号。\n\n### 剖分\n剖分的过程主要由两次搜索组成，首先，我们来一遍 `DFS`，求出每个节点的 `maxSizeChild` 和 `maxDepth`。\n\n```cpp\nstack<Tree *> s;\n\ns.push(root);\nwhile (!s.empty()) {\n\tTree *tree = s.top();\n\tif (tree->visited) {\n\t\ttree->size = 1;\n\t\ttree->maxDepth = tree->depth;\n\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\ttree->size += child->size;\n\t\t\tif (tree->maxSizeChild == NULL || tree->maxSizeChild->size < child->size) {\n\t\t\t\ttree->maxSizeChild = child;\n\t\t\t\ttree->maxDepth = child->maxDepth;\n\t\t\t}\n\t\t}\n\n\t\ts.pop();\n\t} else {\n\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\ts.push(child);\n\t\t}\n\n\t\ttree->visited = true;\n\t}\n}\n```\n\n然后，我们用第二遍搜索来把每一条链连接起来，`DFS` 和 `BFS` 都可以，因为 `BFS` 好写就用 `BFS` 吧 ……\n\n对于每个节点，如果它是根或它不是父节点的 `maxDepthChild`，则我们创建一条从该节点开始的链，否则该节点所在链即为父节点所在链。\n\n```cpp\nqueue<Tree *> q;\n\nq.push(root);\nwhile (!q.empty()) {\n\tTree *tree = q.front();\n\tq.pop();\n\n\tif (tree == root || tree != tree->parent->maxSizeChild) {\n\t\ttree->path = new Path(tree, tree->maxDepth - tree->depth + 1);\n\t\ttree->pos = 0;\n\t} else {\n\t\ttree->path = tree->parent->path;\n\t\ttree->pos = tree->parent->pos + 1;\n\t}\n\n\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\tq.push(child);\n\t}\n}\n```\n\n最后，在线段树上更新每个点的权值：\n\n```cpp\nfor (uint i = 0; i < n; i++) {\n\ttreeNodes[i].path->segmentTree->update(treeNodes[i].pos, treeNodes[i].w);\n}\n```\n\n### 修改\n修改某个点的权值，只需要在该节点所在链上的线段树中更新即可。\n\n```cpp\ninline void update(uint x, uint w) {\n\ttreeNodes[x].path->segmentTree->update(treeNodes[x].pos, w);\n}\n```\n\n### 查询\n查询两个点 `[u, v]` 之间的点权和（或点权极值）的思路如下：\n\n1. 如果 `u` 与 `v` 不同一条链上，则使二者中**所在链链顶节点**深度最小的一个跳到**所在链链顶节点**的父节点位置，继续回到 1；\n2. 如果 `u` 与 `v` 在同一条链上，则直接从线段树中查询。\n\n```cpp\ninline int querySum(uint u, uint v) {\n\tint result = 0;\n\tTree *a = &treeNodes[u], *b = &treeNodes[v];\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) {\n\t\t\tswap(a, b);\n\t\t}\n\n\t\tresult += a->path->segmentTree->querySum(0, a->pos);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) {\n\t\tswap(a, b);\n\t}\n\n\tresult += a->path->segmentTree->querySum(a->pos, b->pos);\n\treturn result;\n}\n```\n\n### 附：无根树转有根树\n为了剖分时更容易一些，我们可以把读入的无根树转化成有根树，这样搜索的时候方便点，当然常数也会大一些 ……\n\n```cpp\ninline void convert() {\n\tqueue<Node *> q;\n\troot = &treeNodes[0];\n\tnew (root) Tree(NULL);\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tnode->visited = true;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\ttreeNodes[node->id].children = new (&treeNodes[edge->to->id]) Tree(&treeNodes[node->id]);\n\t\t\t\tq.push(edge->to);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### 附：线段树\n我们使用线段树来维护每一条链，这里只用到了单点修改，也可以换成树状数组或者 zkw 线段树。\n\n```cpp\nstruct SegmentTree {\n\tstruct Node {\n\t\tstruct Node *lchild, *rchild;\n\t\tuint l, r;\n\t\tint sum, max;\n\n\t\tNode(uint l, uint r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), sum(0), max(0) {}\n\n\t\tvoid update(uint x, int value) {\n\t\t\tif (x > r || x < l) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (x == l && x == r) {\n\t\t\t\tsum = max = value;\n\t\t\t} else {\n\t\t\t\tmax = INT_MIN, sum = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, lchild->max);\n\t\t\t\t\tsum += lchild->sum;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, rchild->max);\n\t\t\t\t\tsum += rchild->sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint querySum(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn sum;\n\t\t\t} else {\n\t\t\t\tint result = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult += lchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult += rchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tint queryMax(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn INT_MIN;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn max;\n\t\t\t} else {\n\t\t\t\tint result = INT_MIN;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult = std::max(result, lchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult = std::max(result, rchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(uint l, uint r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(uint l, uint r) {\n\t\tif (r < l) {\n\t\t\treturn NULL;\n\t\t} else if (r == l) {\n\t\t\treturn new Node(l, r, NULL, NULL);\n\t\t} else {\n\t\t\tuint mid = (l + ((r - l) >> 1));\n\t\t\treturn new Node(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n\n\tvoid update(uint x, int value) {\n\t\troot->update(x, value);\n\t}\n\n\tint querySum(uint l, uint r) {\n\t\treturn root->querySum(l, r);\n\t}\n\n\tint queryMax(uint l, uint r) {\n\t\treturn root->queryMax(l, r);\n\t}\n};\n```\n### 完整代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing std::queue;\nusing std::stack;\nusing std::swap;\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 30000;\n\nstruct Node {\n\tstruct Edge *edges;\n\tuint id;\n\tbool visited;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, Edge *next) : from(from), to(to), next(next) {}\n};\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tstruct Node *lchild, *rchild;\n\t\tuint l, r;\n\t\tint sum, max;\n\n\t\tNode(uint l, uint r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), sum(0), max(0) {}\n\n\t\tvoid update(uint x, int value) {\n\t\t\tif (x > r || x < l) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (x == l && x == r) {\n\t\t\t\tsum = max = value;\n\t\t\t} else {\n\t\t\t\tmax = INT_MIN, sum = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, lchild->max);\n\t\t\t\t\tsum += lchild->sum;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->update(x, value);\n\t\t\t\t\tmax = std::max(max, rchild->max);\n\t\t\t\t\tsum += rchild->sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint querySum(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn sum;\n\t\t\t} else {\n\t\t\t\tint result = 0;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult += lchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult += rchild->querySum(l, r);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tint queryMax(uint l, uint r) {\n\t\t\tif (l > this->r || r < this->l) {\n\t\t\t\treturn INT_MIN;\n\t\t\t}\n\n\t\t\tif (l <= this->l && r >= this->r) {\n\t\t\t\treturn max;\n\t\t\t} else {\n\t\t\t\tint result = INT_MIN;\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tresult = std::max(result, lchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\tresult = std::max(result, rchild->queryMax(l, r));\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(uint l, uint r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(uint l, uint r) {\n\t\tif (r < l) {\n\t\t\treturn NULL;\n\t\t} else if (r == l) {\n\t\t\treturn new Node(l, r, NULL, NULL);\n\t\t} else {\n\t\t\tuint mid = (l + ((r - l) >> 1));\n\t\t\treturn new Node(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n\n\tvoid update(uint x, int value) {\n\t\troot->update(x, value);\n\t}\n\n\tint querySum(uint l, uint r) {\n\t\treturn root->querySum(l, r);\n\t}\n\n\tint queryMax(uint l, uint r) {\n\t\treturn root->queryMax(l, r);\n\t}\n};\n\nstruct Tree {\n\tstruct Path *path;\n\tTree *parent, *children, *maxSizeChild, *next;\n\tuint size, depth, maxDepth, pos;\n\tint w;\n\n\tbool visited;\n\n\tTree() {}\n\tTree(Tree *parent) : parent(parent), depth(!parent ? 0 : parent->depth + 1), next(!parent ? NULL : parent->children), path(NULL), w(0), children(NULL), maxSizeChild(NULL) {}\n} treeNodes[MAXN], *root;\n\nstruct Path {\n\tSegmentTree *segmentTree;\n\tTree *top;\n\n\tPath(struct Tree *top, uint count) : top(top), segmentTree(new SegmentTree(0, count - 1)) {}\n};\n\nuint n, q;\n\ninline void addEdge(uint a, uint b) {\n\tnodes[a].edges = new Edge(&nodes[a], &nodes[b], nodes[a].edges);\n\tnodes[b].edges = new Edge(&nodes[b], &nodes[a], nodes[b].edges);\n}\n\ninline void convert() {\n\tqueue<Node *> q;\n\troot = &treeNodes[0];\n\tnew (root) Tree(NULL);\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tnode->visited = true;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\ttreeNodes[node->id].children = new (&treeNodes[edge->to->id]) Tree(&treeNodes[node->id]);\n\t\t\t\tq.push(edge->to);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void cut() {\n\tstack<Tree *> s;\n\n\ts.push(root);\n\twhile (!s.empty()) {\n\t\tTree *tree = s.top();\n\t\tif (tree->visited) {\n\t\t\ttree->size = 1;\n\t\t\ttree->maxDepth = tree->depth;\n\t\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\t\ttree->size += child->size;\n\t\t\t\tif (tree->maxSizeChild == NULL || tree->maxSizeChild->size < child->size) {\n\t\t\t\t\ttree->maxSizeChild = child;\n\t\t\t\t\ttree->maxDepth = child->maxDepth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t} else {\n\t\t\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\t\t\ts.push(child);\n\t\t\t}\n\n\t\t\ttree->visited = true;\n\t\t}\n\t}\n\nqueue<Tree *> q;\n\nq.push(root);\nwhile (!q.empty()) {\n\tTree *tree = q.front();\n\tq.pop();\n\n\tif (tree == root || tree != tree->parent->maxSizeChild) {\n\t\ttree->path = new Path(tree, tree->maxDepth - tree->depth + 1);\n\t\ttree->pos = 0;\n\t} else {\n\t\ttree->path = tree->parent->path;\n\t\ttree->pos = tree->parent->pos + 1;\n\t}\n\n\tfor (Tree *child = tree->children; child; child = child->next) {\n\t\tq.push(child);\n\t}\n}\n\n\tfor (uint i = 0; i < n; i++) {\n\t\ttreeNodes[i].path->segmentTree->update(treeNodes[i].pos, treeNodes[i].w);\n\t}\n}\n\ninline void update(uint x, uint w) {\n\ttreeNodes[x].w = w;\n\ttreeNodes[x].path->segmentTree->update(treeNodes[x].pos, w);\n}\n\ninline int querySum(uint u, uint v) {\n\tint result = 0;\n\tTree *a = &treeNodes[u], *b = &treeNodes[v];\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) {\n\t\t\tswap(a, b);\n\t\t}\n\n\t\tresult += a->path->segmentTree->querySum(0, a->pos);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) {\n\t\tswap(a, b);\n\t}\n\n\tresult += a->path->segmentTree->querySum(a->pos, b->pos);\n\treturn result;\n}\n\ninline int queryMax(uint u, uint v) {\n\tint result = INT_MIN;\n\tTree *a = &treeNodes[u], *b = &treeNodes[v];\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) {\n\t\t\tswap(a, b);\n\t\t}\n\n\t\tresult = std::max(result, a->path->segmentTree->queryMax(0, a->pos));\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) {\n\t\tswap(a, b);\n\t}\n\n\tresult = std::max(result, a->path->segmentTree->queryMax(a->pos, b->pos));\n\treturn result;\n}\n\nint main() {\n\tscanf(\"%u\", &n);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tnodes[i].id = i;\n\t}\n\n\tfor (uint i = 0; i < n - 1; i++) {\n\t\tuint a, b;\n\t\tscanf(\"%u %u\", &a, &b);\n\t\ta--, b--;\n\n\t\taddEdge(a, b);\n\t}\n\n\tconvert();\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tuint w;\n\t\tscanf(\"%u\", &w);\n\t\ttreeNodes[i].w = w;\n\t}\n\n\tcut();\n\n\tscanf(\"%u\", &q);\n\n\tfor (uint i = 0; i < q; i++) {\n\t\tchar command[6 + 1];\n\t\tscanf(\"%s\", command);\n\t\tif (command[1] == 'H') { // CHANGE\n\t\t\tuint x;\n\t\t\tint w;\n\t\t\tscanf(\"%u %d\", &x, &w);\n\t\t\tx--;\n\n\t\t\tupdate(x, w);\n\t\t} else {\n\t\t\tuint u, v;\n\t\t\tscanf(\"%u %u\", &u, &v);\n\t\t\tu--, v--;\n\n\t\t\tif (command[1] == 'M') { // QMAX\n\t\t\t\tprintf(\"%d\\n\", queryMax(u, v));\n\t\t\t} else { // QSUM\n\t\t\t\tprintf(\"%d\\n\", querySum(u, v));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"cut-tree-notes","published":1,"updated":"2016-03-15T01:46:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nag00doofdklv03zb47"},{"title":"「CTSC1999」星际转移 - 网络流","id":"59","updated":"2016-02-24T13:42:46.000Z","date":"2016-02-24T13:41:36.000Z","_content":"\n现有 `n` 个太空站位于地球与月球之间，且有 `m` 艘太空船在其间来回穿梭。每个太空站可容纳无限多的人，第 `i` 个太空船只可容纳 `H[i]` 个人。每艘太空船将周期性地停靠一系列的太空站。每一艘太空船从一个太空站驶往任一太空站耗时均为 1。人们只能在太空船停靠太空站（或月球、地球）时上、下船。初始时所有人全在地球上，太空船全在初始站。求让所有人尽快地全部转移到月球上的最短时间。\n\n<!-- more -->\n\n### 题目链接\n[COGS 736](http://cogs.top/cogs/problem/problem.php?pid=736)\n\n### 解题思路\n话说这题真是难调 …… qwq\n\n考虑到『一个太空站和一个时间点』确定了一个状态，枚举答案 `t`，将每个太空站拆成 `t + 1` 个点（因为初始状态是在 0 时刻）。对于每一个时刻，从**上一时刻每个太空船的停留站**到**这一时刻每个太空船的停留站**连一条边，容量为该太空船载客量；对于任何一个太空站，从上一时刻到这一时刻连一条边，容量为正无穷（表示人停留在太空站）；对于任意时刻的地球，从源点向其连一条边，容量为正无穷；对于任意时刻的月球，从其向汇点连一条边，容量为正无穷。\n\n从小到大枚举答案，答案每增大 1，在原图中加入新边。直到汇点的流量大于等于总人数，则答案合法。\n\n也可以二分答案 …… 不过那样要拆掉图重建，总感觉数据小的情况下比枚举还要慢。qwq\n\n数据范围有坑！数据范围有坑！数据范围有坑！`n` 和 `m` 的最大值颠倒了！\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 13;\nconst int MAXM = 20;\nconst int MAXK = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n\t//char info[256];\n} nodes[MAXN * (MAXN + 2) * (MAXM + 1) * MAXK * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, k, a[MAXM];\nstd::vector<int> v[MAXM];\nstd::vector<int>::const_iterator currentStation[MAXM];\n\ninline void print(Node *v) {\n\t//printf(\"%s\", v->info);\n\treturn;\n\t//int x = (int)(v - nodes);\n\t//if (x == 0) putchar('s');\n\t//else if (x == n * (n + 2) * (m + 1) * k * 2 + 1) putchar('t');\n\t//else {\n\t//\tprintf(\"{ day: %d, station: %d }\", x / (n + 2), x % (n + 2) - 2);\n\t//}\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\t//print(e->from);\n\t\t\t\t\t//printf(\" -> \");\n\t\t\t\t\t//print(e->to);\n\t\t\t\t\t//putchar('\\n');\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\t//printf(\"(%d)\\n\", (int)(s - nodes));\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\te->flow = 0;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"\\t\\t%d\\n\", capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int stationID(int station, int day) {\n\t//sprintf(nodes[day * (n + 2) + station].info, \"{ day: %d, station: %d }\", day, station - 2);\n\treturn day * (n + 2) + station;\n}\n\ninline int solve() {\n\tconst int s = 0, t = n * (n + 2) * (m + 1) * k * 2 + 1;\n\t//nodes[s].info[0] = 's';\n\t//nodes[t].info[0] = 't';\n\n\t//puts(\"s --> { day: 0, station: 0 }\");\n\taddEdge(s, stationID(2, 0), INT_MAX);\n\t//puts(\"s --> { day: 0, station: -1 }\");\n\taddEdge(stationID(1, 0), t, INT_MAX);\n\n\tfor (int i = 1; i <= (n + 2) * (m + 1) * k * 2; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint oldStation = *currentStation[j - 1];\n\n\t\t\tcurrentStation[j - 1]++;\n\t\t\tif (currentStation[j - 1] == v[j - 1].end()) currentStation[j - 1] = v[j - 1].begin();\n\n\t\t\tint newStation = *currentStation[j - 1];\n\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, oldStation - 2, i, newStation - 2);\n\t\t\taddEdge(stationID(oldStation, i - 1), stationID(newStation, i), a[j - 1]);\n\t\t}\n\t\t\n\t\t//printf(\"s --> { day: %d, station: 0 }\\n\", i);\n\t\t//printf(\"{ day: %d, station: -1 } --> t\\n\", i);\n\t\taddEdge(stationID(1, i), t, INT_MAX);\n\t\taddEdge(s, stationID(2, i), INT_MAX);\n\t\t\n\t\tfor (int j = 3; j <= n + 2; j++) {\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, j - 2, i, j - 2);\n\t\t\taddEdge(stationID(j, i - 1), stationID(j, i), INT_MAX);\n\t\t}\n\n\t\tint flow = dinic(s, t, n * (n + 2) * (m + 1) * k * 2 + 2);\n\t\t//printf(\"%d\\n\", flow);\n\t\tif (flow >= k) return i;\n\t}\n\n\treturn 0;\n}\n\nint main() {\n\t//printf(\"%d\\n\", sizeof(nodes));\n\tfreopen(\"home.in\", \"r\", stdin);\n\tfreopen(\"home.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\n\t\tfor (int j = 0; j < t; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tv[i].push_back(x + 2);\n\t\t}\n\n\t\tcurrentStation[i] = v[i].begin();\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/ctsc1999-home.md","raw":"title: 「CTSC1999」星际转移 - 网络流\ncategories: OI\ntags: \n  - COGS\n  - CTSC\n  - 图论\n  - 网络流\n  - Dinic\n  - 网络流24题\n  - 枚举答案\npermalink: ctsc1999-home\nid: 59\nupdated: '2016-02-24 21:42:46'\ndate: 2016-02-24 21:41:36\n---\n\n现有 `n` 个太空站位于地球与月球之间，且有 `m` 艘太空船在其间来回穿梭。每个太空站可容纳无限多的人，第 `i` 个太空船只可容纳 `H[i]` 个人。每艘太空船将周期性地停靠一系列的太空站。每一艘太空船从一个太空站驶往任一太空站耗时均为 1。人们只能在太空船停靠太空站（或月球、地球）时上、下船。初始时所有人全在地球上，太空船全在初始站。求让所有人尽快地全部转移到月球上的最短时间。\n\n<!-- more -->\n\n### 题目链接\n[COGS 736](http://cogs.top/cogs/problem/problem.php?pid=736)\n\n### 解题思路\n话说这题真是难调 …… qwq\n\n考虑到『一个太空站和一个时间点』确定了一个状态，枚举答案 `t`，将每个太空站拆成 `t + 1` 个点（因为初始状态是在 0 时刻）。对于每一个时刻，从**上一时刻每个太空船的停留站**到**这一时刻每个太空船的停留站**连一条边，容量为该太空船载客量；对于任何一个太空站，从上一时刻到这一时刻连一条边，容量为正无穷（表示人停留在太空站）；对于任意时刻的地球，从源点向其连一条边，容量为正无穷；对于任意时刻的月球，从其向汇点连一条边，容量为正无穷。\n\n从小到大枚举答案，答案每增大 1，在原图中加入新边。直到汇点的流量大于等于总人数，则答案合法。\n\n也可以二分答案 …… 不过那样要拆掉图重建，总感觉数据小的情况下比枚举还要慢。qwq\n\n数据范围有坑！数据范围有坑！数据范围有坑！`n` 和 `m` 的最大值颠倒了！\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 13;\nconst int MAXM = 20;\nconst int MAXK = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n\t//char info[256];\n} nodes[MAXN * (MAXN + 2) * (MAXM + 1) * MAXK * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, k, a[MAXM];\nstd::vector<int> v[MAXM];\nstd::vector<int>::const_iterator currentStation[MAXM];\n\ninline void print(Node *v) {\n\t//printf(\"%s\", v->info);\n\treturn;\n\t//int x = (int)(v - nodes);\n\t//if (x == 0) putchar('s');\n\t//else if (x == n * (n + 2) * (m + 1) * k * 2 + 1) putchar('t');\n\t//else {\n\t//\tprintf(\"{ day: %d, station: %d }\", x / (n + 2), x % (n + 2) - 2);\n\t//}\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\t//print(e->from);\n\t\t\t\t\t//printf(\" -> \");\n\t\t\t\t\t//print(e->to);\n\t\t\t\t\t//putchar('\\n');\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\t//printf(\"(%d)\\n\", (int)(s - nodes));\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\te->flow = 0;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"\\t\\t%d\\n\", capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int stationID(int station, int day) {\n\t//sprintf(nodes[day * (n + 2) + station].info, \"{ day: %d, station: %d }\", day, station - 2);\n\treturn day * (n + 2) + station;\n}\n\ninline int solve() {\n\tconst int s = 0, t = n * (n + 2) * (m + 1) * k * 2 + 1;\n\t//nodes[s].info[0] = 's';\n\t//nodes[t].info[0] = 't';\n\n\t//puts(\"s --> { day: 0, station: 0 }\");\n\taddEdge(s, stationID(2, 0), INT_MAX);\n\t//puts(\"s --> { day: 0, station: -1 }\");\n\taddEdge(stationID(1, 0), t, INT_MAX);\n\n\tfor (int i = 1; i <= (n + 2) * (m + 1) * k * 2; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint oldStation = *currentStation[j - 1];\n\n\t\t\tcurrentStation[j - 1]++;\n\t\t\tif (currentStation[j - 1] == v[j - 1].end()) currentStation[j - 1] = v[j - 1].begin();\n\n\t\t\tint newStation = *currentStation[j - 1];\n\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, oldStation - 2, i, newStation - 2);\n\t\t\taddEdge(stationID(oldStation, i - 1), stationID(newStation, i), a[j - 1]);\n\t\t}\n\t\t\n\t\t//printf(\"s --> { day: %d, station: 0 }\\n\", i);\n\t\t//printf(\"{ day: %d, station: -1 } --> t\\n\", i);\n\t\taddEdge(stationID(1, i), t, INT_MAX);\n\t\taddEdge(s, stationID(2, i), INT_MAX);\n\t\t\n\t\tfor (int j = 3; j <= n + 2; j++) {\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, j - 2, i, j - 2);\n\t\t\taddEdge(stationID(j, i - 1), stationID(j, i), INT_MAX);\n\t\t}\n\n\t\tint flow = dinic(s, t, n * (n + 2) * (m + 1) * k * 2 + 2);\n\t\t//printf(\"%d\\n\", flow);\n\t\tif (flow >= k) return i;\n\t}\n\n\treturn 0;\n}\n\nint main() {\n\t//printf(\"%d\\n\", sizeof(nodes));\n\tfreopen(\"home.in\", \"r\", stdin);\n\tfreopen(\"home.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\n\t\tfor (int j = 0; j < t; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tv[i].push_back(x + 2);\n\t\t}\n\n\t\tcurrentStation[i] = v[i].begin();\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"ctsc1999-home","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nao00dwofdk40s26tsb"},{"title":"「CTSC1997」选课 - 树形DP","id":"15","updated":"2016-01-19T13:05:52.000Z","date":"2016-01-06T21:12:01.000Z","_content":"\n学校开设了 N（<= 300） 门课程，每门课程有不同的学分，每个学生最多可以选择 M 门课程，有些课程有“先修课”，即这门课必须在先修课选定之后再选，每门课程的先修课最多有一门。求获得学分最多的选课方案。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1378](http://codevs.cn/problem/1378/)\n\n### 解题思路\n很显然，这里的依赖关系是以森林的形式给出的，我们增加一个虚拟节点作为所有无先修课的课程的父节点，搜索这棵树，用 $f[i][m]$ 表示选择第 `i` 个节点及其之后节点（兄弟或孩子）中的 `m` 个节点所对应的课程所获得的最大学分，则有两个转移方向：\n\n1. 给第 `i` 个节点和它的**一个或多个子节点**分配一定的课程数量 `k`，剩余课程数量 `m - k - 1` 分给**下一个兄弟节点**。\n2. 不选择第 `i` 个节点，全部课程数量 `m` 分配给**下一个兄弟节点**。\n\n$$f[i][m]={\\max}( {\\max}\\{ f[i.children][k] + f[i.next][m-k-1],k{\\in}[0,m-1] \\},f[i.next][m] )$$\n\n树结构储存时使用类似邻接表的结构，储存当前节点的第一个孩子节点，和下一个兄弟节点。\n\n```C++\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n```\n\n### AC代码\n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = 300;\n\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n\nint n, m;\n\ninline void addTree(int parent, int child, int w) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent], w);\n}\n\nint solve(Tree *t, int m) {\n\tif (!t || m < 0) return 0;\n\n\tif (!t->ans[m].solved) {\n\t\tt->ans[m].value = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->children, i) + solve(t->next, m - i - 1) + t->w);\n\t\t}\n\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->next, m));\n\n\t\tt->ans[m].solved = true;\n\t}\n\n\treturn t->ans[m].value;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint parent, w;\n\t\tscanf(\"%d %d\", &parent, &w);\n\t\taddTree(parent, i, w);\n\t}\n\n\tprintf(\"%d\\n\", solve(&trees[0], m + 1));\n\n\treturn 0;\n}\n```\n","source":"_posts/ctsc1997-course.md","raw":"title: 「CTSC1997」选课 - 树形DP\ncategories: OI\ntags: \n  - CodeVS\n  - CTSC\n  - DP\n  - 树形DP\npermalink: ctsc1997-course\nid: 15\nupdated: '2016-01-19 21:05:52'\ndate: 2016-01-07 05:12:01\n---\n\n学校开设了 N（<= 300） 门课程，每门课程有不同的学分，每个学生最多可以选择 M 门课程，有些课程有“先修课”，即这门课必须在先修课选定之后再选，每门课程的先修课最多有一门。求获得学分最多的选课方案。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1378](http://codevs.cn/problem/1378/)\n\n### 解题思路\n很显然，这里的依赖关系是以森林的形式给出的，我们增加一个虚拟节点作为所有无先修课的课程的父节点，搜索这棵树，用 $f[i][m]$ 表示选择第 `i` 个节点及其之后节点（兄弟或孩子）中的 `m` 个节点所对应的课程所获得的最大学分，则有两个转移方向：\n\n1. 给第 `i` 个节点和它的**一个或多个子节点**分配一定的课程数量 `k`，剩余课程数量 `m - k - 1` 分给**下一个兄弟节点**。\n2. 不选择第 `i` 个节点，全部课程数量 `m` 分配给**下一个兄弟节点**。\n\n$$f[i][m]={\\max}( {\\max}\\{ f[i.children][k] + f[i.next][m-k-1],k{\\in}[0,m-1] \\},f[i.next][m] )$$\n\n树结构储存时使用类似邻接表的结构，储存当前节点的第一个孩子节点，和下一个兄弟节点。\n\n```C++\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n```\n\n### AC代码\n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = 300;\n\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n\nint n, m;\n\ninline void addTree(int parent, int child, int w) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent], w);\n}\n\nint solve(Tree *t, int m) {\n\tif (!t || m < 0) return 0;\n\n\tif (!t->ans[m].solved) {\n\t\tt->ans[m].value = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->children, i) + solve(t->next, m - i - 1) + t->w);\n\t\t}\n\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->next, m));\n\n\t\tt->ans[m].solved = true;\n\t}\n\n\treturn t->ans[m].value;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint parent, w;\n\t\tscanf(\"%d %d\", &parent, &w);\n\t\taddTree(parent, i, w);\n\t}\n\n\tprintf(\"%d\\n\", solve(&trees[0], m + 1));\n\n\treturn 0;\n}\n```\n","slug":"ctsc1997-course","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nav00e8ofdkl9yw5ncv"},{"title":"组合数学学习笔记","date":"2016-03-15T09:16:12.000Z","_content":"\n计数原理、排列、组合、递推关系、等差数列求和公式、自然数平方和公式、二项式定理。\n\n<!-- more -->\n\n### 计数原理\n#### 加法原理\n做一件事有 $ n $ 种途径，每种途径有 $ p_i $ 个不同的方案，则做这件事的方案数为\n\n$$ \\sum\\limits_{i = i}^{n}p_i $$\n\n#### 乘法原理\n做一件事有 $ n $ 个步骤，每个步骤有 $ p_i $ 个不同的方案，则做这件事的方案数为\n\n$$ \\prod\\limits_{i = i}^{n}p_i $$\n\n#### 容斥原理\n统计多个集合的并的元素数量：先加上所有集合的元素的元素数量，再减去『多加的』每两个集合相交的元素数量，再加上『多减的』每三个集合相交的元素数量 ……\n\n即等式左边是多个集合的并的元素数量，等式右边每一项是几个几何的交的元素数量，每一项的符号取决于元素数量的奇偶。\n\n### 排列\n#### 全排列\n把 $ n $ 个元素按照不同顺序排列，设总方案数为 $ f(n) $（定义 $ f(0) = 1 $），考虑第一个元素摆放的位置，得出公式\n\n$$ f(n) = f(n - 1) * n $$\n\n即 $ f(n) = n! $。\n\n#### 普通排列\n从 $ n $ 个元素中取 $ k $ 个，按照不同顺序排列，设总方案数为 $ P(n, k) $，每次选一个数，第一次有 $ n $ 种选择，第二次有 $ n - 1 $ 种选择，直到第 $ k $ 次有 $ n - k + 1 $ 种选择，即\n\n$$ P(n, k) = \\prod\\limits_{i = 0}^{k - 1}(n - i) $$\n\n将上式与 $ n! $ 对比，缺少 $ n - k $ 及之后的项，即\n\n$$ P(n, k) = \\frac{n!}{(n - k)!} $$\n\n#### 有重复元素的全排列\n从 $ k $ 种元素，第 $ i $ 种有 $ n_i $ 个，设 $ n = \\sum\\limits_{i = 1}^{k}n_i $，为了保证答案不重复，可以先求出 $ n! $，再除去每种元素重复的情况，即\n\n$$ \\frac{n!}{\\prod\\limits_{i = 1}^{k}n_i!} $$\n\n### 组合\n#### 组合数\n从 n 个元素中选择 k 个，顺序无关，设总方案数为 $ C(n, k) $。把排列数 $ P(n, k) $ 看做先从 n 各种选择 k 个元素，再对 k 个元素做全排列，即\n\n$$ P(n, k) = C(n, k) * k! $$\n\n移项得\n\n$$\n\\begin{align*}\nC(n, k) & = \\frac{P(n, k)}{k!} \\\\\n& = \\frac{n!}{(n - k)!k!} \\\\\n\\end{align*}\n$$\n\n#### 组合数的性质\n$ C(n, 0) = C(n, n) = 1 $ 全选或全不选只有一种方案。\n\n$ C(n, k) = C(n, n - k) $ 选择 $ k $ 个拿走相当于选择 $ n - k $ 个留下。\n\n$ C(n, k) = C(n - 1, k) + C(n - 1, k - 1) $ 考虑最后一个选还是不选（Pascal 公式，常用来递推计算组合数表）。\n\n#### 可重复选择的组合\n从 n 种无限多的元素中选择 k 个，共有 $ C(n + k - 1, k) $ 种方案。\n\n#### 组合数的计算\n##### 组合数表\n用 Pascal 公式递推，组合数太大要开高精度或者取模。\n\n```cpp\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n    for (int i = 1; i <= MAXN; i++) {\n        combo[i][0] = combo[i][i] = 1;\n        for (int j = 1; j < i; j++){\n            combo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n        }\n    }\n}\n\ninline BigInt &C(int n, int k) {\n    return combo[n][k];\n}\n```\n\n##### 单个计算\n书上有用 `double` 来算的，因为中间乘法 `long long` 可能会溢出，不知道那样会不会损失精度。\n\n```cpp\nlong long C(long long n, long long k) {\n    long long result = 1;\n    for (int i = 1; i <= k; i++) {\n        result = result * (n - i + 1) / i;\n    }\n    return result;\n}\n```\n\n### 递推关系\n#### Fibonacci 数列\n楼梯上共有 $ n $ 个台阶，一次可以走一个或两个，总方案数为\n\n$$ F_n = F_{n - 1} + F_{n - 2} $$\n\n边界为\n\n$$ F_1 = F_2 = 1 $$\n\n#### Catalan 数\n给定一个凸 $ n $ 边形，用 $ n - 3 $ 条不相交的直线将它剖分成 $ n - 2 $ 个三角形，设方案总数为 $ f(n) $。\n\n对每个顶点编号，第 $ i $ 个顶点编号为 $ V_i $。作三角形 $ {V_1}{V_k}{V_n} $（$ 1 \\lt k \\lt n $），该三角形左边是一个 $ k $ 边形，右边是一个 $ n - k + 1 $ 边形，即\n\n$$ f(n) = \\sum\\limits_{k = 2}^{n - 1}f(k)f(n - k + 1) $$\n\n### 公式\n#### 等差数列\n设数列 $ \\{ a_1, a_2, \\cdots, a_n \\} $ 对于任意的 $ 1 \\lt i \\leq n $ 满足 $ a_t - a_{i - 1} = d $，则有\n\n$$ a_i = a_i + (i - 1)d $$\n\n求和公式为\n\n$$\n\\begin{align*}\n\\sum\\limits_{i = i}^{n}a_i & = \\frac{(a_1 + a_n)n}{2} \\\\\n& = \\frac{[2a_1 + (n - 1)d]n}{2} \\\\\n\\end{align*}\n$$\n\n#### 自然数平方和\n$$ \\sum\\limits_{i = 1}^{n}i^2 = \\frac{n(n + 1)(2n + 1)}{6} $$\n\n不会证。\n\n#### 二项式定理\n$$ (a + b) ^ n = \\sum\\limits_{k = 0}^{n}\\binom{n}{k}a^{k}b^{n - k} $$\n","source":"_posts/combinatorics-notes.md","raw":"title: 组合数学学习笔记\ncategories: OI\ntags: \n  - 数学\n  - 组合数学\n  - 学习笔记\n  - 算法模板  \npermalink: combinatorics-notes\ndate: 2016-03-15 17:16:12\n---\n\n计数原理、排列、组合、递推关系、等差数列求和公式、自然数平方和公式、二项式定理。\n\n<!-- more -->\n\n### 计数原理\n#### 加法原理\n做一件事有 $ n $ 种途径，每种途径有 $ p_i $ 个不同的方案，则做这件事的方案数为\n\n$$ \\sum\\limits_{i = i}^{n}p_i $$\n\n#### 乘法原理\n做一件事有 $ n $ 个步骤，每个步骤有 $ p_i $ 个不同的方案，则做这件事的方案数为\n\n$$ \\prod\\limits_{i = i}^{n}p_i $$\n\n#### 容斥原理\n统计多个集合的并的元素数量：先加上所有集合的元素的元素数量，再减去『多加的』每两个集合相交的元素数量，再加上『多减的』每三个集合相交的元素数量 ……\n\n即等式左边是多个集合的并的元素数量，等式右边每一项是几个几何的交的元素数量，每一项的符号取决于元素数量的奇偶。\n\n### 排列\n#### 全排列\n把 $ n $ 个元素按照不同顺序排列，设总方案数为 $ f(n) $（定义 $ f(0) = 1 $），考虑第一个元素摆放的位置，得出公式\n\n$$ f(n) = f(n - 1) * n $$\n\n即 $ f(n) = n! $。\n\n#### 普通排列\n从 $ n $ 个元素中取 $ k $ 个，按照不同顺序排列，设总方案数为 $ P(n, k) $，每次选一个数，第一次有 $ n $ 种选择，第二次有 $ n - 1 $ 种选择，直到第 $ k $ 次有 $ n - k + 1 $ 种选择，即\n\n$$ P(n, k) = \\prod\\limits_{i = 0}^{k - 1}(n - i) $$\n\n将上式与 $ n! $ 对比，缺少 $ n - k $ 及之后的项，即\n\n$$ P(n, k) = \\frac{n!}{(n - k)!} $$\n\n#### 有重复元素的全排列\n从 $ k $ 种元素，第 $ i $ 种有 $ n_i $ 个，设 $ n = \\sum\\limits_{i = 1}^{k}n_i $，为了保证答案不重复，可以先求出 $ n! $，再除去每种元素重复的情况，即\n\n$$ \\frac{n!}{\\prod\\limits_{i = 1}^{k}n_i!} $$\n\n### 组合\n#### 组合数\n从 n 个元素中选择 k 个，顺序无关，设总方案数为 $ C(n, k) $。把排列数 $ P(n, k) $ 看做先从 n 各种选择 k 个元素，再对 k 个元素做全排列，即\n\n$$ P(n, k) = C(n, k) * k! $$\n\n移项得\n\n$$\n\\begin{align*}\nC(n, k) & = \\frac{P(n, k)}{k!} \\\\\n& = \\frac{n!}{(n - k)!k!} \\\\\n\\end{align*}\n$$\n\n#### 组合数的性质\n$ C(n, 0) = C(n, n) = 1 $ 全选或全不选只有一种方案。\n\n$ C(n, k) = C(n, n - k) $ 选择 $ k $ 个拿走相当于选择 $ n - k $ 个留下。\n\n$ C(n, k) = C(n - 1, k) + C(n - 1, k - 1) $ 考虑最后一个选还是不选（Pascal 公式，常用来递推计算组合数表）。\n\n#### 可重复选择的组合\n从 n 种无限多的元素中选择 k 个，共有 $ C(n + k - 1, k) $ 种方案。\n\n#### 组合数的计算\n##### 组合数表\n用 Pascal 公式递推，组合数太大要开高精度或者取模。\n\n```cpp\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n    for (int i = 1; i <= MAXN; i++) {\n        combo[i][0] = combo[i][i] = 1;\n        for (int j = 1; j < i; j++){\n            combo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n        }\n    }\n}\n\ninline BigInt &C(int n, int k) {\n    return combo[n][k];\n}\n```\n\n##### 单个计算\n书上有用 `double` 来算的，因为中间乘法 `long long` 可能会溢出，不知道那样会不会损失精度。\n\n```cpp\nlong long C(long long n, long long k) {\n    long long result = 1;\n    for (int i = 1; i <= k; i++) {\n        result = result * (n - i + 1) / i;\n    }\n    return result;\n}\n```\n\n### 递推关系\n#### Fibonacci 数列\n楼梯上共有 $ n $ 个台阶，一次可以走一个或两个，总方案数为\n\n$$ F_n = F_{n - 1} + F_{n - 2} $$\n\n边界为\n\n$$ F_1 = F_2 = 1 $$\n\n#### Catalan 数\n给定一个凸 $ n $ 边形，用 $ n - 3 $ 条不相交的直线将它剖分成 $ n - 2 $ 个三角形，设方案总数为 $ f(n) $。\n\n对每个顶点编号，第 $ i $ 个顶点编号为 $ V_i $。作三角形 $ {V_1}{V_k}{V_n} $（$ 1 \\lt k \\lt n $），该三角形左边是一个 $ k $ 边形，右边是一个 $ n - k + 1 $ 边形，即\n\n$$ f(n) = \\sum\\limits_{k = 2}^{n - 1}f(k)f(n - k + 1) $$\n\n### 公式\n#### 等差数列\n设数列 $ \\{ a_1, a_2, \\cdots, a_n \\} $ 对于任意的 $ 1 \\lt i \\leq n $ 满足 $ a_t - a_{i - 1} = d $，则有\n\n$$ a_i = a_i + (i - 1)d $$\n\n求和公式为\n\n$$\n\\begin{align*}\n\\sum\\limits_{i = i}^{n}a_i & = \\frac{(a_1 + a_n)n}{2} \\\\\n& = \\frac{[2a_1 + (n - 1)d]n}{2} \\\\\n\\end{align*}\n$$\n\n#### 自然数平方和\n$$ \\sum\\limits_{i = 1}^{n}i^2 = \\frac{n(n + 1)(2n + 1)}{6} $$\n\n不会证。\n\n#### 二项式定理\n$$ (a + b) ^ n = \\sum\\limits_{k = 0}^{n}\\binom{n}{k}a^{k}b^{n - k} $$\n","slug":"combinatorics-notes","published":1,"updated":"2016-03-15T09:20:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nay00eeofdk0q8gx1mj"},{"title":"「COGS 746」骑士共存 - 二分图最大独立集","id":"53","updated":"2016-02-19T03:44:48.000Z","date":"2016-02-19T03:43:42.000Z","_content":"\n在一个 $ N * N $ 个方格的国际象棋棋盘上，马（骑士）可以攻击的棋盘方格如图所示。棋盘上某些方格设置了障碍，骑士不得进入。问最多可以在棋盘上放多少个其实。\n\n<!-- more -->\n\n### 题目链接\n[COGS 746](http://cogs.top/cogs/problem/problem.php?pid=746)\n\n### 解题思路\n在题图中可以发现，每个马可以攻击的格子都在与自身颜色不同的格子上，即整个棋盘可以建立为二分图，并使能互相攻击到的格子位于不同的两列。\n\n> 根据定理，二分图最大独立集即为最小点覆盖集的补集，而最小点覆盖集可以用最小割模型来求解。\n\n> 建立源点 S 和汇点 T，对于二分图中每个 X 点集中的点，从 S 向其连一条边，容量为点权；对于每个 Y 点集中的点，从该点向汇点连一条边，容量为点权；对于原图中的每条边，转化为从 X 点集的点连接到 Y 点集中的点的边，容量为无穷大。求出最小割，则该最小割为简单割，即任意一条割边不可能是中间那条无穷大的边，而这些割边恰好不重复的覆盖了整个二分图中的所有点，并且权值和最小。\n\n> ——摘自《「COGS 734」方格取数 - 二分图最大独立集》\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 200;\nconst int MAXM = MAXN * MAXN;\n\nstruct Point {\n\tint x, y;\n\n\tPoint(int x, int y) : x(x), y(y) {}\n\n\tPoint operator+(const Point &pt) const {\n\t\treturn Point(x + pt.x, y + pt.y);\n\t}\n};\n\nconst Point turns[8] = {\n\tPoint(1, 2),\n\tPoint(2, 1),\n\tPoint(-1, -2),\n\tPoint(-2, -1),\n\tPoint(1, -2),\n\tPoint(-2, 1),\n\tPoint(-1, 2),\n\tPoint(2, -1)\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\nbool blocked[MAXN][MAXN];\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0, nodes[i].currentEdge = nodes[i].firstEdge;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn y * n + x + 1;\n}\n\nint main() {\n\tfreopen(\"knight.in\", \"r\", stdin);\n\tfreopen(\"knight.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y), x--, y--;\n\n\t\tblocked[x][y] = true;\n\t}\n\n\tconst int s = 0, t = n * n + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (blocked[i][j]) continue;\n\n\t\t\tsum++;\n\n\t\t\tint id = getNodeID(i, j);\n\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\t//printf(\"S => (%d, %d)\\n\", i + 1, j + 1);\n\t\t\t\taddEdge(s, id, 1);\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tPoint pt = Point(i, j) + turns[k];\n\t\t\t\t\tif (pt.x < 0 || pt.x > n - 1 || pt.y < 0 || pt.y > n - 1 || blocked[pt.x][pt.y]) continue;\n\n\t\t\t\t\t//printf(\"(%d, %d) => (%d, %d)\\n\", i + 1, j + 1, pt.x + 1, pt.y + 1);\n\t\t\t\t\taddEdge(id, getNodeID(pt.x, pt.y), INT_MAX);\n\t\t\t\t}\n\t\t\t} else addEdge(id, t, 1);//, printf(\"(%d, %d) => T\\n\", i + 1, j + 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * n + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-746.md","raw":"title: 「COGS 746」骑士共存 - 二分图最大独立集\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - Dinic\n  - 网络流24题\n  - 最大独立集\npermalink: cogs-746\nid: 53\nupdated: '2016-02-19 11:44:48'\ndate: 2016-02-19 11:43:42\n---\n\n在一个 $ N * N $ 个方格的国际象棋棋盘上，马（骑士）可以攻击的棋盘方格如图所示。棋盘上某些方格设置了障碍，骑士不得进入。问最多可以在棋盘上放多少个其实。\n\n<!-- more -->\n\n### 题目链接\n[COGS 746](http://cogs.top/cogs/problem/problem.php?pid=746)\n\n### 解题思路\n在题图中可以发现，每个马可以攻击的格子都在与自身颜色不同的格子上，即整个棋盘可以建立为二分图，并使能互相攻击到的格子位于不同的两列。\n\n> 根据定理，二分图最大独立集即为最小点覆盖集的补集，而最小点覆盖集可以用最小割模型来求解。\n\n> 建立源点 S 和汇点 T，对于二分图中每个 X 点集中的点，从 S 向其连一条边，容量为点权；对于每个 Y 点集中的点，从该点向汇点连一条边，容量为点权；对于原图中的每条边，转化为从 X 点集的点连接到 Y 点集中的点的边，容量为无穷大。求出最小割，则该最小割为简单割，即任意一条割边不可能是中间那条无穷大的边，而这些割边恰好不重复的覆盖了整个二分图中的所有点，并且权值和最小。\n\n> ——摘自《「COGS 734」方格取数 - 二分图最大独立集》\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 200;\nconst int MAXM = MAXN * MAXN;\n\nstruct Point {\n\tint x, y;\n\n\tPoint(int x, int y) : x(x), y(y) {}\n\n\tPoint operator+(const Point &pt) const {\n\t\treturn Point(x + pt.x, y + pt.y);\n\t}\n};\n\nconst Point turns[8] = {\n\tPoint(1, 2),\n\tPoint(2, 1),\n\tPoint(-1, -2),\n\tPoint(-2, -1),\n\tPoint(1, -2),\n\tPoint(-2, 1),\n\tPoint(-1, 2),\n\tPoint(2, -1)\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\nbool blocked[MAXN][MAXN];\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0, nodes[i].currentEdge = nodes[i].firstEdge;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn y * n + x + 1;\n}\n\nint main() {\n\tfreopen(\"knight.in\", \"r\", stdin);\n\tfreopen(\"knight.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y), x--, y--;\n\n\t\tblocked[x][y] = true;\n\t}\n\n\tconst int s = 0, t = n * n + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (blocked[i][j]) continue;\n\n\t\t\tsum++;\n\n\t\t\tint id = getNodeID(i, j);\n\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\t//printf(\"S => (%d, %d)\\n\", i + 1, j + 1);\n\t\t\t\taddEdge(s, id, 1);\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tPoint pt = Point(i, j) + turns[k];\n\t\t\t\t\tif (pt.x < 0 || pt.x > n - 1 || pt.y < 0 || pt.y > n - 1 || blocked[pt.x][pt.y]) continue;\n\n\t\t\t\t\t//printf(\"(%d, %d) => (%d, %d)\\n\", i + 1, j + 1, pt.x + 1, pt.y + 1);\n\t\t\t\t\taddEdge(id, getNodeID(pt.x, pt.y), INT_MAX);\n\t\t\t\t}\n\t\t\t} else addEdge(id, t, 1);//, printf(\"(%d, %d) => T\\n\", i + 1, j + 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * n + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-746","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nb100ekofdkymol0ytr"},{"title":"「COGS 742」深海机器人 - 费用流","id":"58","updated":"2016-02-23T13:44:58.000Z","date":"2016-02-23T13:44:06.000Z","_content":"\n有多个深海机器人到达深海海底后离开潜艇向预定目标移动。深海机器人在移动中还必须沿途采集海底生物标本。沿途生物标本由最先遇到它的深海机器人完成采集。每条预定路径上的生物标本的价值是已知的，而且生物标本只能被采集一次。深海机器人只能从其出发位置沿着向北或向东的方向移动，而且多个深海机器人可以在同一时间占据同一位置。\n\n<!-- more -->\n\n### 题目链接\n[COGS 742](http://cogs.top/cogs/problem/problem.php?pid=742)\n\n### 解题思路\n最大费用最大流建模，从源点向每个起点连一条边，流量为出发的机器人数量，费用为零；从每个终点向汇点连一条边，流量为到达的机器人数量，费用为零；把每个格点看做点，从每个格点向其东边、北边各连**两条**边，第一条容量为 1，费用为生物标本价值的相反数（保证第一个通过的机器人取走标本），另一条容量为正无穷，费用为 0（保证多个机器人可占据同一位置，并且路径可重叠）。\n\n计算坐标是个大坑。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXP = 15;\nconst int MAXQ = 15;\nconst int MAXA = 10;\nconst int MAXB = 10;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[(MAXP + 1) * (MAXQ + 1) + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint a, b, p, q;\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\t//printf(\"%d -> %d = %d\\n\", (int)(e->from - nodes), (int)(e->to - nodes), t->flow);\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\t\t//printf(\"flow += %d, cost += %d\\n\", t->flow, t->dist * t->flow);\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tassert(from < (p + 1) * (q + 1) + 2);\n\tassert(to < (p + 1) * (q + 1) + 2);\n\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * (q + 1) + y + 1;\n}\n\nint main() {\n\tfreopen(\"shinkai.in\", \"r\", stdin);\n\tfreopen(\"shinkai.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n%d %d\", &a, &b, &p, &q);\n\n\tconst int s = 0, t = (p + 1) * (q + 1) + 1;\n\n\tfor (int i = 0; i < p + 1; i++) {\n\t\tfor (int j = 0; j < q; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i, j + 1, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int j = 0; j < q + 1; j++) {\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i + 1, j, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < a; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(s, getNodeID(x, y), k, 0);\n\t}\n\n\tfor (int i = 0; i < b; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(getNodeID(x, y), t, k, 0);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, (p + 1) * (q + 1) + 2, flow, cost);\n\n\tprintf(\"%d\\n\", -cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-742.md","raw":"title: 「COGS 742」深海机器人 - 费用流\ncategories: OI\ntags: \n  - COGS\n  - Edmonds-Karp\n  - 网络流24题\n  - 图论\n  - 网络流\n  - 费用流\npermalink: cogs-742\nid: 58\nupdated: '2016-02-23 21:44:58'\ndate: 2016-02-23 21:44:06\n---\n\n有多个深海机器人到达深海海底后离开潜艇向预定目标移动。深海机器人在移动中还必须沿途采集海底生物标本。沿途生物标本由最先遇到它的深海机器人完成采集。每条预定路径上的生物标本的价值是已知的，而且生物标本只能被采集一次。深海机器人只能从其出发位置沿着向北或向东的方向移动，而且多个深海机器人可以在同一时间占据同一位置。\n\n<!-- more -->\n\n### 题目链接\n[COGS 742](http://cogs.top/cogs/problem/problem.php?pid=742)\n\n### 解题思路\n最大费用最大流建模，从源点向每个起点连一条边，流量为出发的机器人数量，费用为零；从每个终点向汇点连一条边，流量为到达的机器人数量，费用为零；把每个格点看做点，从每个格点向其东边、北边各连**两条**边，第一条容量为 1，费用为生物标本价值的相反数（保证第一个通过的机器人取走标本），另一条容量为正无穷，费用为 0（保证多个机器人可占据同一位置，并且路径可重叠）。\n\n计算坐标是个大坑。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXP = 15;\nconst int MAXQ = 15;\nconst int MAXA = 10;\nconst int MAXB = 10;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[(MAXP + 1) * (MAXQ + 1) + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint a, b, p, q;\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\t//printf(\"%d -> %d = %d\\n\", (int)(e->from - nodes), (int)(e->to - nodes), t->flow);\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\t\t//printf(\"flow += %d, cost += %d\\n\", t->flow, t->dist * t->flow);\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tassert(from < (p + 1) * (q + 1) + 2);\n\tassert(to < (p + 1) * (q + 1) + 2);\n\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * (q + 1) + y + 1;\n}\n\nint main() {\n\tfreopen(\"shinkai.in\", \"r\", stdin);\n\tfreopen(\"shinkai.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n%d %d\", &a, &b, &p, &q);\n\n\tconst int s = 0, t = (p + 1) * (q + 1) + 1;\n\n\tfor (int i = 0; i < p + 1; i++) {\n\t\tfor (int j = 0; j < q; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i, j + 1, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int j = 0; j < q + 1; j++) {\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i + 1, j, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < a; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(s, getNodeID(x, y), k, 0);\n\t}\n\n\tfor (int i = 0; i < b; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(getNodeID(x, y), t, k, 0);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, (p + 1) * (q + 1) + 2, flow, cost);\n\n\tprintf(\"%d\\n\", -cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-742","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nb800etofdks3kk6cdm"},{"title":"「COGS 741」负载平衡 - 费用流","id":"61","updated":"2016-02-25T07:38:10.000Z","date":"2016-02-25T07:37:15.000Z","_content":"\nG 公司有 `n` 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 `n` 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。\n\n<!-- more -->\n\n### 题目链接\n[COGS 741](http://cogs.top/cogs/problem/problem.php?pid=741)\n\n### 解题思路\n这道题猛地看上去有点像之前写过的一道贪心 —— 均分纸牌，那道题只要把每一个数减去平均数，然后从左到右累加，特判一下零就好。但这题难点在于是环形的。\n\n首先，还是要将每个仓库中的库存数量减去平均数，目标便转化为把正数全部加到负数中。『只能在相邻的仓库之间搬运』这一条件，让人很容易想到在相邻仓库之间连边，但稍微思考一下就会发现这样是不行的，因为有时候需要将货物重复移动多次才能到达目的仓库。\n\n不妨只考虑最终的结果 —— 正数最后都要被移动到负数里面。在相邻的仓库之间转移，单位代价是 1，则隔着多个位置的仓库之间转移的代价就是**两间仓库的最短距离**，环中两点的最短路只有两种情况，顺时针走或者逆时针走，预处理出来就好。\n\n从源点向每个库存量为正数的点连一条边，容量为库存量，费用为 0；从每个库存量为负数的点向汇点连一条边，容量为库存量的相反数，费用为 0；从每个库存量为正数的点向每个库存量为负数的点连一条边，容量为正无穷，费用为**两间仓库的最短距离**，求出最小费用最大流，则费用即为答案。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], dist[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void getDistances() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tdist[i][j] = dist[j][i] = std::min(std::abs(j - i), (n - j) + i);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"overload.in\", \"r\", stdin);\n\tfreopen(\"overload.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tsum += a[i];\n\t}\n\n\tint average = sum / n;\n\tfor (int i = 0; i < n; i++) a[i] -= average;\n\n\tgetDistances();\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) addEdge(s, i, a[i - 1], 0);\n\t\telse if (a[i - 1] < 0) addEdge(i, t, -a[i - 1], 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (a[j - 1] < 0) addEdge(i, j, INT_MAX, dist[i - 1][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-741.md","raw":"title: 「COGS 741」负载平衡 - 费用流\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - 网络流24题\n  - Edmonds-Karp\n  - 费用流\npermalink: cogs-741\nid: 61\nupdated: '2016-02-25 15:38:10'\ndate: 2016-02-25 15:37:15\n---\n\nG 公司有 `n` 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 `n` 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。\n\n<!-- more -->\n\n### 题目链接\n[COGS 741](http://cogs.top/cogs/problem/problem.php?pid=741)\n\n### 解题思路\n这道题猛地看上去有点像之前写过的一道贪心 —— 均分纸牌，那道题只要把每一个数减去平均数，然后从左到右累加，特判一下零就好。但这题难点在于是环形的。\n\n首先，还是要将每个仓库中的库存数量减去平均数，目标便转化为把正数全部加到负数中。『只能在相邻的仓库之间搬运』这一条件，让人很容易想到在相邻仓库之间连边，但稍微思考一下就会发现这样是不行的，因为有时候需要将货物重复移动多次才能到达目的仓库。\n\n不妨只考虑最终的结果 —— 正数最后都要被移动到负数里面。在相邻的仓库之间转移，单位代价是 1，则隔着多个位置的仓库之间转移的代价就是**两间仓库的最短距离**，环中两点的最短路只有两种情况，顺时针走或者逆时针走，预处理出来就好。\n\n从源点向每个库存量为正数的点连一条边，容量为库存量，费用为 0；从每个库存量为负数的点向汇点连一条边，容量为库存量的相反数，费用为 0；从每个库存量为正数的点向每个库存量为负数的点连一条边，容量为正无穷，费用为**两间仓库的最短距离**，求出最小费用最大流，则费用即为答案。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], dist[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void getDistances() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tdist[i][j] = dist[j][i] = std::min(std::abs(j - i), (n - j) + i);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"overload.in\", \"r\", stdin);\n\tfreopen(\"overload.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tsum += a[i];\n\t}\n\n\tint average = sum / n;\n\tfor (int i = 0; i < n; i++) a[i] -= average;\n\n\tgetDistances();\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) addEdge(s, i, a[i - 1], 0);\n\t\telse if (a[i - 1] < 0) addEdge(i, t, -a[i - 1], 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (a[j - 1] < 0) addEdge(i, j, INT_MAX, dist[i - 1][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-741","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nbl00f1ofdkee7h7z0x"},{"title":"「COGS 740」分配问题 - 二分图最大权匹配","id":"60","updated":"2016-02-25T00:10:00.000Z","date":"2016-02-25T00:08:29.000Z","_content":"\n有 `n` 件工作要分配给 `n` 个人做。第 `i` 个人做第 `j` 件工作产生的效益为 `c[i][j]`。试设计一个将 `n` 件工作分配给 `n` 个人做的分配方案，使产生的总效益最大。\n\n<!-- more -->\n\n### 题目链接\n[COGS 740](http://cogs.top/cogs/problem/problem.php?pid=740)\n\n### 解题思路\n把工作和人放在网络流模型中，可以发现这是一张二分图，问题转化为从图中选取一些边，使这些边没有交点（没有人做重复的工作，没有工作被重复做），并且边权总和最大。即**二分图最大权匹配**。\n\n建立源点与汇点，从源点向每个人连一条边，容量为 1（每个人只能匹配一次），费用为 0；从每个工作到汇点连一条边，容量为 1（每个工作只能匹配一次），费用为 0；从每个人向每个工作连一条边，容量为 0，费用为效益的相反数。求出网络的最小费用最大流，所得费用的相反数即为最大权匹配。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXN + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0), cost(cost) {}\n};\n\nint n, a[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < n + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = n + n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(n + i, t, 1, 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, n + j, 1, a[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n + 2, flow, cost);\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"job.in\", \"r\", stdin);\n\tfreopen(\"job.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n\n\n```","source":"_posts/cogs-740.md","raw":"title: 「COGS 740」分配问题 - 二分图最大权匹配\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - 网络流24题\n  - Edmonds-Karp\n  - 费用流\n  - 二分图匹配\npermalink: cogs-740\nid: 60\nupdated: '2016-02-25 08:10:00'\ndate: 2016-02-25 08:08:29\n---\n\n有 `n` 件工作要分配给 `n` 个人做。第 `i` 个人做第 `j` 件工作产生的效益为 `c[i][j]`。试设计一个将 `n` 件工作分配给 `n` 个人做的分配方案，使产生的总效益最大。\n\n<!-- more -->\n\n### 题目链接\n[COGS 740](http://cogs.top/cogs/problem/problem.php?pid=740)\n\n### 解题思路\n把工作和人放在网络流模型中，可以发现这是一张二分图，问题转化为从图中选取一些边，使这些边没有交点（没有人做重复的工作，没有工作被重复做），并且边权总和最大。即**二分图最大权匹配**。\n\n建立源点与汇点，从源点向每个人连一条边，容量为 1（每个人只能匹配一次），费用为 0；从每个工作到汇点连一条边，容量为 1（每个工作只能匹配一次），费用为 0；从每个人向每个工作连一条边，容量为 0，费用为效益的相反数。求出网络的最小费用最大流，所得费用的相反数即为最大权匹配。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXN + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0), cost(cost) {}\n};\n\nint n, a[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < n + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = n + n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(n + i, t, 1, 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, n + j, 1, a[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n + 2, flow, cost);\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"job.in\", \"r\", stdin);\n\tfreopen(\"job.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n\n\n```","slug":"cogs-740","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nbp00f9ofdklx3z6x1r"},{"title":"「COGS 739」运输问题 - 费用流","id":"57","updated":"2016-02-23T12:35:48.000Z","date":"2016-02-20T13:37:35.000Z","_content":"\nW 公司有 `m` 个仓库和 `n` 个零售商店。第 `i` 个仓库有 $ a_i $ 个货物，第 `j` 个商店需要 $ b_j $ 个货物，从第 `i` 个仓库运输到第 `j` 个零售商店的费用为 $ c_{ij} $，要将所有货物运到商店，最小费用是多少？\n\n<!-- more -->\n\n### 题目链接\n[COGS 739](http://cogs.top/cogs/problem/problem.php?pid=739)\n\n### 解题思路\n裸费用流。\n\n从源点向每个仓库连接一条边，容量为仓库的货物数量；从每个商店向汇点连一条边，容量为商店需要的货物数量；在每一对仓库和商店之间连接一条边，容量为无穷大，费用为运输费用。分别求出最大、最小费用最大流就是答案。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXM], b[MAXN], cost[MAXM][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < m + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = m + n + 1;\n\t\n\tfor (int i = 1; i <= m; i++) addEdge(s, i, a[i - 1], 0);\n\tfor (int j = 1; j <= n; j++) addEdge(m + j, t, b[j - 1], 0);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, m + j, INT_MAX, cost[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, m + n + 2, flow, cost);\n\t\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"tran.in\", \"r\", stdin);\n\tfreopen(\"tran.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &a[i]);\n\tfor (int j = 0; j < n; j++) scanf(\"%d\", &b[j]);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &cost[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-739.md","raw":"title: 「COGS 739」运输问题 - 费用流\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - 费用流\n  - Edmonds-Karp\n  - 网络流24题\npermalink: cogs-739\nid: 57\nupdated: '2016-02-23 20:35:48'\ndate: 2016-02-20 21:37:35\n---\n\nW 公司有 `m` 个仓库和 `n` 个零售商店。第 `i` 个仓库有 $ a_i $ 个货物，第 `j` 个商店需要 $ b_j $ 个货物，从第 `i` 个仓库运输到第 `j` 个零售商店的费用为 $ c_{ij} $，要将所有货物运到商店，最小费用是多少？\n\n<!-- more -->\n\n### 题目链接\n[COGS 739](http://cogs.top/cogs/problem/problem.php?pid=739)\n\n### 解题思路\n裸费用流。\n\n从源点向每个仓库连接一条边，容量为仓库的货物数量；从每个商店向汇点连一条边，容量为商店需要的货物数量；在每一对仓库和商店之间连接一条边，容量为无穷大，费用为运输费用。分别求出最大、最小费用最大流就是答案。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXM], b[MAXN], cost[MAXM][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < m + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = m + n + 1;\n\t\n\tfor (int i = 1; i <= m; i++) addEdge(s, i, a[i - 1], 0);\n\tfor (int j = 1; j <= n; j++) addEdge(m + j, t, b[j - 1], 0);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, m + j, INT_MAX, cost[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, m + n + 2, flow, cost);\n\t\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"tran.in\", \"r\", stdin);\n\tfreopen(\"tran.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &a[i]);\n\tfor (int j = 0; j < n; j++) scanf(\"%d\", &b[j]);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &cost[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-739","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nbw00fiofdka4kurnu1"},{"title":"「COGS 738」数字梯形 - 费用流","id":"52","updated":"2016-02-19T03:35:21.000Z","date":"2016-02-19T03:33:27.000Z","_content":"\n一个数字梯形，共有 `n` 行，第一行有 `m` 个数字，每一行都比上一行多一个数字。从第一行的每一个数字开始，每一次向左下方或左上方走，直到最后一行，有以下三种规则：\n\n1. 任意两条路径没有公共部分；\n2. 任意两条路径只能在点（数字）上有公共部分，不能在边（数字与数字之间）上有公共部分；\n3. 任意两条路径可以在点上或边上有公共部分。\n\n求分别在这三种规则下的路径所经过数字总和的最大值。\n\n<!-- more -->\n\n### 题目链接\n[COGS 738](http://cogs.top/cogs/problem/problem.php?pid=738)\n\n### 解题思路\n因为是从第一行走到最后一行，对于路径有限制，并且最大化总和，所以考虑费用流建模。\n\n将每个数字拆成两个点，中间一条边容量为 1，费用为该数字的相反数；从源点到第一行每个数字的入点连一条边，容量为 1，费用为 0；从最后一行每个数字的出点向汇点连一条边，容量为 1，费用为 1；对于除最后一行外的每个数字，从其出点向其下方两个数字的入点分别连一条边，容量为 1，费用为 0。求出网络的最小费用最大流，则结果费用的相反数即为第一问答案。\n\n有了第一问的基础，后面两问就比较容易了，第二问因为可以在数字上重复，就把每个数字的入点和出点之间的边容量改为正无穷，把指向汇点的边容量也改为正无穷；第三问因为可以在边上重复，就在第二问的基础上把每个数字的出点向下方连接的两条边容量改为正无穷。\n\n一定要注意，计算网络流节点编号要用**梯形面积公式**，设源点 `s` 的编号为 0，则对数字进行拆点后所得的点数量为 $ \\frac{(m + (m + n - 1)) * n} {2} * 2 $，即汇点的编号为 $ \\frac{(m + (m + n - 1)) * n} {2} * 2 + 1 $。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXM = 20;\nconst int MAXN = 20;\nconst int L = 0, R = 1, IN = 0, OUT = 1;\n\nstruct Point {\n\tint x, y;\n\n\tPoint() {}\n\tPoint(int x, int y) : x(x), y(y) {}\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[((MAXM + (MAXM + MAXN - 1)) * MAXN / 2) * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), cost(cost), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXN][MAXM + MAXN - 1], s, t;\nint mapNode[MAXN][MAXM + MAXN - 1][2], mapEdge[MAXN][MAXM + MAXN - 1][2];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\t//printf(\"dist((%d, %d), (%d, %d)) = %d\\n\", e->to->pt1.x, e->to->pt1.y, e->to->pt2.x, e->to->pt2.y, e->to->dist);\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Node *v = t; v != s; v = v->inEdge->from) {\n\t\t\tv->inEdge->flow += t->flow;\n\t\t\tv->inEdge->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tcost += t->dist * t->flow;\n\t\tflow += t->flow;\n\t\t//printf(\"flow += %d\\n\", t->flow);\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void releaseMemory() {\n\tfor (int i = 0; i < ((m + (m + n - 1)) * n / 2) * 2 + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t\tnodes[i].firstEdge = NULL;\n\t}\n}\n\ninline void buildNetwork(int limitPerNode, int limitPerEdge) {\n\treleaseMemory();\n\tfor (int i = 0; i < m; i++) addEdge(s, mapNode[0][i][IN], 1, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\t//printf(\"i(%d) -> %d, j(%d) -> %d\\n\", i + 1, n, j + 1, m + i);\n\t\t\tint (&v)[2] = mapNode[i][j];\n\t\t\tint (&e)[2] = mapEdge[i][j];\n\t\t\t//printf(\"a[i][j] = %d\\n\", a[i][j]);\n\t\t\taddEdge(v[IN], v[OUT], limitPerNode, -a[i][j]);\n\n\t\t\tif (i == n - 1) {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to t\\n\", i + 1, j + 1, a[i][j]);\n\t\t\t\taddEdge(v[OUT], t, limitPerNode, 0);\n\t\t\t} else {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1, a[i + 1][j]);\n\t\t\t\taddEdge(v[OUT], e[L], limitPerEdge, 0);\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1 + 1, a[i + 1][j + 1]);\n\t\t\t\taddEdge(v[OUT], e[R], limitPerEdge, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int solve() {\n\tint flow, cost;\n\tedmondskarp(s, t, ((m + (m + n - 1)) * n / 2) * 2 + 2, flow, cost);\n\treturn -cost;\n}\n\ninline int task1() {\n\tbuildNetwork(1, 1);\n\treturn solve();\n}\n\ninline int task2() {\n\tbuildNetwork(INT_MAX, 1);\n\treturn solve();\n}\n\ninline int task3() {\n\tbuildNetwork(INT_MAX, INT_MAX);\n\treturn solve();\n}\n\nint main() {\n\tfreopen(\"digit.in\", \"r\", stdin);\n\tfreopen(\"digit.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\t\n\ts = 0, t = ((m + (m + n - 1)) * n / 2) * 2 + 1;\n\t//printf(\"t = %d\\n\", t);\n\t\n\tint k = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\n\t\t\tmapNode[i][j][IN] = k++;\n\t\t\tmapNode[i][j][OUT] = k++;\n\t\t\tassert(k - 1 < ((m + (m + n - 1)) * n / 2) * 2 + 1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tmapEdge[i][j][L] = mapNode[i + 1][j][IN];\n\t\t\tmapEdge[i][j][R] = mapNode[i + 1][j + 1][IN];\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", task1());\n\tprintf(\"%d\\n\", task2());\n\tprintf(\"%d\\n\", task3());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-738.md","raw":"title: 「COGS 738」数字梯形 - 费用流\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - 费用流\n  - Edmonds-Karp\n  - 网络流24题\npermalink: cogs-738\nid: 52\nupdated: '2016-02-19 11:35:21'\ndate: 2016-02-19 11:33:27\n---\n\n一个数字梯形，共有 `n` 行，第一行有 `m` 个数字，每一行都比上一行多一个数字。从第一行的每一个数字开始，每一次向左下方或左上方走，直到最后一行，有以下三种规则：\n\n1. 任意两条路径没有公共部分；\n2. 任意两条路径只能在点（数字）上有公共部分，不能在边（数字与数字之间）上有公共部分；\n3. 任意两条路径可以在点上或边上有公共部分。\n\n求分别在这三种规则下的路径所经过数字总和的最大值。\n\n<!-- more -->\n\n### 题目链接\n[COGS 738](http://cogs.top/cogs/problem/problem.php?pid=738)\n\n### 解题思路\n因为是从第一行走到最后一行，对于路径有限制，并且最大化总和，所以考虑费用流建模。\n\n将每个数字拆成两个点，中间一条边容量为 1，费用为该数字的相反数；从源点到第一行每个数字的入点连一条边，容量为 1，费用为 0；从最后一行每个数字的出点向汇点连一条边，容量为 1，费用为 1；对于除最后一行外的每个数字，从其出点向其下方两个数字的入点分别连一条边，容量为 1，费用为 0。求出网络的最小费用最大流，则结果费用的相反数即为第一问答案。\n\n有了第一问的基础，后面两问就比较容易了，第二问因为可以在数字上重复，就把每个数字的入点和出点之间的边容量改为正无穷，把指向汇点的边容量也改为正无穷；第三问因为可以在边上重复，就在第二问的基础上把每个数字的出点向下方连接的两条边容量改为正无穷。\n\n一定要注意，计算网络流节点编号要用**梯形面积公式**，设源点 `s` 的编号为 0，则对数字进行拆点后所得的点数量为 $ \\frac{(m + (m + n - 1)) * n} {2} * 2 $，即汇点的编号为 $ \\frac{(m + (m + n - 1)) * n} {2} * 2 + 1 $。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXM = 20;\nconst int MAXN = 20;\nconst int L = 0, R = 1, IN = 0, OUT = 1;\n\nstruct Point {\n\tint x, y;\n\n\tPoint() {}\n\tPoint(int x, int y) : x(x), y(y) {}\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[((MAXM + (MAXM + MAXN - 1)) * MAXN / 2) * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), cost(cost), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXN][MAXM + MAXN - 1], s, t;\nint mapNode[MAXN][MAXM + MAXN - 1][2], mapEdge[MAXN][MAXM + MAXN - 1][2];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\t//printf(\"dist((%d, %d), (%d, %d)) = %d\\n\", e->to->pt1.x, e->to->pt1.y, e->to->pt2.x, e->to->pt2.y, e->to->dist);\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Node *v = t; v != s; v = v->inEdge->from) {\n\t\t\tv->inEdge->flow += t->flow;\n\t\t\tv->inEdge->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tcost += t->dist * t->flow;\n\t\tflow += t->flow;\n\t\t//printf(\"flow += %d\\n\", t->flow);\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void releaseMemory() {\n\tfor (int i = 0; i < ((m + (m + n - 1)) * n / 2) * 2 + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t\tnodes[i].firstEdge = NULL;\n\t}\n}\n\ninline void buildNetwork(int limitPerNode, int limitPerEdge) {\n\treleaseMemory();\n\tfor (int i = 0; i < m; i++) addEdge(s, mapNode[0][i][IN], 1, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\t//printf(\"i(%d) -> %d, j(%d) -> %d\\n\", i + 1, n, j + 1, m + i);\n\t\t\tint (&v)[2] = mapNode[i][j];\n\t\t\tint (&e)[2] = mapEdge[i][j];\n\t\t\t//printf(\"a[i][j] = %d\\n\", a[i][j]);\n\t\t\taddEdge(v[IN], v[OUT], limitPerNode, -a[i][j]);\n\n\t\t\tif (i == n - 1) {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to t\\n\", i + 1, j + 1, a[i][j]);\n\t\t\t\taddEdge(v[OUT], t, limitPerNode, 0);\n\t\t\t} else {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1, a[i + 1][j]);\n\t\t\t\taddEdge(v[OUT], e[L], limitPerEdge, 0);\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1 + 1, a[i + 1][j + 1]);\n\t\t\t\taddEdge(v[OUT], e[R], limitPerEdge, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int solve() {\n\tint flow, cost;\n\tedmondskarp(s, t, ((m + (m + n - 1)) * n / 2) * 2 + 2, flow, cost);\n\treturn -cost;\n}\n\ninline int task1() {\n\tbuildNetwork(1, 1);\n\treturn solve();\n}\n\ninline int task2() {\n\tbuildNetwork(INT_MAX, 1);\n\treturn solve();\n}\n\ninline int task3() {\n\tbuildNetwork(INT_MAX, INT_MAX);\n\treturn solve();\n}\n\nint main() {\n\tfreopen(\"digit.in\", \"r\", stdin);\n\tfreopen(\"digit.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\t\n\ts = 0, t = ((m + (m + n - 1)) * n / 2) * 2 + 1;\n\t//printf(\"t = %d\\n\", t);\n\t\n\tint k = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\n\t\t\tmapNode[i][j][IN] = k++;\n\t\t\tmapNode[i][j][OUT] = k++;\n\t\t\tassert(k - 1 < ((m + (m + n - 1)) * n / 2) * 2 + 1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tmapEdge[i][j][L] = mapNode[i + 1][j][IN];\n\t\t\tmapEdge[i][j][R] = mapNode[i + 1][j + 1][IN];\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", task1());\n\tprintf(\"%d\\n\", task2());\n\tprintf(\"%d\\n\", task3());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-738","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nc100fqofdkos3jucrs"},{"title":"「COGS 734」方格取数 - 二分图最大独立集","id":"51","updated":"2016-02-15T09:03:18.000Z","date":"2016-02-15T09:02:01.000Z","_content":"\n在一个有 $ M * N $ 个方格的棋盘中，每个方格中有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大。\n\n<!-- more -->\n\n### 题目链接\n[COGS 734](http://cogs.top/cogs/problem/problem.php?pid=734)\n\n### 解题思路\n任意两个数所在的方格没有公共边，考虑把所有的格子建成图，不能同时选择的点之间两两连边，求出一个点权和最大的子图（最大独立集），其和即为答案。\n\n进一步分析，发现这个图是一个二分图 —— 因为每个点只会和**棋盘中与其相邻的点**连边。\n\n根据定理，二分图最大独立集即为最小点覆盖集的补集，而最小点覆盖集可以用最小割模型来求解。\n\n建立源点 S 和汇点 T，对于二分图中每个 X 点集中的点，从 S 向其连一条边，容量为点权；对于每个 Y 点集中的点，从该点向汇点连一条边，容量为点权；对于原图中的每条边，转化为从 X 点集的点连接到 Y 点集中的点的边，容量为无穷大。求出最小割，则该最小割为简单割，即任意一条割边不可能是中间那条无穷大的边，而这些割边恰好不重复的覆盖了整个二分图中的所有点，并且权值和最小。\n\n建立二分图模型的时候注意细节。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 30;\nconst int MAXM = 30;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN * MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * n + y + 1;\n}\n\nint main() {\n\tfreopen(\"grid.in\", \"r\", stdin);\n\tfreopen(\"grid.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tconst int s = 0, t = n * m + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint num;\n\t\t\tscanf(\"%d\", &num);\n\t\t\tsum += num;\n\n\t\t\tint id = getNodeID(i, j);\n\t\t\tbool flag = (i + j) % 2 == 0;\n\n\t\t\tif (flag) addEdge(s, id, num);\n\t\t\telse addEdge(id, t, num);\n\n\t\t\tif (flag) {\n\t\t\t\tif (i > 0) addEdge(id, getNodeID(i - 1, j), INT_MAX);\n\t\t\t\tif (i < m - 1) addEdge(id, getNodeID(i + 1, j), INT_MAX);\n\t\t\t\tif (j > 0) addEdge(id, getNodeID(i, j - 1), INT_MAX);\n\t\t\t\tif (j < n - 1) addEdge(id, getNodeID(i, j + 1), INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-734.md","raw":"title: 「COGS 734」方格取数 - 二分图最大独立集\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - Dinic\n  - 网络流24题\n  - 最大独立集\npermalink: cogs-734\nid: 51\nupdated: '2016-02-15 17:03:18'\ndate: 2016-02-15 17:02:01\n---\n\n在一个有 $ M * N $ 个方格的棋盘中，每个方格中有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大。\n\n<!-- more -->\n\n### 题目链接\n[COGS 734](http://cogs.top/cogs/problem/problem.php?pid=734)\n\n### 解题思路\n任意两个数所在的方格没有公共边，考虑把所有的格子建成图，不能同时选择的点之间两两连边，求出一个点权和最大的子图（最大独立集），其和即为答案。\n\n进一步分析，发现这个图是一个二分图 —— 因为每个点只会和**棋盘中与其相邻的点**连边。\n\n根据定理，二分图最大独立集即为最小点覆盖集的补集，而最小点覆盖集可以用最小割模型来求解。\n\n建立源点 S 和汇点 T，对于二分图中每个 X 点集中的点，从 S 向其连一条边，容量为点权；对于每个 Y 点集中的点，从该点向汇点连一条边，容量为点权；对于原图中的每条边，转化为从 X 点集的点连接到 Y 点集中的点的边，容量为无穷大。求出最小割，则该最小割为简单割，即任意一条割边不可能是中间那条无穷大的边，而这些割边恰好不重复的覆盖了整个二分图中的所有点，并且权值和最小。\n\n建立二分图模型的时候注意细节。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 30;\nconst int MAXM = 30;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN * MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * n + y + 1;\n}\n\nint main() {\n\tfreopen(\"grid.in\", \"r\", stdin);\n\tfreopen(\"grid.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tconst int s = 0, t = n * m + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint num;\n\t\t\tscanf(\"%d\", &num);\n\t\t\tsum += num;\n\n\t\t\tint id = getNodeID(i, j);\n\t\t\tbool flag = (i + j) % 2 == 0;\n\n\t\t\tif (flag) addEdge(s, id, num);\n\t\t\telse addEdge(id, t, num);\n\n\t\t\tif (flag) {\n\t\t\t\tif (i > 0) addEdge(id, getNodeID(i - 1, j), INT_MAX);\n\t\t\t\tif (i < m - 1) addEdge(id, getNodeID(i + 1, j), INT_MAX);\n\t\t\t\tif (j > 0) addEdge(id, getNodeID(i, j - 1), INT_MAX);\n\t\t\t\tif (j < n - 1) addEdge(id, getNodeID(i, j + 1), INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-734","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nc600fyofdkmwy5gz51"},{"title":"「COGS 731」最长递增子序列 - 线性DP + 网络流","id":"48","updated":"2016-02-09T06:40:10.000Z","date":"2016-02-09T06:37:32.000Z","_content":"\n给定正整数序列 `X1 ~ Xn`。\n\n1. 计算其最长递增子序列的长度 `s`。\n2. 计算从给定的序列中最多可取出多少个长度为 `s` 的递增子序列。\n3. 如果允许在取出的序列中多次使用 `X1` 和 `Xn`，则从给定序列中最多可取出多少个长度为 `s` 的递增子序列。\n\n<!-- more -->\n\n### 题目链接\n[COGS 731](http://cogs.top/cogs/problem/problem.php?pid=731)\n\n### 解题思路\n首先，重要的事情说三遍：**非严格递增！非严格递增！非严格递增！**\n\n设以 $X_i$ 结尾的最长递增子序列长度为 $F_i$，用动态规划求出每个 $F_i$，最大的一个就是第一问答案，设它为 $K$。\n\n第二问采用网络流建模：\n\n1. 对于每个满足 $F_i = K$ 的点，从该点向汇点连一条边，容量为 1；\n2. 对于每个满足 $F_i = 1$ 的点，从源点向该点连一条边，容量为 1；\n3. 对于第一问中每一次所有的有效状态转移（即满足$ X_j≤X_i $且$F_i=F_j+1$的点对 `i`、`j`）从 `j` 向 `i` 连一条边，容量为 1。\n\n求出最大流即为答案。\n\n但是这样做有个问题，某一个点可能被使用所次，不符合题目要求。解决方法是把每一个点 `i` 拆成两个点 `i` 和 `i'`，所有进入该点的边连接 `i`，所有出该点边从 `i'` 连出，并从 `i` 到 `i'` 连接一条容量为 1 的边，保证了流过每个点的流量最多为 1。\n\n第三问只需要在第二问的基础上做出一些修改，把所有与 `1`、`n` 两个点相关的边容量改为无穷大，就可以使这两个数“可多次使用”。\n\n**注意特判**，如果输入进来的是一个严格递降序列，答案就是 1、N、N。从这里我们可以看出细节的重要性以及出题人的恶意。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 500;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], f[MAXN], k;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int dp() {\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint last = 0;\n\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j] <= a[i] && f[j] > last) last = f[j];\n\t\t}\n\n\t\tf[i] = last + 1;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\treturn ans;\n}\n\ninline int solve2() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(i, i + n, 1);\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, 1);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, 1);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\ninline int solve3() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint capacity = 1;\n\t\tif (i == 1 || i == n) capacity = INT_MAX;\n\n\t\taddEdge(i, i + n, capacity) ;\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, capacity);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, capacity);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1 && a[j - 1] <= a[i - 1]) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\nint main() {\n\tfreopen(\"alis.in\", \"r\", stdin);\n\tfreopen(\"alis.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tk = dp();\n\tprintf(\"%d\\n\", k);\n\n\tif (k == 1) printf(\"%d\\n%d\\n\", n, n);\n\telse {\n\t\tprintf(\"%d\\n\", solve2());\n\t\tprintf(\"%d\\n\", solve3());\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-731.md","raw":"title: 「COGS 731」最长递增子序列 - 线性DP + 网络流\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - Dinic\n  - 网络流24题\npermalink: cogs-731\nid: 48\nupdated: '2016-02-09 14:40:10'\ndate: 2016-02-09 14:37:32\n---\n\n给定正整数序列 `X1 ~ Xn`。\n\n1. 计算其最长递增子序列的长度 `s`。\n2. 计算从给定的序列中最多可取出多少个长度为 `s` 的递增子序列。\n3. 如果允许在取出的序列中多次使用 `X1` 和 `Xn`，则从给定序列中最多可取出多少个长度为 `s` 的递增子序列。\n\n<!-- more -->\n\n### 题目链接\n[COGS 731](http://cogs.top/cogs/problem/problem.php?pid=731)\n\n### 解题思路\n首先，重要的事情说三遍：**非严格递增！非严格递增！非严格递增！**\n\n设以 $X_i$ 结尾的最长递增子序列长度为 $F_i$，用动态规划求出每个 $F_i$，最大的一个就是第一问答案，设它为 $K$。\n\n第二问采用网络流建模：\n\n1. 对于每个满足 $F_i = K$ 的点，从该点向汇点连一条边，容量为 1；\n2. 对于每个满足 $F_i = 1$ 的点，从源点向该点连一条边，容量为 1；\n3. 对于第一问中每一次所有的有效状态转移（即满足$ X_j≤X_i $且$F_i=F_j+1$的点对 `i`、`j`）从 `j` 向 `i` 连一条边，容量为 1。\n\n求出最大流即为答案。\n\n但是这样做有个问题，某一个点可能被使用所次，不符合题目要求。解决方法是把每一个点 `i` 拆成两个点 `i` 和 `i'`，所有进入该点的边连接 `i`，所有出该点边从 `i'` 连出，并从 `i` 到 `i'` 连接一条容量为 1 的边，保证了流过每个点的流量最多为 1。\n\n第三问只需要在第二问的基础上做出一些修改，把所有与 `1`、`n` 两个点相关的边容量改为无穷大，就可以使这两个数“可多次使用”。\n\n**注意特判**，如果输入进来的是一个严格递降序列，答案就是 1、N、N。从这里我们可以看出细节的重要性以及出题人的恶意。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 500;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], f[MAXN], k;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int dp() {\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint last = 0;\n\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j] <= a[i] && f[j] > last) last = f[j];\n\t\t}\n\n\t\tf[i] = last + 1;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\treturn ans;\n}\n\ninline int solve2() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(i, i + n, 1);\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, 1);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, 1);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\ninline int solve3() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint capacity = 1;\n\t\tif (i == 1 || i == n) capacity = INT_MAX;\n\n\t\taddEdge(i, i + n, capacity) ;\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, capacity);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, capacity);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1 && a[j - 1] <= a[i - 1]) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\nint main() {\n\tfreopen(\"alis.in\", \"r\", stdin);\n\tfreopen(\"alis.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tk = dp();\n\tprintf(\"%d\\n\", k);\n\n\tif (k == 1) printf(\"%d\\n%d\\n\", n, n);\n\telse {\n\t\tprintf(\"%d\\n\", solve2());\n\t\tprintf(\"%d\\n\", solve3());\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-731","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4ncc00g6ofdkjhh63rne"},{"title":"「COGS 729」圆桌聚餐 - 网络流","id":"47","updated":"2016-02-09T06:41:05.000Z","date":"2016-02-09T05:42:59.000Z","_content":"\n假设有来自 `m` 个不同单位的代表参加一次国际会议。每个单位的代表数分别为 `ri`。会议餐厅共有 `n` 张餐桌，每张餐桌可容纳 `ci` 个代表就餐。\n\n为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。试设计一个算法，给出满足要求的代表就餐方案。\n\n<!-- more -->\n\n### 题目链接\n[COGS 729](http://cogs.top/cogs/problem/problem.php?pid=729)\n\n### 解题思路\n问题的关键就是：\n\n**每个单位最多有一个人做到一张单独的餐桌上！**\n\n进行网络流建模，建立源点 `S`，由 `S` 向每个代表单位的点连一条边，容量为单位人数；建立汇点 `T`，由每个代表餐桌的点向 `T` 连一条边，容量为餐桌容纳人数；分别从每个单位向所有餐桌连一条边，容量为 `1`。\n\n然后求出最大流，如果最大流小于所有单位人数总和，那么问题无解，否则有解，即所有由单位指向餐桌的边构成了一组解。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 270;\nconst int MAXM = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint m, n;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint main() {\n\tfreopen(\"roundtable.in\", \"r\", stdin);\n\tfreopen(\"roundtable.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m + n + 2; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = m + n + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsum += x;\n\n\t\taddEdge(s, i, x);\n\n\t\tfor (int j = m + 1; j <= m + n; j++) addEdge(i, j, 1);\n\t}\n\n\tfor (int i = m + 1; i <= m + n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, m + n + 2);\n\tif (maxFlow == sum) {\n\t\tputs(\"1\");\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tstd::vector<int> v;\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->id > m && e->to->id <= m + n && e->flow == e->capacity) {\n\t\t\t\t\tv.push_back(e->to->id - m);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstd::sort(v.begin(), v.end());\n\n\t\t\tfor (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) {\n\t\t\t\tprintf(\"%d \", *p);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t} else puts(\"0\");\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-729.md","raw":"title: 「COGS 729」圆桌聚餐 - 网络流\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - 网络流24题\n  - Dinic\npermalink: cogs-729\nid: 47\nupdated: '2016-02-09 14:41:05'\ndate: 2016-02-09 13:42:59\n---\n\n假设有来自 `m` 个不同单位的代表参加一次国际会议。每个单位的代表数分别为 `ri`。会议餐厅共有 `n` 张餐桌，每张餐桌可容纳 `ci` 个代表就餐。\n\n为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。试设计一个算法，给出满足要求的代表就餐方案。\n\n<!-- more -->\n\n### 题目链接\n[COGS 729](http://cogs.top/cogs/problem/problem.php?pid=729)\n\n### 解题思路\n问题的关键就是：\n\n**每个单位最多有一个人做到一张单独的餐桌上！**\n\n进行网络流建模，建立源点 `S`，由 `S` 向每个代表单位的点连一条边，容量为单位人数；建立汇点 `T`，由每个代表餐桌的点向 `T` 连一条边，容量为餐桌容纳人数；分别从每个单位向所有餐桌连一条边，容量为 `1`。\n\n然后求出最大流，如果最大流小于所有单位人数总和，那么问题无解，否则有解，即所有由单位指向餐桌的边构成了一组解。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 270;\nconst int MAXM = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint m, n;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint main() {\n\tfreopen(\"roundtable.in\", \"r\", stdin);\n\tfreopen(\"roundtable.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m + n + 2; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = m + n + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsum += x;\n\n\t\taddEdge(s, i, x);\n\n\t\tfor (int j = m + 1; j <= m + n; j++) addEdge(i, j, 1);\n\t}\n\n\tfor (int i = m + 1; i <= m + n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, m + n + 2);\n\tif (maxFlow == sum) {\n\t\tputs(\"1\");\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tstd::vector<int> v;\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->id > m && e->to->id <= m + n && e->flow == e->capacity) {\n\t\t\t\t\tv.push_back(e->to->id - m);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstd::sort(v.begin(), v.end());\n\n\t\t\tfor (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) {\n\t\t\t\tprintf(\"%d \", *p);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t} else puts(\"0\");\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-729","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nch00gdofdkrg0l9m4g"},{"title":"「COGS 728」最小路径覆盖问题 - 二分图匹配","id":"45","updated":"2016-02-06T14:53:58.000Z","date":"2016-02-06T14:52:12.000Z","_content":"\n给定有向图 $G=(V,E)$ 。设 P 是 G 的一个简单路（顶点不相交）的集合。如果 V 中每个顶点恰好在 P 的一条路上，则称 P 是 G 的一个路径覆盖。P 中路径可以从 V 的任何一个顶点开始，长度也是任意的，特别地，可以为 0。G 的最小路径覆盖是 G 的所含路径条数最少的路径覆盖。\n\n设计一个有效算法求一个有向无环图 G 的最小路径覆盖。\n\n<!-- more -->\n\n### 题目链接\n[COGS 728](http://cogs.top/cogs/problem/problem.php?pid=728)\n\n### 解题思路\n用最少的路径覆盖所有的点。先从最简单的图开始，如果图中没有边，那么每个点都是一条独立的路径；如果添加一条边进去，那么需要的路径数量就减小 1；如果再添加一条边进去，并且这条边与上一条边有相同起点或终点的话，那么这条边对答案是没有贡献的，如果这条边与上一条边首尾相接或者不相交的话，那么需要的路径数量减小 1。\n\n综上所述，问题转化为，从一个有向无环图中选出尽量多的边，使任意两条边没有相同起点或终点。\n\n进一步将问题转化为二分图匹配，将每个点拆成左右两个，对于原图中任意一条有向边 `(u, v)`，在新图中将左边的 `u` 和右边的 `v` 连接，然后求出最大匹配，用总点数减去最大匹配就是答案。\n\n输出方案嘛，只要枚举起点然后沿着匹配边向下搜就好咯 ……\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, level;\n\tbool visited;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void printPath(Node *v) {\n\tprintf(\"%d \", v->id);\n\n\tv->visited = true;\n\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\tif (e->flow == e->capacity && e->to->id != 0 && !nodes[e->to->id].visited) {\n\t\t\tprintPath(&nodes[e->to->id]);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"path3.in\", \"r\", stdin);\n\tfreopen(\"path3.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1), addEdge(i + n, t, 1), nodes[i].id = nodes[i + n].id = i;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u, v + n, 1);\n\t}\n\n\tint maxMatch = dinic(s, t, n * 2 + 2);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!nodes[i].visited) {\n\t\t\tprintPath(&nodes[i]);\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", n - maxMatch);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-728.md","raw":"title: 「COGS 728」最小路径覆盖问题 - 二分图匹配\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - Dinic\n  - 二分图匹配\n  - 网络流24题\npermalink: cogs-728\nid: 45\nupdated: '2016-02-06 22:53:58'\ndate: 2016-02-06 22:52:12\n---\n\n给定有向图 $G=(V,E)$ 。设 P 是 G 的一个简单路（顶点不相交）的集合。如果 V 中每个顶点恰好在 P 的一条路上，则称 P 是 G 的一个路径覆盖。P 中路径可以从 V 的任何一个顶点开始，长度也是任意的，特别地，可以为 0。G 的最小路径覆盖是 G 的所含路径条数最少的路径覆盖。\n\n设计一个有效算法求一个有向无环图 G 的最小路径覆盖。\n\n<!-- more -->\n\n### 题目链接\n[COGS 728](http://cogs.top/cogs/problem/problem.php?pid=728)\n\n### 解题思路\n用最少的路径覆盖所有的点。先从最简单的图开始，如果图中没有边，那么每个点都是一条独立的路径；如果添加一条边进去，那么需要的路径数量就减小 1；如果再添加一条边进去，并且这条边与上一条边有相同起点或终点的话，那么这条边对答案是没有贡献的，如果这条边与上一条边首尾相接或者不相交的话，那么需要的路径数量减小 1。\n\n综上所述，问题转化为，从一个有向无环图中选出尽量多的边，使任意两条边没有相同起点或终点。\n\n进一步将问题转化为二分图匹配，将每个点拆成左右两个，对于原图中任意一条有向边 `(u, v)`，在新图中将左边的 `u` 和右边的 `v` 连接，然后求出最大匹配，用总点数减去最大匹配就是答案。\n\n输出方案嘛，只要枚举起点然后沿着匹配边向下搜就好咯 ……\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, level;\n\tbool visited;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void printPath(Node *v) {\n\tprintf(\"%d \", v->id);\n\n\tv->visited = true;\n\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\tif (e->flow == e->capacity && e->to->id != 0 && !nodes[e->to->id].visited) {\n\t\t\tprintPath(&nodes[e->to->id]);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"path3.in\", \"r\", stdin);\n\tfreopen(\"path3.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1), addEdge(i + n, t, 1), nodes[i].id = nodes[i + n].id = i;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u, v + n, 1);\n\t}\n\n\tint maxMatch = dinic(s, t, n * 2 + 2);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!nodes[i].visited) {\n\t\t\tprintPath(&nodes[i]);\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", n - maxMatch);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-728","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4ncl00gkofdk0v815i0a"},{"title":"「COGS 727」太空飞行计划 - 最大权闭合图","id":"49","updated":"2016-02-15T00:45:03.000Z","date":"2016-02-15T00:39:38.000Z","_content":"\nW 教授正在为国家航天中心计划一系列的太空飞行。可供选择的实验集合为 $ E = \\{ E1, E2, …, Em \\} $，这些实验需要使用的全部仪器的集合为 $ I = \\{ I1, I2, …, In \\} $。实验 $ E_j $ 需要用到的仪器是 $ R_j∈I $。仪器 $ I_k $ 的费用为 $ c_k $。实验 $ E_j $ 的赞助商为该实验结果支付 $ p_j $。设计方案使收益最大。 \n\n<!-- more -->\n\n### 题目链接\n[COGS 727](http://cogs.top/cogs/problem/problem.php?pid=727)\n\n### 解题思路\n首先，这个问题抽象出来是一个『最大权闭合图』问题 —— 把每个实验作为点，权值为获利；把每个仪器作为点，权值为费用的**相反数**，求出一个点权和最大的子图，使这个子图中的每个点的所有出边指向的点都在这个子图中。特殊的，这个子图可以为空。\n\n根据胡伯涛的论文，最大权闭合图可以用最小割模型来求解：添加源点和汇点，对于原图中的每个**正权点**，连接一条从源点流向该点的边，容量为权值；对于原图中的每个**负权点**，连接一条从该点流向汇点的边，容量为权值的**绝对值**；对于原图中的每一条有向边，对应在网络中连接一条容量为正无穷的边。求出该网络的最小割，割边中所有边一定是从源点连接到一个正权点或从一个负权点连到汇点，这些与割边相连的正权点是**不选择**的点，与割边相连的负权点是**选择**的负权点。\n\n重点来说下怎么求最小割，用 Dinic 求出最大流之后，在**包含反向边**的残量网络中沿着**不满流**的边进行 BFS，将遍历到的点做上标记。BFS 结束后，所有有标记的点组成 `S` 集合，无标记的点组成 `T` 集合。枚举每条边，所有跨越了 `S` 和 `T` 集合的边组成了最小割。\n\n得到不选择的正权点之后，用 `std::set_difference` 求出与所有正权点的差集就是选择的正权点。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <queue>\n#include <list>\n#include <utility>\n#include <vector>\n#include <set>\n#include <iterator>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n\tbool flag;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\nstd::list<std::pair<Node *, Node *> > edgeList;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n\n\tedgeList.push_back(std::make_pair(&nodes[from], &nodes[to]));\n}\n\ninline void minCut(int s) {\n\tstd::queue<Node *> q;;\n\tq.push(&nodes[s]);\n\tnodes[s].flag = true;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && !e->to->flag) {\n\t\t\t\te->to->flag = true;\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::list<std::pair<Node *, Node *> >::iterator p = edgeList.begin();\n\twhile (p != edgeList.end()) {\n\t\tif (p->first->flag && !p->second->flag) p++;\n\t\telse p = edgeList.erase(p);\n\t}\n}\n\nint main() {\n\tfreopen(\"shuttle.in\", \"r\", stdin);\n\tfreopen(\"shuttle.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n\", &m, &n);\n\n\tfor (int i = 0; i < n + m + 1; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = n + m + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tstd::string str;\n\t\tstd::getline(std::cin, str);\n\n\t\tstd::stringstream ss;\n\t\tss << str;\n\n\t\tint x;\n\t\tss >> x;\n\t\tsum += x;\n\t\taddEdge(s, n + i, x);\n\n\t\twhile (!ss.eof()) {\n\t\t\tss >> x;\n\t\t\taddEdge(n + i, x, INT_MAX);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\n\tminCut(s);\n\n\tstd::vector<int> v;\n\tstd::set<int> set, setAll;\n\tfor (std::list<std::pair<Node *, Node *> >::const_iterator p = edgeList.begin(); p != edgeList.end(); p++) {\n\t\tif (p->first->id == s) set.insert(p->second->id - n);\n\t\telse v.push_back(p->first->id);\n\t}\n\n\tfor (int i = 1; i <= m; i++) setAll.insert(i);\n\n\tstd::set<int> setDifference;\n\tstd::set_difference(setAll.begin(), setAll.end(), set.begin(), set.end(), std::inserter(setDifference, setDifference.begin()));\n\tstd::copy(setDifference.begin(), setDifference.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\t\n\tstd::sort(v.begin(), v.end());\n\tstd::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-727.md","raw":"title: 「COGS 727」太空飞行计划 - 最大权闭合图\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - Dinic\n  - 网络流24题\n  - 最大权闭合图\npermalink: cogs-727\nid: 49\nupdated: '2016-02-15 08:45:03'\ndate: 2016-02-15 08:39:38\n---\n\nW 教授正在为国家航天中心计划一系列的太空飞行。可供选择的实验集合为 $ E = \\{ E1, E2, …, Em \\} $，这些实验需要使用的全部仪器的集合为 $ I = \\{ I1, I2, …, In \\} $。实验 $ E_j $ 需要用到的仪器是 $ R_j∈I $。仪器 $ I_k $ 的费用为 $ c_k $。实验 $ E_j $ 的赞助商为该实验结果支付 $ p_j $。设计方案使收益最大。 \n\n<!-- more -->\n\n### 题目链接\n[COGS 727](http://cogs.top/cogs/problem/problem.php?pid=727)\n\n### 解题思路\n首先，这个问题抽象出来是一个『最大权闭合图』问题 —— 把每个实验作为点，权值为获利；把每个仪器作为点，权值为费用的**相反数**，求出一个点权和最大的子图，使这个子图中的每个点的所有出边指向的点都在这个子图中。特殊的，这个子图可以为空。\n\n根据胡伯涛的论文，最大权闭合图可以用最小割模型来求解：添加源点和汇点，对于原图中的每个**正权点**，连接一条从源点流向该点的边，容量为权值；对于原图中的每个**负权点**，连接一条从该点流向汇点的边，容量为权值的**绝对值**；对于原图中的每一条有向边，对应在网络中连接一条容量为正无穷的边。求出该网络的最小割，割边中所有边一定是从源点连接到一个正权点或从一个负权点连到汇点，这些与割边相连的正权点是**不选择**的点，与割边相连的负权点是**选择**的负权点。\n\n重点来说下怎么求最小割，用 Dinic 求出最大流之后，在**包含反向边**的残量网络中沿着**不满流**的边进行 BFS，将遍历到的点做上标记。BFS 结束后，所有有标记的点组成 `S` 集合，无标记的点组成 `T` 集合。枚举每条边，所有跨越了 `S` 和 `T` 集合的边组成了最小割。\n\n得到不选择的正权点之后，用 `std::set_difference` 求出与所有正权点的差集就是选择的正权点。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <queue>\n#include <list>\n#include <utility>\n#include <vector>\n#include <set>\n#include <iterator>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n\tbool flag;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\nstd::list<std::pair<Node *, Node *> > edgeList;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n\n\tedgeList.push_back(std::make_pair(&nodes[from], &nodes[to]));\n}\n\ninline void minCut(int s) {\n\tstd::queue<Node *> q;;\n\tq.push(&nodes[s]);\n\tnodes[s].flag = true;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && !e->to->flag) {\n\t\t\t\te->to->flag = true;\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::list<std::pair<Node *, Node *> >::iterator p = edgeList.begin();\n\twhile (p != edgeList.end()) {\n\t\tif (p->first->flag && !p->second->flag) p++;\n\t\telse p = edgeList.erase(p);\n\t}\n}\n\nint main() {\n\tfreopen(\"shuttle.in\", \"r\", stdin);\n\tfreopen(\"shuttle.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n\", &m, &n);\n\n\tfor (int i = 0; i < n + m + 1; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = n + m + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tstd::string str;\n\t\tstd::getline(std::cin, str);\n\n\t\tstd::stringstream ss;\n\t\tss << str;\n\n\t\tint x;\n\t\tss >> x;\n\t\tsum += x;\n\t\taddEdge(s, n + i, x);\n\n\t\twhile (!ss.eof()) {\n\t\t\tss >> x;\n\t\t\taddEdge(n + i, x, INT_MAX);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\n\tminCut(s);\n\n\tstd::vector<int> v;\n\tstd::set<int> set, setAll;\n\tfor (std::list<std::pair<Node *, Node *> >::const_iterator p = edgeList.begin(); p != edgeList.end(); p++) {\n\t\tif (p->first->id == s) set.insert(p->second->id - n);\n\t\telse v.push_back(p->first->id);\n\t}\n\n\tfor (int i = 1; i <= m; i++) setAll.insert(i);\n\n\tstd::set<int> setDifference;\n\tstd::set_difference(setAll.begin(), setAll.end(), set.begin(), set.end(), std::inserter(setDifference, setDifference.begin()));\n\tstd::copy(setDifference.begin(), setDifference.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\t\n\tstd::sort(v.begin(), v.end());\n\tstd::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-727","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4ncq00gsofdkys3g2ywr"},{"title":"「COGS 439」软件补丁 - 记忆化搜索 + 位运算","id":"50","updated":"2016-02-15T02:17:27.000Z","date":"2016-02-15T02:13:28.000Z","_content":"\n现在有一个软件，共有 `n` 个 BUG，开发人员开发了 `m` 个补丁，每个补丁有一个应用条件，要求某些 BUG 比如存在，某些 BUG 可以不存在，某些 BUG 存在或不存在都可以；每个补丁有一个影响，会使某些 BUG 消失，会使某些 BUG 产生；每个 BUG 有一个应用时间。问修复所有 BUG 需要的最短时间为多少。\n\n<!-- more -->\n\n### 题目链接\n[COGS 439](http://cogs.top/cogs/problem/problem.php?pid=439)\n\n### 解题思路\n记录状态：用一个 `unsigned int` 类型的数记录状态，从右边数第 `i` 个二进制位表示第 `i` 个 BUG 是否存在。用 `std::tr1::unordered_map`（哈希表）存储状态到所有时间的映射，即 `map[status]` 表示从初始状态到状态 `status` 所用的最短时间。\n\n状态转移：每个补丁存储两个值 `effectAddition`、`effectSubtract`，前者表示应用该补丁后新增加的 BUG，后者表示减少的 BUG，则状态转移为：\n\n```cpp\nnewStatus = ~(~(status | effectAddition) | effectSubtract)\n```\n\n一个难点在于怎样判断补丁的应用条件，「某些 BUG 存在或不存在都可以」是难以用位运算来体现的（或者说我不会），所以我们可以把这种情况转化为「某些 BUG 必须存在」，然后在判断条件时先将当前状态加上那些「可有可无」的 BUG，然后继续判断。\n\n```cpp\n  \t((status | conditionAny) & conditionTrue)\n\t\t== (conditionTrue | conditionAny)\n&&\t(~status & conditionFalse)\n\t\t== conditionFalse\n```\n\n话说其实这道题暴力表示状态，一位一位地判断、转移也可以过的，而且照样是 COGS 上提交记录第一 ……\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <tr1/unordered_map>\n#include <queue>\n\nconst int MAXN = 20;\nconst int MAXM = 100;\n\nstruct Patch {\n\tunsigned int conditionTrue, conditionFalse, conditionAny;\n\tunsigned int effectAddition, effectSubtract;\n\tint time;\n} patches[MAXM];\n\nint n, m;\nstd::tr1::unordered_map<unsigned int, int> map;\n\ninline void setBit(unsigned int &status, int i, bool flag) {\n\tif (flag) status |= (1 << i);\n\telse status &= ~(1 << i);\n}\n\ninline bool getBit(unsigned int &status, int i) {\n\treturn ((status >> i) & 1) == 1;\n}\n\ninline void printStatus(unsigned int status, bool newLine = true) {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (getBit(status, i) == true) putchar('1');\n\t\telse putchar('0');\n\t}\n\n\tif (newLine) putchar('\\n');\n}\n\ninline void bfs(unsigned int start) {\n\tstd::queue<unsigned int> q;\n\tq.push(start);\n\tmap[start] = 0;\n\n\twhile (!q.empty()) {\n\t\tunsigned int status = q.front();\n\t\t//printStatus(status);\n\t\tq.pop();\n\n\t\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\t\tif (!(\n\t\t\t\t\t\t((status | p->conditionAny) & p->conditionTrue)\n\t\t\t\t\t\t\t== (p->conditionTrue | p->conditionAny)\n\t\t\t\t\t&&\t(~status & p->conditionFalse)\n\t\t\t\t\t\t\t== p->conditionFalse\n\t\t\t)) continue;\n\t\t\t\n\t\t\tunsigned int newStatus = ~(~(status | p->effectAddition) | p->effectSubtract);\n\n\t\t\tint step = map[status];\n\t\t\tif (map.count(newStatus) != 0 && map[newStatus] <= step + p->time) continue;\n\n\t\t\t//printf(\"from `\"), printStatus(status, false), printf(\"` useing `%d(%s, %s)`  to `\", (int)(p - patches + 1), p->condition, p->effect), printStatus(newStatus, false), printf(\"`\\n\");\n\n\t\t\tmap[newStatus] = step + p->time;\n\t\t\tq.push(newStatus);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"bugs.in\", \"r\", stdin);\n\tfreopen(\"bugs.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\tchar condition[MAXN + 1], effect[MAXN + 1];\n\t\tscanf(\"%d %s %s\", &p->time, condition, effect);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (condition[i] == '0') setBit(p->conditionAny, i, true), setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '+') setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '-') setBit(p->conditionFalse, i, true);\n\n\t\t\tif (effect[i] == '+') setBit(p->effectAddition, i, true);\n\t\t\telse if (effect[i] == '-') setBit(p->effectSubtract, i, true);\n\t\t}\n\t}\n\n\tunsigned int status = 0;\n\tfor (int i = 0; i < n; i++) setBit(status, i, true);\n\n\tbfs(status);\n\n\tif (map.count(0) == 0) puts(\"-1\");\n\telse printf(\"%d\\n\", map[0]);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n\n### 吐槽\n又是一道不是网络流但被放进「网络流24题」里的~~水~~题。","source":"_posts/cogs-439.md","raw":"title: 「COGS 439」软件补丁 - 记忆化搜索 + 位运算\ncategories: OI\ntags: \n  - 搜索\n  - 记忆化搜索\n  - 位运算\n  - COGS\n  - 网络流24题\n  - map\npermalink: cogs-439\nid: 50\nupdated: '2016-02-15 10:17:27'\ndate: 2016-02-15 10:13:28\n---\n\n现在有一个软件，共有 `n` 个 BUG，开发人员开发了 `m` 个补丁，每个补丁有一个应用条件，要求某些 BUG 比如存在，某些 BUG 可以不存在，某些 BUG 存在或不存在都可以；每个补丁有一个影响，会使某些 BUG 消失，会使某些 BUG 产生；每个 BUG 有一个应用时间。问修复所有 BUG 需要的最短时间为多少。\n\n<!-- more -->\n\n### 题目链接\n[COGS 439](http://cogs.top/cogs/problem/problem.php?pid=439)\n\n### 解题思路\n记录状态：用一个 `unsigned int` 类型的数记录状态，从右边数第 `i` 个二进制位表示第 `i` 个 BUG 是否存在。用 `std::tr1::unordered_map`（哈希表）存储状态到所有时间的映射，即 `map[status]` 表示从初始状态到状态 `status` 所用的最短时间。\n\n状态转移：每个补丁存储两个值 `effectAddition`、`effectSubtract`，前者表示应用该补丁后新增加的 BUG，后者表示减少的 BUG，则状态转移为：\n\n```cpp\nnewStatus = ~(~(status | effectAddition) | effectSubtract)\n```\n\n一个难点在于怎样判断补丁的应用条件，「某些 BUG 存在或不存在都可以」是难以用位运算来体现的（或者说我不会），所以我们可以把这种情况转化为「某些 BUG 必须存在」，然后在判断条件时先将当前状态加上那些「可有可无」的 BUG，然后继续判断。\n\n```cpp\n  \t((status | conditionAny) & conditionTrue)\n\t\t== (conditionTrue | conditionAny)\n&&\t(~status & conditionFalse)\n\t\t== conditionFalse\n```\n\n话说其实这道题暴力表示状态，一位一位地判断、转移也可以过的，而且照样是 COGS 上提交记录第一 ……\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <tr1/unordered_map>\n#include <queue>\n\nconst int MAXN = 20;\nconst int MAXM = 100;\n\nstruct Patch {\n\tunsigned int conditionTrue, conditionFalse, conditionAny;\n\tunsigned int effectAddition, effectSubtract;\n\tint time;\n} patches[MAXM];\n\nint n, m;\nstd::tr1::unordered_map<unsigned int, int> map;\n\ninline void setBit(unsigned int &status, int i, bool flag) {\n\tif (flag) status |= (1 << i);\n\telse status &= ~(1 << i);\n}\n\ninline bool getBit(unsigned int &status, int i) {\n\treturn ((status >> i) & 1) == 1;\n}\n\ninline void printStatus(unsigned int status, bool newLine = true) {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (getBit(status, i) == true) putchar('1');\n\t\telse putchar('0');\n\t}\n\n\tif (newLine) putchar('\\n');\n}\n\ninline void bfs(unsigned int start) {\n\tstd::queue<unsigned int> q;\n\tq.push(start);\n\tmap[start] = 0;\n\n\twhile (!q.empty()) {\n\t\tunsigned int status = q.front();\n\t\t//printStatus(status);\n\t\tq.pop();\n\n\t\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\t\tif (!(\n\t\t\t\t\t\t((status | p->conditionAny) & p->conditionTrue)\n\t\t\t\t\t\t\t== (p->conditionTrue | p->conditionAny)\n\t\t\t\t\t&&\t(~status & p->conditionFalse)\n\t\t\t\t\t\t\t== p->conditionFalse\n\t\t\t)) continue;\n\t\t\t\n\t\t\tunsigned int newStatus = ~(~(status | p->effectAddition) | p->effectSubtract);\n\n\t\t\tint step = map[status];\n\t\t\tif (map.count(newStatus) != 0 && map[newStatus] <= step + p->time) continue;\n\n\t\t\t//printf(\"from `\"), printStatus(status, false), printf(\"` useing `%d(%s, %s)`  to `\", (int)(p - patches + 1), p->condition, p->effect), printStatus(newStatus, false), printf(\"`\\n\");\n\n\t\t\tmap[newStatus] = step + p->time;\n\t\t\tq.push(newStatus);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"bugs.in\", \"r\", stdin);\n\tfreopen(\"bugs.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\tchar condition[MAXN + 1], effect[MAXN + 1];\n\t\tscanf(\"%d %s %s\", &p->time, condition, effect);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (condition[i] == '0') setBit(p->conditionAny, i, true), setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '+') setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '-') setBit(p->conditionFalse, i, true);\n\n\t\t\tif (effect[i] == '+') setBit(p->effectAddition, i, true);\n\t\t\telse if (effect[i] == '-') setBit(p->effectSubtract, i, true);\n\t\t}\n\t}\n\n\tunsigned int status = 0;\n\tfor (int i = 0; i < n; i++) setBit(status, i, true);\n\n\tbfs(status);\n\n\tif (map.count(0) == 0) puts(\"-1\");\n\telse printf(\"%d\\n\", map[0]);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n\n### 吐槽\n又是一道不是网络流但被放进「网络流24题」里的~~水~~题。","slug":"cogs-439","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4ncv00h1ofdk7znjyldv"},{"title":"「COGS 396」魔术球问题 - 贪心","id":"46","updated":"2016-02-06T15:04:22.000Z","date":"2016-02-06T15:02:55.000Z","_content":"\n假设有 `n` 根柱子，现要按下述规则在这n根柱子中依次放入编号为 1，2，3，4 ...... 的球。\n\n1. 每次只能在某根柱子的最上面放球；\n2. 在同一根柱子中，任何 2 个相邻球的编号之和为完全平方数。\n\n试设计一个算法，计算出在 `n` 根柱子上最多能放多少个球。\n\n<!-- more -->\n\n### 题目链接\n[COGS 396](http://cogs.top/cogs/problem/problem.php?pid=396)\n\n### 解题思路\n放球的两个条件很显然，在上面放再多的球是不影响下面的。并且，某个球放在哪一根柱子上，只会影响其之上的球的编号，而不会影响全局的球总数。\n\n所以可以使用贪心解决：策略是，先从一个柱子开始，每次枚举所有柱子，只要某个柱子能放就放上去，然后继续放下一个；直到所有的柱子不能放当前的球，则添加一个柱子；最后不能在添加时，就是最优解。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nconst int MAXN = 60;\n\nint n;\nstd::vector<int> v[MAXN];\n\ninline bool isSquareNumber(int x) {\n\tint root = floor(sqrt(x));\n\treturn root * root == x;\n}\n\nint main() {\n\tfreopen(\"balla.in\", \"r\", stdin);\n\tfreopen(\"balla.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint x = 1;\n\tfor (int k = 1; k <= n; k++) {\n\t\twhile (20000528) {\n\t\t\tbool flag = false;\n\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tif (v[i].empty() || isSquareNumber(v[i].back() + x)) {\n\t\t\t\t\tv[i].push_back(x++);\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!flag) break;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", x - 1);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-396.md","raw":"title: 「COGS 396」魔术球问题 - 贪心\ncategories: OI\ntags: \n  - COGS\n  - 贪心\n  - 网络流24题\npermalink: cogs-396\nid: 46\nupdated: '2016-02-06 23:04:22'\ndate: 2016-02-06 23:02:55\n---\n\n假设有 `n` 根柱子，现要按下述规则在这n根柱子中依次放入编号为 1，2，3，4 ...... 的球。\n\n1. 每次只能在某根柱子的最上面放球；\n2. 在同一根柱子中，任何 2 个相邻球的编号之和为完全平方数。\n\n试设计一个算法，计算出在 `n` 根柱子上最多能放多少个球。\n\n<!-- more -->\n\n### 题目链接\n[COGS 396](http://cogs.top/cogs/problem/problem.php?pid=396)\n\n### 解题思路\n放球的两个条件很显然，在上面放再多的球是不影响下面的。并且，某个球放在哪一根柱子上，只会影响其之上的球的编号，而不会影响全局的球总数。\n\n所以可以使用贪心解决：策略是，先从一个柱子开始，每次枚举所有柱子，只要某个柱子能放就放上去，然后继续放下一个；直到所有的柱子不能放当前的球，则添加一个柱子；最后不能在添加时，就是最优解。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nconst int MAXN = 60;\n\nint n;\nstd::vector<int> v[MAXN];\n\ninline bool isSquareNumber(int x) {\n\tint root = floor(sqrt(x));\n\treturn root * root == x;\n}\n\nint main() {\n\tfreopen(\"balla.in\", \"r\", stdin);\n\tfreopen(\"balla.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint x = 1;\n\tfor (int k = 1; k <= n; k++) {\n\t\twhile (20000528) {\n\t\t\tbool flag = false;\n\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tif (v[i].empty() || isSquareNumber(v[i].back() + x)) {\n\t\t\t\t\tv[i].push_back(x++);\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!flag) break;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", x - 1);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-396","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nd100hcofdk8vfp0u8j"},{"title":"「COGS 14」搭配飞行员 - 二分图匹配","id":"44","updated":"2016-02-06T14:22:28.000Z","date":"2016-02-06T14:21:18.000Z","_content":"\n从一个二分图中选出尽量多的边，使得任意两条边没有公共点。\n\n<!-- more -->\n\n### 题目链接\n[COGS 14](http://cogs.top/cogs/problem/problem.php?pid=14)\n\n### 解题思路\n二分图匹配，可以用匈牙利~~也可以用带花树~~，然而我不会写。\n\n所以要把二分图最大匹配转化成最大流 …… \n\n设二分图左右两列分别为 `X` 和 `Y`，建立超级源点 `S`，从 `S` 向 `X` 中的每个点连一条边，容量为 `1`，建立超级汇点 `T`，从 `Y` 中的每个点向 `T` 连一条边，容量为 `1`。最后对于原图的每一条边 `(u, v)`（假设 `u` 在左侧 `v` 在右侧），连接一条由 `u` 指向 `v` 的**有向**边，容量为 `1`。然后跑一遍最大流就是最大匹配啦！\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, n1;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + 1; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tfreopen(\"flyer.in\", \"r\", stdin);\n\tfreopen(\"flyer.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &n1);\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n1; i++) addEdge(s, i, 1);\n\tfor (int i = n1 + 1; i <= n; i++) addEdge(i, t, 1);\n\n\twhile (!feof(stdin)) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v, 1);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s, t));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-14.md","raw":"title: 「COGS 14」搭配飞行员 - 二分图匹配\ncategories: OI\ntags: \n  - COGS\n  - 图论\n  - 网络流\n  - Dinic\n  - 二分图匹配\n  - 网络流24题\npermalink: cogs-14\nid: 44\nupdated: '2016-02-06 22:22:28'\ndate: 2016-02-06 22:21:18\n---\n\n从一个二分图中选出尽量多的边，使得任意两条边没有公共点。\n\n<!-- more -->\n\n### 题目链接\n[COGS 14](http://cogs.top/cogs/problem/problem.php?pid=14)\n\n### 解题思路\n二分图匹配，可以用匈牙利~~也可以用带花树~~，然而我不会写。\n\n所以要把二分图最大匹配转化成最大流 …… \n\n设二分图左右两列分别为 `X` 和 `Y`，建立超级源点 `S`，从 `S` 向 `X` 中的每个点连一条边，容量为 `1`，建立超级汇点 `T`，从 `Y` 中的每个点向 `T` 连一条边，容量为 `1`。最后对于原图的每一条边 `(u, v)`（假设 `u` 在左侧 `v` 在右侧），连接一条由 `u` 指向 `v` 的**有向**边，容量为 `1`。然后跑一遍最大流就是最大匹配啦！\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, n1;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + 1; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tfreopen(\"flyer.in\", \"r\", stdin);\n\tfreopen(\"flyer.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &n1);\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n1; i++) addEdge(s, i, 1);\n\tfor (int i = n1 + 1; i <= n; i++) addEdge(i, t, 1);\n\n\twhile (!feof(stdin)) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v, 1);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s, t));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-14","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nd500hhofdkpw6vn5no"},{"title":"「CodeVS 3269」混合背包 - 背包DP","id":"3","updated":"2016-01-19T13:08:13.000Z","date":"2015-11-22T21:00:15.000Z","_content":"\n背包体积为 `V`（<= 200,000），给出 `N`（<= 200）个物品，每个物品占用体积为 `Vi`，价值为 `Wi`，每个物品要么至多取 `1` 件，要么至多取 `Mi`（> 1）件，要么数量无限，求装入背包内物品总价值的最大值。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### 解题思路\n混合三种背包问题，很经典的一个问题。  \n首先分开考虑这三种背包问题的解法。  \n使用动态规划，用 `f[v]` 表示把所有物品按要求装入一个体积为 `v` （`v` <= `V`）的背包时，装入背包内物品总价值的最大值。    \n首先，对于 01 背包，显而易见其方程为：\n\n$$f[v] = max(f[v], f[v - Vi] + Wi)$$\n\n实现代码（`t[i].v` 和 `t[i].w` 分别代表 `Vi` 和 `Wi`）\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (int v = V; v >= 0; v--) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n特别注意第二层循环枚举 `v` 时的顺序，`v` 必须从 `V` 到 `0` 循环，因为当前 `f[v]` 要根据一个当 `v` 更小时的 `f[v]` 推出（为了腾出大小为 `Vi` 的空间防第 `i` 件物品），保证在计算 `f[v]` 时，`f[v - Vi]` 一定是**没有尝试过**放置第 `i` 件物品时的状态。  \n\n对于完全背包，我们可以将其每件拆分成 `V` / `Vi` 件 `01` 背包物品，对每件物品进行一次 01 背包处理。但显然这样做效率会很低。  \n考虑到完全背包与 01 背包的不同点，仅在于 01 背包每种物品**只能放置一次**，而完全背包可以放置**任意次**，将其体现在动态规划的状态转移上，即完全背包问题，需要保证在计算 `f[v]` 时，`f[v - Vi]` 一定是**已经尝试过**放置第 `i` 件物品时的状态。而只需将第二层循环 `v` 的遍历顺序改为从 `0` 到 `V` 即可。  \n实现代码为（`t[i].v` 和 `t[i].w` 分别代表 `Vi` 和 `Wi`）：\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (unsigned int v = 0; v <= V; v++) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n这两段代码的差异比较难理解，这里举个例子：背包容量 `V = 10`，仅有一件物品体积 `Vi = 3`，价值 `Wi = 5`，现将这件物品尝试放入背包。  \n\n如果这件物品是 `01` 背包：  \n当 `v = 10` 时，**`f[v - Vi] = f[7] = 0`**，`f[v]` 被更新为 `5`。  \n当 `v = 9` 时，`f[v - Vi] = f[6] = 0`，`f[v]` 被更新为 `5`。  \n当 `v = 8` 时，`f[v - Vi] = f[5] = 0`，`f[v]` 被更新为 `5`。  \n**当 `v = 7` 时，`f[v - Vi] = f[4] = 0`，`f[v]` 被更新为 `5`。**  \n……  \n当 `v = 4` 时，`f[v - Vi] = f[1] = 0`，`f[v]` 被更新为 `5`。  \n当 `v = 3` 时，`f[v - Vi] = f[0] = 0`，`f[v]` 被更新为 `5`。  \n\n如果这件物品是完全背包：  \n当 `v = 3` 时，**`f[v - Vi] = f[0] = 0`**，`f[v]` 被更新为 `5`。  \n当 `v = 4` 时，`f[v - Vi] = f[1] = 0`，`f[v]` 被更新为 `5`。  \n……  \n**当 `v = 6` 时，`f[v - Vi] = f[3] = 5`，`f[v]` 被更新为 `10`。**  \n……  \n**当 `v = 9` 时，`f[v - Vi] = f[6] = 10`，`f[v]` 被更新为 `15`。**  \n当 `v = 10` 时，`f[v - Vi] = f[7] = 10`，`f[v]` 被更新为 `15`。  \n\n以上例子可以体现出 01 背包与完全背包解法上的区别与问题实质的联系。  \n\n回到原来的话题上来，我们已经解决了前两类问题——01 背包和完全背包，现在来看多重背包。  \n还是考虑拆分，把一件可以装 `Mi` 次的多重背包物品拆分成 `Mi` 件 01 背包物品，分别对其进行 01 背包处理。这种方法很好理解，但时间复杂度达到了$O(V*{\\Sigma}Mi)$，考虑将其优化。  \n我们采用类似二进制的思想，将每个多重背包物品拆分为 `t` 个不同的 01 背包物品，每一个拆分后的物品都有一个系数 `k`，该物品的体积和价值分别等于**原物品的体积和价值乘以这个系数**，并且使所有拆分后的物品的系数之和${\\Sigma}k = Mi$，即原物品最多被放置的次数。并且要使每个系数 `k` 分别为 $1$,$2$,$4$,…,$2 ^ {t - 1}$,$Wi - 2 ^ {t - 1}$。  \n举个例子，当 `Mi = 17` 时，将其拆成 `5` 件物品，系数 `k` 分别为 `1`,`2`,`4`,`8`,`2`。  \n使用二进制思想优化过的算法，复杂度降为了$O(V * {\\Sigma}{\\log}Wi)$。  \n实现代码为（`t[i].v` 和 `t[i].w` 分别代表 `Vi` 和 `Wi`）：  \n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tunsigned int logx = log2(t[i].m), x = 0;\n\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\tx += (1 << j); // 1 << j 将 1 按二进制位左移 j 位，快速计算 2 的 j 次方\n\t\tfor (int v = V; v >= 0; v--) { // 01 背包\n\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x < t[i].m) { // 如果不能 2 的幂作为系数将原物品完全拆分，则多拆分出一件物品 k = Wi - 2 ^ (t - 1)\n\t\tfor (int v = V; v >= 0; v--) { // 01 背包\n\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t}\n\t\t}\n\t}\n}\n```\n三种背包问题的思路明确后，就可以考虑混合背包问题了，具体实现方法是对于每一种物品，判断物品类型，分别进行处理。  \n### AC 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 200;\nconst unsigned int MAXV = 200000;\n\nunsigned int n, V;\n\nstruct thing_t {\n\tunsigned int v, w;\n\tint m;\n} t[MAXN];\n\nunsigned int f[MAXV + 1];\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tch = getchar();\n\t\tflag = true;\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nunsigned int log2(unsigned int x) {\n\tunsigned int i = 0, y = 0;\n\twhile ((y += (1 << i)) <= x) {\n\t\ti++;\n\t}\n\treturn i - 1;\n}\n\nint main() {\n\tread(n), read(V);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tread(t[i].v), read(t[i].w), read(t[i].m);\n\t}\n\n\tregister unsigned int result = 0;\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tif (t[i].m == 1) {\n\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (t[i].m == -1) {\n\t\t\tfor (unsigned int v = 0; v <= V; v++) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned int logx = log2(t[i].m), x = 0;\n\t\t\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\t\t\tx += (1 << j);\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (x < t[i].m) {\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", result);\n\n\treturn 0;\n}\n```\n### 吐槽\n这段时间在学习 dp，听 liujz 学长讲完后自己抱着书啃了好久 ……  \n算是有些理解了吧 >_<","source":"_posts/codevs-3269.md","raw":"title: 「CodeVS 3269」混合背包 - 背包DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - 背包DP\npermalink: codevs-3269\nid: 3\nupdated: '2016-01-19 21:08:13'\ndate: 2015-11-23 05:00:15\n---\n\n背包体积为 `V`（<= 200,000），给出 `N`（<= 200）个物品，每个物品占用体积为 `Vi`，价值为 `Wi`，每个物品要么至多取 `1` 件，要么至多取 `Mi`（> 1）件，要么数量无限，求装入背包内物品总价值的最大值。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### 解题思路\n混合三种背包问题，很经典的一个问题。  \n首先分开考虑这三种背包问题的解法。  \n使用动态规划，用 `f[v]` 表示把所有物品按要求装入一个体积为 `v` （`v` <= `V`）的背包时，装入背包内物品总价值的最大值。    \n首先，对于 01 背包，显而易见其方程为：\n\n$$f[v] = max(f[v], f[v - Vi] + Wi)$$\n\n实现代码（`t[i].v` 和 `t[i].w` 分别代表 `Vi` 和 `Wi`）\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (int v = V; v >= 0; v--) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n特别注意第二层循环枚举 `v` 时的顺序，`v` 必须从 `V` 到 `0` 循环，因为当前 `f[v]` 要根据一个当 `v` 更小时的 `f[v]` 推出（为了腾出大小为 `Vi` 的空间防第 `i` 件物品），保证在计算 `f[v]` 时，`f[v - Vi]` 一定是**没有尝试过**放置第 `i` 件物品时的状态。  \n\n对于完全背包，我们可以将其每件拆分成 `V` / `Vi` 件 `01` 背包物品，对每件物品进行一次 01 背包处理。但显然这样做效率会很低。  \n考虑到完全背包与 01 背包的不同点，仅在于 01 背包每种物品**只能放置一次**，而完全背包可以放置**任意次**，将其体现在动态规划的状态转移上，即完全背包问题，需要保证在计算 `f[v]` 时，`f[v - Vi]` 一定是**已经尝试过**放置第 `i` 件物品时的状态。而只需将第二层循环 `v` 的遍历顺序改为从 `0` 到 `V` 即可。  \n实现代码为（`t[i].v` 和 `t[i].w` 分别代表 `Vi` 和 `Wi`）：\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (unsigned int v = 0; v <= V; v++) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n这两段代码的差异比较难理解，这里举个例子：背包容量 `V = 10`，仅有一件物品体积 `Vi = 3`，价值 `Wi = 5`，现将这件物品尝试放入背包。  \n\n如果这件物品是 `01` 背包：  \n当 `v = 10` 时，**`f[v - Vi] = f[7] = 0`**，`f[v]` 被更新为 `5`。  \n当 `v = 9` 时，`f[v - Vi] = f[6] = 0`，`f[v]` 被更新为 `5`。  \n当 `v = 8` 时，`f[v - Vi] = f[5] = 0`，`f[v]` 被更新为 `5`。  \n**当 `v = 7` 时，`f[v - Vi] = f[4] = 0`，`f[v]` 被更新为 `5`。**  \n……  \n当 `v = 4` 时，`f[v - Vi] = f[1] = 0`，`f[v]` 被更新为 `5`。  \n当 `v = 3` 时，`f[v - Vi] = f[0] = 0`，`f[v]` 被更新为 `5`。  \n\n如果这件物品是完全背包：  \n当 `v = 3` 时，**`f[v - Vi] = f[0] = 0`**，`f[v]` 被更新为 `5`。  \n当 `v = 4` 时，`f[v - Vi] = f[1] = 0`，`f[v]` 被更新为 `5`。  \n……  \n**当 `v = 6` 时，`f[v - Vi] = f[3] = 5`，`f[v]` 被更新为 `10`。**  \n……  \n**当 `v = 9` 时，`f[v - Vi] = f[6] = 10`，`f[v]` 被更新为 `15`。**  \n当 `v = 10` 时，`f[v - Vi] = f[7] = 10`，`f[v]` 被更新为 `15`。  \n\n以上例子可以体现出 01 背包与完全背包解法上的区别与问题实质的联系。  \n\n回到原来的话题上来，我们已经解决了前两类问题——01 背包和完全背包，现在来看多重背包。  \n还是考虑拆分，把一件可以装 `Mi` 次的多重背包物品拆分成 `Mi` 件 01 背包物品，分别对其进行 01 背包处理。这种方法很好理解，但时间复杂度达到了$O(V*{\\Sigma}Mi)$，考虑将其优化。  \n我们采用类似二进制的思想，将每个多重背包物品拆分为 `t` 个不同的 01 背包物品，每一个拆分后的物品都有一个系数 `k`，该物品的体积和价值分别等于**原物品的体积和价值乘以这个系数**，并且使所有拆分后的物品的系数之和${\\Sigma}k = Mi$，即原物品最多被放置的次数。并且要使每个系数 `k` 分别为 $1$,$2$,$4$,…,$2 ^ {t - 1}$,$Wi - 2 ^ {t - 1}$。  \n举个例子，当 `Mi = 17` 时，将其拆成 `5` 件物品，系数 `k` 分别为 `1`,`2`,`4`,`8`,`2`。  \n使用二进制思想优化过的算法，复杂度降为了$O(V * {\\Sigma}{\\log}Wi)$。  \n实现代码为（`t[i].v` 和 `t[i].w` 分别代表 `Vi` 和 `Wi`）：  \n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tunsigned int logx = log2(t[i].m), x = 0;\n\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\tx += (1 << j); // 1 << j 将 1 按二进制位左移 j 位，快速计算 2 的 j 次方\n\t\tfor (int v = V; v >= 0; v--) { // 01 背包\n\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x < t[i].m) { // 如果不能 2 的幂作为系数将原物品完全拆分，则多拆分出一件物品 k = Wi - 2 ^ (t - 1)\n\t\tfor (int v = V; v >= 0; v--) { // 01 背包\n\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t}\n\t\t}\n\t}\n}\n```\n三种背包问题的思路明确后，就可以考虑混合背包问题了，具体实现方法是对于每一种物品，判断物品类型，分别进行处理。  \n### AC 代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 200;\nconst unsigned int MAXV = 200000;\n\nunsigned int n, V;\n\nstruct thing_t {\n\tunsigned int v, w;\n\tint m;\n} t[MAXN];\n\nunsigned int f[MAXV + 1];\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tch = getchar();\n\t\tflag = true;\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nunsigned int log2(unsigned int x) {\n\tunsigned int i = 0, y = 0;\n\twhile ((y += (1 << i)) <= x) {\n\t\ti++;\n\t}\n\treturn i - 1;\n}\n\nint main() {\n\tread(n), read(V);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tread(t[i].v), read(t[i].w), read(t[i].m);\n\t}\n\n\tregister unsigned int result = 0;\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tif (t[i].m == 1) {\n\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (t[i].m == -1) {\n\t\t\tfor (unsigned int v = 0; v <= V; v++) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned int logx = log2(t[i].m), x = 0;\n\t\t\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\t\t\tx += (1 << j);\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (x < t[i].m) {\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", result);\n\n\treturn 0;\n}\n```\n### 吐槽\n这段时间在学习 dp，听 liujz 学长讲完后自己抱着书啃了好久 ……  \n算是有些理解了吧 >_<","slug":"codevs-3269","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nd900hpofdkl5ztsrzz"},{"title":"「CodeVS 3269」混合背包 - 背包DP + 单调队列","id":"23","updated":"2016-01-19T13:03:26.000Z","date":"2016-01-14T21:47:45.000Z","_content":"\n背包体积为 `V`（<= 200,000），给出 `N`（<= 200）个物品，每个物品占用体积为 `Vi`，价值为 `Wi`，每个物品要么至多取 `1` 件，要么至多取 `Mi`（> `1`）件，要么数量无限，求装入背包内物品总价值的最大值。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### 解题思路\n01 和完全这两种之前写过，这里就重点说说怎么用单调队列来解多重。\n\n首先，对于多重背包的每件物品，`n` 表示这件物品的数量，`w` 表示这件物品的体积，`c` 表示这件物品的价值。\n\n朴素的多重背包状态转移方程为：\n\n$$ f[i]=\\max\\{f[i-k*c]+k*w,k{\\in}[0,n]\\} $$\n\n设 $r=i ~~ \\% ~~ c$，$m=i ~~ / ~~ c$。\n\n`m` 的意义为，如果当前状态的背包容量全部用来放当前物品，能放多少件。  \n`r` 的意义为，如果当前状态的背包容量全部用来放当前物品，则剩下的容量是多少。\n\n到此，我们可以修改一下方程，使原来的枚举 `i` 变为先枚举 `r`，然后在 $[0,m]$ 上枚举 `d`，以 $(m-d)*c+r$代替原来的 `i`。\n\n$$ f[(m-d)*c+r]=\\max\\{f[(m-d)*c+r]+d*w,d{\\in}[0,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n令\n\n$$ k=m-d $$\n\n代入上式得\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]+(m-k)*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n进一步化为\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]-k*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n令\n\n$$ g(k,r)=f[k*c+r]-k*w $$\n\n代入上式得\n\n$$ f[k*c+r]=\\max\\{g(k,r),k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n由此得到一个可以用单调队列优化的方程，结合方程我们知道，$ f[k*c+r] $是由之前的 `n + 1` 项的最大值推出的，于是用一个长度为 `n + 1` 的单调队列维护 $g(k,r)$，就可以 $O(1)$ 地求出每个状态。\n\n需要注意的是，在使用单调队列实现这个算法时，方程中的 `m` 应该被替换为当前状态对应的 `k`，因为枚举的 `k` 总是当前状态的**背包容量全部用来放当前物品的最大件数**。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <deque>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXV = 200000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, V;\nint f[MAXV + 1];\n\ninline void pack(int c, int w, int n) {\n\tif (n == 1) {\n\t\tfor (int v = V; v >= c; v--) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else if (n == -1) {\n\t\tfor (int v = c; v <= V; v++) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else {\n\t\tn = std::min(n, V / c);\n\t\tfor (int r = 0; r < c; r++) {\n\t\t\tMonotoneQueue<int> q;\n\t\t\tint m = (V - r) / c;\n\t\t\tfor (int k = 0; k <= m; k++) {\n\t\t\t\tif (q.size() == n + 1) q.pop();\n\t\t\t\tq.push(f[k * c + r] - k * w);\n\t\t\t\tf[k * c + r] = q.top() + k * w;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &V);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, w, n;\n\t\tscanf(\"%d %d %d\", &c, &w, &n);\n\t\tpack(c, w, n);\n\t}\n\n\tprintf(\"%d\\n\", f[V]);\n\n\treturn 0;\n}\n```","source":"_posts/codevs-3269-monotone-queue.md","raw":"title: 「CodeVS 3269」混合背包 - 背包DP + 单调队列\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - 单调队列\n  - 背包DP\npermalink: codevs-3269-monotone-queue\nid: 23\nupdated: '2016-01-19 21:03:26'\ndate: 2016-01-15 05:47:45\n---\n\n背包体积为 `V`（<= 200,000），给出 `N`（<= 200）个物品，每个物品占用体积为 `Vi`，价值为 `Wi`，每个物品要么至多取 `1` 件，要么至多取 `Mi`（> `1`）件，要么数量无限，求装入背包内物品总价值的最大值。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### 解题思路\n01 和完全这两种之前写过，这里就重点说说怎么用单调队列来解多重。\n\n首先，对于多重背包的每件物品，`n` 表示这件物品的数量，`w` 表示这件物品的体积，`c` 表示这件物品的价值。\n\n朴素的多重背包状态转移方程为：\n\n$$ f[i]=\\max\\{f[i-k*c]+k*w,k{\\in}[0,n]\\} $$\n\n设 $r=i ~~ \\% ~~ c$，$m=i ~~ / ~~ c$。\n\n`m` 的意义为，如果当前状态的背包容量全部用来放当前物品，能放多少件。  \n`r` 的意义为，如果当前状态的背包容量全部用来放当前物品，则剩下的容量是多少。\n\n到此，我们可以修改一下方程，使原来的枚举 `i` 变为先枚举 `r`，然后在 $[0,m]$ 上枚举 `d`，以 $(m-d)*c+r$代替原来的 `i`。\n\n$$ f[(m-d)*c+r]=\\max\\{f[(m-d)*c+r]+d*w,d{\\in}[0,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n令\n\n$$ k=m-d $$\n\n代入上式得\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]+(m-k)*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n进一步化为\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]-k*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n令\n\n$$ g(k,r)=f[k*c+r]-k*w $$\n\n代入上式得\n\n$$ f[k*c+r]=\\max\\{g(k,r),k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n由此得到一个可以用单调队列优化的方程，结合方程我们知道，$ f[k*c+r] $是由之前的 `n + 1` 项的最大值推出的，于是用一个长度为 `n + 1` 的单调队列维护 $g(k,r)$，就可以 $O(1)$ 地求出每个状态。\n\n需要注意的是，在使用单调队列实现这个算法时，方程中的 `m` 应该被替换为当前状态对应的 `k`，因为枚举的 `k` 总是当前状态的**背包容量全部用来放当前物品的最大件数**。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <deque>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXV = 200000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, V;\nint f[MAXV + 1];\n\ninline void pack(int c, int w, int n) {\n\tif (n == 1) {\n\t\tfor (int v = V; v >= c; v--) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else if (n == -1) {\n\t\tfor (int v = c; v <= V; v++) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else {\n\t\tn = std::min(n, V / c);\n\t\tfor (int r = 0; r < c; r++) {\n\t\t\tMonotoneQueue<int> q;\n\t\t\tint m = (V - r) / c;\n\t\t\tfor (int k = 0; k <= m; k++) {\n\t\t\t\tif (q.size() == n + 1) q.pop();\n\t\t\t\tq.push(f[k * c + r] - k * w);\n\t\t\t\tf[k * c + r] = q.top() + k * w;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &V);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, w, n;\n\t\tscanf(\"%d %d %d\", &c, &w, &n);\n\t\tpack(c, w, n);\n\t}\n\n\tprintf(\"%d\\n\", f[V]);\n\n\treturn 0;\n}\n```","slug":"codevs-3269-monotone-queue","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4ndf00huofdktf9opz43"},{"title":"「CodeVS 3168 / 3162」抄书问题 - 划分DP / 二分答案","id":"14","updated":"2016-01-06T13:03:26.000Z","date":"2016-01-05T21:47:45.000Z","_content":"\n把 `M` 本有顺序的书分给 `K` 个人抄写，每一个人的抄写速度都一样，一本书不允许给两个（或以上）的人抄写，分给每一个人的书，必须是连续的（比如不能把第一、第三、第四本数给同一个人抄写）。现在请你设计一种方案，使得复制时间最短。复制时间为抄写页数最多的人用去的时间。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 3162 - 抄书问题](http://codevs.cn/problem/3162/)  \n[CodeVS 3168 - 抄书问题 3](http://codevs.cn/problem/3168/)\n\n### 划分DP\n考虑用动态规划求出最短时间，以 $a[m]$ 表示第 `m` 本书的页数，$f[m][k]$ 表示前 `m` 本书给前 `k` 个人抄需要的最短时间。\n\n边界条件为：\n$$f[m][1]={\\sum_{i=1}^{n}}a[i]$$\n\n转移方程为：\n$$f[m][k]={\\min} \\{ {\\max}(f[i][k-1],{ \\sum_{j=i+1}^{m}}a[j]), i{\\in}[k-1,m-1]\\}$$\n\n即，枚举第 `k` 个人抄的书数，从“前面 `k - 1` 个人每人只抄一本，剩下的全留给第 `k` 个人”到“前面 `k - 1` 个人一共抄 `m - 1` 本，给第 `k` 个人留一本”，并上第 `k` 个人抄的时间，取最小值。\n\n求书本页数的区间和可以用一个前缀和数组来优化时间复杂度，故该算法时间复杂度为 $O(km^2)$。\n\n```C++\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n```\n### 二分答案\n加大后的数据量已不能使用 DP 的方法，考虑对最短时间在**最大页数**到**总页数**之间进行二分，检验过程**贪心**枚举每一本书，从最后一个人开始，如果当前的人还能抄就给他抄，否则给前一个人抄，如果最后能抄完则可行。\n\n时间复杂度为 $O(m{\\log}m)$。\n\n```C++\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n```\n### 方案输出\n输出方案算是这题最难的地方。~~才不会告诉你们我 WA 了 8 次呢！~~\n\n和二分答案求最短时间的思路相似，贪心枚举每本书，从最后一个人开始（注意题目要求前面的人少抄），如果当前人还能抄，就给他抄，否则给下一个人抄，**如果剩余人的数量大于剩余书的数量，则无论如何都要给下一个人抄（后面的全给抄完了咱前面的吵啥啊）**。\n\n输出顺序可以用一个栈来调整。\n\n```C++\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n```\n### AC代码（划分DP，CodeVS 3162）\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 100;\nconst int MAXK = 100;\n\nint m, k;\nint a[MAXM], prefix[MAXM], f[MAXM][MAXK], pageCount[MAXK];\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefix();\n\tmemset(f, 0xff, sizeof(f));\n\n\tans = search(m, k);\n\tprintPlan();\n\n\treturn 0;\n}\n```\n\n### AC代码（二分答案，CodeVS 3162，CodeVS 3168）\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 1000000;\nconst int MAXK = 10000;\n\nint m, k;\nint a[MAXM], prefix[MAXM], pageCount[MAXK], max;\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tmax = std::max(max, a[i]);\n\t}\n\n\tmakePrefix();\n\n\tans = binaryDivide();\n\tprintPlan();\n\n\treturn 0;\n}\n```\n","source":"_posts/codevs-3168-3162.md","raw":"title: 「CodeVS 3168 / 3162」抄书问题 - 划分DP / 二分答案\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - 二分答案\n  - 划分DP\n  - 贪心\npermalink: codevs-3168-3162\nid: 14\nupdated: '2016-01-06 21:03:26'\ndate: 2016-01-06 05:47:45\n---\n\n把 `M` 本有顺序的书分给 `K` 个人抄写，每一个人的抄写速度都一样，一本书不允许给两个（或以上）的人抄写，分给每一个人的书，必须是连续的（比如不能把第一、第三、第四本数给同一个人抄写）。现在请你设计一种方案，使得复制时间最短。复制时间为抄写页数最多的人用去的时间。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 3162 - 抄书问题](http://codevs.cn/problem/3162/)  \n[CodeVS 3168 - 抄书问题 3](http://codevs.cn/problem/3168/)\n\n### 划分DP\n考虑用动态规划求出最短时间，以 $a[m]$ 表示第 `m` 本书的页数，$f[m][k]$ 表示前 `m` 本书给前 `k` 个人抄需要的最短时间。\n\n边界条件为：\n$$f[m][1]={\\sum_{i=1}^{n}}a[i]$$\n\n转移方程为：\n$$f[m][k]={\\min} \\{ {\\max}(f[i][k-1],{ \\sum_{j=i+1}^{m}}a[j]), i{\\in}[k-1,m-1]\\}$$\n\n即，枚举第 `k` 个人抄的书数，从“前面 `k - 1` 个人每人只抄一本，剩下的全留给第 `k` 个人”到“前面 `k - 1` 个人一共抄 `m - 1` 本，给第 `k` 个人留一本”，并上第 `k` 个人抄的时间，取最小值。\n\n求书本页数的区间和可以用一个前缀和数组来优化时间复杂度，故该算法时间复杂度为 $O(km^2)$。\n\n```C++\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n```\n### 二分答案\n加大后的数据量已不能使用 DP 的方法，考虑对最短时间在**最大页数**到**总页数**之间进行二分，检验过程**贪心**枚举每一本书，从最后一个人开始，如果当前的人还能抄就给他抄，否则给前一个人抄，如果最后能抄完则可行。\n\n时间复杂度为 $O(m{\\log}m)$。\n\n```C++\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n```\n### 方案输出\n输出方案算是这题最难的地方。~~才不会告诉你们我 WA 了 8 次呢！~~\n\n和二分答案求最短时间的思路相似，贪心枚举每本书，从最后一个人开始（注意题目要求前面的人少抄），如果当前人还能抄，就给他抄，否则给下一个人抄，**如果剩余人的数量大于剩余书的数量，则无论如何都要给下一个人抄（后面的全给抄完了咱前面的吵啥啊）**。\n\n输出顺序可以用一个栈来调整。\n\n```C++\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n```\n### AC代码（划分DP，CodeVS 3162）\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 100;\nconst int MAXK = 100;\n\nint m, k;\nint a[MAXM], prefix[MAXM], f[MAXM][MAXK], pageCount[MAXK];\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefix();\n\tmemset(f, 0xff, sizeof(f));\n\n\tans = search(m, k);\n\tprintPlan();\n\n\treturn 0;\n}\n```\n\n### AC代码（二分答案，CodeVS 3162，CodeVS 3168）\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 1000000;\nconst int MAXK = 10000;\n\nint m, k;\nint a[MAXM], prefix[MAXM], pageCount[MAXK], max;\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tmax = std::max(max, a[i]);\n\t}\n\n\tmakePrefix();\n\n\tans = binaryDivide();\n\tprintPlan();\n\n\treturn 0;\n}\n```\n","slug":"codevs-3168-3162","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4ndk00i0ofdkabqlvccz"},{"title":"「CodeVS 2822」爱在心中 - 强联通分量","date":"2016-03-04T02:47:42.000Z","_content":"\n在爱的国度里有 N 个人，在他们的心中都有着一个爱的名单，上面记载着他所爱的人（不会出现自爱的情况）。爱是具有传递性的，即如果 A 爱 B，B 爱 C，则 A 也爱 C。\n\n如果有这样一部分人，他们彼此都相爱，则他们就超越了一切的限制，用集体的爱化身成为一个爱心天使。现在，我们想知道在这个爱的国度里会出现多少爱心天使。而且，如果某个爱心天使被其他所有人或爱心天使所爱则请输出这个爱心天使是由哪些人构成的，否则输出 -1。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 2822](http://codevs.cn/problem/2822/)\n\n### 解题思路\n第一问很明显的，求出图中有多少不是单点的强联通分量就是答案。\n\n第二问，把每个强联通分量缩成一个点，重新构图，如果新图中有出度为零的点，则该点对应的原图中的点集即为第二问答案。注意排除一个点情况。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint id, dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tstd::vector<int> vec;\n\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t\tu->connected->vec.push_back(u->id);\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1 && connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1) {\n\t\t\tans++;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\tConnected *loved = contract(count);\n\tif (!loved) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tstd::sort(loved->vec.begin(), loved->vec.end());\n\n\t\tfor (std::vector<int>::const_iterator p = loved->vec.begin(); p != loved->vec.end(); p++) {\n\t\t\tprintf(\"%d \", *p);\n\t\t}\n\n\t\tputchar('\\n');\n\t}\n\n\treturn 0;\n}\n\n```\n","source":"_posts/codevs-2822.md","raw":"title: 「CodeVS 2822」爱在心中 - 强联通分量\ncategories: OI\ntags: \n  - CodeVS\n  - 图论\n  - Tarjan\n  - 强联通分量\n  - 缩点\npermalink: codevs-2822\ndate: 2016-03-04 10:47:42\n---\n\n在爱的国度里有 N 个人，在他们的心中都有着一个爱的名单，上面记载着他所爱的人（不会出现自爱的情况）。爱是具有传递性的，即如果 A 爱 B，B 爱 C，则 A 也爱 C。\n\n如果有这样一部分人，他们彼此都相爱，则他们就超越了一切的限制，用集体的爱化身成为一个爱心天使。现在，我们想知道在这个爱的国度里会出现多少爱心天使。而且，如果某个爱心天使被其他所有人或爱心天使所爱则请输出这个爱心天使是由哪些人构成的，否则输出 -1。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 2822](http://codevs.cn/problem/2822/)\n\n### 解题思路\n第一问很明显的，求出图中有多少不是单点的强联通分量就是答案。\n\n第二问，把每个强联通分量缩成一个点，重新构图，如果新图中有出度为零的点，则该点对应的原图中的点集即为第二问答案。注意排除一个点情况。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint id, dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tstd::vector<int> vec;\n\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t\tu->connected->vec.push_back(u->id);\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1 && connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1) {\n\t\t\tans++;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\tConnected *loved = contract(count);\n\tif (!loved) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tstd::sort(loved->vec.begin(), loved->vec.end());\n\n\t\tfor (std::vector<int>::const_iterator p = loved->vec.begin(); p != loved->vec.end(); p++) {\n\t\t\tprintf(\"%d \", *p);\n\t\t}\n\n\t\tputchar('\\n');\n\t}\n\n\treturn 0;\n}\n\n```\n","slug":"codevs-2822","published":1,"updated":"2016-03-15T01:05:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4ndp00i7ofdkltzqkb9k"},{"title":"「CodeVS 2598」编辑距离问题 - 线性DP","id":"17","updated":"2016-01-19T13:05:21.000Z","date":"2016-01-08T21:32:19.000Z","_content":"\n设 A 和 B 是 2 个字符串。要用最少的字符操作将字符串 A 转换为字符串 B。这里所说的字符操作包括：\n\n1. 删除一个字符；\n2. 插入一个字符；\n3. 将一个字符改为另一个字符。\n\n求将字符串 A 变换为字符串 B 所用的最少字符操作数，即 A 到 B 的编辑距离。\n\n字符串 A、B 的长度均不超过4000。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 2598](http://codevs.cn/problem/2598/)\n\n### 解题思路\n字符串的题乍一看都很恶心，但这道题仔细想想还是很简单的。\n用 `f[i][j]` 表示字符串 A 的前 `i` 个字符到字符串 B 的前 `j` 个字符的编辑距离，则转移方程为：\n\n$$ f[i][j] = \\cases{ f[i-1][j-1] & A[i]=B[j] \\\\ {\\min}(f[i][j-1],f[i-1][j],f[i-1][j-1])+1 & A[i] ≠ B[j]} $$\n\n当 $ A[i]=B[j] $ 时，当前位置无需编辑，直接等于上一位的编辑距离。\n\n当 $ A[i]≠B[j] $ 时，有三种情况：\n\n1. 字符串 B 的前 `j` 位可由 $A[i]$ 编辑到 $B[j-1]$ 后插入 B 的第 `j` 个字符得到。\n2. 字符串 B 的前 `j` 位可由 $A[i-1]$ 编辑到 $B[j]$ 后删除 A 的第 `i` 个字符得到。\n3. 字符串 B 的前 `j` 位可由 $A[i-1]$ 编辑到 $B[j-1]$ 后修改 A 的第 `i` 个字符为 B 的第 `j` 个字符得到。\n\n### AC代码\n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 4000;\n\nchar s1[MAXN + 1], s2[MAXN + 1];\nint n1, n2, ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == 0) return j;\n\tif (j == 0) return i;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (s1[i - 1] == s2[j - 1]) {\n\t\t\tans[i - 1][j - 1] = search(i - 1, j - 1);\n\t\t} else {\n\t\t\tans[i - 1][j - 1] = INT_MAX;\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j - 1) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i, j - 1) + 1);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%s %s\", s1, s2);\n\tn1 = strlen(s1), n2 = strlen(s2);\n\n\tprintf(\"%d\\n\", search(n1, n2));\n\treturn 0;\n}\n```","source":"_posts/codevs-2598.md","raw":"title: 「CodeVS 2598」编辑距离问题 - 线性DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - 字符串\n  - 线性DP\npermalink: codevs-2598\nid: 17\nupdated: '2016-01-19 21:05:21'\ndate: 2016-01-09 05:32:19\n---\n\n设 A 和 B 是 2 个字符串。要用最少的字符操作将字符串 A 转换为字符串 B。这里所说的字符操作包括：\n\n1. 删除一个字符；\n2. 插入一个字符；\n3. 将一个字符改为另一个字符。\n\n求将字符串 A 变换为字符串 B 所用的最少字符操作数，即 A 到 B 的编辑距离。\n\n字符串 A、B 的长度均不超过4000。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 2598](http://codevs.cn/problem/2598/)\n\n### 解题思路\n字符串的题乍一看都很恶心，但这道题仔细想想还是很简单的。\n用 `f[i][j]` 表示字符串 A 的前 `i` 个字符到字符串 B 的前 `j` 个字符的编辑距离，则转移方程为：\n\n$$ f[i][j] = \\cases{ f[i-1][j-1] & A[i]=B[j] \\\\ {\\min}(f[i][j-1],f[i-1][j],f[i-1][j-1])+1 & A[i] ≠ B[j]} $$\n\n当 $ A[i]=B[j] $ 时，当前位置无需编辑，直接等于上一位的编辑距离。\n\n当 $ A[i]≠B[j] $ 时，有三种情况：\n\n1. 字符串 B 的前 `j` 位可由 $A[i]$ 编辑到 $B[j-1]$ 后插入 B 的第 `j` 个字符得到。\n2. 字符串 B 的前 `j` 位可由 $A[i-1]$ 编辑到 $B[j]$ 后删除 A 的第 `i` 个字符得到。\n3. 字符串 B 的前 `j` 位可由 $A[i-1]$ 编辑到 $B[j-1]$ 后修改 A 的第 `i` 个字符为 B 的第 `j` 个字符得到。\n\n### AC代码\n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 4000;\n\nchar s1[MAXN + 1], s2[MAXN + 1];\nint n1, n2, ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == 0) return j;\n\tif (j == 0) return i;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (s1[i - 1] == s2[j - 1]) {\n\t\t\tans[i - 1][j - 1] = search(i - 1, j - 1);\n\t\t} else {\n\t\t\tans[i - 1][j - 1] = INT_MAX;\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j - 1) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i, j - 1) + 1);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%s %s\", s1, s2);\n\tn1 = strlen(s1), n2 = strlen(s2);\n\n\tprintf(\"%d\\n\", search(n1, n2));\n\treturn 0;\n}\n```","slug":"codevs-2598","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4ndu00ieofdkuach27pc"},{"title":"「CodeVS 1563」奶牛的交通 - 网络流","id":"42","updated":"2016-02-06T14:23:12.000Z","date":"2016-02-05T13:06:41.000Z","_content":"\n给出一个无向图，问最少割掉多少个点使 `s` 点与 `t` 点不连通。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1563](http://codevs.cn/problem/1563/)  \n[洛谷 1345](http://www.luogu.org/problem/show?pid=1345)\n\n### 解题思路\n首先，这题一看就是最小割，由最小割最大流定理得，求出最大流就是最小割。\n\n怎么流？\n\n一般的网络流，流量都在边上，求出的割也是割的边 …… 而我们这次需要割点，那就拆点呀！\n\n把每个点拆成 `i` 和 `i'` 两个点，`i` 表示进入这个点，`i'` 表示离开这个点。由 `i` 向 `i'` 连接一条有向边，容量为 1。对于原图中任意一条有向边 `(i, j)`，连接 `(i', j)`，容量为正无穷。\n\n于是就完成了喜闻乐见的建模，求出 `s'` 到 `t` （想一想为什么不是 `s` 到 `t'`？）的最大流就是答案啦！\n\n###AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 600;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, s, t;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"addEdge(%d, %d, %d)\\n\", from + 1, to + 1, capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void link(int u, int v) {\n\taddEdge(u + n, v, INT_MAX);\n\taddEdge(v + n, u, INT_MAX);\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->capacity != e->flow) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn t->level != 0;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t){\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tscanf(\"%d %d %d %d\", &n, &m, &s, &t), s--, t--;\n\n\tfor (int i = 0; i < n; i++) addEdge(i, i + n, 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\n\t\tlink(u, v);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s + n, t));\n\n\treturn 0;\n}\n```\n","source":"_posts/codevs-1563.md","raw":"title: 「CodeVS 1563」奶牛的交通 - 网络流\ncategories: OI\ntags: \n  - CodeVS\n  - 网络流\n  - Dinic\n  - 图论\npermalink: codevs-1563\nid: 42\nupdated: '2016-02-06 22:23:12'\ndate: 2016-02-05 21:06:41\n---\n\n给出一个无向图，问最少割掉多少个点使 `s` 点与 `t` 点不连通。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1563](http://codevs.cn/problem/1563/)  \n[洛谷 1345](http://www.luogu.org/problem/show?pid=1345)\n\n### 解题思路\n首先，这题一看就是最小割，由最小割最大流定理得，求出最大流就是最小割。\n\n怎么流？\n\n一般的网络流，流量都在边上，求出的割也是割的边 …… 而我们这次需要割点，那就拆点呀！\n\n把每个点拆成 `i` 和 `i'` 两个点，`i` 表示进入这个点，`i'` 表示离开这个点。由 `i` 向 `i'` 连接一条有向边，容量为 1。对于原图中任意一条有向边 `(i, j)`，连接 `(i', j)`，容量为正无穷。\n\n于是就完成了喜闻乐见的建模，求出 `s'` 到 `t` （想一想为什么不是 `s` 到 `t'`？）的最大流就是答案啦！\n\n###AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 600;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, s, t;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"addEdge(%d, %d, %d)\\n\", from + 1, to + 1, capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void link(int u, int v) {\n\taddEdge(u + n, v, INT_MAX);\n\taddEdge(v + n, u, INT_MAX);\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->capacity != e->flow) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn t->level != 0;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t){\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tscanf(\"%d %d %d %d\", &n, &m, &s, &t), s--, t--;\n\n\tfor (int i = 0; i < n; i++) addEdge(i, i + n, 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\n\t\tlink(u, v);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s + n, t));\n\n\treturn 0;\n}\n```\n","slug":"codevs-1563","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4ne900ilofdk8263tvyl"},{"title":"「CodeVS 1345」饥饿的奶牛 - 线性DP","id":"21","updated":"2016-01-19T13:04:02.000Z","date":"2016-01-13T21:17:18.000Z","_content":"\n在 `n`（≤ 1000）条线段中选出若干条，保证任意两条线段没有公共点（端点也不能重合），使总长度最大。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1345](http://codevs.cn/problem/1345/)\n\n### 解题思路\n刚开始确实晕了，又是想线段树又是想背包 ……\n\n保证线段不重合是个难点 …… 解决方法以线段的右端点排序，**去除后效性**。\n\n以 $ f[i] $ 表示前 `i` 条线段中选出若干条（必选第 `i` 条）的最大总长度，则转移方程为：\n\n$$ f[i]=\\max\\{f[j],r(j)< l(i)\\}+length(i) $$\n\n简单地说，就是只要**保证最后一条线段不与当前线段重合**，就可以添加当前线段。\n\n注意最终答案是 $ max\\{f[i],i{\\in}[1,n]\\} $，而不一定是 $f[n]$，因为不选最后一条线段可能比选最后一条线段更优。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 1000;\n\nstruct Range {\n\tint l, r;\n\n\tint length() {\n\t\treturn r - l + 1;\n\t}\n\n\tbool operator<(const Range &other) const {\n\t\tif (r == other.r) return l < other.l;\n\t\telse return r < other.r;\n\t}\n} a[MAXN];\n\nint n, f[MAXN];\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].l, &a[i].r);\n\t}\n\n\tstd::sort(a, a + n);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint max = 0;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j].r < a[i].l) max = std::max(max, f[j]);\n\t\t}\n\n\t\tf[i] = a[i].length() + max;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/codevs-1345.md","raw":"title: 「CodeVS 1345」饥饿的奶牛 - 线性DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - 线性DP\npermalink: codevs-1345\nid: 21\nupdated: '2016-01-19 21:04:02'\ndate: 2016-01-14 05:17:18\n---\n\n在 `n`（≤ 1000）条线段中选出若干条，保证任意两条线段没有公共点（端点也不能重合），使总长度最大。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1345](http://codevs.cn/problem/1345/)\n\n### 解题思路\n刚开始确实晕了，又是想线段树又是想背包 ……\n\n保证线段不重合是个难点 …… 解决方法以线段的右端点排序，**去除后效性**。\n\n以 $ f[i] $ 表示前 `i` 条线段中选出若干条（必选第 `i` 条）的最大总长度，则转移方程为：\n\n$$ f[i]=\\max\\{f[j],r(j)< l(i)\\}+length(i) $$\n\n简单地说，就是只要**保证最后一条线段不与当前线段重合**，就可以添加当前线段。\n\n注意最终答案是 $ max\\{f[i],i{\\in}[1,n]\\} $，而不一定是 $f[n]$，因为不选最后一条线段可能比选最后一条线段更优。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 1000;\n\nstruct Range {\n\tint l, r;\n\n\tint length() {\n\t\treturn r - l + 1;\n\t}\n\n\tbool operator<(const Range &other) const {\n\t\tif (r == other.r) return l < other.l;\n\t\telse return r < other.r;\n\t}\n} a[MAXN];\n\nint n, f[MAXN];\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].l, &a[i].r);\n\t}\n\n\tstd::sort(a, a + n);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint max = 0;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j].r < a[i].l) max = std::max(max, f[j]);\n\t\t}\n\n\t\tf[i] = a[i].length() + max;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"codevs-1345","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nee00irofdk8m3gzz21"},{"title":"「BZOJ 2683」简单题 - CDQ","id":"43","updated":"2016-02-05T14:46:27.000Z","date":"2016-02-05T14:42:35.000Z","_content":"\n有一个$N*N$的棋盘，每个格子内有一个整数，初始时的时候全部为 0，现在需要维护两种操作：\n\n1. 将格子$(x,y)$里的数字加上$A$；\n2. 输出$(x1,y1)(x2,y2)$这个矩形内的数字和。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 2683](http://www.lydsy.com/JudgeOnline/problem.php?id=2683)\n\n### 解题思路\n离线，按照 X 轴排序，将其转化为时间 …… 然后 CDQ 之！\n\n进行 CDQ 时，用一个树状数组维护 Y 轴的信息，把 ID 小于等于 `mid` 的一半中的修改操作产生的影响加到 ID 大于 `mid` 的另一半的查询结果中。\n\n因为统计的是矩形区域的数字总和，所以要把一次询问转化为四次，用下图所示的方法求出答案（图片来自 WC2016 李建老师的课件）：\n\n![cdq](bzoj-2683/cdq.png)\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 200000 * 4;\n\nenum OperateType {\n\tUpdate = 1, Query = 2\n};\n\nstruct Operate {\n\tOperateType type;\n\tint id, x, y, *ans, num;\n\n\tOperate(OperateType type, int id, int x, int y, int num, int *ans = NULL) : type(type), id(id), x(x), y(y), ans(ans), num(num) {}\n\tOperate() {}\n\n\tbool operator<(const Operate &other) const {\n\t\tif (x < other.x) return true;\n\t\telse if (x == other.x && y < other.y) return true;\n\t\telse if (x == other.x && y == other.y && id < other.id) return true;\n\t\treturn false;\n\t}\n};\n\nstd::vector<Operate> v;\nint n, ans[MAXM];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & (-x);\n\t}\n\n\tvoid update(int pos, int x) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) {\n\t\t\ta[i - 1] += x;\n\t\t}\n\t}\n\n\tint query(int pos) {\n\t\tint ans = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) {\n\t\t\tans += a[i - 1];\n\t\t}\n\n\t\treturn ans;\n\t}\n} bit;\n\nvoid cdq(int l, int r) {\n\tif (l >= r) return;\n\n\tint mid = l + ((r - l) >> 1);\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, o.num);\n\t\telse if (o.id > mid && o.type == Query) *o.ans += bit.query(o.y) * o.num;\n\t}\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, -o.num);\n\t}\n\n\tstatic Operate a[MAXM];\n\tint L = l, R = mid + 1;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (v[i - 1].id <= mid) a[L++ - 1] = v[i - 1];\n\t\telse a[R++ - 1] = v[i - 1];\n\t}\n\tmemcpy(&v[l - 1], &a[l - 1], sizeof(Operate) * (r - l + 1));\n\n\tcdq(l, mid), cdq(mid + 1, r);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tint m = 0, queryCount = 0;\n\twhile (20000528) {\n\t\tint type;\n\t\tscanf(\"%d\", &type);\n\n\t\tif (type == 1) {\n\t\t\tint x, y, num;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &num);\n\t\t\tv.push_back(Operate(Update, ++m, x, y, num));\n\t\t} else if (type == 2) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y1 - 1, 1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y2, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y1 - 1, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y2, 1, &ans[queryCount]));\n\t\t\tqueryCount++;\n\t\t} else break;\n\t}\n\n\tstd::sort(v.begin(), v.end());\n\tcdq(1, m);\n\n\tfor (int i = 0; i < queryCount; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2683.md","raw":"title: 「BZOJ 2683」简单题 - CDQ\ncategories: OI\ntags: \n  - BZOJ\n  - CDQ\n  - 树状数组\n  - 高级数据结构\n  - 数据结构\npermalink: bzoj-2683\nid: 43\nupdated: '2016-02-05 22:46:27'\ndate: 2016-02-05 22:42:35\n---\n\n有一个$N*N$的棋盘，每个格子内有一个整数，初始时的时候全部为 0，现在需要维护两种操作：\n\n1. 将格子$(x,y)$里的数字加上$A$；\n2. 输出$(x1,y1)(x2,y2)$这个矩形内的数字和。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 2683](http://www.lydsy.com/JudgeOnline/problem.php?id=2683)\n\n### 解题思路\n离线，按照 X 轴排序，将其转化为时间 …… 然后 CDQ 之！\n\n进行 CDQ 时，用一个树状数组维护 Y 轴的信息，把 ID 小于等于 `mid` 的一半中的修改操作产生的影响加到 ID 大于 `mid` 的另一半的查询结果中。\n\n因为统计的是矩形区域的数字总和，所以要把一次询问转化为四次，用下图所示的方法求出答案（图片来自 WC2016 李建老师的课件）：\n\n![cdq](bzoj-2683/cdq.png)\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 200000 * 4;\n\nenum OperateType {\n\tUpdate = 1, Query = 2\n};\n\nstruct Operate {\n\tOperateType type;\n\tint id, x, y, *ans, num;\n\n\tOperate(OperateType type, int id, int x, int y, int num, int *ans = NULL) : type(type), id(id), x(x), y(y), ans(ans), num(num) {}\n\tOperate() {}\n\n\tbool operator<(const Operate &other) const {\n\t\tif (x < other.x) return true;\n\t\telse if (x == other.x && y < other.y) return true;\n\t\telse if (x == other.x && y == other.y && id < other.id) return true;\n\t\treturn false;\n\t}\n};\n\nstd::vector<Operate> v;\nint n, ans[MAXM];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & (-x);\n\t}\n\n\tvoid update(int pos, int x) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) {\n\t\t\ta[i - 1] += x;\n\t\t}\n\t}\n\n\tint query(int pos) {\n\t\tint ans = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) {\n\t\t\tans += a[i - 1];\n\t\t}\n\n\t\treturn ans;\n\t}\n} bit;\n\nvoid cdq(int l, int r) {\n\tif (l >= r) return;\n\n\tint mid = l + ((r - l) >> 1);\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, o.num);\n\t\telse if (o.id > mid && o.type == Query) *o.ans += bit.query(o.y) * o.num;\n\t}\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, -o.num);\n\t}\n\n\tstatic Operate a[MAXM];\n\tint L = l, R = mid + 1;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (v[i - 1].id <= mid) a[L++ - 1] = v[i - 1];\n\t\telse a[R++ - 1] = v[i - 1];\n\t}\n\tmemcpy(&v[l - 1], &a[l - 1], sizeof(Operate) * (r - l + 1));\n\n\tcdq(l, mid), cdq(mid + 1, r);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tint m = 0, queryCount = 0;\n\twhile (20000528) {\n\t\tint type;\n\t\tscanf(\"%d\", &type);\n\n\t\tif (type == 1) {\n\t\t\tint x, y, num;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &num);\n\t\t\tv.push_back(Operate(Update, ++m, x, y, num));\n\t\t} else if (type == 2) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y1 - 1, 1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y2, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y1 - 1, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y2, 1, &ans[queryCount]));\n\t\t\tqueryCount++;\n\t\t} else break;\n\t}\n\n\tstd::sort(v.begin(), v.end());\n\tcdq(1, m);\n\n\tfor (int i = 0; i < queryCount; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2683","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4neh00iwofdkynsogwvx"},{"title":"「BZOJ 2442」修剪草坪 - 线性DP + 单调队列","id":"24","updated":"2016-01-19T13:03:11.000Z","date":"2016-01-16T14:32:47.000Z","_content":"\nFJ 有 `N`（$1 ≤ N ≤ 100,000$）只排成一排的奶牛，编号为 `1` 到 `N`。每只奶牛的效率是不同的，奶牛 `i` 的效率为$E_i$（$0 ≤ E_i ≤ 1,000,000,000$）。\n\n靠近的奶牛们很熟悉，因此，如果 FJ 安排超过 `K` 只连续的奶牛，那么，这些奶牛就会罢工去开派对。因此，现在 FJ 需要你的帮助，计算 FJ 可以得到的最大效率，并且该方案中没有连续的超过 `K` 只奶牛。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 4654](http://codevs.cn/problem/4654/)  \n[BZOJ 2442](http://www.lydsy.com/JudgeOnline/problem.php?id=2442)\n\n### 解题思路\n一个 $O(n^2)$ 的解法是采用线性 DP，用 $a[i]$ 表示第 `i` 头奶牛的效率，$f[i]$ 表示选择前 `i` 只奶牛中部分或全部可获得的最大效率，对于每次状态转移，枚举 `j`（$i-k ≤ j < i$），计算不选择第 `j` 头奶牛时的最大效率。\n\n$$ f[i]=\\max(\\max\\{f[j-1]+{\\sum_{x=j+1}^{i}}a[x],j{\\in}[i-k,i)\\},f[i-1]) $$\n\n边界条件为：\n\n$$ f[1]=a[1] $$\n\n用前缀和数组来维护效率和，每次转移要耗费 $O(n)$ 的时间。\n\n实现代码：（注意边界判断和数组访问的 `-1`）\n\n```cpp\nf[0] = a[0];\nfor (int i = 2; i <= n; i++) {\n\tfor (int j = std::max(i - k, 0); j < i; j++) {\n\t\tif (j == 0) f[i - 1] = std::max(f[i - 1], prefixSum[i - 1] - 0);\n\t\telse f[i - 1] = std::max(f[i - 1], (j == 1 ? 0 : f[j - 1 - 1]) + prefixSum[i - 1] - prefixSum[j + 1 - 1 - 1]);\n\t\tf[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n}\n```\n\n现在让我们来尝试优化这个 DP，首先，设\n\n$$ sum[i]={\\sum_{x=1}^{i}}a[x] $$\n\n忽略 $f[i-1]$，把转移方程中的前缀和项展开\n\n$$ f[i] = \\max\\{f[j-1]+sum[i]-sum[j-1],j{\\in}[i-k,i)\\} $$\n\n令\n\n$$ g(x) = f[x-1]-sum[x-1] $$\n\n则转移方程的前半部分化为\n\n$$ f[i] = \\max\\{g(j),j{\\in}[i-k,i)\\}+sum[i] $$\n\n用一个长度为 `k + 1` 的单调队列来维护 $g(j)$，然后就可以优化到 $O(1)$ 的计算出每个状态。\n\n最终，新的转移方程为\n\n$$ f[i] = \\max(\\max\\{f[j-1]-sum(j-1),j{\\in}[i-k,i)\\}+sum[i],f[i-1]) $$\n\n两个坑：\n\n1. $E_i$加起来妥妥的爆 `int`，快上 `long long` 保平安；\n2. 边界条件！边界条件！边界条件！\n\n~~（才不是坑呢是我太弱了啦）~~\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <deque>\n\nconst int MAXN = 100000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, k, a[MAXN];\nlong long prefixSum[MAXN], f[MAXN + 1];\n\ninline void makePrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 0; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline long long sum(int i, int j) {\n\tif (i > j) return 0;\n\treturn i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefixSum();\n\n\tMonotoneQueue<long long> q;\n\tq.push(0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (q.size() == k + 1) q.pop();\n\n\t\tq.push((i == 1 ? 0 : f[i - 1 - 1]) - prefixSum[i + 1 - 1 - 1]);\n\n\t\tf[i - 1] = q.top() + prefixSum[i - 1];\n\t\tif (i != 1) f[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n\n\tprintf(\"%lld\\n\", f[n - 1]);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-2442.md","raw":"title: 「BZOJ 2442」修剪草坪 - 线性DP + 单调队列\ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - DP\n  - 单调队列\n  - 线性DP\npermalink: bzoj-2442\nid: 24\nupdated: '2016-01-19 21:03:11'\ndate: 2016-01-16 22:32:47\n---\n\nFJ 有 `N`（$1 ≤ N ≤ 100,000$）只排成一排的奶牛，编号为 `1` 到 `N`。每只奶牛的效率是不同的，奶牛 `i` 的效率为$E_i$（$0 ≤ E_i ≤ 1,000,000,000$）。\n\n靠近的奶牛们很熟悉，因此，如果 FJ 安排超过 `K` 只连续的奶牛，那么，这些奶牛就会罢工去开派对。因此，现在 FJ 需要你的帮助，计算 FJ 可以得到的最大效率，并且该方案中没有连续的超过 `K` 只奶牛。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 4654](http://codevs.cn/problem/4654/)  \n[BZOJ 2442](http://www.lydsy.com/JudgeOnline/problem.php?id=2442)\n\n### 解题思路\n一个 $O(n^2)$ 的解法是采用线性 DP，用 $a[i]$ 表示第 `i` 头奶牛的效率，$f[i]$ 表示选择前 `i` 只奶牛中部分或全部可获得的最大效率，对于每次状态转移，枚举 `j`（$i-k ≤ j < i$），计算不选择第 `j` 头奶牛时的最大效率。\n\n$$ f[i]=\\max(\\max\\{f[j-1]+{\\sum_{x=j+1}^{i}}a[x],j{\\in}[i-k,i)\\},f[i-1]) $$\n\n边界条件为：\n\n$$ f[1]=a[1] $$\n\n用前缀和数组来维护效率和，每次转移要耗费 $O(n)$ 的时间。\n\n实现代码：（注意边界判断和数组访问的 `-1`）\n\n```cpp\nf[0] = a[0];\nfor (int i = 2; i <= n; i++) {\n\tfor (int j = std::max(i - k, 0); j < i; j++) {\n\t\tif (j == 0) f[i - 1] = std::max(f[i - 1], prefixSum[i - 1] - 0);\n\t\telse f[i - 1] = std::max(f[i - 1], (j == 1 ? 0 : f[j - 1 - 1]) + prefixSum[i - 1] - prefixSum[j + 1 - 1 - 1]);\n\t\tf[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n}\n```\n\n现在让我们来尝试优化这个 DP，首先，设\n\n$$ sum[i]={\\sum_{x=1}^{i}}a[x] $$\n\n忽略 $f[i-1]$，把转移方程中的前缀和项展开\n\n$$ f[i] = \\max\\{f[j-1]+sum[i]-sum[j-1],j{\\in}[i-k,i)\\} $$\n\n令\n\n$$ g(x) = f[x-1]-sum[x-1] $$\n\n则转移方程的前半部分化为\n\n$$ f[i] = \\max\\{g(j),j{\\in}[i-k,i)\\}+sum[i] $$\n\n用一个长度为 `k + 1` 的单调队列来维护 $g(j)$，然后就可以优化到 $O(1)$ 的计算出每个状态。\n\n最终，新的转移方程为\n\n$$ f[i] = \\max(\\max\\{f[j-1]-sum(j-1),j{\\in}[i-k,i)\\}+sum[i],f[i-1]) $$\n\n两个坑：\n\n1. $E_i$加起来妥妥的爆 `int`，快上 `long long` 保平安；\n2. 边界条件！边界条件！边界条件！\n\n~~（才不是坑呢是我太弱了啦）~~\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <deque>\n\nconst int MAXN = 100000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, k, a[MAXN];\nlong long prefixSum[MAXN], f[MAXN + 1];\n\ninline void makePrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 0; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline long long sum(int i, int j) {\n\tif (i > j) return 0;\n\treturn i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefixSum();\n\n\tMonotoneQueue<long long> q;\n\tq.push(0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (q.size() == k + 1) q.pop();\n\n\t\tq.push((i == 1 ? 0 : f[i - 1 - 1]) - prefixSum[i + 1 - 1 - 1]);\n\n\t\tf[i - 1] = q.top() + prefixSum[i - 1];\n\t\tif (i != 1) f[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n\n\tprintf(\"%lld\\n\", f[n - 1]);\n\n\treturn 0;\n}\n```","slug":"bzoj-2442","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nep00j5ofdk5ud8nfda"},{"title":"「BZOJ 2143」飞飞侠 - 最短路","date":"2016-03-22T11:50:15.000Z","_content":"\n飞国是一个 $ N * M $ 的矩形方阵，每个格子代表一个街区。飞国是没有交通工具的。飞侠完全靠地面的弹射装置来移动。每个街区都装有弹射装置。使用弹射装置是需要支付一定费用的。而且每个弹射装置都有自己的弹力。设第 $ i $ 行第 $ j $ 列的弹射装置有 $ A_{ij} $ 的费用和 $ B_{ij} $ 的弹力。并规定有相邻边的格子间距离是 $ 1 $。那么，任何飞侠都只需要在 $ (i,j) $ 支付 $ A_{ij} $ 的费用就可以任 意选择弹到距离不超过 $ B_{ij} $ 的位置了。\n\n有三个飞侠，分别叫做 X、Y、Z。现在它们决定聚在一起玩，于是想往其中一人的位置集合。告诉你 $ 3 $ 个飞侠的坐标，求往哪里集合大家需要花的费用总和最低。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 2143](www.lydsy.com/JudgeOnline/problem.php?id=2143)\n\n### 解题思路\n直接裸最短路只能过 40%，考虑从每个位置能走到的位置的坐标最多为 $ B_{ij} $，为空中的每个位置建立节点，从地面到空中 $ B_{ij} $ 高度需要 $ A_{ij} $ 的花费，从空中每个位置到其前后左右位置，高度下降一个单位，花费为 0。这样做有效的减少了边的数量，虽然点变多了，但 Dijkstra 的堆优化效果会更加明显。\n\n然而这样还是过不了的 …… 考虑到 Dijkstra 贪心选择最近点的特点，如果从堆中取出的点的到起点距离比三个飞侠的到起点的距离还要大，就可以直接剪枝。\n\n### AC代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <cstdlib>\n#include <queue>\n\nconst int MAXN = 150;\nconst int MAXM = 150;\n\nstruct Node {\n\tint dist;\n} nodes[MAXN][MAXM][MAXN + MAXM + 1];\n\nint n, m, a[MAXN][MAXM], b[MAXN][MAXM];\n\nstruct Point {\n\tint x, y, k;\n\n\tPoint(int x = 0, int y = 0, int k = 0) : x(x), y(y), k(k) {}\n\n\tNode *operator->() const {\n\t\treturn &nodes[x][y][k];\n\t}\n\n\tPoint up(int k) {\n\t\treturn Point(x, y, k);\n\t}\n\n\tPoint move(int x, int y) {\n\t\treturn Point(this->x + x, this->y + y, k - 1);\n\t}\n\n\tbool isValid() {\n\t\treturn x >= 0 && x < n && y >= 0 && y < m && k >= 0;\n\t}\n\n\tint a() {\n\t\treturn ::a[x][y];\n\t}\n\n\tint b() {\n\t\treturn ::b[x][y];\n\t}\n\n\tstruct Compare {\n\t\tbool operator()(const Point &a, const Point &b) {\n\t\t\treturn a->dist > b->dist;\n\t\t}\n\t};\n} p[3];\n\nvoid dijkstra(const Point &start) {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k <= n + m; k++) {\n\t\t\t\tnodes[i][j][k].dist = INT_MAX;\n\t\t\t}\n\t\t}\n\t}\n\n\tstart->dist = 0;\n\n\tstd::priority_queue<Point, std::vector<Point>, Point::Compare> q;\n\tq.push(start);\n\n\twhile (!q.empty()) {\n\t\tPoint p = q.top();\n\t\tq.pop();\n\n\t\tif (p->dist > ::p[0]->dist && p->dist > ::p[1]->dist && p->dist > ::p[2]->dist) continue;\n\n\t\tif (p.k == 0) {\n\t\t\tPoint up = p.up(p.b());\n\t\t\tif (up->dist > p->dist + p.a()) up->dist = p->dist + p.a(), q.push(up);\n\t\t} else {\n\t\t\tPoint side;\n\t\t\tif ((side = p.move(0, 1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, -1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(-1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t}\n\t}\n\n\t// puts(\">_<\");\n}\n\nint main() {\n\t// freopen(\"fly.in\", \"r\", stdin);\n\t// freopen(\"fly.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &b[i][j]);\n\t\t\tif (b[i][j] > n + m) b[i][j] = n + m;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 3; i++) scanf(\"%d %d\", &p[i].x, &p[i].y), p[i].x--, p[i].y--;\n\n\tint dist[3][3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tdijkstra(p[i]);\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tdist[i][j] = p[j]->dist;\n\t\t}\n\t}\n\n\tint ans = INT_MAX;\n\tchar ansPos = '\\0';\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (dist[0][i] == INT_MAX || dist[1][i] == INT_MAX || dist[2][i] == INT_MAX) continue;\n\t\tint tmp = dist[0][i] + dist[1][i] + dist[2][i];\n\t\tif (tmp < ans) ans = tmp, ansPos = 'X' + i;\n\t}\n\n\tif (ans == INT_MAX) puts(\"NO\");\n\telse printf(\"%c\\n%d\\n\", ansPos, ans);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2143.md","raw":"title: 「BZOJ 2143」飞飞侠 - 最短路\ncategories: OI\ntags: \n  - BZOJ\n  - 最短路\n  - Dijkstra\n  - 安师大附中集训\npermalink: bzoj-2143\ndate: 2016-03-22 19:50:15\n---\n\n飞国是一个 $ N * M $ 的矩形方阵，每个格子代表一个街区。飞国是没有交通工具的。飞侠完全靠地面的弹射装置来移动。每个街区都装有弹射装置。使用弹射装置是需要支付一定费用的。而且每个弹射装置都有自己的弹力。设第 $ i $ 行第 $ j $ 列的弹射装置有 $ A_{ij} $ 的费用和 $ B_{ij} $ 的弹力。并规定有相邻边的格子间距离是 $ 1 $。那么，任何飞侠都只需要在 $ (i,j) $ 支付 $ A_{ij} $ 的费用就可以任 意选择弹到距离不超过 $ B_{ij} $ 的位置了。\n\n有三个飞侠，分别叫做 X、Y、Z。现在它们决定聚在一起玩，于是想往其中一人的位置集合。告诉你 $ 3 $ 个飞侠的坐标，求往哪里集合大家需要花的费用总和最低。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 2143](www.lydsy.com/JudgeOnline/problem.php?id=2143)\n\n### 解题思路\n直接裸最短路只能过 40%，考虑从每个位置能走到的位置的坐标最多为 $ B_{ij} $，为空中的每个位置建立节点，从地面到空中 $ B_{ij} $ 高度需要 $ A_{ij} $ 的花费，从空中每个位置到其前后左右位置，高度下降一个单位，花费为 0。这样做有效的减少了边的数量，虽然点变多了，但 Dijkstra 的堆优化效果会更加明显。\n\n然而这样还是过不了的 …… 考虑到 Dijkstra 贪心选择最近点的特点，如果从堆中取出的点的到起点距离比三个飞侠的到起点的距离还要大，就可以直接剪枝。\n\n### AC代码\n```c++\n#include <cstdio>\n#include <climits>\n#include <cstdlib>\n#include <queue>\n\nconst int MAXN = 150;\nconst int MAXM = 150;\n\nstruct Node {\n\tint dist;\n} nodes[MAXN][MAXM][MAXN + MAXM + 1];\n\nint n, m, a[MAXN][MAXM], b[MAXN][MAXM];\n\nstruct Point {\n\tint x, y, k;\n\n\tPoint(int x = 0, int y = 0, int k = 0) : x(x), y(y), k(k) {}\n\n\tNode *operator->() const {\n\t\treturn &nodes[x][y][k];\n\t}\n\n\tPoint up(int k) {\n\t\treturn Point(x, y, k);\n\t}\n\n\tPoint move(int x, int y) {\n\t\treturn Point(this->x + x, this->y + y, k - 1);\n\t}\n\n\tbool isValid() {\n\t\treturn x >= 0 && x < n && y >= 0 && y < m && k >= 0;\n\t}\n\n\tint a() {\n\t\treturn ::a[x][y];\n\t}\n\n\tint b() {\n\t\treturn ::b[x][y];\n\t}\n\n\tstruct Compare {\n\t\tbool operator()(const Point &a, const Point &b) {\n\t\t\treturn a->dist > b->dist;\n\t\t}\n\t};\n} p[3];\n\nvoid dijkstra(const Point &start) {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k <= n + m; k++) {\n\t\t\t\tnodes[i][j][k].dist = INT_MAX;\n\t\t\t}\n\t\t}\n\t}\n\n\tstart->dist = 0;\n\n\tstd::priority_queue<Point, std::vector<Point>, Point::Compare> q;\n\tq.push(start);\n\n\twhile (!q.empty()) {\n\t\tPoint p = q.top();\n\t\tq.pop();\n\n\t\tif (p->dist > ::p[0]->dist && p->dist > ::p[1]->dist && p->dist > ::p[2]->dist) continue;\n\n\t\tif (p.k == 0) {\n\t\t\tPoint up = p.up(p.b());\n\t\t\tif (up->dist > p->dist + p.a()) up->dist = p->dist + p.a(), q.push(up);\n\t\t} else {\n\t\t\tPoint side;\n\t\t\tif ((side = p.move(0, 1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, -1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(-1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t}\n\t}\n\n\t// puts(\">_<\");\n}\n\nint main() {\n\t// freopen(\"fly.in\", \"r\", stdin);\n\t// freopen(\"fly.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &b[i][j]);\n\t\t\tif (b[i][j] > n + m) b[i][j] = n + m;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 3; i++) scanf(\"%d %d\", &p[i].x, &p[i].y), p[i].x--, p[i].y--;\n\n\tint dist[3][3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tdijkstra(p[i]);\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tdist[i][j] = p[j]->dist;\n\t\t}\n\t}\n\n\tint ans = INT_MAX;\n\tchar ansPos = '\\0';\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (dist[0][i] == INT_MAX || dist[1][i] == INT_MAX || dist[2][i] == INT_MAX) continue;\n\t\tint tmp = dist[0][i] + dist[1][i] + dist[2][i];\n\t\tif (tmp < ans) ans = tmp, ansPos = 'X' + i;\n\t}\n\n\tif (ans == INT_MAX) puts(\"NO\");\n\telse printf(\"%c\\n%d\\n\", ansPos, ans);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2143","published":1,"updated":"2016-03-22T11:53:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4net00jcofdkv0jxezl5"},{"title":"「BZOJ 1756」小白逛公园 - 线段树","id":"38","updated":"2016-01-24T15:24:35.000Z","date":"2016-01-24T15:19:48.000Z","_content":"\n路的一边从南到北依次排着 `n` 个公园，一开始，小白就根据公园的风景给每个公园打了分。小新为了省事，每次遛狗的时候都会事先规定一个范围，小白只可以选择第 `a` 个和第 `b` 个公园之间（包括 `a`、`b` 两个公园）选择连续的一些公园玩。小白当然希望选出的公园的分数总和尽量高咯。同时，由于一些公园的景观会有所改变，所以，小白的打分也可能会有一些变化。那么，就请你来帮小白选择公园吧。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 1756](http://www.lydsy.com/JudgeOnline/problem.php?id=1756)\n\n### 解题思路\n区间内最大连续和，还带修改，当然是线段树咯！\n\n每个节点维护以下几项信息：\n\n1. 区间总和；\n2. 区间最大连续和；\n3. **强制包含左端点**的最大连续和；\n4. **强制包含右端点**的最大连续和。\n\n然后使用动态规划的方式求出每个节点的四个值即可。\n\n查询麻烦一点，如果跨左右子树查询的话，需要维护**要查询的区间**的以上四项值，然后用相似的方式向上传递。\n\n合并两个区间时，需要注意细节。\n\n还有就是读入 `a`、`b` 时，有可能 `a` 比 `b` 大！\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 100000;\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tint value, sum, lsum, rsum, maxSum;\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild) {}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (lchild) sum += lchild->sum;\n\t\t\tif (rchild) sum += rchild->sum;\n\n\t\t\tlsum = rsum = sum;\n\t\t\tif (lchild) {\n\t\t\t\tlsum = std::max(lsum, lchild->lsum);\n\t\t\t\tif (rchild) lsum = std::max(lsum, lchild->sum + rchild->lsum);\n\t\t\t}\n\t\t\tif (rchild) {\n\t\t\t\trsum = std::max(rsum, rchild->rsum);\n\t\t\t\tif (lchild) rsum = std::max(rsum, rchild->sum + lchild->rsum);\n\t\t\t}\n\n\t\t\tmaxSum = sum;\n\t\t\tmaxSum = std::max(maxSum, lsum);\n\t\t\tmaxSum = std::max(maxSum, rsum);\n\t\t\tif (lchild) maxSum = std::max(maxSum, lchild->maxSum);\n\t\t\tif (rchild) maxSum = std::max(maxSum, rchild->maxSum);\n\t\t\tif (lchild && rchild) maxSum = std::max(maxSum, lchild->rsum + rchild->lsum);\n\t\t}\n\n\t\tvoid query(int l, int r, int &sum, int &lsum, int &rsum, int &maxSum) {\n\t\t\tif (this->l > r || this->r < l) throw;\n\t\t\telse if (this->l >= l && this->r <= r) {\n\t\t\t\tsum = this->sum;\n\t\t\t\tlsum = this->lsum;\n\t\t\t\trsum = this->rsum;\n\t\t\t\tmaxSum = this->maxSum;\n\t\t\t} else {\n\t\t\t\tint mid = this->l + ((this->r - this->l) >> 1);\n\t\t\t\tif (r <= mid) return lchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\tif (l >= mid + 1) return rchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\telse {\n\t\t\t\t\tint suml, lsuml, rsuml, maxSuml;\n\t\t\t\t\tint sumr, lsumr, rsumr, maxSumr;\n\t\t\t\t\tlchild->query(l, r, suml, lsuml, rsuml, maxSuml);\n\t\t\t\t\trchild->query(l, r, sumr, lsumr, rsumr, maxSumr);\n\n\t\t\t\t\tmaxSum = sum = suml + sumr;\n\t\t\t\t\tlsum = std::max(lsuml, suml + lsumr);\n\t\t\t\t\trsum = std::max(rsumr, sumr + rsuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSumr);\n\t\t\t\t\tmaxSum = std::max(maxSum, lsumr + rsuml);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid update(int pos, int value) {\n\t\t\tif (this->l > pos || this->r < pos) return;\n\t\t\telse if (this->l == pos && this->r == pos) this->value = value, maintain();\n\t\t\telse {\n\t\t\t\tif (lchild) lchild->update(pos, value);\n\t\t\t\tif (rchild) rchild->update(pos, value);\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tvoid update(int pos, int value) {\n\t\troot->update(pos, value);\n\t}\n\n\tint query(int l, int r) {\n\t\tint sum, lsum, rsum, maxSum;\n\t\troot->query(l, r, sum, lsum, rsum, maxSum);\n\t\treturn maxSum;\n\t}\n};\n\nint main() {\n\tint n, m;\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tSegmentTree *segment = new SegmentTree(1, n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsegment->update(i, x);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\tif (k == 1) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", segment->query(std::min(l, r), std::max(l, r)));\n\t\t} else {\n\t\t\tint p, s;\n\t\t\tscanf(\"%d %d\", &p, &s);\n\t\t\tsegment->update(p, s);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1756.md","raw":"title: 「BZOJ 1756」小白逛公园 - 线段树\ncategories: OI\ntags: \n  - BZOJ\n  - 线段树\n  - 高级数据结构\n  - 数据结构\n  - DP\npermalink: bzoj-1756\nid: 38\nupdated: '2016-01-24 23:24:35'\ndate: 2016-01-24 23:19:48\n---\n\n路的一边从南到北依次排着 `n` 个公园，一开始，小白就根据公园的风景给每个公园打了分。小新为了省事，每次遛狗的时候都会事先规定一个范围，小白只可以选择第 `a` 个和第 `b` 个公园之间（包括 `a`、`b` 两个公园）选择连续的一些公园玩。小白当然希望选出的公园的分数总和尽量高咯。同时，由于一些公园的景观会有所改变，所以，小白的打分也可能会有一些变化。那么，就请你来帮小白选择公园吧。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 1756](http://www.lydsy.com/JudgeOnline/problem.php?id=1756)\n\n### 解题思路\n区间内最大连续和，还带修改，当然是线段树咯！\n\n每个节点维护以下几项信息：\n\n1. 区间总和；\n2. 区间最大连续和；\n3. **强制包含左端点**的最大连续和；\n4. **强制包含右端点**的最大连续和。\n\n然后使用动态规划的方式求出每个节点的四个值即可。\n\n查询麻烦一点，如果跨左右子树查询的话，需要维护**要查询的区间**的以上四项值，然后用相似的方式向上传递。\n\n合并两个区间时，需要注意细节。\n\n还有就是读入 `a`、`b` 时，有可能 `a` 比 `b` 大！\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 100000;\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tint value, sum, lsum, rsum, maxSum;\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild) {}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (lchild) sum += lchild->sum;\n\t\t\tif (rchild) sum += rchild->sum;\n\n\t\t\tlsum = rsum = sum;\n\t\t\tif (lchild) {\n\t\t\t\tlsum = std::max(lsum, lchild->lsum);\n\t\t\t\tif (rchild) lsum = std::max(lsum, lchild->sum + rchild->lsum);\n\t\t\t}\n\t\t\tif (rchild) {\n\t\t\t\trsum = std::max(rsum, rchild->rsum);\n\t\t\t\tif (lchild) rsum = std::max(rsum, rchild->sum + lchild->rsum);\n\t\t\t}\n\n\t\t\tmaxSum = sum;\n\t\t\tmaxSum = std::max(maxSum, lsum);\n\t\t\tmaxSum = std::max(maxSum, rsum);\n\t\t\tif (lchild) maxSum = std::max(maxSum, lchild->maxSum);\n\t\t\tif (rchild) maxSum = std::max(maxSum, rchild->maxSum);\n\t\t\tif (lchild && rchild) maxSum = std::max(maxSum, lchild->rsum + rchild->lsum);\n\t\t}\n\n\t\tvoid query(int l, int r, int &sum, int &lsum, int &rsum, int &maxSum) {\n\t\t\tif (this->l > r || this->r < l) throw;\n\t\t\telse if (this->l >= l && this->r <= r) {\n\t\t\t\tsum = this->sum;\n\t\t\t\tlsum = this->lsum;\n\t\t\t\trsum = this->rsum;\n\t\t\t\tmaxSum = this->maxSum;\n\t\t\t} else {\n\t\t\t\tint mid = this->l + ((this->r - this->l) >> 1);\n\t\t\t\tif (r <= mid) return lchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\tif (l >= mid + 1) return rchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\telse {\n\t\t\t\t\tint suml, lsuml, rsuml, maxSuml;\n\t\t\t\t\tint sumr, lsumr, rsumr, maxSumr;\n\t\t\t\t\tlchild->query(l, r, suml, lsuml, rsuml, maxSuml);\n\t\t\t\t\trchild->query(l, r, sumr, lsumr, rsumr, maxSumr);\n\n\t\t\t\t\tmaxSum = sum = suml + sumr;\n\t\t\t\t\tlsum = std::max(lsuml, suml + lsumr);\n\t\t\t\t\trsum = std::max(rsumr, sumr + rsuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSumr);\n\t\t\t\t\tmaxSum = std::max(maxSum, lsumr + rsuml);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid update(int pos, int value) {\n\t\t\tif (this->l > pos || this->r < pos) return;\n\t\t\telse if (this->l == pos && this->r == pos) this->value = value, maintain();\n\t\t\telse {\n\t\t\t\tif (lchild) lchild->update(pos, value);\n\t\t\t\tif (rchild) rchild->update(pos, value);\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tvoid update(int pos, int value) {\n\t\troot->update(pos, value);\n\t}\n\n\tint query(int l, int r) {\n\t\tint sum, lsum, rsum, maxSum;\n\t\troot->query(l, r, sum, lsum, rsum, maxSum);\n\t\treturn maxSum;\n\t}\n};\n\nint main() {\n\tint n, m;\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tSegmentTree *segment = new SegmentTree(1, n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsegment->update(i, x);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\tif (k == 1) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", segment->query(std::min(l, r), std::max(l, r)));\n\t\t} else {\n\t\t\tint p, s;\n\t\t\tscanf(\"%d %d\", &p, &s);\n\t\t\tsegment->update(p, s);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1756","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4ney00jjofdkfjlp2m34"},{"title":"「BZOJ 1477」青蛙的约会 - 扩展欧几里得","date":"2016-01-23T15:20:01.000Z","_content":"\n我们把这两只青蛙分别叫做青蛙 A 和青蛙 B，并且规定纬度线上东经 0 度处为原点，由东往西为正方向，单位长度 1 米，这样我们就得到了一条首尾相接的数轴。设青蛙 A 的出发点坐标是 x，青蛙 B 的出发点坐标是 y。青蛙 A 一次能跳 m 米，青蛙 B 一次能跳 n 米，两只青蛙跳一次所花费的时间相同。纬度线总长 L 米。现在要你求出它们跳了几次以后才会碰面。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 1477](http://www.lydsy.com/JudgeOnline/problem.php?id=1477)  \n[Tyvj 2366](http://tyvj.cn/p/2366)\n\n### 解题思路\n设两只青蛙跳了 $t$ 次后碰面，则有：\n\n$$ \\cases{x+tm=k_{1}*L \\\\ y+tn=k_{2}*L} $$\n\n令 $k=k_{1}-k_{2}$，得\n\n$$ (x+tm)-(y+tn)=kL $$\n\n移项，得\n$$\n(x-y)+(m-n)t=kL \\\\\n(m-n)t+(-L)k=y-x\n$$\n\n题目转化为求一个二元一次不定方程的**最小正整数**解。\n\n扩展欧几里得直接上即可，注意细节，注意细节，注意细节！\n\n### AC代码\n```cpp\n#include <cstdio>\n\nconst long long MAXX = 2000000000;\nconst long long MAXY = 2000000000;\nconst long long MAXN = 2000000000;\nconst long long MAXM = 2000000000;\nconst long long MAXL = 2100000000;\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\ninline bool solve(long long a, long long b, long long c, long long &x, long long &y) {\n\tif (b < 0) a = -a, b = -b, c = -c;\n\tlong long g;\n\texgcd(a, b, g, x, y);\n\tif (c % g != 0) return false;\n\tx = x * c / g;\n\ty = y * c / g;\n\tlong long newx = ((x % b) + b) % b;\n\ty = y - ((newx - x) / (b / g)) * (a / g);\n\tx = newx;\n\treturn true;\n}\n\nint main() {\n\tlong long x, y, m, n, l;\n\tscanf(\"%lld %lld %lld %lld %lld\", &x, &y, &m, &n, &l);\n\n\tlong long t, k;\n\n\tif (!solve(m - n, -l, y - x, t, k)) puts(\"Impossible\");\n\telse printf(\"%lld\\n\", t);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1477.md","raw":"title: 「BZOJ 1477」青蛙的约会 - 扩展欧几里得\ncategories: OI\ntags: \n  - BZOJ\n  - Tyvj\n  - EXGCD\n  - 数论\npermalink: bzoj-1477\ndate: 2016-01-23 23:20:01\n---\n\n我们把这两只青蛙分别叫做青蛙 A 和青蛙 B，并且规定纬度线上东经 0 度处为原点，由东往西为正方向，单位长度 1 米，这样我们就得到了一条首尾相接的数轴。设青蛙 A 的出发点坐标是 x，青蛙 B 的出发点坐标是 y。青蛙 A 一次能跳 m 米，青蛙 B 一次能跳 n 米，两只青蛙跳一次所花费的时间相同。纬度线总长 L 米。现在要你求出它们跳了几次以后才会碰面。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 1477](http://www.lydsy.com/JudgeOnline/problem.php?id=1477)  \n[Tyvj 2366](http://tyvj.cn/p/2366)\n\n### 解题思路\n设两只青蛙跳了 $t$ 次后碰面，则有：\n\n$$ \\cases{x+tm=k_{1}*L \\\\ y+tn=k_{2}*L} $$\n\n令 $k=k_{1}-k_{2}$，得\n\n$$ (x+tm)-(y+tn)=kL $$\n\n移项，得\n$$\n(x-y)+(m-n)t=kL \\\\\n(m-n)t+(-L)k=y-x\n$$\n\n题目转化为求一个二元一次不定方程的**最小正整数**解。\n\n扩展欧几里得直接上即可，注意细节，注意细节，注意细节！\n\n### AC代码\n```cpp\n#include <cstdio>\n\nconst long long MAXX = 2000000000;\nconst long long MAXY = 2000000000;\nconst long long MAXN = 2000000000;\nconst long long MAXM = 2000000000;\nconst long long MAXL = 2100000000;\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\ninline bool solve(long long a, long long b, long long c, long long &x, long long &y) {\n\tif (b < 0) a = -a, b = -b, c = -c;\n\tlong long g;\n\texgcd(a, b, g, x, y);\n\tif (c % g != 0) return false;\n\tx = x * c / g;\n\ty = y * c / g;\n\tlong long newx = ((x % b) + b) % b;\n\ty = y - ((newx - x) / (b / g)) * (a / g);\n\tx = newx;\n\treturn true;\n}\n\nint main() {\n\tlong long x, y, m, n, l;\n\tscanf(\"%lld %lld %lld %lld %lld\", &x, &y, &m, &n, &l);\n\n\tlong long t, k;\n\n\tif (!solve(m - n, -l, y - x, t, k)) puts(\"Impossible\");\n\telse printf(\"%lld\\n\", t);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1477","published":1,"updated":"2016-03-15T01:50:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nf200jqofdkh8vik3po"},{"title":"「BZOJ 1251」序列终结者 - Splay","id":"27","updated":"2016-01-19T13:02:18.000Z","date":"2016-01-18T13:44:15.000Z","_content":"\n给定一个长度为 `N` 的序列，每个序列的元素是一个整数。要支持以下三种操作：\n\n1. 将 `[L,R]` 这个区间内的所有数加上 `V`。\n2. 将 `[L,R]` 这个区间翻转，比如 `1 2 3 4` 变成 `4 3 2 1`。\n3. 求 `[L,R]` 这个区间中的最大值。 最开始所有元素都是 `0`。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 1251](http://www.lydsy.com/JudgeOnline/problem.php?id=1251)  \n[CodeVS 4655](http://codevs.cn/problem/4655/)\n\n### 解题思路\nSplay 裸题，比文艺平衡树强一点，那个没有区间修改和查询。\n\n区间修改：和翻转一样，维护一个 `lazy-tag`，然后 `pushDown()` 的时候下放即可。\n\n区间查询：维护一个子树值的和，查询的时候直接选择区间然后返回这个和。需要在 `maintain()` 中维护。\n\n细节需要注意，各种下放 ……\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\n\nvoid print();\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, max, lazy;\n\t\tint size;\n\t\tbool reversed, bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), lazy(0), max(value), reversed(false), root(root), bound(bound), size(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\n\t\t\tsize = 1;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\tstd::swap(child[L], child[R]);\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->lazy += lazy, child[L]->value += lazy, child[L]->max += lazy;\n\t\t\t\tif (child[R]) child[R]->lazy += lazy, child[R]->value += lazy, child[R]->max += lazy;\n\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid build(const T *a, int n) {\n\t\troot = buildRange(a, 1, n, NULL);\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tNode *buildRange(const T *a, int l, int r, Node *parent) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tif (l != r) {\n\t\t\tv->child[L] = buildRange(a, l, mid - 1, v);\n\t\t\tv->child[R] = buildRange(a, mid + 1, r, v);\n\t\t}\n\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\t\t*v = new Node(parent, 0, &root, true);\n\t\t(*v)->maintain();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\t//v->pushDown();\n\t\twhile (v->pushDown(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + 1;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t\t//printf(\"select(k = %d)\\n\", k);\n\t\t\t//print();\n\t\t\t//v->pushDown();\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid update(int l, int r, const T &addition) {\n\t\tNode *range = select(l, r);\n\t\trange->value += addition, range->lazy += addition, range->max += addition;\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\treturn range->max;\n\t}\n\n\tvoid reverse(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfsFetch(a, root);\n\t}\n\n\tvoid dfsFetch(T *&a, Node *v) {\n\t\tif (!v) return;\n\t\tv->pushDown(), v->maintain();\n\t\tdfsFetch(a, v->child[L]);\n\t\tif (!v->bound) *a++ = v->value;\n\t\tdfsFetch(a, v->child[R]);\n\t}\n};\n\nint n, m, a[MAXN];\nSplay<int> splay;\n\nvoid dfs(Splay<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[Splay<int>::L], depth + 1);\n\tv->pushDown(), v->maintain();\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d : %d\\n\", v->value, v->size);\n\tdfs(v->child[Splay<int>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tmemset(a, 0, sizeof(int) * n);\n\tsplay.build(a, n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint command;\n\t\tscanf(\"%d\", &command);\n\t\tif (command == 1) {\n\t\t\tint l, r, addition;\n\t\t\tscanf(\"%d %d %d\", &l, &r, &addition);\n\t\t\tsplay.update(l, r, addition);\n\t\t} else if (command == 2) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tsplay.reverse(l, r);\n\t\t} else if (command == 3) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", splay.queryMax(l, r));\n\t\t} else throw;\n\t}\n\n\t//print();\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-1251.md","raw":"title: 「BZOJ 1251」序列终结者 - Splay\ncategories: OI\ntags: \n  - Splay\n  - BZOJ\n  - CodeVS\n  - 高级数据结构\npermalink: bzoj-1251\nid: 27\nupdated: '2016-01-19 21:02:18'\ndate: 2016-01-18 21:44:15\n---\n\n给定一个长度为 `N` 的序列，每个序列的元素是一个整数。要支持以下三种操作：\n\n1. 将 `[L,R]` 这个区间内的所有数加上 `V`。\n2. 将 `[L,R]` 这个区间翻转，比如 `1 2 3 4` 变成 `4 3 2 1`。\n3. 求 `[L,R]` 这个区间中的最大值。 最开始所有元素都是 `0`。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 1251](http://www.lydsy.com/JudgeOnline/problem.php?id=1251)  \n[CodeVS 4655](http://codevs.cn/problem/4655/)\n\n### 解题思路\nSplay 裸题，比文艺平衡树强一点，那个没有区间修改和查询。\n\n区间修改：和翻转一样，维护一个 `lazy-tag`，然后 `pushDown()` 的时候下放即可。\n\n区间查询：维护一个子树值的和，查询的时候直接选择区间然后返回这个和。需要在 `maintain()` 中维护。\n\n细节需要注意，各种下放 ……\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\n\nvoid print();\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, max, lazy;\n\t\tint size;\n\t\tbool reversed, bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), lazy(0), max(value), reversed(false), root(root), bound(bound), size(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\n\t\t\tsize = 1;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\tstd::swap(child[L], child[R]);\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->lazy += lazy, child[L]->value += lazy, child[L]->max += lazy;\n\t\t\t\tif (child[R]) child[R]->lazy += lazy, child[R]->value += lazy, child[R]->max += lazy;\n\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid build(const T *a, int n) {\n\t\troot = buildRange(a, 1, n, NULL);\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tNode *buildRange(const T *a, int l, int r, Node *parent) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tif (l != r) {\n\t\t\tv->child[L] = buildRange(a, l, mid - 1, v);\n\t\t\tv->child[R] = buildRange(a, mid + 1, r, v);\n\t\t}\n\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\t\t*v = new Node(parent, 0, &root, true);\n\t\t(*v)->maintain();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\t//v->pushDown();\n\t\twhile (v->pushDown(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + 1;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t\t//printf(\"select(k = %d)\\n\", k);\n\t\t\t//print();\n\t\t\t//v->pushDown();\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid update(int l, int r, const T &addition) {\n\t\tNode *range = select(l, r);\n\t\trange->value += addition, range->lazy += addition, range->max += addition;\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\treturn range->max;\n\t}\n\n\tvoid reverse(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfsFetch(a, root);\n\t}\n\n\tvoid dfsFetch(T *&a, Node *v) {\n\t\tif (!v) return;\n\t\tv->pushDown(), v->maintain();\n\t\tdfsFetch(a, v->child[L]);\n\t\tif (!v->bound) *a++ = v->value;\n\t\tdfsFetch(a, v->child[R]);\n\t}\n};\n\nint n, m, a[MAXN];\nSplay<int> splay;\n\nvoid dfs(Splay<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[Splay<int>::L], depth + 1);\n\tv->pushDown(), v->maintain();\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d : %d\\n\", v->value, v->size);\n\tdfs(v->child[Splay<int>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tmemset(a, 0, sizeof(int) * n);\n\tsplay.build(a, n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint command;\n\t\tscanf(\"%d\", &command);\n\t\tif (command == 1) {\n\t\t\tint l, r, addition;\n\t\t\tscanf(\"%d %d %d\", &l, &r, &addition);\n\t\t\tsplay.update(l, r, addition);\n\t\t} else if (command == 2) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tsplay.reverse(l, r);\n\t\t} else if (command == 3) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", splay.queryMax(l, r));\n\t\t} else throw;\n\t}\n\n\t//print();\n\n\treturn 0;\n}\n```","slug":"bzoj-1251","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nfb00jwofdkrj7powso"},{"title":"高精度加、减、乘模板","date":"2016-03-14T13:34:42.000Z","_content":"\n今天早上写了一道高精度的题，一口气敲完了高精度加、减、乘。现在把模板放在这备用着 \n…… 需要者自取。\n\n<!-- more -->\n\n```cpp\n#include <cstring>\n#include <iostream>\n#include <vector>\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), \nx.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] \n+ '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); \ni++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n```\n","source":"_posts/bigint-template.md","raw":"title: 高精度加、减、乘模板\ncategories: OI\ntags: \n  - 高精度\n  - 算法模板\npermalink: bigint-template\ndate: 2016-03-14 21:34:42\n---\n\n今天早上写了一道高精度的题，一口气敲完了高精度加、减、乘。现在把模板放在这备用着 \n…… 需要者自取。\n\n<!-- more -->\n\n```cpp\n#include <cstring>\n#include <iostream>\n#include <vector>\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), \nx.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] \n+ '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); \ni++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n```\n","slug":"bigint-template","published":1,"updated":"2016-03-15T01:05:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nfg00k2ofdkwpu8zy3j"},{"title":"「APIO2009」抢掠计划 - 强联通分量","date":"2016-03-10T11:57:45.000Z","_content":"\n城中的道路都是单向的。不同的道路由路口连接。在每个路口都设立了一个 ATM 取款机。酒吧也都设在路口，虽然并不是每个路口都设有酒吧。他将从市中心出发，沿着单向道路行驶，抢劫所有他途径的 ATM 机，最终他将在一个酒吧庆祝他的胜利。\n\n他获知了每个 ATM 机中可以掠取的现金数额。他希望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可以经过同一路口或道路任意多次。但只要他抢劫过某个 ATM 机后，该 ATM 机里面就不会再有钱了。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1611](http://codevs.cn/problem/1611/)  \n[BZOJ 1179](http://www.lydsy.com/JudgeOnline/problem.php?id=1179)\n\n### 解题思路\nTarjan 求强联通分量，一个强联通分量中的点肯定可以同时被抢走。缩点后图转化为 DAG，求出 DAG 上的最长路即为答案。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\nstruct SCC;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge, *currentEdge;\n\tint dfn, low, w, dist;\n\tbool inStack, pushed, visited, isBar, inQueue;\n\tSCC *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint size;\n} sccs[MAXN];\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\telse if (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\te = e->next;\n\t\t\t} else  {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tNode *u;\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t\tu->scc->v.w += u->w;\n\t\t\t\t\t\tu->scc->v.isBar |= u->isBar;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\tNode *from = &e->from->scc->v, *to = &e->to->scc->v;\n\t\t\t\tfrom->firstEdge = new Edge(from, to);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void bellmanford(int start) {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[start].scc->v);\n\tnodes[start].scc->v.dist = nodes[start].scc->v.w;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\tv->inQueue = false;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist < v->dist + e->to->w) {\n\t\t\t\te->to->dist = v->dist + e->to->w;\n\t\t\t\t\n\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &nodes[i].w);\n\t}\n\n\tint s, p;\n\tscanf(\"%d %d\", &s, &p), s--;\n\n\tfor (int i = 0; i < p; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x), x--;\n\t\tnodes[x].isBar = true;\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tbellmanford(s);\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.isBar) ans = std::max(ans, sccs[i].v.dist);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n\n### 吐槽\n一开始想到最长路，然后写了个 Dijkstra …… 写了个 Dijkstra ……\n\n(╯‵□′)╯︵┻━┻ 为什么我要写 Dijkstra！\n\n┬—┬ノ('-'ノ) 改成 Bellman-Ford 之后 WA 的更离谱了 ……\n\n最后发现是读进来的起点下标忘了减一 ……\n\n以后不能再出这种沙茶错误了啊啊啊啊啊啊 OvO ……\n\n### 还是吐槽\n从测试点命名中我们可以看出出题人的恶意 →_→\n\n|       测试点      | 结果| 内存使用量 | 时间使用量|\n| ---------------- |:--:|:--------:|:--------:|\n| large-dag-0.in   | AC | 42504kB  | 423ms    |\n| large-dag-1.in   | AC | 51052kB  | 476ms    |\n| large-path-0.in  | AC | 55288kB  | 491ms    |\n| large-path-1.in  | AC | 53096kB  | 494ms    |\n| large-tree-0.in  | AC | 49512kB  | 430ms    |\n| large-tree-1.in  | AC | 49772kB  | 406ms    |\n| medium-dag-0.in  | AC | 364kB    | 2ms      |\n| medium-dag-1.in  | AC | 492kB    | 2ms      |\n| medium-path-0.in | AC | 488kB    | 2ms      |\n| medium-path-1.in | AC | 492kB    | 2ms      |\n| medium-tree-0.in | AC | 360kB    | 2ms      |\n| medium-tree-1.in | AC | 492kB    | 1ms      |\n| small-dag-0.in   | AC | 128kB    | 1ms      |\n| small-path-0.in  | AC | 128kB    | 1ms      |\n| small-tree-0.in  | AC | 256kB    | 1ms      |\n","source":"_posts/apio2009-atm.md","raw":"title: 「APIO2009」抢掠计划 - 强联通分量\ncategories: OI\ntags: \n  - BZOJ\n  - APIO\n  - 强联通分量\n  - Tarjan\n  - 缩点\n  - DAG\n  - 最长路\n  - Bellman-Ford\npermalink: apio2009-atm\ndate: 2016-03-10 19:57:45\n---\n\n城中的道路都是单向的。不同的道路由路口连接。在每个路口都设立了一个 ATM 取款机。酒吧也都设在路口，虽然并不是每个路口都设有酒吧。他将从市中心出发，沿着单向道路行驶，抢劫所有他途径的 ATM 机，最终他将在一个酒吧庆祝他的胜利。\n\n他获知了每个 ATM 机中可以掠取的现金数额。他希望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可以经过同一路口或道路任意多次。但只要他抢劫过某个 ATM 机后，该 ATM 机里面就不会再有钱了。\n\n<!-- more -->\n\n### 题目链接\n[CodeVS 1611](http://codevs.cn/problem/1611/)  \n[BZOJ 1179](http://www.lydsy.com/JudgeOnline/problem.php?id=1179)\n\n### 解题思路\nTarjan 求强联通分量，一个强联通分量中的点肯定可以同时被抢走。缩点后图转化为 DAG，求出 DAG 上的最长路即为答案。\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\nstruct SCC;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge, *currentEdge;\n\tint dfn, low, w, dist;\n\tbool inStack, pushed, visited, isBar, inQueue;\n\tSCC *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint size;\n} sccs[MAXN];\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\telse if (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\te = e->next;\n\t\t\t} else  {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tNode *u;\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t\tu->scc->v.w += u->w;\n\t\t\t\t\t\tu->scc->v.isBar |= u->isBar;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\tNode *from = &e->from->scc->v, *to = &e->to->scc->v;\n\t\t\t\tfrom->firstEdge = new Edge(from, to);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void bellmanford(int start) {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[start].scc->v);\n\tnodes[start].scc->v.dist = nodes[start].scc->v.w;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\tv->inQueue = false;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist < v->dist + e->to->w) {\n\t\t\t\te->to->dist = v->dist + e->to->w;\n\t\t\t\t\n\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &nodes[i].w);\n\t}\n\n\tint s, p;\n\tscanf(\"%d %d\", &s, &p), s--;\n\n\tfor (int i = 0; i < p; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x), x--;\n\t\tnodes[x].isBar = true;\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tbellmanford(s);\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.isBar) ans = std::max(ans, sccs[i].v.dist);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n\n### 吐槽\n一开始想到最长路，然后写了个 Dijkstra …… 写了个 Dijkstra ……\n\n(╯‵□′)╯︵┻━┻ 为什么我要写 Dijkstra！\n\n┬—┬ノ('-'ノ) 改成 Bellman-Ford 之后 WA 的更离谱了 ……\n\n最后发现是读进来的起点下标忘了减一 ……\n\n以后不能再出这种沙茶错误了啊啊啊啊啊啊 OvO ……\n\n### 还是吐槽\n从测试点命名中我们可以看出出题人的恶意 →_→\n\n|       测试点      | 结果| 内存使用量 | 时间使用量|\n| ---------------- |:--:|:--------:|:--------:|\n| large-dag-0.in   | AC | 42504kB  | 423ms    |\n| large-dag-1.in   | AC | 51052kB  | 476ms    |\n| large-path-0.in  | AC | 55288kB  | 491ms    |\n| large-path-1.in  | AC | 53096kB  | 494ms    |\n| large-tree-0.in  | AC | 49512kB  | 430ms    |\n| large-tree-1.in  | AC | 49772kB  | 406ms    |\n| medium-dag-0.in  | AC | 364kB    | 2ms      |\n| medium-dag-1.in  | AC | 492kB    | 2ms      |\n| medium-path-0.in | AC | 488kB    | 2ms      |\n| medium-path-1.in | AC | 492kB    | 2ms      |\n| medium-tree-0.in | AC | 360kB    | 2ms      |\n| medium-tree-1.in | AC | 492kB    | 1ms      |\n| small-dag-0.in   | AC | 128kB    | 1ms      |\n| small-path-0.in  | AC | 128kB    | 1ms      |\n| small-tree-0.in  | AC | 256kB    | 1ms      |\n","slug":"apio2009-atm","published":1,"updated":"2016-03-15T01:05:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nfj00k6ofdkiorphnzk"},{"title":"「AHOI2008」紧急集合 - LCA","date":"2016-03-07T12:36:46.000Z","_content":"\n在树上寻找一个点，使其到给定三点的距离之和最小。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 1787](http://www.lydsy.com/JudgeOnline/problem.php?id=1787)\n\n### 解题思路\n从样例中找出规律，三个点两两之间的 LCA 必有一对相等，写了个数据生成器用大数据验证了一下，确实是成立的。\n\n进一步得到规律，要找的点就是除了相等的一对 LCA 以外的另一个 LCA …… 别问我怎么证明，我不会 qwq\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXLOGN = 19; // log(500000, 2) = 18.931568569324174\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, depth;\n\t\n\tstruct SparseTable {\n\t\tint dist;\n\t\tNode *v;\n\t} st[MAXLOGN + 1];\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int u, int v) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v]);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u]);\n}\n\ninline void makeSparseTable() {\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->depth == 0) {\n\t\t\t\te->to->depth = v->depth + 1;\n\n\t\t\t\te->to->st[0].v = v;\n\t\t\t\te->to->st[0].dist = 1;\n\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tnodes[0].st[0].v = &nodes[0];\n\tnodes[0].st[0].dist = 0;\n\n\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].st[j].v = nodes[i].st[j - 1].v->st[j - 1].v;\n\t\t\tnodes[i].st[j].dist = nodes[i].st[j - 1].dist + nodes[i].st[j - 1].v->st[j - 1].dist;\n\t\t}\n\t}\n}\n\ninline int query(const int a, const int b, Node **lca = NULL) {\n\tNode *u = &nodes[a], *v = &nodes[b];\n\tint dist = 0;\n\n\tif (u->depth < v->depth) {\n\t\tstd::swap(u, v);\n\t}\n\n\tif (u->depth != v->depth) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != NULL && u->st[i].v->depth >= v->depth) {\n\t\t\t\tdist += u->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (u != v) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != v->st[i].v) {\n\t\t\t\tdist += u->st[i].dist + v->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t\tv = v->st[i].v;\n\t\t\t}\n\t\t}\n\n\t\tdist += u->st[0].dist + v->st[0].dist;\n\t\t\n\t\tif (lca) *lca = u->st[0].v;\n\t\treturn dist;\n\t}\n\n\tif (lca) *lca = u;\n\treturn dist;\n}\n\ninline int solve(int a, int b, int c) {\n\tNode *ab, *bc, *ca;\n\tint distAB, distBC, distCA;\n\n\tquery(a, b, &ab);\n\tquery(b, c, &bc);\n\tquery(c, a, &ca);\n\n\t// printf(\"%d, %d, %d\\n\", ab->id, bc->id, ca->id);\n\n\tNode *v;\n\tif (ab == bc) {\n\t\tv = ca;\n\t} else if (bc == ca) {\n\t\tv = ab;\n\t} else if (ca == ab) {\n\t\tv = bc;\n\t}\n\n\tassert(v != NULL);\n\treturn v->id;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\n\t\taddEdge(u, v);\n\t}\n\n\tmakeSparseTable();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c), a--, b--, c--;\n\n\t\tint id = solve(a, b, c);\n\t\tint dist = query(a, id - 1) + query(b, id - 1) + query(c, id - 1);\n\n\t\tprintf(\"%d %d\\n\", id, dist);\n\t}\n\n\treturn 0;\n}\n```\n\n### 数据生成器\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct UnionFindSet {\n\tint a[MAXN];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) a[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn a[x] == x ? x : a[x] = find(a[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\ta[find(x)] = find(y);\n\t}\n};\n\ninline int rand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tint x = rand();\n\tsrand((time(NULL) << 16) | ((clock() << 16) >> 16) ^ x ^ MAGIC_NUMBER);\n\treturn (rand() ^ x) % (r - l + 1) + l;\n}\n\nint main() {\n\tint n = MAXN, m = MAXM;\n\n\tstatic UnionFindSet ufs;\n\tufs.init(n);\n\n\tprintf(\"%d %d\\n\", n, m);\n\n\tfor (int i = 0; i < n - 1; ) {\n\t\tint u, v;\n\t\tu = rand(1, n), v = rand(1, n);\n\n\t\tif (ufs.find(u - 1) != ufs.find(v - 1)) {\n\t\t\tufs.merge(u - 1, v - 1);\n\t\t\tprintf(\"%d %d\\n\", u, v);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\ta = rand(1, n), b = rand(1, n), c = rand(1, n);\n\n\t\tprintf(\"%d %d %d\\n\", a, b, c);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/ahoi2008-meet.md","raw":"title: 「AHOI2008」紧急集合 - LCA\ncategories: OI\ntags: \n  - BZOJ\n  - AHOI\n  - LCA\n  - 乱搞\n  - 倍增\npermalink: ahoi2008-meet\ndate: 2016-03-07 20:36:46\n---\n\n在树上寻找一个点，使其到给定三点的距离之和最小。\n\n<!-- more -->\n\n### 题目链接\n[BZOJ 1787](http://www.lydsy.com/JudgeOnline/problem.php?id=1787)\n\n### 解题思路\n从样例中找出规律，三个点两两之间的 LCA 必有一对相等，写了个数据生成器用大数据验证了一下，确实是成立的。\n\n进一步得到规律，要找的点就是除了相等的一对 LCA 以外的另一个 LCA …… 别问我怎么证明，我不会 qwq\n\n### AC代码\n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXLOGN = 19; // log(500000, 2) = 18.931568569324174\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, depth;\n\t\n\tstruct SparseTable {\n\t\tint dist;\n\t\tNode *v;\n\t} st[MAXLOGN + 1];\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int u, int v) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v]);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u]);\n}\n\ninline void makeSparseTable() {\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->depth == 0) {\n\t\t\t\te->to->depth = v->depth + 1;\n\n\t\t\t\te->to->st[0].v = v;\n\t\t\t\te->to->st[0].dist = 1;\n\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tnodes[0].st[0].v = &nodes[0];\n\tnodes[0].st[0].dist = 0;\n\n\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].st[j].v = nodes[i].st[j - 1].v->st[j - 1].v;\n\t\t\tnodes[i].st[j].dist = nodes[i].st[j - 1].dist + nodes[i].st[j - 1].v->st[j - 1].dist;\n\t\t}\n\t}\n}\n\ninline int query(const int a, const int b, Node **lca = NULL) {\n\tNode *u = &nodes[a], *v = &nodes[b];\n\tint dist = 0;\n\n\tif (u->depth < v->depth) {\n\t\tstd::swap(u, v);\n\t}\n\n\tif (u->depth != v->depth) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != NULL && u->st[i].v->depth >= v->depth) {\n\t\t\t\tdist += u->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (u != v) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != v->st[i].v) {\n\t\t\t\tdist += u->st[i].dist + v->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t\tv = v->st[i].v;\n\t\t\t}\n\t\t}\n\n\t\tdist += u->st[0].dist + v->st[0].dist;\n\t\t\n\t\tif (lca) *lca = u->st[0].v;\n\t\treturn dist;\n\t}\n\n\tif (lca) *lca = u;\n\treturn dist;\n}\n\ninline int solve(int a, int b, int c) {\n\tNode *ab, *bc, *ca;\n\tint distAB, distBC, distCA;\n\n\tquery(a, b, &ab);\n\tquery(b, c, &bc);\n\tquery(c, a, &ca);\n\n\t// printf(\"%d, %d, %d\\n\", ab->id, bc->id, ca->id);\n\n\tNode *v;\n\tif (ab == bc) {\n\t\tv = ca;\n\t} else if (bc == ca) {\n\t\tv = ab;\n\t} else if (ca == ab) {\n\t\tv = bc;\n\t}\n\n\tassert(v != NULL);\n\treturn v->id;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\n\t\taddEdge(u, v);\n\t}\n\n\tmakeSparseTable();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c), a--, b--, c--;\n\n\t\tint id = solve(a, b, c);\n\t\tint dist = query(a, id - 1) + query(b, id - 1) + query(c, id - 1);\n\n\t\tprintf(\"%d %d\\n\", id, dist);\n\t}\n\n\treturn 0;\n}\n```\n\n### 数据生成器\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct UnionFindSet {\n\tint a[MAXN];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) a[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn a[x] == x ? x : a[x] = find(a[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\ta[find(x)] = find(y);\n\t}\n};\n\ninline int rand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tint x = rand();\n\tsrand((time(NULL) << 16) | ((clock() << 16) >> 16) ^ x ^ MAGIC_NUMBER);\n\treturn (rand() ^ x) % (r - l + 1) + l;\n}\n\nint main() {\n\tint n = MAXN, m = MAXM;\n\n\tstatic UnionFindSet ufs;\n\tufs.init(n);\n\n\tprintf(\"%d %d\\n\", n, m);\n\n\tfor (int i = 0; i < n - 1; ) {\n\t\tint u, v;\n\t\tu = rand(1, n), v = rand(1, n);\n\n\t\tif (ufs.find(u - 1) != ufs.find(v - 1)) {\n\t\t\tufs.merge(u - 1, v - 1);\n\t\t\tprintf(\"%d %d\\n\", u, v);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\ta = rand(1, n), b = rand(1, n), c = rand(1, n);\n\n\t\tprintf(\"%d %d %d\\n\", a, b, c);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"ahoi2008-meet","published":1,"updated":"2016-03-15T01:05:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nfq00kkofdkuyid7cpu"},{"title":"「省选模拟赛」小奇的集合 - 矩阵乘法","date":"2016-03-20T14:50:45.000Z","_content":"\n有一个大小为 $ n $ 的可重集 $ S $，小奇每次操作可以加入一个数 $ a + b $（$ a $，$ b $ 均属于 $ S $），求 $ k $ 次操作后它可获得的 $ S $ 的和的最大值（数据保证这个值为非负数）。\n\n<!-- more -->\n\n### 解题思路\n每次要取的都是最大的和次大的，考虑最大的和次大的都是非负数正数的情况，使用矩阵乘法（$ m1 $ 为最大值，$ m2 $ 为次大值，$ s $ 为当前总和）：\n\n$$\n\\left(\n  \\begin{array}{ccc}\n    m1 + m2 \\\\\n    m1 \\\\\n    s + m1 + m2 \\\\\n  \\end{array}\n\\right)\n= \\left(\n  \\begin{array}{ccc}\n    1 & 1 & 0 \\\\\n    1 & 0 & 0 \\\\\n    1 & 1 & 1 \\\\\n  \\end{array}\n\\right)\n* \\left(\n  \\begin{array}{ccc}\n    m1 \\\\\n    m2 \\\\\n    s \\\\\n  \\end{array}\n\\right)\n$$\n\n对于次大值为负的情况，先模拟，直到为正再用矩阵乘法。\n\n### AC代码\n```c++\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\nconst int MAXK = 1000000000;\nconst int MOD = 10000007;\n\ntemplate<typename T>\nstruct Matrix {\n\tT a[3][3];\n\n\tMatrix(T x1 = 1, T x2 = 0, T x3 = 0, T x4 = 0, T x5 = 1, T x6 = 0, T x7 = 0, T x8 = 0, T x9 = 1) {\n\t\ta[0][0] = x1, a[0][1] = x2, a[0][2] = x3;\n\t\ta[1][0] = x4, a[1][1] = x5, a[1][2] = x6;\n\t\ta[2][0] = x7, a[2][1] = x8, a[2][2] = x9;\n\t}\n\n\tconst T &operator()(int i, int j) const {\n\t\treturn a[i][j];\n\t}\n\t\n\tT &operator()(int i, int j) {\n\t\treturn a[i][j];\n\t}\n\t\n\tvoid print() {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tprintf(\"[ \");\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tprintf(\"%lld \", a[i][j]);\n\t\t\t}\n\t\t\tprintf(\"] \");\n\t\t}\n\t\tputchar('\\n');\n\t}\n};\n\ntemplate <typename T>\nMatrix<T> operator*(const Matrix<T> &a, const Matrix<T> &b) {\n\tMatrix<T> r(\n\t\t0, 0, 0,\n\t\t0, 0, 0,\n\t\t0, 0, 0\n\t);\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tr(i, j) = (r(i, j) + (a(i, k) * b(k, j)) % MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\t// r.print();\n\treturn r;\n}\n\ntemplate <typename T>\nMatrix<T> pow(Matrix<T> m, int x) {\n\tMatrix<T> ans;\n\t/*for (int i = 0; i < x - 1; i++) ans = ans * m;\n\treturn ans;*/\n\t\n\tfor (; x; x >>= 1, m = m * m){\n\t\t// printf(\"x = %d\\n\", x);\n\t\tif (x & 1) ans = ans * m;\n\t}\n\treturn ans;\n}\n\nint max = INT_MIN, max2 = INT_MIN, sum;\n\nint main() {\n\t// freopen(\"set.in\", \"r\", stdin);\n\t// freopen(\"set.out\", \"w\", stdout);\n\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint num;\n\t\tscanf(\"%d\", &num);\n\t\t\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\t\n\twhile (max2 < 0) {\n\t\tk--;\n\t\tint num = max + max2;\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\n\tMatrix<long long> base(\n\t\t1, 1, 0,\n\t\t1, 0, 0,\n\t\t1, 1, 1\n\t);\n\t\n\tMatrix<long long> init(\n\t\tmax % MOD, 0, 0,\n\t\tmax2 % MOD, 0, 0,\n\t\tsum % MOD, 0, 0\n\t);\n\t\t\n\tMatrix<long long> result = pow(base, k) * init;\n\n\t// printf(\"%d\\n\", (sum + (result(2, 0) * max) % MOD + (result(2, 1) * max2) % MOD) % MOD);\n\tprintf(\"%d\\n\", (result(2, 0) + MOD) % MOD);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/20160319-set.md","raw":"title: 「省选模拟赛」小奇的集合 - 矩阵乘法\ncategories: OI\ntags: \n  - 安师大附中集训\n  - 矩阵乘法\n  - 快速幂\n  - 数学\npermalink: 20160319-set\ndate: 2016-03-20 22:50:45\n---\n\n有一个大小为 $ n $ 的可重集 $ S $，小奇每次操作可以加入一个数 $ a + b $（$ a $，$ b $ 均属于 $ S $），求 $ k $ 次操作后它可获得的 $ S $ 的和的最大值（数据保证这个值为非负数）。\n\n<!-- more -->\n\n### 解题思路\n每次要取的都是最大的和次大的，考虑最大的和次大的都是非负数正数的情况，使用矩阵乘法（$ m1 $ 为最大值，$ m2 $ 为次大值，$ s $ 为当前总和）：\n\n$$\n\\left(\n  \\begin{array}{ccc}\n    m1 + m2 \\\\\n    m1 \\\\\n    s + m1 + m2 \\\\\n  \\end{array}\n\\right)\n= \\left(\n  \\begin{array}{ccc}\n    1 & 1 & 0 \\\\\n    1 & 0 & 0 \\\\\n    1 & 1 & 1 \\\\\n  \\end{array}\n\\right)\n* \\left(\n  \\begin{array}{ccc}\n    m1 \\\\\n    m2 \\\\\n    s \\\\\n  \\end{array}\n\\right)\n$$\n\n对于次大值为负的情况，先模拟，直到为正再用矩阵乘法。\n\n### AC代码\n```c++\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\nconst int MAXK = 1000000000;\nconst int MOD = 10000007;\n\ntemplate<typename T>\nstruct Matrix {\n\tT a[3][3];\n\n\tMatrix(T x1 = 1, T x2 = 0, T x3 = 0, T x4 = 0, T x5 = 1, T x6 = 0, T x7 = 0, T x8 = 0, T x9 = 1) {\n\t\ta[0][0] = x1, a[0][1] = x2, a[0][2] = x3;\n\t\ta[1][0] = x4, a[1][1] = x5, a[1][2] = x6;\n\t\ta[2][0] = x7, a[2][1] = x8, a[2][2] = x9;\n\t}\n\n\tconst T &operator()(int i, int j) const {\n\t\treturn a[i][j];\n\t}\n\t\n\tT &operator()(int i, int j) {\n\t\treturn a[i][j];\n\t}\n\t\n\tvoid print() {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tprintf(\"[ \");\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tprintf(\"%lld \", a[i][j]);\n\t\t\t}\n\t\t\tprintf(\"] \");\n\t\t}\n\t\tputchar('\\n');\n\t}\n};\n\ntemplate <typename T>\nMatrix<T> operator*(const Matrix<T> &a, const Matrix<T> &b) {\n\tMatrix<T> r(\n\t\t0, 0, 0,\n\t\t0, 0, 0,\n\t\t0, 0, 0\n\t);\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tr(i, j) = (r(i, j) + (a(i, k) * b(k, j)) % MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\t// r.print();\n\treturn r;\n}\n\ntemplate <typename T>\nMatrix<T> pow(Matrix<T> m, int x) {\n\tMatrix<T> ans;\n\t/*for (int i = 0; i < x - 1; i++) ans = ans * m;\n\treturn ans;*/\n\t\n\tfor (; x; x >>= 1, m = m * m){\n\t\t// printf(\"x = %d\\n\", x);\n\t\tif (x & 1) ans = ans * m;\n\t}\n\treturn ans;\n}\n\nint max = INT_MIN, max2 = INT_MIN, sum;\n\nint main() {\n\t// freopen(\"set.in\", \"r\", stdin);\n\t// freopen(\"set.out\", \"w\", stdout);\n\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint num;\n\t\tscanf(\"%d\", &num);\n\t\t\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\t\n\twhile (max2 < 0) {\n\t\tk--;\n\t\tint num = max + max2;\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\n\tMatrix<long long> base(\n\t\t1, 1, 0,\n\t\t1, 0, 0,\n\t\t1, 1, 1\n\t);\n\t\n\tMatrix<long long> init(\n\t\tmax % MOD, 0, 0,\n\t\tmax2 % MOD, 0, 0,\n\t\tsum % MOD, 0, 0\n\t);\n\t\t\n\tMatrix<long long> result = pow(base, k) * init;\n\n\t// printf(\"%d\\n\", (sum + (result(2, 0) * max) % MOD + (result(2, 1) * max2) % MOD) % MOD);\n\tprintf(\"%d\\n\", (result(2, 0) + MOD) % MOD);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"20160319-set","published":1,"updated":"2016-03-22T09:51:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4nfw00kuofdktffv11r3"},{"title":"「省选模拟赛」小奇的糖果 - 扫描线 + 链表","date":"2016-03-20T14:58:12.000Z","_content":"\n有 $ N $ 个彩色糖果在平面上。小奇想在平面上取一条水平的线段，并拾起它上方或下方的所有糖果。求出最多能够拾起多少糖果，使得获得的糖果并不包含所有的颜色。\n\n<!-- more -->\n\n### 解题思路\n对纵坐标离散化。\n\n用树状数组维护「当前」横坐标在某个区间内的糖果数量。\n\n用链表维护「当前」某个糖果左边右边与它横坐标最近的两个糖果。\n\n扫描线从上往下扫，初始时树状数组为满，扫到某个新纵坐标把一条直线上所有糖果从树状数组中删掉。对于每个扫描到的糖果，先把它从链表中删掉，考虑这种颜色不选，统计它左边和它右边两个与它颜色相同的糖果之间的糖果数量，更新答案。\n\n跑扫描线之前还要先算出每两个相邻的糖果之间的答案。\n\n题目中允许取上边或下边，只需要将纵坐标取反即可。\n\n### AC代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <list>\n\nconst int MAXT = 3;\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Candy {\n\tint xOrigin, yOrigin;\n\tint x, y;\n\tint color;\n\tstd::list<Candy>::iterator p;\n} candies[MAXN];\n\nbool compareByY(const Candy &a, const Candy &b) {\n\treturn a.y < b.y;\n}\n\nbool compareByX(const Candy &a, const Candy &b) {\n\treturn a.x < b.x;\n}\n\nint n, k, xSet[MAXN], ySet[MAXN], cx, cy;\nstd::list<Candy> list[MAXK];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(int pos, int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tint sum(int pos) {\n\t\tint result = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) result += a[i - 1];\n\t\treturn result;\n\t}\n\n\tint query(int l, int r) {\n\t\t// printf(\"query(%d, %d) = %d\\n\", l, r, sum(r) - sum(l - 1));\n\t\treturn sum(r) - sum(l - 1);\n\t}\n\n\tvoid clear() {\n\t\tmemset(a, 0, sizeof(a));\n\t}\n} bit;\n\ninline int solve() {\n\tbit.clear();\n\tfor (int i = 0; i < k; i++) list[i].clear();\n\n\tstd::sort(candies, candies + n, &compareByX);\n\tfor (int i = 0; i < n; i++) {\n\t\tcandies[i].p = list[candies[i].color].insert(list[candies[i].color].end(), candies[i]);\n\t\tbit.update(candies[i].x, 1);\n\t}\n\n\tstd::sort(candies, candies + n, &compareByY);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint last = 0;\n\t\tfor (std::list<Candy>::const_iterator p = list[i].begin(); p != list[i].end(); p++) {\n\t\t\tans = std::max(ans, bit.query(last + 1, p->x - 1));\n\t\t\tlast = p->x;\n\t\t}\n\n\t\tans = std::max(ans, bit.query(last + 1, n));\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0 || candies[i].y != candies[i - 1].y) {\n\t\t\tfor (int j = i; j < n && candies[j].y == candies[i].y; j++) {\n\t\t\t\tbit.update(candies[j].x, -1);\n\t\t\t}\n\t\t}\n\n\t\tint l, r;\n\n\t\tstd::list<Candy>::iterator &p = candies[i].p;\n\t\tif (p != list[candies[i].color].begin()) {\n\t\t\tstd::list<Candy>::const_iterator prev = p;\n\t\t\tprev--;\n\t\t\tl = prev->x + 1;\n\t\t} else l = 1;\n\n\t\tstd::list<Candy>::const_iterator next = p;\n\t\tnext++;\n\n\t\tif (next != list[candies[i].color].end()) {\n\t\t\tr = next->x - 1;\n\t\t} else r = n;\n\n\t\tans = std::max(ans, bit.query(l, r));\n\n\t\tlist[candies[i].color].erase(p);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"candy.in\", \"r\", stdin);\n\t// freopen(\"candy.out\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%d %d\", &n, &k);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &candies[i].xOrigin, &candies[i].yOrigin, &candies[i].color), candies[i].color--;\n\t\t\txSet[i] = candies[i].xOrigin;\n\t\t\tySet[i] = candies[i].yOrigin;\n\t\t}\n\n\t\tint *xEnd, *yEnd;\n\t\tstd::sort(xSet, xSet + n);\n\t\tstd::sort(ySet, ySet + n);\n\t\txEnd = std::unique(xSet, xSet + n);\n\t\tyEnd = std::unique(ySet, ySet + n);\n\n\t\tcx = xEnd - xSet;\n\t\tcy = yEnd - ySet;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcandies[i].x = std::lower_bound(xSet, xEnd, candies[i].xOrigin) - xSet + 1;\n\t\t\tcandies[i].y = std::lower_bound(ySet, yEnd, candies[i].yOrigin) - ySet + 1;\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tans = std::max(ans, solve());\n\t\tfor (int i = 0; i < n; i++) candies[i].y = -candies[i].y;\n\t\tans = std::max(ans, solve());\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\ntitle: 「省选模拟赛」小奇的糖果 - 扫描线 + 链表\n","source":"_posts/20160319-candy.md","raw":"title: 「省选模拟赛」小奇的糖果 - 扫描线 + 链表\ncategories: OI\ntags: \n  - 安师大附中集训\n  - 扫描线\n  - 链表\n  - 树状数组\n  - 离散化\npermalink: 20160319-candy\ndate: 2016-03-20 22:58:12\n---\n\n有 $ N $ 个彩色糖果在平面上。小奇想在平面上取一条水平的线段，并拾起它上方或下方的所有糖果。求出最多能够拾起多少糖果，使得获得的糖果并不包含所有的颜色。\n\n<!-- more -->\n\n### 解题思路\n对纵坐标离散化。\n\n用树状数组维护「当前」横坐标在某个区间内的糖果数量。\n\n用链表维护「当前」某个糖果左边右边与它横坐标最近的两个糖果。\n\n扫描线从上往下扫，初始时树状数组为满，扫到某个新纵坐标把一条直线上所有糖果从树状数组中删掉。对于每个扫描到的糖果，先把它从链表中删掉，考虑这种颜色不选，统计它左边和它右边两个与它颜色相同的糖果之间的糖果数量，更新答案。\n\n跑扫描线之前还要先算出每两个相邻的糖果之间的答案。\n\n题目中允许取上边或下边，只需要将纵坐标取反即可。\n\n### AC代码\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <list>\n\nconst int MAXT = 3;\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Candy {\n\tint xOrigin, yOrigin;\n\tint x, y;\n\tint color;\n\tstd::list<Candy>::iterator p;\n} candies[MAXN];\n\nbool compareByY(const Candy &a, const Candy &b) {\n\treturn a.y < b.y;\n}\n\nbool compareByX(const Candy &a, const Candy &b) {\n\treturn a.x < b.x;\n}\n\nint n, k, xSet[MAXN], ySet[MAXN], cx, cy;\nstd::list<Candy> list[MAXK];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(int pos, int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tint sum(int pos) {\n\t\tint result = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) result += a[i - 1];\n\t\treturn result;\n\t}\n\n\tint query(int l, int r) {\n\t\t// printf(\"query(%d, %d) = %d\\n\", l, r, sum(r) - sum(l - 1));\n\t\treturn sum(r) - sum(l - 1);\n\t}\n\n\tvoid clear() {\n\t\tmemset(a, 0, sizeof(a));\n\t}\n} bit;\n\ninline int solve() {\n\tbit.clear();\n\tfor (int i = 0; i < k; i++) list[i].clear();\n\n\tstd::sort(candies, candies + n, &compareByX);\n\tfor (int i = 0; i < n; i++) {\n\t\tcandies[i].p = list[candies[i].color].insert(list[candies[i].color].end(), candies[i]);\n\t\tbit.update(candies[i].x, 1);\n\t}\n\n\tstd::sort(candies, candies + n, &compareByY);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint last = 0;\n\t\tfor (std::list<Candy>::const_iterator p = list[i].begin(); p != list[i].end(); p++) {\n\t\t\tans = std::max(ans, bit.query(last + 1, p->x - 1));\n\t\t\tlast = p->x;\n\t\t}\n\n\t\tans = std::max(ans, bit.query(last + 1, n));\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0 || candies[i].y != candies[i - 1].y) {\n\t\t\tfor (int j = i; j < n && candies[j].y == candies[i].y; j++) {\n\t\t\t\tbit.update(candies[j].x, -1);\n\t\t\t}\n\t\t}\n\n\t\tint l, r;\n\n\t\tstd::list<Candy>::iterator &p = candies[i].p;\n\t\tif (p != list[candies[i].color].begin()) {\n\t\t\tstd::list<Candy>::const_iterator prev = p;\n\t\t\tprev--;\n\t\t\tl = prev->x + 1;\n\t\t} else l = 1;\n\n\t\tstd::list<Candy>::const_iterator next = p;\n\t\tnext++;\n\n\t\tif (next != list[candies[i].color].end()) {\n\t\t\tr = next->x - 1;\n\t\t} else r = n;\n\n\t\tans = std::max(ans, bit.query(l, r));\n\n\t\tlist[candies[i].color].erase(p);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"candy.in\", \"r\", stdin);\n\t// freopen(\"candy.out\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%d %d\", &n, &k);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &candies[i].xOrigin, &candies[i].yOrigin, &candies[i].color), candies[i].color--;\n\t\t\txSet[i] = candies[i].xOrigin;\n\t\t\tySet[i] = candies[i].yOrigin;\n\t\t}\n\n\t\tint *xEnd, *yEnd;\n\t\tstd::sort(xSet, xSet + n);\n\t\tstd::sort(ySet, ySet + n);\n\t\txEnd = std::unique(xSet, xSet + n);\n\t\tyEnd = std::unique(ySet, ySet + n);\n\n\t\tcx = xEnd - xSet;\n\t\tcy = yEnd - ySet;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcandies[i].x = std::lower_bound(xSet, xEnd, candies[i].xOrigin) - xSet + 1;\n\t\t\tcandies[i].y = std::lower_bound(ySet, yEnd, candies[i].yOrigin) - ySet + 1;\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tans = std::max(ans, solve());\n\t\tfor (int i = 0; i < n; i++) candies[i].y = -candies[i].y;\n\t\tans = std::max(ans, solve());\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\ntitle: 「省选模拟赛」小奇的糖果 - 扫描线 + 链表\n","slug":"20160319-candy","published":1,"updated":"2016-03-22T09:51:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cim3d4ng100l2ofdkmcr5kncc"}],"PostAsset":[{"_id":"source/_posts/virtualbox-archlinux/hotkey.png","post":"cim3d4myf000fofdkvorc8dw7","slug":"hotkey.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/network.png","post":"cim3d4myf000fofdkvorc8dw7","slug":"network.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/port.png","post":"cim3d4myf000fofdkvorc8dw7","slug":"port.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/screenfetch.png","post":"cim3d4myf000fofdkvorc8dw7","slug":"screenfetch.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/share.png","post":"cim3d4myf000fofdkvorc8dw7","slug":"share.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/terminal.png","post":"cim3d4myf000fofdkvorc8dw7","slug":"terminal.png","modified":1},{"_id":"source/_posts/uva-11538/cells.png","post":"cim3d4n0c001eofdk774u3r1g","slug":"cells.png","modified":1},{"_id":"source/_posts/splay-notes-1/splay.png","post":"cim3d4n39004cofdkwvpswn69","slug":"splay.png","modified":1},{"_id":"source/_posts/osx-softwares/dropbox.png","post":"cim3d4n5v007qofdk0d96lic9","slug":"dropbox.png","modified":1},{"_id":"source/_posts/osx-softwares/feeluown.png","post":"cim3d4n5v007qofdk0d96lic9","slug":"feeluown.png","modified":1},{"_id":"source/_posts/osx-softwares/fileroller.png","post":"cim3d4n5v007qofdk0d96lic9","slug":"fileroller.png","modified":1},{"_id":"source/_posts/osx-softwares/flashlight.png","post":"cim3d4n5v007qofdk0d96lic9","slug":"flashlight.png","modified":1},{"_id":"source/_posts/osx-softwares/gimp.png","post":"cim3d4n5v007qofdk0d96lic9","slug":"gimp.png","modified":1},{"_id":"source/_posts/osx-softwares/go2shell.png","post":"cim3d4n5v007qofdk0d96lic9","slug":"go2shell.png","modified":1},{"_id":"source/_posts/osx-softwares/karabiner.png","post":"cim3d4n5v007qofdk0d96lic9","slug":"karabiner.png","modified":1},{"_id":"source/_posts/osx-softwares/libreoffice-writer.png","post":"cim3d4n5v007qofdk0d96lic9","slug":"libreoffice-writer.png","modified":1},{"_id":"source/_posts/osx-softwares/macdown.png","post":"cim3d4n5v007qofdk0d96lic9","slug":"macdown.png","modified":1},{"_id":"source/_posts/osx-softwares/macvim.png","post":"cim3d4n5v007qofdk0d96lic9","slug":"macvim.png","modified":1},{"_id":"source/_posts/osx-softwares/shadowsocksx.png","post":"cim3d4n5v007qofdk0d96lic9","slug":"shadowsocksx.png","modified":1},{"_id":"source/_posts/osx-softwares/teamviewer.png","post":"cim3d4n5v007qofdk0d96lic9","slug":"teamviewer.png","modified":1},{"_id":"source/_posts/osx-softwares/virtualbox.png","post":"cim3d4n5v007qofdk0d96lic9","slug":"virtualbox.png","modified":1},{"_id":"source/_posts/osx-softwares/vlc.png","post":"cim3d4n5v007qofdk0d96lic9","slug":"vlc.png","modified":1},{"_id":"source/_posts/osx-enable-retina/plist-edit.png","post":"cim3d4n7e007vofdkbk3nuv9a","slug":"plist-edit.png","modified":1},{"_id":"source/_posts/cut-tree-notes/cutTree.png","post":"cim3d4nag00doofdklv03zb47","slug":"cutTree.png","modified":1},{"_id":"source/_posts/bzoj-2683/cdq.png","post":"cim3d4neh00iwofdkynsogwvx","slug":"cdq.png","modified":1}],"PostCategory":[{"post_id":"cim3d4mws0000ofdkzo4y48ox","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4mxg0007ofdkpbrukxvb"},{"post_id":"cim3d4myf000fofdkvorc8dw7","category_id":"cim3d4myh000gofdk5um61roz","_id":"cim3d4myk000nofdk1z9xocby"},{"post_id":"cim3d4mzu000uofdkp17nlmwn","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4mzx000vofdk6mbll5vf"},{"post_id":"cim3d4n050016ofdk78tkozav","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n070017ofdkycbyw2mi"},{"post_id":"cim3d4n0c001eofdk774u3r1g","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n0d001fofdkjoovcy01"},{"post_id":"cim3d4n0q001kofdkhukbg2re","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n0s001lofdkohnmm8xn"},{"post_id":"cim3d4n0z001sofdk8y6w9rfe","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n10001tofdkvncllt90"},{"post_id":"cim3d4n150020ofdkh3mdembu","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n170021ofdkcbeurfgs"},{"post_id":"cim3d4n1d002cofdkbfyq92d0","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n1e002dofdkbqu0bnlu"},{"post_id":"cim3d4n1h002kofdkt0rfrcr0","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n1j002lofdkw9te9sml"},{"post_id":"cim3d4n1u002wofdkmrks4ex1","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n2c002xofdk07n18852"},{"post_id":"cim3d4n2f0035ofdk17kt6res","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n2h0036ofdk4wznc83h"},{"post_id":"cim3d4n2l003hofdki6w2w8en","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n2m003iofdko2sp4nod"},{"post_id":"cim3d4n2p003qofdkve54eii5","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n2r003rofdk2u7nwrog"},{"post_id":"cim3d4n2t003wofdkd0h08gfw","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n2v003xofdk8g3hitm5"},{"post_id":"cim3d4n2z0044ofdkt82vlk52","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n310045ofdkp6stbynt"},{"post_id":"cim3d4n39004cofdkwvpswn69","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n3c004dofdkajctsrl0"},{"post_id":"cim3d4n3o004jofdkvpb4tc4y","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n3t004kofdk32xecl67"},{"post_id":"cim3d4n3y004xofdkqackgp34","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n40004yofdkcmie48r6"},{"post_id":"cim3d4n430057ofdkah54r4vc","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n450058ofdk9b47bm0l"},{"post_id":"cim3d4n4a005iofdkem946jkh","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n4c005jofdkajvpr3e9"},{"post_id":"cim3d4n4m005tofdkkobiu8x8","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n4p005uofdk56342luh"},{"post_id":"cim3d4n4t0063ofdk3bsbe60t","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n4v0064ofdk9l04s4q4"},{"post_id":"cim3d4n4z006cofdk99g0xv7w","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n50006dofdksmxilrah"},{"post_id":"cim3d4n54006nofdk746fzpi0","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n55006oofdkyu9pi3zp"},{"post_id":"cim3d4n5d006xofdkdoje2n0r","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n5i006yofdk1bod1scx"},{"post_id":"cim3d4n5m0076ofdkbbpr8wkg","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n5n0077ofdkpsf97nco"},{"post_id":"cim3d4n5s007iofdk8h8d8esq","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n5s007jofdkd5i4fvii"},{"post_id":"cim3d4n5v007qofdk0d96lic9","category_id":"cim3d4myh000gofdk5um61roz","_id":"cim3d4n5w007rofdkfyxcc35e"},{"post_id":"cim3d4n7e007vofdkbk3nuv9a","category_id":"cim3d4myh000gofdk5um61roz","_id":"cim3d4n7g007wofdkoh2pr3gr"},{"post_id":"cim3d4n7k0080ofdk5wzt5y3g","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n7l0081ofdkg82tlfso"},{"post_id":"cim3d4n7n0086ofdkd0zwwssk","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n7o0087ofdk9v0m4rq1"},{"post_id":"cim3d4n7r008gofdknmpeypaw","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n7u008hofdkcu8ytq96"},{"post_id":"cim3d4n7z008sofdkzy7a7cn0","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n80008tofdkvk3d6ykx"},{"post_id":"cim3d4n82008zofdkxpdyslf1","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n830090ofdkf3b8r5yt"},{"post_id":"cim3d4n860099ofdkl4vtequb","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n87009aofdk3kurhr7b"},{"post_id":"cim3d4n89009hofdk872x6hof","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n8b009iofdktzfz9612"},{"post_id":"cim3d4n8d009nofdkbxfcca59","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n8f009oofdk4tlj284j"},{"post_id":"cim3d4n8j009zofdk20ri6pxq","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n8k00a0ofdks8art77s"},{"post_id":"cim3d4n8o00a7ofdkhbtjoso3","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n8p00a8ofdkv7uh12qi"},{"post_id":"cim3d4n8t00ajofdkqu23xlbn","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n8v00akofdk3ha246ti"},{"post_id":"cim3d4n8z00arofdkxl8fylib","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n9000asofdklz81njvg"},{"post_id":"cim3d4n9300ayofdkdklijg72","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n9400azofdk4un5p4ac"},{"post_id":"cim3d4n9500b3ofdky4bojlzy","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n9700b4ofdkwfdxsn4a"},{"post_id":"cim3d4n9900bbofdk5fo61rso","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n9b00bcofdkkd37k8wv"},{"post_id":"cim3d4n9e00boofdk7yuks0bd","category_id":"cim3d4myh000gofdk5um61roz","_id":"cim3d4n9f00bpofdko98xs98q"},{"post_id":"cim3d4n9i00bwofdklf65k2pt","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n9j00bxofdkjv68g3mt"},{"post_id":"cim3d4n9m00c4ofdkgdhx66oa","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n9n00c5ofdkxihrli2r"},{"post_id":"cim3d4n9q00cdofdkkf4zassw","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n9r00ceofdkxp05f5dt"},{"post_id":"cim3d4n9t00clofdkpfj3uoeo","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n9v00cmofdklg2tb8dq"},{"post_id":"cim3d4n9y00cuofdk0nbpk236","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4n9z00cvofdkl7tb8d68"},{"post_id":"cim3d4na200d2ofdkmomcpjl5","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4na400d3ofdkc9twu3mt"},{"post_id":"cim3d4na700d9ofdk0qnx4cda","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4na900daofdkcii9g78h"},{"post_id":"cim3d4nad00dhofdke14lfqsb","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4nae00diofdk7ewvcz8s"},{"post_id":"cim3d4nag00doofdklv03zb47","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4nai00dpofdksnoy2ihp"},{"post_id":"cim3d4nao00dwofdk40s26tsb","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4nap00dxofdk66vklxfa"},{"post_id":"cim3d4nav00e8ofdkl9yw5ncv","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4naw00e9ofdk6hebymi8"},{"post_id":"cim3d4nay00eeofdk0q8gx1mj","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4naz00efofdkvqmggb7h"},{"post_id":"cim3d4nb100ekofdkymol0ytr","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4nb300elofdkqs2dwscz"},{"post_id":"cim3d4nb800etofdks3kk6cdm","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4nbc00euofdk95339498"},{"post_id":"cim3d4nbl00f1ofdkee7h7z0x","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4nbn00f2ofdk55iux99l"},{"post_id":"cim3d4nbp00f9ofdklx3z6x1r","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4nbr00faofdkpay7zt77"},{"post_id":"cim3d4nbw00fiofdka4kurnu1","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4nbx00fjofdk3be0343b"},{"post_id":"cim3d4nc100fqofdkos3jucrs","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4nc300frofdktm1y6lu2"},{"post_id":"cim3d4nc600fyofdkmwy5gz51","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4nc800fzofdkcx7myh8d"},{"post_id":"cim3d4ncc00g6ofdkjhh63rne","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4ncd00g7ofdk63g9znx3"},{"post_id":"cim3d4nch00gdofdkrg0l9m4g","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4nci00geofdkaf1mnbj5"},{"post_id":"cim3d4ncl00gkofdk0v815i0a","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4ncn00glofdkgu4icgyk"},{"post_id":"cim3d4ncq00gsofdkys3g2ywr","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4ncr00gtofdkjjcz2lod"},{"post_id":"cim3d4ncv00h1ofdk7znjyldv","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4ncw00h2ofdkridvchue"},{"post_id":"cim3d4nd100hcofdk8vfp0u8j","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4nd300hdofdkpxamtuty"},{"post_id":"cim3d4nd500hhofdkpw6vn5no","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4nd600hiofdkzilj2p3h"},{"post_id":"cim3d4nd900hpofdkl5ztsrzz","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4ndb00hqofdkxqdqjheg"},{"post_id":"cim3d4ndf00huofdktf9opz43","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4ndg00hvofdkcwkm80r7"},{"post_id":"cim3d4ndk00i0ofdkabqlvccz","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4ndl00i1ofdkn8vpve9x"},{"post_id":"cim3d4ndp00i7ofdkltzqkb9k","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4ndr00i8ofdkekyodt9n"},{"post_id":"cim3d4ndu00ieofdkuach27pc","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4ndw00ifofdky5nv03oi"},{"post_id":"cim3d4ne900ilofdk8263tvyl","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4neb00imofdkugpjly5f"},{"post_id":"cim3d4nee00irofdk8m3gzz21","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4nef00isofdkuyw1hk5d"},{"post_id":"cim3d4neh00iwofdkynsogwvx","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4nej00ixofdk32tglqt5"},{"post_id":"cim3d4nep00j5ofdk5ud8nfda","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4ner00j6ofdkwy7iqgsj"},{"post_id":"cim3d4net00jcofdkv0jxezl5","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4nev00jdofdkrxx0fs76"},{"post_id":"cim3d4ney00jjofdkfjlp2m34","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4nez00jkofdkufp4dbyg"},{"post_id":"cim3d4nf200jqofdkh8vik3po","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4nf900jrofdk9xbs82ch"},{"post_id":"cim3d4nfb00jwofdkrj7powso","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4nfd00jxofdkfzxme4wg"},{"post_id":"cim3d4nfg00k2ofdkwpu8zy3j","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4nfh00k3ofdkkanszfp2"},{"post_id":"cim3d4nfj00k6ofdkiorphnzk","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4nfl00k7ofdkveicotka"},{"post_id":"cim3d4nfq00kkofdkuyid7cpu","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4nfs00klofdkxsuprlzx"},{"post_id":"cim3d4nfw00kuofdktffv11r3","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4nfx00kvofdkf5z8onfl"},{"post_id":"cim3d4ng100l2ofdkmcr5kncc","category_id":"cim3d4mx70001ofdkfy3px9kl","_id":"cim3d4ng200l3ofdki6czgx58"}],"PostTag":[{"post_id":"cim3d4mws0000ofdkzo4y48ox","tag_id":"cim3d4mx70002ofdklekif86g","_id":"cim3d4mxh0008ofdkw0k6gvk6"},{"post_id":"cim3d4mws0000ofdkzo4y48ox","tag_id":"cim3d4mxe0003ofdkdm4dl99o","_id":"cim3d4mxh0009ofdkmrqs8hvy"},{"post_id":"cim3d4mws0000ofdkzo4y48ox","tag_id":"cim3d4mxf0004ofdkji2tbv1k","_id":"cim3d4mxi000aofdko1gb8n6l"},{"post_id":"cim3d4mws0000ofdkzo4y48ox","tag_id":"cim3d4mxf0005ofdk046v51ln","_id":"cim3d4mxi000bofdk4sz28ahg"},{"post_id":"cim3d4mws0000ofdkzo4y48ox","tag_id":"cim3d4mxf0006ofdke2hwb42e","_id":"cim3d4mxi000cofdkd15wwx9s"},{"post_id":"cim3d4myf000fofdkvorc8dw7","tag_id":"cim3d4myh000hofdkx1w4qomx","_id":"cim3d4myl000oofdki5aon40q"},{"post_id":"cim3d4myf000fofdkvorc8dw7","tag_id":"cim3d4myj000iofdkk6xd6wif","_id":"cim3d4myl000pofdk3c72bxkz"},{"post_id":"cim3d4myf000fofdkvorc8dw7","tag_id":"cim3d4myj000jofdk9ezbtcxt","_id":"cim3d4myl000qofdkdb3a1tkq"},{"post_id":"cim3d4myf000fofdkvorc8dw7","tag_id":"cim3d4myj000kofdk70r7hc2s","_id":"cim3d4mym000rofdkdwl20vm2"},{"post_id":"cim3d4myf000fofdkvorc8dw7","tag_id":"cim3d4myj000lofdk5vokz20z","_id":"cim3d4mym000sofdkqp34n4xd"},{"post_id":"cim3d4myf000fofdkvorc8dw7","tag_id":"cim3d4myj000mofdke8tekpet","_id":"cim3d4mym000tofdkta6y2463"},{"post_id":"cim3d4mzu000uofdkp17nlmwn","tag_id":"cim3d4mzy000wofdk625dyrw1","_id":"cim3d4n000011ofdkurbm9sgv"},{"post_id":"cim3d4mzu000uofdkp17nlmwn","tag_id":"cim3d4mzz000xofdk9gb5glv9","_id":"cim3d4n010012ofdkmkj0riuk"},{"post_id":"cim3d4mzu000uofdkp17nlmwn","tag_id":"cim3d4n00000yofdkdm341tud","_id":"cim3d4n010013ofdkuvywpf0y"},{"post_id":"cim3d4mzu000uofdkp17nlmwn","tag_id":"cim3d4n00000zofdkyqrajr19","_id":"cim3d4n020014ofdkunyzjjtq"},{"post_id":"cim3d4mzu000uofdkp17nlmwn","tag_id":"cim3d4n000010ofdk25vmk2od","_id":"cim3d4n020015ofdkvx7fos9j"},{"post_id":"cim3d4n050016ofdk78tkozav","tag_id":"cim3d4mzy000wofdk625dyrw1","_id":"cim3d4n09001aofdkmwk39nj0"},{"post_id":"cim3d4n050016ofdk78tkozav","tag_id":"cim3d4mzz000xofdk9gb5glv9","_id":"cim3d4n09001bofdksd558j39"},{"post_id":"cim3d4n050016ofdk78tkozav","tag_id":"cim3d4n080018ofdk6liznv8i","_id":"cim3d4n0a001cofdk7tvvkgcv"},{"post_id":"cim3d4n050016ofdk78tkozav","tag_id":"cim3d4n080019ofdkkb134ai8","_id":"cim3d4n0a001dofdka090xza9"},{"post_id":"cim3d4n0c001eofdk774u3r1g","tag_id":"cim3d4mzy000wofdk625dyrw1","_id":"cim3d4n0e001gofdkze2sztx4"},{"post_id":"cim3d4n0c001eofdk774u3r1g","tag_id":"cim3d4mzz000xofdk9gb5glv9","_id":"cim3d4n0e001hofdkj90jfrcb"},{"post_id":"cim3d4n0c001eofdk774u3r1g","tag_id":"cim3d4n080018ofdk6liznv8i","_id":"cim3d4n0e001iofdky60f23rb"},{"post_id":"cim3d4n0c001eofdk774u3r1g","tag_id":"cim3d4n000010ofdk25vmk2od","_id":"cim3d4n0e001jofdkye0udjda"},{"post_id":"cim3d4n0q001kofdkhukbg2re","tag_id":"cim3d4mzy000wofdk625dyrw1","_id":"cim3d4n0u001oofdki7oz32zh"},{"post_id":"cim3d4n0q001kofdkhukbg2re","tag_id":"cim3d4mzz000xofdk9gb5glv9","_id":"cim3d4n0w001pofdk38mzno5v"},{"post_id":"cim3d4n0q001kofdkhukbg2re","tag_id":"cim3d4n0s001mofdknpymi3n4","_id":"cim3d4n0w001qofdkblb3oepx"},{"post_id":"cim3d4n0q001kofdkhukbg2re","tag_id":"cim3d4n0t001nofdksw6s8kom","_id":"cim3d4n0x001rofdkv72dapfh"},{"post_id":"cim3d4n0z001sofdk8y6w9rfe","tag_id":"cim3d4mzy000wofdk625dyrw1","_id":"cim3d4n12001vofdkxkd0td53"},{"post_id":"cim3d4n0z001sofdk8y6w9rfe","tag_id":"cim3d4mzz000xofdk9gb5glv9","_id":"cim3d4n13001wofdk4pg7f1r5"},{"post_id":"cim3d4n0z001sofdk8y6w9rfe","tag_id":"cim3d4n0s001mofdknpymi3n4","_id":"cim3d4n13001xofdku5w80a63"},{"post_id":"cim3d4n0z001sofdk8y6w9rfe","tag_id":"cim3d4n00000yofdkdm341tud","_id":"cim3d4n13001yofdkn1lme452"},{"post_id":"cim3d4n0z001sofdk8y6w9rfe","tag_id":"cim3d4n10001uofdkjoh7gytm","_id":"cim3d4n13001zofdka40n611d"},{"post_id":"cim3d4n150020ofdkh3mdembu","tag_id":"cim3d4mzy000wofdk625dyrw1","_id":"cim3d4n190025ofdkkg3hkcir"},{"post_id":"cim3d4n150020ofdkh3mdembu","tag_id":"cim3d4mzz000xofdk9gb5glv9","_id":"cim3d4n1b0026ofdk02gc9prm"},{"post_id":"cim3d4n150020ofdkh3mdembu","tag_id":"cim3d4n180022ofdkqgbkozko","_id":"cim3d4n1b0027ofdkz5pwlh64"},{"post_id":"cim3d4n150020ofdkh3mdembu","tag_id":"cim3d4n0s001mofdknpymi3n4","_id":"cim3d4n1b0028ofdkh70dudzs"},{"post_id":"cim3d4n150020ofdkh3mdembu","tag_id":"cim3d4n000010ofdk25vmk2od","_id":"cim3d4n1b0029ofdkjohut8br"},{"post_id":"cim3d4n150020ofdkh3mdembu","tag_id":"cim3d4n180023ofdkya9sa1gz","_id":"cim3d4n1c002aofdkw9nd32t4"},{"post_id":"cim3d4n150020ofdkh3mdembu","tag_id":"cim3d4n190024ofdktxtmq020","_id":"cim3d4n1c002bofdkpyvy4pl1"},{"post_id":"cim3d4n1d002cofdkbfyq92d0","tag_id":"cim3d4mzy000wofdk625dyrw1","_id":"cim3d4n1f002fofdkhloikvjf"},{"post_id":"cim3d4n1d002cofdkbfyq92d0","tag_id":"cim3d4mzz000xofdk9gb5glv9","_id":"cim3d4n1f002gofdkd74ctjjm"},{"post_id":"cim3d4n1d002cofdkbfyq92d0","tag_id":"cim3d4n0s001mofdknpymi3n4","_id":"cim3d4n1f002hofdk420oenf2"},{"post_id":"cim3d4n1d002cofdkbfyq92d0","tag_id":"cim3d4n00000yofdkdm341tud","_id":"cim3d4n1f002iofdkdgh66eqb"},{"post_id":"cim3d4n1d002cofdkbfyq92d0","tag_id":"cim3d4n1e002eofdki0g553ji","_id":"cim3d4n1f002jofdkvpkce5o5"},{"post_id":"cim3d4n1h002kofdkt0rfrcr0","tag_id":"cim3d4mzy000wofdk625dyrw1","_id":"cim3d4n1m002pofdkyzaj9dyg"},{"post_id":"cim3d4n1h002kofdkt0rfrcr0","tag_id":"cim3d4mzz000xofdk9gb5glv9","_id":"cim3d4n1m002qofdkq2ew5e0x"},{"post_id":"cim3d4n1h002kofdkt0rfrcr0","tag_id":"cim3d4n0s001mofdknpymi3n4","_id":"cim3d4n1n002rofdkd13d2evn"},{"post_id":"cim3d4n1h002kofdkt0rfrcr0","tag_id":"cim3d4n000010ofdk25vmk2od","_id":"cim3d4n1n002sofdkomiax0f7"},{"post_id":"cim3d4n1h002kofdkt0rfrcr0","tag_id":"cim3d4n1j002mofdku7x312a3","_id":"cim3d4n1n002tofdkk2ael5v3"},{"post_id":"cim3d4n1h002kofdkt0rfrcr0","tag_id":"cim3d4n1l002nofdkkw4fhrtd","_id":"cim3d4n1n002uofdkzur3zb7x"},{"post_id":"cim3d4n1h002kofdkt0rfrcr0","tag_id":"cim3d4n1l002oofdk9f3kjrwq","_id":"cim3d4n1n002vofdka11dsbvp"},{"post_id":"cim3d4n1u002wofdkmrks4ex1","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4n2d0031ofdk60sw63lk"},{"post_id":"cim3d4n1u002wofdkmrks4ex1","tag_id":"cim3d4n00000yofdkdm341tud","_id":"cim3d4n2e0032ofdkxm43xxxb"},{"post_id":"cim3d4n1u002wofdkmrks4ex1","tag_id":"cim3d4n2c002zofdks2jqydqn","_id":"cim3d4n2e0033ofdko7icmbl2"},{"post_id":"cim3d4n1u002wofdkmrks4ex1","tag_id":"cim3d4n2c0030ofdkg4al9kb9","_id":"cim3d4n2e0034ofdkisx9e1lz"},{"post_id":"cim3d4n2f0035ofdk17kt6res","tag_id":"cim3d4n2h0037ofdkguwuehk4","_id":"cim3d4n2j003cofdk3hgdkgl2"},{"post_id":"cim3d4n2f0035ofdk17kt6res","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4n2j003dofdk9r9v1hhr"},{"post_id":"cim3d4n2f0035ofdk17kt6res","tag_id":"cim3d4n2i0039ofdkdzcxm4ip","_id":"cim3d4n2j003eofdk9h6vl4xk"},{"post_id":"cim3d4n2f0035ofdk17kt6res","tag_id":"cim3d4n2i003aofdk8769jstb","_id":"cim3d4n2j003fofdkzg15aljn"},{"post_id":"cim3d4n2f0035ofdk17kt6res","tag_id":"cim3d4n2i003bofdkm8inufyb","_id":"cim3d4n2j003gofdk2zuukaa3"},{"post_id":"cim3d4n2l003hofdki6w2w8en","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4n2n003lofdknalurynh"},{"post_id":"cim3d4n2l003hofdki6w2w8en","tag_id":"cim3d4n2h0037ofdkguwuehk4","_id":"cim3d4n2o003mofdkoitvxv43"},{"post_id":"cim3d4n2l003hofdki6w2w8en","tag_id":"cim3d4n2m003jofdkw4f4zpm1","_id":"cim3d4n2o003nofdkjbbym08p"},{"post_id":"cim3d4n2l003hofdki6w2w8en","tag_id":"cim3d4n2n003kofdkj8oqrcsv","_id":"cim3d4n2o003oofdkud4wr4hn"},{"post_id":"cim3d4n2l003hofdki6w2w8en","tag_id":"cim3d4n2i003bofdkm8inufyb","_id":"cim3d4n2o003pofdk6ln79xj2"},{"post_id":"cim3d4n2p003qofdkve54eii5","tag_id":"cim3d4n2r003sofdkiiqis9of","_id":"cim3d4n2s003uofdk5n69jlvl"},{"post_id":"cim3d4n2p003qofdkve54eii5","tag_id":"cim3d4n2r003tofdkvu1s0f3p","_id":"cim3d4n2s003vofdk161n1o4m"},{"post_id":"cim3d4n2t003wofdkd0h08gfw","tag_id":"cim3d4n2v003yofdkwvgb6m53","_id":"cim3d4n2v003zofdk747ugb4n"},{"post_id":"cim3d4n2t003wofdkd0h08gfw","tag_id":"cim3d4mxf0006ofdke2hwb42e","_id":"cim3d4n2w0040ofdkz04z2ba0"},{"post_id":"cim3d4n2t003wofdkd0h08gfw","tag_id":"cim3d4n2h0037ofdkguwuehk4","_id":"cim3d4n2w0041ofdks3zfiz21"},{"post_id":"cim3d4n2t003wofdkd0h08gfw","tag_id":"cim3d4mxf0005ofdk046v51ln","_id":"cim3d4n2x0042ofdkpxj79p1j"},{"post_id":"cim3d4n2t003wofdkd0h08gfw","tag_id":"cim3d4n2i003bofdkm8inufyb","_id":"cim3d4n2x0043ofdkztihk6z6"},{"post_id":"cim3d4n2z0044ofdkt82vlk52","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4n330047ofdkojg5jmhi"},{"post_id":"cim3d4n2z0044ofdkt82vlk52","tag_id":"cim3d4n2v003yofdkwvgb6m53","_id":"cim3d4n340048ofdkpe9hb7ih"},{"post_id":"cim3d4n2z0044ofdkt82vlk52","tag_id":"cim3d4n2h0037ofdkguwuehk4","_id":"cim3d4n340049ofdknrpfmmqs"},{"post_id":"cim3d4n2z0044ofdkt82vlk52","tag_id":"cim3d4mxf0005ofdk046v51ln","_id":"cim3d4n34004aofdkomxx4grx"},{"post_id":"cim3d4n2z0044ofdkt82vlk52","tag_id":"cim3d4mxf0006ofdke2hwb42e","_id":"cim3d4n34004bofdkvpwr1zsl"},{"post_id":"cim3d4n39004cofdkwvpswn69","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4n3c004eofdk2tkaxuo7"},{"post_id":"cim3d4n39004cofdkwvpswn69","tag_id":"cim3d4n2v003yofdkwvgb6m53","_id":"cim3d4n3d004fofdk1jqmja0f"},{"post_id":"cim3d4n39004cofdkwvpswn69","tag_id":"cim3d4n2h0037ofdkguwuehk4","_id":"cim3d4n3d004gofdkxjb892us"},{"post_id":"cim3d4n39004cofdkwvpswn69","tag_id":"cim3d4mxf0005ofdk046v51ln","_id":"cim3d4n3d004hofdkdfee05ar"},{"post_id":"cim3d4n39004cofdkwvpswn69","tag_id":"cim3d4mxf0006ofdke2hwb42e","_id":"cim3d4n3d004iofdkk3xb660w"},{"post_id":"cim3d4n3o004jofdkvpb4tc4y","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4n3w004qofdkmlb3yop4"},{"post_id":"cim3d4n3o004jofdkvpb4tc4y","tag_id":"cim3d4n3t004lofdkb0h8w9hm","_id":"cim3d4n3x004rofdk3fgdjeh8"},{"post_id":"cim3d4n3o004jofdkvpb4tc4y","tag_id":"cim3d4n3v004mofdkqtz7u3pc","_id":"cim3d4n3x004sofdk4ebcg994"},{"post_id":"cim3d4n3o004jofdkvpb4tc4y","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4n3x004tofdk39h0b9rq"},{"post_id":"cim3d4n3o004jofdkvpb4tc4y","tag_id":"cim3d4n3v004nofdkk5sqjazy","_id":"cim3d4n3x004uofdkur89tuim"},{"post_id":"cim3d4n3o004jofdkvpb4tc4y","tag_id":"cim3d4n3w004oofdktv6fxe2l","_id":"cim3d4n3x004vofdkxpbmyutx"},{"post_id":"cim3d4n3o004jofdkvpb4tc4y","tag_id":"cim3d4n3w004pofdkfdwcz7ve","_id":"cim3d4n3x004wofdkgs3h8f0q"},{"post_id":"cim3d4n3y004xofdkqackgp34","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4n410051ofdkhlfsh4lb"},{"post_id":"cim3d4n3y004xofdkqackgp34","tag_id":"cim3d4n3t004lofdkb0h8w9hm","_id":"cim3d4n420052ofdkz3ursiuj"},{"post_id":"cim3d4n3y004xofdkqackgp34","tag_id":"cim3d4n40004zofdk3bimk3ge","_id":"cim3d4n420053ofdknxo6kjv3"},{"post_id":"cim3d4n3y004xofdkqackgp34","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4n420054ofdk3h5xd6cp"},{"post_id":"cim3d4n3y004xofdkqackgp34","tag_id":"cim3d4n3v004nofdkk5sqjazy","_id":"cim3d4n420055ofdk8ebcsqtt"},{"post_id":"cim3d4n3y004xofdkqackgp34","tag_id":"cim3d4n410050ofdklc8guwte","_id":"cim3d4n420056ofdklvg628t7"},{"post_id":"cim3d4n430057ofdkah54r4vc","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4n47005bofdkylk2flyr"},{"post_id":"cim3d4n430057ofdkah54r4vc","tag_id":"cim3d4n3t004lofdkb0h8w9hm","_id":"cim3d4n48005cofdk8gco5jmi"},{"post_id":"cim3d4n430057ofdkah54r4vc","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4n48005dofdk32e2qmo3"},{"post_id":"cim3d4n430057ofdkah54r4vc","tag_id":"cim3d4mxf0005ofdk046v51ln","_id":"cim3d4n48005eofdktix6etff"},{"post_id":"cim3d4n430057ofdkah54r4vc","tag_id":"cim3d4mxf0006ofdke2hwb42e","_id":"cim3d4n48005fofdk7c0x6ppv"},{"post_id":"cim3d4n430057ofdkah54r4vc","tag_id":"cim3d4n460059ofdkh0az896i","_id":"cim3d4n48005gofdksqv657vo"},{"post_id":"cim3d4n430057ofdkah54r4vc","tag_id":"cim3d4n47005aofdkapptxanz","_id":"cim3d4n48005hofdktkhy99eb"},{"post_id":"cim3d4n4a005iofdkem946jkh","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4n4f005mofdkt3hzsz55"},{"post_id":"cim3d4n4a005iofdkem946jkh","tag_id":"cim3d4n4c005kofdkmile7kus","_id":"cim3d4n4g005nofdkbbkwd0jd"},{"post_id":"cim3d4n4a005iofdkem946jkh","tag_id":"cim3d4mx70002ofdklekif86g","_id":"cim3d4n4g005oofdk4toa61l2"},{"post_id":"cim3d4n4a005iofdkem946jkh","tag_id":"cim3d4n4e005lofdky3epoi2z","_id":"cim3d4n4h005pofdkv2483pf7"},{"post_id":"cim3d4n4a005iofdkem946jkh","tag_id":"cim3d4n47005aofdkapptxanz","_id":"cim3d4n4h005qofdk63w11jez"},{"post_id":"cim3d4n4a005iofdkem946jkh","tag_id":"cim3d4mxf0005ofdk046v51ln","_id":"cim3d4n4h005rofdkx6feqodu"},{"post_id":"cim3d4n4a005iofdkem946jkh","tag_id":"cim3d4mxf0006ofdke2hwb42e","_id":"cim3d4n4h005sofdkzh0v3bxk"},{"post_id":"cim3d4n4m005tofdkkobiu8x8","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4n4r005wofdk24oiu6l4"},{"post_id":"cim3d4n4m005tofdkkobiu8x8","tag_id":"cim3d4n4c005kofdkmile7kus","_id":"cim3d4n4r005xofdkjdhqkjri"},{"post_id":"cim3d4n4m005tofdkkobiu8x8","tag_id":"cim3d4mx70002ofdklekif86g","_id":"cim3d4n4r005yofdkop8raojl"},{"post_id":"cim3d4n4m005tofdkkobiu8x8","tag_id":"cim3d4n3w004oofdktv6fxe2l","_id":"cim3d4n4r005zofdkth38z8uq"},{"post_id":"cim3d4n4m005tofdkkobiu8x8","tag_id":"cim3d4n4p005vofdkgqcurz6m","_id":"cim3d4n4r0060ofdkhod484yo"},{"post_id":"cim3d4n4m005tofdkkobiu8x8","tag_id":"cim3d4n3v004nofdkk5sqjazy","_id":"cim3d4n4s0061ofdkpb4jha8q"},{"post_id":"cim3d4n4m005tofdkkobiu8x8","tag_id":"cim3d4n3v004mofdkqtz7u3pc","_id":"cim3d4n4s0062ofdkptn123wg"},{"post_id":"cim3d4n4t0063ofdk3bsbe60t","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4n4x0067ofdk2ga16gqw"},{"post_id":"cim3d4n4t0063ofdk3bsbe60t","tag_id":"cim3d4n4c005kofdkmile7kus","_id":"cim3d4n4x0068ofdkuwoxq2sz"},{"post_id":"cim3d4n4t0063ofdk3bsbe60t","tag_id":"cim3d4mx70002ofdklekif86g","_id":"cim3d4n4x0069ofdkte61dnwg"},{"post_id":"cim3d4n4t0063ofdk3bsbe60t","tag_id":"cim3d4n4w0065ofdk1bywdd2t","_id":"cim3d4n4y006aofdkgj4263am"},{"post_id":"cim3d4n4t0063ofdk3bsbe60t","tag_id":"cim3d4n4w0066ofdkr86a83mb","_id":"cim3d4n4y006bofdkvxxmrjaw"},{"post_id":"cim3d4n4z006cofdk99g0xv7w","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4n52006gofdk1kaszm7e"},{"post_id":"cim3d4n4z006cofdk99g0xv7w","tag_id":"cim3d4n4c005kofdkmile7kus","_id":"cim3d4n53006hofdkzbdnh72m"},{"post_id":"cim3d4n4z006cofdk99g0xv7w","tag_id":"cim3d4n2i0039ofdkdzcxm4ip","_id":"cim3d4n53006iofdkrwp2ebyf"},{"post_id":"cim3d4n4z006cofdk99g0xv7w","tag_id":"cim3d4n2i003aofdk8769jstb","_id":"cim3d4n53006jofdkzlk1zzo0"},{"post_id":"cim3d4n4z006cofdk99g0xv7w","tag_id":"cim3d4n50006eofdkac6kuk0b","_id":"cim3d4n53006kofdklf788wsj"},{"post_id":"cim3d4n4z006cofdk99g0xv7w","tag_id":"cim3d4n51006fofdkekfi17ul","_id":"cim3d4n53006lofdktihh81ua"},{"post_id":"cim3d4n4z006cofdk99g0xv7w","tag_id":"cim3d4n2m003jofdkw4f4zpm1","_id":"cim3d4n53006mofdkbpepi9xf"},{"post_id":"cim3d4n54006nofdk746fzpi0","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4n59006rofdkptv2hyu7"},{"post_id":"cim3d4n54006nofdk746fzpi0","tag_id":"cim3d4n4c005kofdkmile7kus","_id":"cim3d4n5a006sofdkyrcoxbe9"},{"post_id":"cim3d4n54006nofdk746fzpi0","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4n5a006tofdk1rj5xdik"},{"post_id":"cim3d4n54006nofdk746fzpi0","tag_id":"cim3d4n4p005vofdkgqcurz6m","_id":"cim3d4n5a006uofdkic68g8zg"},{"post_id":"cim3d4n54006nofdk746fzpi0","tag_id":"cim3d4n56006pofdkkboq5jo1","_id":"cim3d4n5a006vofdkcfu2eevc"},{"post_id":"cim3d4n54006nofdk746fzpi0","tag_id":"cim3d4n58006qofdkq522zhq5","_id":"cim3d4n5b006wofdkl5sn4l56"},{"post_id":"cim3d4n5d006xofdkdoje2n0r","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4n5j006zofdk8js7n5wz"},{"post_id":"cim3d4n5d006xofdkdoje2n0r","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4n5k0070ofdkfhz2kny3"},{"post_id":"cim3d4n5d006xofdkdoje2n0r","tag_id":"cim3d4n4c005kofdkmile7kus","_id":"cim3d4n5k0071ofdkpezf81m7"},{"post_id":"cim3d4n5d006xofdkdoje2n0r","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4n5k0072ofdk9mry7x2w"},{"post_id":"cim3d4n5d006xofdkdoje2n0r","tag_id":"cim3d4n3v004nofdkk5sqjazy","_id":"cim3d4n5k0073ofdkvbvs0vts"},{"post_id":"cim3d4n5d006xofdkdoje2n0r","tag_id":"cim3d4n410050ofdklc8guwte","_id":"cim3d4n5k0074ofdkwfpybuzr"},{"post_id":"cim3d4n5d006xofdkdoje2n0r","tag_id":"cim3d4n40004zofdk3bimk3ge","_id":"cim3d4n5k0075ofdkjv6gnqtb"},{"post_id":"cim3d4n5m0076ofdkbbpr8wkg","tag_id":"cim3d4n5n0078ofdkmx5mjp9x","_id":"cim3d4n5p007cofdkrs4crqf1"},{"post_id":"cim3d4n5m0076ofdkbbpr8wkg","tag_id":"cim3d4n5o0079ofdkhftl99ab","_id":"cim3d4n5p007dofdkzps5z661"},{"post_id":"cim3d4n5m0076ofdkbbpr8wkg","tag_id":"cim3d4n5o007aofdknut6t1tc","_id":"cim3d4n5p007eofdk4fc6vm1z"},{"post_id":"cim3d4n5m0076ofdkbbpr8wkg","tag_id":"cim3d4n3w004oofdktv6fxe2l","_id":"cim3d4n5q007fofdkokn2a1wn"},{"post_id":"cim3d4n5m0076ofdkbbpr8wkg","tag_id":"cim3d4n3w004pofdkfdwcz7ve","_id":"cim3d4n5q007gofdkt5qk22ro"},{"post_id":"cim3d4n5m0076ofdkbbpr8wkg","tag_id":"cim3d4n5p007bofdkexys79c2","_id":"cim3d4n5q007hofdk5sx7c9va"},{"post_id":"cim3d4n5s007iofdk8h8d8esq","tag_id":"cim3d4n5n0078ofdkmx5mjp9x","_id":"cim3d4n5t007kofdky9qds4cl"},{"post_id":"cim3d4n5s007iofdk8h8d8esq","tag_id":"cim3d4n0s001mofdknpymi3n4","_id":"cim3d4n5u007lofdkzy08fexo"},{"post_id":"cim3d4n5s007iofdk8h8d8esq","tag_id":"cim3d4n0t001nofdksw6s8kom","_id":"cim3d4n5u007mofdkaxs78646"},{"post_id":"cim3d4n5s007iofdk8h8d8esq","tag_id":"cim3d4n1j002mofdku7x312a3","_id":"cim3d4n5u007nofdklwayqgov"},{"post_id":"cim3d4n5s007iofdk8h8d8esq","tag_id":"cim3d4n000010ofdk25vmk2od","_id":"cim3d4n5u007oofdkvn8m2zd3"},{"post_id":"cim3d4n5s007iofdk8h8d8esq","tag_id":"cim3d4mzz000xofdk9gb5glv9","_id":"cim3d4n5u007pofdkugz5zau4"},{"post_id":"cim3d4n5v007qofdk0d96lic9","tag_id":"cim3d4myh000hofdkx1w4qomx","_id":"cim3d4n5w007tofdkkzj7v7gw"},{"post_id":"cim3d4n5v007qofdk0d96lic9","tag_id":"cim3d4n5w007sofdkrutm812f","_id":"cim3d4n5x007uofdkrujeimqf"},{"post_id":"cim3d4n7e007vofdkbk3nuv9a","tag_id":"cim3d4myh000hofdkx1w4qomx","_id":"cim3d4n7h007yofdklvcpqau3"},{"post_id":"cim3d4n7e007vofdkbk3nuv9a","tag_id":"cim3d4n7g007xofdktyp8yh6v","_id":"cim3d4n7h007zofdkg030lr2p"},{"post_id":"cim3d4n7k0080ofdk5wzt5y3g","tag_id":"cim3d4mzz000xofdk9gb5glv9","_id":"cim3d4n7l0082ofdkclidec7e"},{"post_id":"cim3d4n7k0080ofdk5wzt5y3g","tag_id":"cim3d4n180022ofdkqgbkozko","_id":"cim3d4n7m0083ofdkg528uba4"},{"post_id":"cim3d4n7k0080ofdk5wzt5y3g","tag_id":"cim3d4n2h0037ofdkguwuehk4","_id":"cim3d4n7m0084ofdkuio2ukud"},{"post_id":"cim3d4n7k0080ofdk5wzt5y3g","tag_id":"cim3d4n2i003bofdkm8inufyb","_id":"cim3d4n7m0085ofdk43exy4rd"},{"post_id":"cim3d4n7n0086ofdkd0zwwssk","tag_id":"cim3d4n7p0088ofdkwnv6pg7h","_id":"cim3d4n7q008aofdkx0om3qbi"},{"post_id":"cim3d4n7n0086ofdkd0zwwssk","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4n7q008bofdku8mgvy1c"},{"post_id":"cim3d4n7n0086ofdkd0zwwssk","tag_id":"cim3d4n2c002zofdks2jqydqn","_id":"cim3d4n7q008cofdkbp8d7pn4"},{"post_id":"cim3d4n7n0086ofdkd0zwwssk","tag_id":"cim3d4n180022ofdkqgbkozko","_id":"cim3d4n7q008dofdkfxgrvdrv"},{"post_id":"cim3d4n7n0086ofdkd0zwwssk","tag_id":"cim3d4n7p0089ofdkdekjkob1","_id":"cim3d4n7q008eofdkhw02e33m"},{"post_id":"cim3d4n7n0086ofdkd0zwwssk","tag_id":"cim3d4n180023ofdkya9sa1gz","_id":"cim3d4n7r008fofdkxoc53b7y"},{"post_id":"cim3d4n7r008gofdknmpeypaw","tag_id":"cim3d4n7p0088ofdkwnv6pg7h","_id":"cim3d4n7w008lofdkwv7vv2wi"},{"post_id":"cim3d4n7r008gofdknmpeypaw","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4n7x008mofdkb93fpo1i"},{"post_id":"cim3d4n7r008gofdknmpeypaw","tag_id":"cim3d4n7u008iofdkdh0zpyx7","_id":"cim3d4n7x008nofdk5kfwhvfs"},{"post_id":"cim3d4n7r008gofdknmpeypaw","tag_id":"cim3d4n7v008jofdkrdmx94cp","_id":"cim3d4n7x008oofdkho0rezju"},{"post_id":"cim3d4n7r008gofdknmpeypaw","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4n7x008pofdk4gmultxf"},{"post_id":"cim3d4n7r008gofdknmpeypaw","tag_id":"cim3d4n3w004oofdktv6fxe2l","_id":"cim3d4n7x008qofdkoxxk2ytk"},{"post_id":"cim3d4n7r008gofdknmpeypaw","tag_id":"cim3d4n7v008kofdk8g8mgc24","_id":"cim3d4n7x008rofdk3b67vdgx"},{"post_id":"cim3d4n7z008sofdkzy7a7cn0","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4n80008uofdk8hblkgww"},{"post_id":"cim3d4n7z008sofdkzy7a7cn0","tag_id":"cim3d4n00000yofdkdm341tud","_id":"cim3d4n81008vofdkzi4b6cpz"},{"post_id":"cim3d4n7z008sofdkzy7a7cn0","tag_id":"cim3d4n7p0088ofdkwnv6pg7h","_id":"cim3d4n81008wofdkzjru6f4l"},{"post_id":"cim3d4n7z008sofdkzy7a7cn0","tag_id":"cim3d4n2c002zofdks2jqydqn","_id":"cim3d4n81008xofdkjvd73dvl"},{"post_id":"cim3d4n7z008sofdkzy7a7cn0","tag_id":"cim3d4n00000zofdkyqrajr19","_id":"cim3d4n81008yofdkowa2txwz"},{"post_id":"cim3d4n82008zofdkxpdyslf1","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4n840092ofdkr1g2mduj"},{"post_id":"cim3d4n82008zofdkxpdyslf1","tag_id":"cim3d4n00000yofdkdm341tud","_id":"cim3d4n850093ofdk6k8mpfij"},{"post_id":"cim3d4n82008zofdkxpdyslf1","tag_id":"cim3d4n2c002zofdks2jqydqn","_id":"cim3d4n850094ofdkjkswbsbf"},{"post_id":"cim3d4n82008zofdkxpdyslf1","tag_id":"cim3d4n7u008iofdkdh0zpyx7","_id":"cim3d4n850095ofdk1d00jvtm"},{"post_id":"cim3d4n82008zofdkxpdyslf1","tag_id":"cim3d4n830091ofdkfb4750m7","_id":"cim3d4n850096ofdkdsfbdyy0"},{"post_id":"cim3d4n82008zofdkxpdyslf1","tag_id":"cim3d4n7v008jofdkrdmx94cp","_id":"cim3d4n850097ofdkurmpco9b"},{"post_id":"cim3d4n82008zofdkxpdyslf1","tag_id":"cim3d4n1e002eofdki0g553ji","_id":"cim3d4n850098ofdkpl2x68is"},{"post_id":"cim3d4n860099ofdkl4vtequb","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4n87009bofdklmkgg8w0"},{"post_id":"cim3d4n860099ofdkl4vtequb","tag_id":"cim3d4n00000yofdkdm341tud","_id":"cim3d4n88009cofdkztnut89h"},{"post_id":"cim3d4n860099ofdkl4vtequb","tag_id":"cim3d4n7p0088ofdkwnv6pg7h","_id":"cim3d4n88009dofdk6zvydil0"},{"post_id":"cim3d4n860099ofdkl4vtequb","tag_id":"cim3d4n2c0030ofdkg4al9kb9","_id":"cim3d4n88009eofdka59mhtsc"},{"post_id":"cim3d4n860099ofdkl4vtequb","tag_id":"cim3d4n7v008jofdkrdmx94cp","_id":"cim3d4n88009fofdkez55mf6y"},{"post_id":"cim3d4n860099ofdkl4vtequb","tag_id":"cim3d4n2c002zofdks2jqydqn","_id":"cim3d4n88009gofdksq6mmw6p"},{"post_id":"cim3d4n89009hofdk872x6hof","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4n8b009jofdkd49p44cr"},{"post_id":"cim3d4n89009hofdk872x6hof","tag_id":"cim3d4n00000yofdkdm341tud","_id":"cim3d4n8c009kofdkqtoohspf"},{"post_id":"cim3d4n89009hofdk872x6hof","tag_id":"cim3d4n7p0088ofdkwnv6pg7h","_id":"cim3d4n8c009lofdkoqlu9b98"},{"post_id":"cim3d4n89009hofdk872x6hof","tag_id":"cim3d4n2c0030ofdkg4al9kb9","_id":"cim3d4n8c009mofdk8a5cpwgq"},{"post_id":"cim3d4n8d009nofdkbxfcca59","tag_id":"cim3d4n8f009pofdkj508byss","_id":"cim3d4n8h009uofdkoxyj77et"},{"post_id":"cim3d4n8d009nofdkbxfcca59","tag_id":"cim3d4n8g009qofdk9t4zu53l","_id":"cim3d4n8h009vofdkvx8f572x"},{"post_id":"cim3d4n8d009nofdkbxfcca59","tag_id":"cim3d4n8g009rofdkyoa03m3p","_id":"cim3d4n8h009wofdku9xxbxf1"},{"post_id":"cim3d4n8d009nofdkbxfcca59","tag_id":"cim3d4n8g009sofdk93spclg9","_id":"cim3d4n8i009xofdk3kxeklid"},{"post_id":"cim3d4n8d009nofdkbxfcca59","tag_id":"cim3d4n8h009tofdkh8eh18jn","_id":"cim3d4n8i009yofdkrx9c4l1k"},{"post_id":"cim3d4n8j009zofdk20ri6pxq","tag_id":"cim3d4n8f009pofdkj508byss","_id":"cim3d4n8l00a1ofdkjzic1j2l"},{"post_id":"cim3d4n8j009zofdk20ri6pxq","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4n8m00a2ofdk2pzgxpb4"},{"post_id":"cim3d4n8j009zofdk20ri6pxq","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4n8n00a3ofdkhhmbee0z"},{"post_id":"cim3d4n8j009zofdk20ri6pxq","tag_id":"cim3d4mxe0003ofdkdm4dl99o","_id":"cim3d4n8n00a4ofdkso5a8jy4"},{"post_id":"cim3d4n8j009zofdk20ri6pxq","tag_id":"cim3d4mxf0005ofdk046v51ln","_id":"cim3d4n8n00a5ofdkbp4pnr7q"},{"post_id":"cim3d4n8j009zofdk20ri6pxq","tag_id":"cim3d4mxf0006ofdke2hwb42e","_id":"cim3d4n8n00a6ofdkr5tfkd27"},{"post_id":"cim3d4n8o00a7ofdkhbtjoso3","tag_id":"cim3d4n8f009pofdkj508byss","_id":"cim3d4n8r00abofdkboxf24b2"},{"post_id":"cim3d4n8o00a7ofdkhbtjoso3","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4n8s00acofdkhiug7rbv"},{"post_id":"cim3d4n8o00a7ofdkhbtjoso3","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4n8s00adofdk5afxfc6k"},{"post_id":"cim3d4n8o00a7ofdkhbtjoso3","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4n8s00aeofdkttokzkyg"},{"post_id":"cim3d4n8o00a7ofdkhbtjoso3","tag_id":"cim3d4n3v004nofdkk5sqjazy","_id":"cim3d4n8s00afofdkv4lxzrb0"},{"post_id":"cim3d4n8o00a7ofdkhbtjoso3","tag_id":"cim3d4n8q00a9ofdkwyo9w42z","_id":"cim3d4n8s00agofdk6q5v2ghy"},{"post_id":"cim3d4n8o00a7ofdkhbtjoso3","tag_id":"cim3d4n8r00aaofdkj4lbs792","_id":"cim3d4n8s00ahofdk7175btrc"},{"post_id":"cim3d4n8o00a7ofdkhbtjoso3","tag_id":"cim3d4n3v004mofdkqtz7u3pc","_id":"cim3d4n8s00aiofdk0wwqvstw"},{"post_id":"cim3d4n8t00ajofdkqu23xlbn","tag_id":"cim3d4n8f009pofdkj508byss","_id":"cim3d4n8v00alofdk270r4bwy"},{"post_id":"cim3d4n8t00ajofdkqu23xlbn","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4n8w00amofdk1496w6r2"},{"post_id":"cim3d4n8t00ajofdkqu23xlbn","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4n8w00anofdkffh7z7yq"},{"post_id":"cim3d4n8t00ajofdkqu23xlbn","tag_id":"cim3d4n2v003yofdkwvgb6m53","_id":"cim3d4n8w00aoofdk04i1pxrr"},{"post_id":"cim3d4n8t00ajofdkqu23xlbn","tag_id":"cim3d4mxf0006ofdke2hwb42e","_id":"cim3d4n8w00apofdkfcyszo6h"},{"post_id":"cim3d4n8t00ajofdkqu23xlbn","tag_id":"cim3d4mxf0005ofdk046v51ln","_id":"cim3d4n8w00aqofdklj1zm8dp"},{"post_id":"cim3d4n8z00arofdkxl8fylib","tag_id":"cim3d4n8f009pofdkj508byss","_id":"cim3d4n9100atofdkrjhio3b1"},{"post_id":"cim3d4n8z00arofdkxl8fylib","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4n9100auofdkyyynw3w3"},{"post_id":"cim3d4n8z00arofdkxl8fylib","tag_id":"cim3d4n2v003yofdkwvgb6m53","_id":"cim3d4n9100avofdk2jj9hcs6"},{"post_id":"cim3d4n8z00arofdkxl8fylib","tag_id":"cim3d4mxf0006ofdke2hwb42e","_id":"cim3d4n9200awofdkraletia2"},{"post_id":"cim3d4n8z00arofdkxl8fylib","tag_id":"cim3d4mxf0005ofdk046v51ln","_id":"cim3d4n9200axofdkm2ehwq2j"},{"post_id":"cim3d4n9300ayofdkdklijg72","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4n9400b0ofdk9ja9xhb8"},{"post_id":"cim3d4n9300ayofdkdklijg72","tag_id":"cim3d4n8f009pofdkj508byss","_id":"cim3d4n9400b1ofdke2senhyt"},{"post_id":"cim3d4n9300ayofdkdklijg72","tag_id":"cim3d4n8g009rofdkyoa03m3p","_id":"cim3d4n9400b2ofdk0nv5yweh"},{"post_id":"cim3d4n9500b3ofdky4bojlzy","tag_id":"cim3d4n9700b5ofdk2hz8zvj1","_id":"cim3d4n9800b6ofdkkfu12b5v"},{"post_id":"cim3d4n9500b3ofdky4bojlzy","tag_id":"cim3d4n2h0037ofdkguwuehk4","_id":"cim3d4n9800b7ofdk0ofqsai2"},{"post_id":"cim3d4n9500b3ofdky4bojlzy","tag_id":"cim3d4mxf0005ofdk046v51ln","_id":"cim3d4n9800b8ofdkawgjw4rl"},{"post_id":"cim3d4n9500b3ofdky4bojlzy","tag_id":"cim3d4mxf0006ofdke2hwb42e","_id":"cim3d4n9800b9ofdkzpciyhmp"},{"post_id":"cim3d4n9500b3ofdky4bojlzy","tag_id":"cim3d4n2i003bofdkm8inufyb","_id":"cim3d4n9800baofdkpcbf6s9f"},{"post_id":"cim3d4n9900bbofdk5fo61rso","tag_id":"cim3d4n9b00bdofdknkx4bzib","_id":"cim3d4n9c00bfofdkf8srt5jb"},{"post_id":"cim3d4n9900bbofdk5fo61rso","tag_id":"cim3d4n5n0078ofdkmx5mjp9x","_id":"cim3d4n9d00bgofdk2k45po0n"},{"post_id":"cim3d4n9900bbofdk5fo61rso","tag_id":"cim3d4n5o0079ofdkhftl99ab","_id":"cim3d4n9d00bhofdkt9s6ato1"},{"post_id":"cim3d4n9900bbofdk5fo61rso","tag_id":"cim3d4n4w0066ofdkr86a83mb","_id":"cim3d4n9d00biofdk3wvt0bho"},{"post_id":"cim3d4n9900bbofdk5fo61rso","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4n9d00bjofdkvehxa57g"},{"post_id":"cim3d4n9900bbofdk5fo61rso","tag_id":"cim3d4n2h0037ofdkguwuehk4","_id":"cim3d4n9d00bkofdkt1a5vrb9"},{"post_id":"cim3d4n9900bbofdk5fo61rso","tag_id":"cim3d4n8g009rofdkyoa03m3p","_id":"cim3d4n9d00blofdkry7af203"},{"post_id":"cim3d4n9900bbofdk5fo61rso","tag_id":"cim3d4n9c00beofdk7ky68put","_id":"cim3d4n9d00bmofdkbepjq1lt"},{"post_id":"cim3d4n9900bbofdk5fo61rso","tag_id":"cim3d4n2i003bofdkm8inufyb","_id":"cim3d4n9d00bnofdkvvh4swol"},{"post_id":"cim3d4n9e00boofdk7yuks0bd","tag_id":"cim3d4n9f00bqofdkvirmx4r6","_id":"cim3d4n9h00btofdkmv9m87er"},{"post_id":"cim3d4n9e00boofdk7yuks0bd","tag_id":"cim3d4n9g00brofdkuz3nhq20","_id":"cim3d4n9h00buofdkuus21uo6"},{"post_id":"cim3d4n9e00boofdk7yuks0bd","tag_id":"cim3d4n9g00bsofdkupzvjnrn","_id":"cim3d4n9h00bvofdkngmuhpwm"},{"post_id":"cim3d4n9i00bwofdklf65k2pt","tag_id":"cim3d4n47005aofdkapptxanz","_id":"cim3d4n9k00byofdkstuahfdv"},{"post_id":"cim3d4n9i00bwofdklf65k2pt","tag_id":"cim3d4n460059ofdkh0az896i","_id":"cim3d4n9l00bzofdk9vkxpuvf"},{"post_id":"cim3d4n9i00bwofdklf65k2pt","tag_id":"cim3d4n2v003yofdkwvgb6m53","_id":"cim3d4n9l00c0ofdkc17qvytg"},{"post_id":"cim3d4n9i00bwofdklf65k2pt","tag_id":"cim3d4mxf0005ofdk046v51ln","_id":"cim3d4n9l00c1ofdk6ux9cbkp"},{"post_id":"cim3d4n9i00bwofdklf65k2pt","tag_id":"cim3d4mxf0006ofdke2hwb42e","_id":"cim3d4n9l00c2ofdkwj0933mb"},{"post_id":"cim3d4n9i00bwofdklf65k2pt","tag_id":"cim3d4n2i003bofdkm8inufyb","_id":"cim3d4n9l00c3ofdk040mvefb"},{"post_id":"cim3d4n9m00c4ofdkgdhx66oa","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4n9o00c8ofdkov69w3u2"},{"post_id":"cim3d4n9m00c4ofdkgdhx66oa","tag_id":"cim3d4n9n00c6ofdk4c12tusd","_id":"cim3d4n9p00c9ofdk61sm3idd"},{"post_id":"cim3d4n9m00c4ofdkgdhx66oa","tag_id":"cim3d4n9o00c7ofdkb6sasg28","_id":"cim3d4n9p00caofdk1cb3uyl1"},{"post_id":"cim3d4n9m00c4ofdkgdhx66oa","tag_id":"cim3d4n2h0037ofdkguwuehk4","_id":"cim3d4n9p00cbofdk3gw5ldr5"},{"post_id":"cim3d4n9m00c4ofdkgdhx66oa","tag_id":"cim3d4n2i003bofdkm8inufyb","_id":"cim3d4n9p00ccofdkn1ymi70o"},{"post_id":"cim3d4n9q00cdofdkkf4zassw","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4n9s00cgofdk2cmtd5de"},{"post_id":"cim3d4n9q00cdofdkkf4zassw","tag_id":"cim3d4n9r00cfofdkelp5iuhq","_id":"cim3d4n9t00chofdkgvnbl72q"},{"post_id":"cim3d4n9q00cdofdkkf4zassw","tag_id":"cim3d4n2v003yofdkwvgb6m53","_id":"cim3d4n9t00ciofdk11bob0c7"},{"post_id":"cim3d4n9q00cdofdkkf4zassw","tag_id":"cim3d4mxf0005ofdk046v51ln","_id":"cim3d4n9t00cjofdkvr8qta0d"},{"post_id":"cim3d4n9q00cdofdkkf4zassw","tag_id":"cim3d4mxf0006ofdke2hwb42e","_id":"cim3d4n9t00ckofdknckvawq8"},{"post_id":"cim3d4n9t00clofdkpfj3uoeo","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4n9w00cpofdk221p2yq4"},{"post_id":"cim3d4n9t00clofdkpfj3uoeo","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4n9x00cqofdkjhr0sd20"},{"post_id":"cim3d4n9t00clofdkpfj3uoeo","tag_id":"cim3d4n9v00cnofdkqgt9g4wu","_id":"cim3d4n9x00crofdkxpsha8s7"},{"post_id":"cim3d4n9t00clofdkpfj3uoeo","tag_id":"cim3d4n9v00coofdkqezo6auj","_id":"cim3d4n9x00csofdkmbshfwo3"},{"post_id":"cim3d4n9t00clofdkpfj3uoeo","tag_id":"cim3d4n2r003tofdkvu1s0f3p","_id":"cim3d4n9x00ctofdkz8iipkn0"},{"post_id":"cim3d4n9y00cuofdk0nbpk236","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4na000cxofdk5orkr1ef"},{"post_id":"cim3d4n9y00cuofdk0nbpk236","tag_id":"cim3d4n9z00cwofdkwik8q7sd","_id":"cim3d4na100cyofdksuufljsd"},{"post_id":"cim3d4n9y00cuofdk0nbpk236","tag_id":"cim3d4n2i0039ofdkdzcxm4ip","_id":"cim3d4na100czofdkqt8ukp8c"},{"post_id":"cim3d4n9y00cuofdk0nbpk236","tag_id":"cim3d4n2i003aofdk8769jstb","_id":"cim3d4na100d0ofdkoasp6rrs"},{"post_id":"cim3d4n9y00cuofdk0nbpk236","tag_id":"cim3d4n50006eofdkac6kuk0b","_id":"cim3d4na100d1ofdkjg4r99my"},{"post_id":"cim3d4na200d2ofdkmomcpjl5","tag_id":"cim3d4na400d4ofdkmfy6d8wg","_id":"cim3d4na600d6ofdkz6428ech"},{"post_id":"cim3d4na200d2ofdkmomcpjl5","tag_id":"cim3d4na500d5ofdklcljravy","_id":"cim3d4na600d7ofdkilrbowi3"},{"post_id":"cim3d4na200d2ofdkmomcpjl5","tag_id":"cim3d4n2r003sofdkiiqis9of","_id":"cim3d4na600d8ofdk8z8byl6e"},{"post_id":"cim3d4na700d9ofdk0qnx4cda","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4naa00dbofdk39q8w0d2"},{"post_id":"cim3d4na700d9ofdk0qnx4cda","tag_id":"cim3d4n3v004nofdkk5sqjazy","_id":"cim3d4nab00dcofdkkz20g3rg"},{"post_id":"cim3d4na700d9ofdk0qnx4cda","tag_id":"cim3d4n410050ofdklc8guwte","_id":"cim3d4nac00ddofdkqgo2k5bd"},{"post_id":"cim3d4na700d9ofdk0qnx4cda","tag_id":"cim3d4n40004zofdk3bimk3ge","_id":"cim3d4nac00deofdkmp6orrav"},{"post_id":"cim3d4na700d9ofdk0qnx4cda","tag_id":"cim3d4n2h0037ofdkguwuehk4","_id":"cim3d4nac00dfofdkc07y5a4s"},{"post_id":"cim3d4na700d9ofdk0qnx4cda","tag_id":"cim3d4n2i003bofdkm8inufyb","_id":"cim3d4nac00dgofdk21fkjnjm"},{"post_id":"cim3d4nad00dhofdke14lfqsb","tag_id":"cim3d4n2h0037ofdkguwuehk4","_id":"cim3d4naf00djofdk7z7llwg1"},{"post_id":"cim3d4nad00dhofdke14lfqsb","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4naf00dkofdkxn6u70p3"},{"post_id":"cim3d4nad00dhofdke14lfqsb","tag_id":"cim3d4n3v004nofdkk5sqjazy","_id":"cim3d4naf00dlofdkosuxjf8z"},{"post_id":"cim3d4nad00dhofdke14lfqsb","tag_id":"cim3d4n3v004mofdkqtz7u3pc","_id":"cim3d4naf00dmofdk0jg3l5bw"},{"post_id":"cim3d4nad00dhofdke14lfqsb","tag_id":"cim3d4n2i003bofdkm8inufyb","_id":"cim3d4naf00dnofdkf2jboy70"},{"post_id":"cim3d4nag00doofdklv03zb47","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4nai00dqofdkvhflagx3"},{"post_id":"cim3d4nag00doofdklv03zb47","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4naj00drofdky8f1b1y2"},{"post_id":"cim3d4nag00doofdklv03zb47","tag_id":"cim3d4mxf0005ofdk046v51ln","_id":"cim3d4naj00dsofdkf4lwi40g"},{"post_id":"cim3d4nag00doofdklv03zb47","tag_id":"cim3d4mxe0003ofdkdm4dl99o","_id":"cim3d4naj00dtofdkoszc9wej"},{"post_id":"cim3d4nag00doofdklv03zb47","tag_id":"cim3d4mxf0006ofdke2hwb42e","_id":"cim3d4naj00duofdkbv277dmw"},{"post_id":"cim3d4nag00doofdklv03zb47","tag_id":"cim3d4n2i003bofdkm8inufyb","_id":"cim3d4naj00dvofdkg51e8l8g"},{"post_id":"cim3d4nao00dwofdk40s26tsb","tag_id":"cim3d4nap00dyofdkegglo3sg","_id":"cim3d4nas00e1ofdk31lxpz56"},{"post_id":"cim3d4nao00dwofdk40s26tsb","tag_id":"cim3d4naq00dzofdkqz52kuiv","_id":"cim3d4nat00e2ofdkpgek2lum"},{"post_id":"cim3d4nao00dwofdk40s26tsb","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4nat00e3ofdkmb9wye5v"},{"post_id":"cim3d4nao00dwofdk40s26tsb","tag_id":"cim3d4n3v004nofdkk5sqjazy","_id":"cim3d4nat00e4ofdkgfdabwlw"},{"post_id":"cim3d4nao00dwofdk40s26tsb","tag_id":"cim3d4n3v004mofdkqtz7u3pc","_id":"cim3d4nat00e5ofdkpp72e3dc"},{"post_id":"cim3d4nao00dwofdk40s26tsb","tag_id":"cim3d4nar00e0ofdkenw03s0f","_id":"cim3d4nat00e6ofdkkkugrz7a"},{"post_id":"cim3d4nao00dwofdk40s26tsb","tag_id":"cim3d4n58006qofdkq522zhq5","_id":"cim3d4nat00e7ofdkd3cbbss4"},{"post_id":"cim3d4nav00e8ofdkl9yw5ncv","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4naw00eaofdkfmth2ca6"},{"post_id":"cim3d4nav00e8ofdkl9yw5ncv","tag_id":"cim3d4naq00dzofdkqz52kuiv","_id":"cim3d4nax00ebofdkdznko61l"},{"post_id":"cim3d4nav00e8ofdkl9yw5ncv","tag_id":"cim3d4n00000yofdkdm341tud","_id":"cim3d4nax00ecofdk3x8x29k8"},{"post_id":"cim3d4nav00e8ofdkl9yw5ncv","tag_id":"cim3d4n830091ofdkfb4750m7","_id":"cim3d4nax00edofdklw9qexny"},{"post_id":"cim3d4nay00eeofdk0q8gx1mj","tag_id":"cim3d4mzz000xofdk9gb5glv9","_id":"cim3d4naz00egofdk9e7n5onm"},{"post_id":"cim3d4nay00eeofdk0q8gx1mj","tag_id":"cim3d4n080018ofdk6liznv8i","_id":"cim3d4nb000ehofdk8w1i8tpc"},{"post_id":"cim3d4nay00eeofdk0q8gx1mj","tag_id":"cim3d4n2h0037ofdkguwuehk4","_id":"cim3d4nb000eiofdkt0i554ru"},{"post_id":"cim3d4nay00eeofdk0q8gx1mj","tag_id":"cim3d4n2i003bofdkm8inufyb","_id":"cim3d4nb000ejofdkmorelqh0"},{"post_id":"cim3d4nb100ekofdkymol0ytr","tag_id":"cim3d4nap00dyofdkegglo3sg","_id":"cim3d4nb500enofdkxbibj5q8"},{"post_id":"cim3d4nb100ekofdkymol0ytr","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4nb700eoofdkqz4g9kzk"},{"post_id":"cim3d4nb100ekofdkymol0ytr","tag_id":"cim3d4n3v004nofdkk5sqjazy","_id":"cim3d4nb700epofdklr19kcb8"},{"post_id":"cim3d4nb100ekofdkymol0ytr","tag_id":"cim3d4n3v004mofdkqtz7u3pc","_id":"cim3d4nb700eqofdkzhbb65fm"},{"post_id":"cim3d4nb100ekofdkymol0ytr","tag_id":"cim3d4nar00e0ofdkenw03s0f","_id":"cim3d4nb700erofdkqt1jpf83"},{"post_id":"cim3d4nb100ekofdkymol0ytr","tag_id":"cim3d4nb300emofdkbr3ycu9n","_id":"cim3d4nb700esofdkkl25m4x7"},{"post_id":"cim3d4nb800etofdks3kk6cdm","tag_id":"cim3d4nap00dyofdkegglo3sg","_id":"cim3d4nbd00evofdkpwufu8qd"},{"post_id":"cim3d4nb800etofdks3kk6cdm","tag_id":"cim3d4n40004zofdk3bimk3ge","_id":"cim3d4nbk00ewofdkfkgnajdm"},{"post_id":"cim3d4nb800etofdks3kk6cdm","tag_id":"cim3d4nar00e0ofdkenw03s0f","_id":"cim3d4nbk00exofdkxz0mml87"},{"post_id":"cim3d4nb800etofdks3kk6cdm","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4nbk00eyofdkuq5n24x6"},{"post_id":"cim3d4nb800etofdks3kk6cdm","tag_id":"cim3d4n3v004nofdkk5sqjazy","_id":"cim3d4nbk00ezofdk5sf2gop8"},{"post_id":"cim3d4nb800etofdks3kk6cdm","tag_id":"cim3d4n410050ofdklc8guwte","_id":"cim3d4nbk00f0ofdkyt1jath0"},{"post_id":"cim3d4nbl00f1ofdkee7h7z0x","tag_id":"cim3d4nap00dyofdkegglo3sg","_id":"cim3d4nbn00f3ofdkdvf716hp"},{"post_id":"cim3d4nbl00f1ofdkee7h7z0x","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4nbo00f4ofdk1zfoq7cm"},{"post_id":"cim3d4nbl00f1ofdkee7h7z0x","tag_id":"cim3d4n3v004nofdkk5sqjazy","_id":"cim3d4nbo00f5ofdkve9mgbio"},{"post_id":"cim3d4nbl00f1ofdkee7h7z0x","tag_id":"cim3d4nar00e0ofdkenw03s0f","_id":"cim3d4nbo00f6ofdknrm2ailv"},{"post_id":"cim3d4nbl00f1ofdkee7h7z0x","tag_id":"cim3d4n40004zofdk3bimk3ge","_id":"cim3d4nbo00f7ofdk9yrdyj17"},{"post_id":"cim3d4nbl00f1ofdkee7h7z0x","tag_id":"cim3d4n410050ofdklc8guwte","_id":"cim3d4nbo00f8ofdk1ggevdd7"},{"post_id":"cim3d4nbp00f9ofdklx3z6x1r","tag_id":"cim3d4nap00dyofdkegglo3sg","_id":"cim3d4nbs00fbofdkjxaka2wj"},{"post_id":"cim3d4nbp00f9ofdklx3z6x1r","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4nbu00fcofdkszryz0ui"},{"post_id":"cim3d4nbp00f9ofdklx3z6x1r","tag_id":"cim3d4n3v004nofdkk5sqjazy","_id":"cim3d4nbu00fdofdk2cq7v4c5"},{"post_id":"cim3d4nbp00f9ofdklx3z6x1r","tag_id":"cim3d4nar00e0ofdkenw03s0f","_id":"cim3d4nbu00feofdk5v1v9wy9"},{"post_id":"cim3d4nbp00f9ofdklx3z6x1r","tag_id":"cim3d4n40004zofdk3bimk3ge","_id":"cim3d4nbu00ffofdkvyv5q31f"},{"post_id":"cim3d4nbp00f9ofdklx3z6x1r","tag_id":"cim3d4n410050ofdklc8guwte","_id":"cim3d4nbu00fgofdk4ja4k1ks"},{"post_id":"cim3d4nbp00f9ofdklx3z6x1r","tag_id":"cim3d4n4p005vofdkgqcurz6m","_id":"cim3d4nbu00fhofdkgs090q4a"},{"post_id":"cim3d4nbw00fiofdka4kurnu1","tag_id":"cim3d4nap00dyofdkegglo3sg","_id":"cim3d4nbz00fkofdkdrxd3uj1"},{"post_id":"cim3d4nbw00fiofdka4kurnu1","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4nc000flofdkaj8xxf38"},{"post_id":"cim3d4nbw00fiofdka4kurnu1","tag_id":"cim3d4n3v004nofdkk5sqjazy","_id":"cim3d4nc000fmofdkb6hlov3p"},{"post_id":"cim3d4nbw00fiofdka4kurnu1","tag_id":"cim3d4n410050ofdklc8guwte","_id":"cim3d4nc000fnofdknqmsvk9b"},{"post_id":"cim3d4nbw00fiofdka4kurnu1","tag_id":"cim3d4n40004zofdk3bimk3ge","_id":"cim3d4nc000foofdkslulge7l"},{"post_id":"cim3d4nbw00fiofdka4kurnu1","tag_id":"cim3d4nar00e0ofdkenw03s0f","_id":"cim3d4nc000fpofdk1ytpbcz8"},{"post_id":"cim3d4nc100fqofdkos3jucrs","tag_id":"cim3d4nap00dyofdkegglo3sg","_id":"cim3d4nc400fsofdkrr47qfva"},{"post_id":"cim3d4nc100fqofdkos3jucrs","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4nc500ftofdkn6o60s33"},{"post_id":"cim3d4nc100fqofdkos3jucrs","tag_id":"cim3d4n3v004nofdkk5sqjazy","_id":"cim3d4nc500fuofdkub1tpchg"},{"post_id":"cim3d4nc100fqofdkos3jucrs","tag_id":"cim3d4n410050ofdklc8guwte","_id":"cim3d4nc500fvofdkmrrsumvw"},{"post_id":"cim3d4nc100fqofdkos3jucrs","tag_id":"cim3d4n40004zofdk3bimk3ge","_id":"cim3d4nc500fwofdke3cwlxqh"},{"post_id":"cim3d4nc100fqofdkos3jucrs","tag_id":"cim3d4nar00e0ofdkenw03s0f","_id":"cim3d4nc500fxofdkv3j016ga"},{"post_id":"cim3d4nc600fyofdkmwy5gz51","tag_id":"cim3d4nap00dyofdkegglo3sg","_id":"cim3d4nc900g0ofdk0znoapnu"},{"post_id":"cim3d4nc600fyofdkmwy5gz51","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4ncb00g1ofdkbhmueo1f"},{"post_id":"cim3d4nc600fyofdkmwy5gz51","tag_id":"cim3d4n3v004nofdkk5sqjazy","_id":"cim3d4ncb00g2ofdkyj6a02vr"},{"post_id":"cim3d4nc600fyofdkmwy5gz51","tag_id":"cim3d4n3v004mofdkqtz7u3pc","_id":"cim3d4ncb00g3ofdk5ltek4je"},{"post_id":"cim3d4nc600fyofdkmwy5gz51","tag_id":"cim3d4nar00e0ofdkenw03s0f","_id":"cim3d4ncb00g4ofdkqp5bm57k"},{"post_id":"cim3d4nc600fyofdkmwy5gz51","tag_id":"cim3d4nb300emofdkbr3ycu9n","_id":"cim3d4ncb00g5ofdkyce3p06g"},{"post_id":"cim3d4ncc00g6ofdkjhh63rne","tag_id":"cim3d4nap00dyofdkegglo3sg","_id":"cim3d4nce00g8ofdky84ynbrm"},{"post_id":"cim3d4ncc00g6ofdkjhh63rne","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4ncf00g9ofdk276bgtvj"},{"post_id":"cim3d4ncc00g6ofdkjhh63rne","tag_id":"cim3d4n3v004nofdkk5sqjazy","_id":"cim3d4ncf00gaofdkqt3ym2me"},{"post_id":"cim3d4ncc00g6ofdkjhh63rne","tag_id":"cim3d4n3v004mofdkqtz7u3pc","_id":"cim3d4ncf00gbofdkwxdq649w"},{"post_id":"cim3d4ncc00g6ofdkjhh63rne","tag_id":"cim3d4nar00e0ofdkenw03s0f","_id":"cim3d4ncf00gcofdkhra4pxwu"},{"post_id":"cim3d4nch00gdofdkrg0l9m4g","tag_id":"cim3d4nap00dyofdkegglo3sg","_id":"cim3d4ncj00gfofdkksr7w6pm"},{"post_id":"cim3d4nch00gdofdkrg0l9m4g","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4nck00ggofdk11aq44ne"},{"post_id":"cim3d4nch00gdofdkrg0l9m4g","tag_id":"cim3d4n3v004nofdkk5sqjazy","_id":"cim3d4nck00ghofdks2a5vpp7"},{"post_id":"cim3d4nch00gdofdkrg0l9m4g","tag_id":"cim3d4nar00e0ofdkenw03s0f","_id":"cim3d4nck00giofdkhfzytp77"},{"post_id":"cim3d4nch00gdofdkrg0l9m4g","tag_id":"cim3d4n3v004mofdkqtz7u3pc","_id":"cim3d4nck00gjofdkttgb2l5i"},{"post_id":"cim3d4ncl00gkofdk0v815i0a","tag_id":"cim3d4nap00dyofdkegglo3sg","_id":"cim3d4nco00gmofdkt7ihk7od"},{"post_id":"cim3d4ncl00gkofdk0v815i0a","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4ncp00gnofdknyeuymgy"},{"post_id":"cim3d4ncl00gkofdk0v815i0a","tag_id":"cim3d4n3v004nofdkk5sqjazy","_id":"cim3d4ncp00goofdk0mrwx8bv"},{"post_id":"cim3d4ncl00gkofdk0v815i0a","tag_id":"cim3d4n3v004mofdkqtz7u3pc","_id":"cim3d4ncp00gpofdk588et2tl"},{"post_id":"cim3d4ncl00gkofdk0v815i0a","tag_id":"cim3d4n4p005vofdkgqcurz6m","_id":"cim3d4ncp00gqofdkaxjo12tx"},{"post_id":"cim3d4ncl00gkofdk0v815i0a","tag_id":"cim3d4nar00e0ofdkenw03s0f","_id":"cim3d4ncp00grofdk4wi4f227"},{"post_id":"cim3d4ncq00gsofdkys3g2ywr","tag_id":"cim3d4nap00dyofdkegglo3sg","_id":"cim3d4ncs00gvofdkqnmghr93"},{"post_id":"cim3d4ncq00gsofdkys3g2ywr","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4nct00gwofdkbs8ox8rh"},{"post_id":"cim3d4ncq00gsofdkys3g2ywr","tag_id":"cim3d4n3v004nofdkk5sqjazy","_id":"cim3d4nct00gxofdka6s2tvje"},{"post_id":"cim3d4ncq00gsofdkys3g2ywr","tag_id":"cim3d4n3v004mofdkqtz7u3pc","_id":"cim3d4nct00gyofdkt5omdtfv"},{"post_id":"cim3d4ncq00gsofdkys3g2ywr","tag_id":"cim3d4nar00e0ofdkenw03s0f","_id":"cim3d4nct00gzofdkhmur5iwt"},{"post_id":"cim3d4ncq00gsofdkys3g2ywr","tag_id":"cim3d4ncs00guofdkdg93s8sl","_id":"cim3d4nct00h0ofdk91ieg8jp"},{"post_id":"cim3d4ncv00h1ofdk7znjyldv","tag_id":"cim3d4ncw00h3ofdk9tzio605","_id":"cim3d4ncz00h6ofdk42zlomhg"},{"post_id":"cim3d4ncv00h1ofdk7znjyldv","tag_id":"cim3d4ncx00h4ofdkiyysl89i","_id":"cim3d4nd000h7ofdknkf17ojr"},{"post_id":"cim3d4ncv00h1ofdk7znjyldv","tag_id":"cim3d4ncy00h5ofdkjv252wap","_id":"cim3d4nd000h8ofdkegq24xuo"},{"post_id":"cim3d4ncv00h1ofdk7znjyldv","tag_id":"cim3d4nap00dyofdkegglo3sg","_id":"cim3d4nd000h9ofdk881piutf"},{"post_id":"cim3d4ncv00h1ofdk7znjyldv","tag_id":"cim3d4nar00e0ofdkenw03s0f","_id":"cim3d4nd000haofdkoysw5xk0"},{"post_id":"cim3d4ncv00h1ofdk7znjyldv","tag_id":"cim3d4n8h009tofdkh8eh18jn","_id":"cim3d4nd000hbofdk61wb9tw5"},{"post_id":"cim3d4nd100hcofdk8vfp0u8j","tag_id":"cim3d4nap00dyofdkegglo3sg","_id":"cim3d4nd300heofdkaua5n3qm"},{"post_id":"cim3d4nd100hcofdk8vfp0u8j","tag_id":"cim3d4n4w0065ofdk1bywdd2t","_id":"cim3d4nd400hfofdk6o55wr16"},{"post_id":"cim3d4nd100hcofdk8vfp0u8j","tag_id":"cim3d4nar00e0ofdkenw03s0f","_id":"cim3d4nd400hgofdkqn2stogr"},{"post_id":"cim3d4nd500hhofdkpw6vn5no","tag_id":"cim3d4nap00dyofdkegglo3sg","_id":"cim3d4nd700hjofdktd5l649z"},{"post_id":"cim3d4nd500hhofdkpw6vn5no","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4nd800hkofdkgs0dww79"},{"post_id":"cim3d4nd500hhofdkpw6vn5no","tag_id":"cim3d4n3v004nofdkk5sqjazy","_id":"cim3d4nd800hlofdkmet2fkna"},{"post_id":"cim3d4nd500hhofdkpw6vn5no","tag_id":"cim3d4n3v004mofdkqtz7u3pc","_id":"cim3d4nd800hmofdkpis108uw"},{"post_id":"cim3d4nd500hhofdkpw6vn5no","tag_id":"cim3d4n4p005vofdkgqcurz6m","_id":"cim3d4nd800hnofdk66r1woy6"},{"post_id":"cim3d4nd500hhofdkpw6vn5no","tag_id":"cim3d4nar00e0ofdkenw03s0f","_id":"cim3d4nd800hoofdkknyg41tf"},{"post_id":"cim3d4nd900hpofdkl5ztsrzz","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4ndc00hrofdk2jvyc5n5"},{"post_id":"cim3d4nd900hpofdkl5ztsrzz","tag_id":"cim3d4n00000yofdkdm341tud","_id":"cim3d4ndc00hsofdkc39he8ck"},{"post_id":"cim3d4nd900hpofdkl5ztsrzz","tag_id":"cim3d4n1e002eofdki0g553ji","_id":"cim3d4ndc00htofdksoqchmw7"},{"post_id":"cim3d4ndf00huofdktf9opz43","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4ndg00hwofdk2en5cea4"},{"post_id":"cim3d4ndf00huofdktf9opz43","tag_id":"cim3d4n00000yofdkdm341tud","_id":"cim3d4ndi00hxofdkk6ama1e6"},{"post_id":"cim3d4ndf00huofdktf9opz43","tag_id":"cim3d4n9700b5ofdk2hz8zvj1","_id":"cim3d4ndi00hyofdkmfva43zn"},{"post_id":"cim3d4ndf00huofdktf9opz43","tag_id":"cim3d4n1e002eofdki0g553ji","_id":"cim3d4ndi00hzofdkv43ovhud"},{"post_id":"cim3d4ndk00i0ofdkabqlvccz","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4ndn00i2ofdkfi8f7omx"},{"post_id":"cim3d4ndk00i0ofdkabqlvccz","tag_id":"cim3d4n00000yofdkdm341tud","_id":"cim3d4ndo00i3ofdkfv30uvgo"},{"post_id":"cim3d4ndk00i0ofdkabqlvccz","tag_id":"cim3d4n3w004oofdktv6fxe2l","_id":"cim3d4ndo00i4ofdkqlrynhk8"},{"post_id":"cim3d4ndk00i0ofdkabqlvccz","tag_id":"cim3d4n2c0030ofdkg4al9kb9","_id":"cim3d4ndo00i5ofdkm0wx8960"},{"post_id":"cim3d4ndk00i0ofdkabqlvccz","tag_id":"cim3d4n4w0065ofdk1bywdd2t","_id":"cim3d4ndo00i6ofdkc3eoahk8"},{"post_id":"cim3d4ndp00i7ofdkltzqkb9k","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4nds00i9ofdkwhjtqlnx"},{"post_id":"cim3d4ndp00i7ofdkltzqkb9k","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4ndt00iaofdkaesi78mt"},{"post_id":"cim3d4ndp00i7ofdkltzqkb9k","tag_id":"cim3d4n2i003aofdk8769jstb","_id":"cim3d4ndt00ibofdktzfbzgvq"},{"post_id":"cim3d4ndp00i7ofdkltzqkb9k","tag_id":"cim3d4n2i0039ofdkdzcxm4ip","_id":"cim3d4ndt00icofdk6wtfs334"},{"post_id":"cim3d4ndp00i7ofdkltzqkb9k","tag_id":"cim3d4n50006eofdkac6kuk0b","_id":"cim3d4ndt00idofdk6ju3z0f3"},{"post_id":"cim3d4ndu00ieofdkuach27pc","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4ndx00ihofdkh676mgrz"},{"post_id":"cim3d4ndu00ieofdkuach27pc","tag_id":"cim3d4n00000yofdkdm341tud","_id":"cim3d4ndy00iiofdktnyoj8il"},{"post_id":"cim3d4ndu00ieofdkuach27pc","tag_id":"cim3d4n9o00c7ofdkb6sasg28","_id":"cim3d4ndy00ijofdkigihva0m"},{"post_id":"cim3d4ndu00ieofdkuach27pc","tag_id":"cim3d4ndw00igofdkfknutadc","_id":"cim3d4ndy00ikofdk8shq70ok"},{"post_id":"cim3d4ne900ilofdk8263tvyl","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4neb00inofdkrl8hv7u5"},{"post_id":"cim3d4ne900ilofdk8263tvyl","tag_id":"cim3d4n3v004nofdkk5sqjazy","_id":"cim3d4nec00ioofdk1uedswj4"},{"post_id":"cim3d4ne900ilofdk8263tvyl","tag_id":"cim3d4n3v004mofdkqtz7u3pc","_id":"cim3d4nec00ipofdksh0zb1ln"},{"post_id":"cim3d4ne900ilofdk8263tvyl","tag_id":"cim3d4n2i0038ofdk1ce4bi2o","_id":"cim3d4nec00iqofdkf9nmno8b"},{"post_id":"cim3d4nee00irofdk8m3gzz21","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4neg00itofdklde7snm0"},{"post_id":"cim3d4nee00irofdk8m3gzz21","tag_id":"cim3d4n00000yofdkdm341tud","_id":"cim3d4neg00iuofdkv293797o"},{"post_id":"cim3d4nee00irofdk8m3gzz21","tag_id":"cim3d4ndw00igofdkfknutadc","_id":"cim3d4neg00ivofdk8sgvqi7w"},{"post_id":"cim3d4neh00iwofdkynsogwvx","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4nel00j0ofdky476npv2"},{"post_id":"cim3d4neh00iwofdkynsogwvx","tag_id":"cim3d4nej00iyofdkhltywosl","_id":"cim3d4nem00j1ofdk7ug5dy73"},{"post_id":"cim3d4neh00iwofdkynsogwvx","tag_id":"cim3d4nek00izofdkqh7k44f9","_id":"cim3d4nem00j2ofdkmoehpvwe"},{"post_id":"cim3d4neh00iwofdkynsogwvx","tag_id":"cim3d4mxf0006ofdke2hwb42e","_id":"cim3d4nem00j3ofdkqklndrpd"},{"post_id":"cim3d4neh00iwofdkynsogwvx","tag_id":"cim3d4mxf0005ofdk046v51ln","_id":"cim3d4nem00j4ofdk9cthvoyl"},{"post_id":"cim3d4nep00j5ofdk5ud8nfda","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4ner00j7ofdkc7g9tuqv"},{"post_id":"cim3d4nep00j5ofdk5ud8nfda","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4nes00j8ofdktjo9w29t"},{"post_id":"cim3d4nep00j5ofdk5ud8nfda","tag_id":"cim3d4n00000yofdkdm341tud","_id":"cim3d4nes00j9ofdkgwob1f17"},{"post_id":"cim3d4nep00j5ofdk5ud8nfda","tag_id":"cim3d4n9700b5ofdk2hz8zvj1","_id":"cim3d4nes00jaofdkxf83601s"},{"post_id":"cim3d4nep00j5ofdk5ud8nfda","tag_id":"cim3d4ndw00igofdkfknutadc","_id":"cim3d4nes00jbofdkwaz3c9lt"},{"post_id":"cim3d4net00jcofdkv0jxezl5","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4new00jfofdkzg5bv55o"},{"post_id":"cim3d4net00jcofdkv0jxezl5","tag_id":"cim3d4n2n003kofdkj8oqrcsv","_id":"cim3d4nex00jgofdkp1dzarci"},{"post_id":"cim3d4net00jcofdkv0jxezl5","tag_id":"cim3d4nev00jeofdkufrsao1k","_id":"cim3d4nex00jhofdkvylavnp5"},{"post_id":"cim3d4net00jcofdkv0jxezl5","tag_id":"cim3d4mx70002ofdklekif86g","_id":"cim3d4nex00jiofdkq70yf6tq"},{"post_id":"cim3d4ney00jjofdkfjlp2m34","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4nf000jlofdkap21vut3"},{"post_id":"cim3d4ney00jjofdkfjlp2m34","tag_id":"cim3d4mxf0004ofdkji2tbv1k","_id":"cim3d4nf100jmofdkbxz4tbyz"},{"post_id":"cim3d4ney00jjofdkfjlp2m34","tag_id":"cim3d4mxf0006ofdke2hwb42e","_id":"cim3d4nf100jnofdkqetl2p5k"},{"post_id":"cim3d4ney00jjofdkfjlp2m34","tag_id":"cim3d4mxf0005ofdk046v51ln","_id":"cim3d4nf100joofdkkkmnnwai"},{"post_id":"cim3d4ney00jjofdkfjlp2m34","tag_id":"cim3d4n00000yofdkdm341tud","_id":"cim3d4nf100jpofdkiz522ak7"},{"post_id":"cim3d4nf200jqofdkh8vik3po","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4nf900jsofdkbtpnhe1d"},{"post_id":"cim3d4nf200jqofdkh8vik3po","tag_id":"cim3d4n2c002zofdks2jqydqn","_id":"cim3d4nfa00jtofdkfpqmnf0q"},{"post_id":"cim3d4nf200jqofdkh8vik3po","tag_id":"cim3d4n7p0089ofdkdekjkob1","_id":"cim3d4nfa00juofdk1e34rta9"},{"post_id":"cim3d4nf200jqofdkh8vik3po","tag_id":"cim3d4n180022ofdkqgbkozko","_id":"cim3d4nfb00jvofdkok75745w"},{"post_id":"cim3d4nfb00jwofdkrj7powso","tag_id":"cim3d4n2v003yofdkwvgb6m53","_id":"cim3d4nfd00jyofdkyfp4ksrh"},{"post_id":"cim3d4nfb00jwofdkrj7powso","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4nfe00jzofdkz8sulks7"},{"post_id":"cim3d4nfb00jwofdkrj7powso","tag_id":"cim3d4n2c002yofdkv2qzx8mv","_id":"cim3d4nfe00k0ofdktokd20sb"},{"post_id":"cim3d4nfb00jwofdkrj7powso","tag_id":"cim3d4mxf0006ofdke2hwb42e","_id":"cim3d4nfe00k1ofdknj26bz9k"},{"post_id":"cim3d4nfg00k2ofdkwpu8zy3j","tag_id":"cim3d4n0t001nofdksw6s8kom","_id":"cim3d4nfh00k4ofdklzutgpsl"},{"post_id":"cim3d4nfg00k2ofdkwpu8zy3j","tag_id":"cim3d4n2i003bofdkm8inufyb","_id":"cim3d4nfi00k5ofdk7zti5yjc"},{"post_id":"cim3d4nfj00k6ofdkiorphnzk","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4nfn00kcofdkagzerain"},{"post_id":"cim3d4nfj00k6ofdkiorphnzk","tag_id":"cim3d4nfl00k8ofdkcrzxnu6x","_id":"cim3d4nfp00kdofdknzxdxaea"},{"post_id":"cim3d4nfj00k6ofdkiorphnzk","tag_id":"cim3d4n2i0039ofdkdzcxm4ip","_id":"cim3d4nfp00keofdk7lfj0a2a"},{"post_id":"cim3d4nfj00k6ofdkiorphnzk","tag_id":"cim3d4n2i003aofdk8769jstb","_id":"cim3d4nfp00kfofdktes9plft"},{"post_id":"cim3d4nfj00k6ofdkiorphnzk","tag_id":"cim3d4n50006eofdkac6kuk0b","_id":"cim3d4nfp00kgofdk946oqtm3"},{"post_id":"cim3d4nfj00k6ofdkiorphnzk","tag_id":"cim3d4nfm00k9ofdkazmgvkpl","_id":"cim3d4nfp00khofdkpgje0630"},{"post_id":"cim3d4nfj00k6ofdkiorphnzk","tag_id":"cim3d4nfm00kaofdk0w7zel67","_id":"cim3d4nfp00kiofdknl3ynllv"},{"post_id":"cim3d4nfj00k6ofdkiorphnzk","tag_id":"cim3d4nfn00kbofdkzifut3te","_id":"cim3d4nfp00kjofdkpna2sltf"},{"post_id":"cim3d4nfq00kkofdkuyid7cpu","tag_id":"cim3d4n310046ofdke5791vzg","_id":"cim3d4nft00kpofdkisyazwg4"},{"post_id":"cim3d4nfq00kkofdkuyid7cpu","tag_id":"cim3d4nfs00kmofdkoqp6fmnv","_id":"cim3d4nfv00kqofdkmf6gokvw"},{"post_id":"cim3d4nfq00kkofdkuyid7cpu","tag_id":"cim3d4nfs00knofdksdz2u5e2","_id":"cim3d4nfv00krofdkidh7ji72"},{"post_id":"cim3d4nfq00kkofdkuyid7cpu","tag_id":"cim3d4nft00koofdkyfz7trmk","_id":"cim3d4nfv00ksofdkyhs4s49v"},{"post_id":"cim3d4nfq00kkofdkuyid7cpu","tag_id":"cim3d4n4w0066ofdkr86a83mb","_id":"cim3d4nfv00ktofdkwe11vleg"},{"post_id":"cim3d4nfw00kuofdktffv11r3","tag_id":"cim3d4mx70002ofdklekif86g","_id":"cim3d4nfz00kyofdkuhyvx3zl"},{"post_id":"cim3d4nfw00kuofdktffv11r3","tag_id":"cim3d4nfx00kwofdky0lzqt16","_id":"cim3d4ng000kzofdk4fibc6m1"},{"post_id":"cim3d4nfw00kuofdktffv11r3","tag_id":"cim3d4nfy00kxofdkn6n5qz5v","_id":"cim3d4ng000l0ofdktwu9zdr5"},{"post_id":"cim3d4nfw00kuofdktffv11r3","tag_id":"cim3d4mzz000xofdk9gb5glv9","_id":"cim3d4ng000l1ofdkq1670ktd"},{"post_id":"cim3d4ng100l2ofdkmcr5kncc","tag_id":"cim3d4mx70002ofdklekif86g","_id":"cim3d4ng400l6ofdkk2zf5eln"},{"post_id":"cim3d4ng100l2ofdkmcr5kncc","tag_id":"cim3d4ng200l4ofdkjap8oett","_id":"cim3d4ng500l7ofdkalsofhho"},{"post_id":"cim3d4ng100l2ofdkmcr5kncc","tag_id":"cim3d4ng300l5ofdkau4so9yj","_id":"cim3d4ng500l8ofdkvic41mqc"},{"post_id":"cim3d4ng100l2ofdkmcr5kncc","tag_id":"cim3d4nek00izofdkqh7k44f9","_id":"cim3d4ng500l9ofdk25wjozry"},{"post_id":"cim3d4ng100l2ofdkmcr5kncc","tag_id":"cim3d4n8g009qofdk9t4zu53l","_id":"cim3d4ng500laofdkin7fwh0y"}],"Tag":[{"name":"安师大附中集训","_id":"cim3d4mx70002ofdklekif86g"},{"name":"树链剖分","_id":"cim3d4mxe0003ofdkdm4dl99o"},{"name":"线段树","_id":"cim3d4mxf0004ofdkji2tbv1k"},{"name":"数据结构","_id":"cim3d4mxf0005ofdk046v51ln"},{"name":"高级数据结构","_id":"cim3d4mxf0006ofdke2hwb42e"},{"name":"OS X","_id":"cim3d4myh000hofdkx1w4qomx"},{"name":"Linux","_id":"cim3d4myj000iofdkk6xd6wif"},{"name":"Archlinux","_id":"cim3d4myj000jofdk9ezbtcxt"},{"name":"VirtualBox","_id":"cim3d4myj000kofdk70r7hc2s"},{"name":"虚拟机","_id":"cim3d4myj000lofdk5vokz20z"},{"name":"SSH","_id":"cim3d4myj000mofdke8tekpet"},{"name":"UVa","_id":"cim3d4mzy000wofdk625dyrw1"},{"name":"数学","_id":"cim3d4mzz000xofdk9gb5glv9"},{"name":"DP","_id":"cim3d4n00000yofdkdm341tud"},{"name":"区间DP","_id":"cim3d4n00000zofdkyqrajr19"},{"name":"计数原理","_id":"cim3d4n000010ofdk25vmk2od"},{"name":"组合数学","_id":"cim3d4n080018ofdk6liznv8i"},{"name":"容斥原理","_id":"cim3d4n080019ofdkkb134ai8"},{"name":"递推","_id":"cim3d4n0s001mofdknpymi3n4"},{"name":"高精度","_id":"cim3d4n0t001nofdksw6s8kom"},{"name":"数位DP","_id":"cim3d4n10001uofdkjoh7gytm"},{"name":"数论","_id":"cim3d4n180022ofdkqgbkozko"},{"name":"乘法逆元","_id":"cim3d4n180023ofdkya9sa1gz"},{"name":"全排列","_id":"cim3d4n190024ofdktxtmq020"},{"name":"背包DP","_id":"cim3d4n1e002eofdki0g553ji"},{"name":"组合数","_id":"cim3d4n1j002mofdku7x312a3"},{"name":"整数划分","_id":"cim3d4n1l002nofdkkw4fhrtd"},{"name":"回溯","_id":"cim3d4n1l002oofdk9f3kjrwq"},{"name":"CodeVS","_id":"cim3d4n2c002yofdkv2qzx8mv"},{"name":"Tyvj","_id":"cim3d4n2c002zofdks2jqydqn"},{"name":"划分DP","_id":"cim3d4n2c0030ofdkg4al9kb9"},{"name":"学习笔记","_id":"cim3d4n2h0037ofdkguwuehk4"},{"name":"图论","_id":"cim3d4n2i0038ofdk1ce4bi2o"},{"name":"强联通分量","_id":"cim3d4n2i0039ofdkdzcxm4ip"},{"name":"Tarjan","_id":"cim3d4n2i003aofdk8769jstb"},{"name":"算法模板","_id":"cim3d4n2i003bofdkm8inufyb"},{"name":"差分约束系统","_id":"cim3d4n2m003jofdkw4f4zpm1"},{"name":"最短路","_id":"cim3d4n2n003kofdkj8oqrcsv"},{"name":"C++","_id":"cim3d4n2r003sofdkiiqis9of"},{"name":"STL","_id":"cim3d4n2r003tofdkvu1s0f3p"},{"name":"Splay","_id":"cim3d4n2v003yofdkwvgb6m53"},{"name":"BZOJ","_id":"cim3d4n310046ofdke5791vzg"},{"name":"SDOI","_id":"cim3d4n3t004lofdkb0h8w9hm"},{"name":"Dinic","_id":"cim3d4n3v004mofdkqtz7u3pc"},{"name":"网络流","_id":"cim3d4n3v004nofdkk5sqjazy"},{"name":"二分答案","_id":"cim3d4n3w004oofdktv6fxe2l"},{"name":"实数二分","_id":"cim3d4n3w004pofdkfdwcz7ve"},{"name":"Edmonds-Karp","_id":"cim3d4n40004zofdk3bimk3ge"},{"name":"费用流","_id":"cim3d4n410050ofdklc8guwte"},{"name":"动态树","_id":"cim3d4n460059ofdkh0az896i"},{"name":"Link-Cut Tree","_id":"cim3d4n47005aofdkapptxanz"},{"name":"SCOI","_id":"cim3d4n4c005kofdkmile7kus"},{"name":"离线","_id":"cim3d4n4e005lofdky3epoi2z"},{"name":"二分图匹配","_id":"cim3d4n4p005vofdkgqcurz6m"},{"name":"贪心","_id":"cim3d4n4w0065ofdk1bywdd2t"},{"name":"倍增","_id":"cim3d4n4w0066ofdkr86a83mb"},{"name":"缩点","_id":"cim3d4n50006eofdkac6kuk0b"},{"name":"拓扑排序","_id":"cim3d4n51006fofdkekfi17ul"},{"name":"匈牙利算法","_id":"cim3d4n56006pofdkkboq5jo1"},{"name":"枚举答案","_id":"cim3d4n58006qofdkq522zhq5"},{"name":"POJ","_id":"cim3d4n5n0078ofdkmx5mjp9x"},{"name":"Prim","_id":"cim3d4n5o0079ofdkhftl99ab"},{"name":"生成树","_id":"cim3d4n5o007aofdknut6t1tc"},{"name":"分数规划","_id":"cim3d4n5p007bofdkexys79c2"},{"name":"软件","_id":"cim3d4n5w007sofdkrutm812f"},{"name":"HiDPI","_id":"cim3d4n7g007xofdktyp8yh6v"},{"name":"NOIP","_id":"cim3d4n7p0088ofdkwnv6pg7h"},{"name":"EXGCD","_id":"cim3d4n7p0089ofdkdekjkob1"},{"name":"Vijos","_id":"cim3d4n7u008iofdkdh0zpyx7"},{"name":"洛谷","_id":"cim3d4n7v008jofdkrdmx94cp"},{"name":"二分图染色","_id":"cim3d4n7v008kofdk8g8mgc24"},{"name":"树形DP","_id":"cim3d4n830091ofdkfb4750m7"},{"name":"NOI","_id":"cim3d4n8f009pofdkj508byss"},{"name":"离散化","_id":"cim3d4n8g009qofdk9t4zu53l"},{"name":"并查集","_id":"cim3d4n8g009rofdkyoa03m3p"},{"name":"哈希","_id":"cim3d4n8g009sofdk93spclg9"},{"name":"map","_id":"cim3d4n8h009tofdkh8eh18jn"},{"name":"最小割","_id":"cim3d4n8q00a9ofdkwyo9w42z"},{"name":"最大权闭合子图","_id":"cim3d4n8r00aaofdkj4lbs792"},{"name":"单调队列","_id":"cim3d4n9700b5ofdk2hz8zvj1"},{"name":"Kruskal","_id":"cim3d4n9b00bdofdknkx4bzib"},{"name":"最小生成树","_id":"cim3d4n9c00beofdk7ky68put"},{"name":"Markdown","_id":"cim3d4n9f00bqofdkvirmx4r6"},{"name":"LaTex","_id":"cim3d4n9g00brofdkuz3nhq20"},{"name":"GitHub","_id":"cim3d4n9g00bsofdkupzvjnrn"},{"name":"KMP","_id":"cim3d4n9n00c6ofdk4c12tusd"},{"name":"字符串","_id":"cim3d4n9o00c7ofdkb6sasg28"},{"name":"JSOI","_id":"cim3d4n9r00cfofdkelp5iuhq"},{"name":"HNOI","_id":"cim3d4n9v00cnofdkqgt9g4wu"},{"name":"set","_id":"cim3d4n9v00coofdkqezo6auj"},{"name":"HAOI","_id":"cim3d4n9z00cwofdkwik8q7sd"},{"name":"GDB","_id":"cim3d4na400d4ofdkmfy6d8wg"},{"name":"调试","_id":"cim3d4na500d5ofdklcljravy"},{"name":"COGS","_id":"cim3d4nap00dyofdkegglo3sg"},{"name":"CTSC","_id":"cim3d4naq00dzofdkqz52kuiv"},{"name":"网络流24题","_id":"cim3d4nar00e0ofdkenw03s0f"},{"name":"最大独立集","_id":"cim3d4nb300emofdkbr3ycu9n"},{"name":"最大权闭合图","_id":"cim3d4ncs00guofdkdg93s8sl"},{"name":"搜索","_id":"cim3d4ncw00h3ofdk9tzio605"},{"name":"记忆化搜索","_id":"cim3d4ncx00h4ofdkiyysl89i"},{"name":"位运算","_id":"cim3d4ncy00h5ofdkjv252wap"},{"name":"线性DP","_id":"cim3d4ndw00igofdkfknutadc"},{"name":"CDQ","_id":"cim3d4nej00iyofdkhltywosl"},{"name":"树状数组","_id":"cim3d4nek00izofdkqh7k44f9"},{"name":"Dijkstra","_id":"cim3d4nev00jeofdkufrsao1k"},{"name":"APIO","_id":"cim3d4nfl00k8ofdkcrzxnu6x"},{"name":"DAG","_id":"cim3d4nfm00k9ofdkazmgvkpl"},{"name":"最长路","_id":"cim3d4nfm00kaofdk0w7zel67"},{"name":"Bellman-Ford","_id":"cim3d4nfn00kbofdkzifut3te"},{"name":"AHOI","_id":"cim3d4nfs00kmofdkoqp6fmnv"},{"name":"LCA","_id":"cim3d4nfs00knofdksdz2u5e2"},{"name":"乱搞","_id":"cim3d4nft00koofdkyfz7trmk"},{"name":"矩阵乘法","_id":"cim3d4nfx00kwofdky0lzqt16"},{"name":"快速幂","_id":"cim3d4nfy00kxofdkn6n5qz5v"},{"name":"扫描线","_id":"cim3d4ng200l4ofdkjap8oett"},{"name":"链表","_id":"cim3d4ng300l5ofdkau4so9yj"}]}}