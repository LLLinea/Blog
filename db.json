{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/vno/source/js/main.js","path":"js/main.js","modified":0},{"_id":"themes/vno/source/js/insight.js","path":"js/insight.js","modified":0},{"_id":"themes/vno/source/js/embed.js","path":"js/embed.js","modified":0},{"_id":"themes/vno/source/js/APlayer.min.js","path":"js/APlayer.min.js","modified":0},{"_id":"themes/vno/source/images/show/list.jpeg","path":"images/show/list.jpeg","modified":0},{"_id":"themes/vno/source/images/show/home.png","path":"images/show/home.png","modified":0},{"_id":"themes/vno/source/images/show/google-analytics.jpeg","path":"images/show/google-analytics.jpeg","modified":0},{"_id":"themes/vno/source/images/show/baidu_tongji.jpeg","path":"images/show/baidu_tongji.jpeg","modified":0},{"_id":"themes/vno/source/images/show/article.jpeg","path":"images/show/article.jpeg","modified":0},{"_id":"themes/vno/source/images/background-cover.jpg","path":"images/background-cover.jpg","modified":0},{"_id":"themes/vno/source/images/avatar.png","path":"images/avatar.png","modified":0},{"_id":"themes/vno/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0},{"_id":"themes/vno/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0},{"_id":"themes/vno/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0},{"_id":"themes/vno/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0},{"_id":"themes/vno/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0},{"_id":"themes/vno/source/css/vno.styl","path":"css/vno.styl","modified":0},{"_id":"themes/vno/source/css/tomorrow.css","path":"css/tomorrow.css","modified":0},{"_id":"themes/vno/source/css/search.styl","path":"css/search.styl","modified":0}],"Cache":[{"_id":"source/_posts/20160318-color.md","shasum":"4ba75ba58df47c2827d754b7cd1403c2e5a4fe5f","modified":1462959204410},{"_id":"source/_posts/20160319-candy.md","shasum":"f13122a5162f37bd168bbe581916353a80bf96ce","modified":1462959204410},{"_id":"source/_posts/20160319-set.md","shasum":"e7eb9c83dfd79c39fa6ab6288487d7451fd8be9f","modified":1462959204410},{"_id":"source/_posts/20160331-naive.md","shasum":"3ff152e74585ff685591863055fd944851352fd7","modified":1462959204420},{"_id":"source/_posts/20160404-theory.md","shasum":"e65366ddf744b97ea3c4e04212ea7f53221f1abe","modified":1477351973565},{"_id":"source/_posts/20160527-array.md","shasum":"a76262669f5104a91a95a469b2389802a606aaf0","modified":1464365684525},{"_id":"source/_posts/acam-notes/acam.svg","shasum":"443fe0f8ed15e6b9ef1aadeadef650b8ff57e031","modified":1481071571494},{"_id":"source/_posts/acam-notes/acam2.svg","shasum":"02f0702387bd40ee0980ea1da05b2eff5fd05ec8","modified":1481071560998},{"_id":"source/_posts/acam-notes.md","shasum":"4c93f93fe8c9359fd3b327026a4234d85c653ee5","modified":1482806479683},{"_id":"source/_posts/ahoi2008-meet.md","shasum":"e0b091db3a703654300269a5e26b61cc9b345c43","modified":1462959204420},{"_id":"source/_posts/ahoi2013-diff.md","shasum":"7bc65d01071dd6e1b407a23fe06febf89aae7bf0","modified":1475155507464},{"_id":"source/_posts/ahoi2014-story.md","shasum":"2612b109cd4041278c1c642edf3bdfd804a3abe1","modified":1482631025190},{"_id":"source/_posts/apio2009-atm.md","shasum":"4c8b22e60777afe7205ce9a900eb1a02256c28e8","modified":1462959204420},{"_id":"source/_posts/apio2010-commando.md","shasum":"8fa94fab900ebf9c22c4f8323b5ae51a80ba6041","modified":1477351986840},{"_id":"source/_posts/at-the-cross-of-time/mzr.lrc","shasum":"25283ad79892beb5c83c43d981fdd32fbee30466","modified":1472609600778},{"_id":"source/_posts/at-the-cross-of-time.md","shasum":"45ffba5970ed4c74e713773e1024167d15177171","modified":1479656938381},{"_id":"source/_posts/bsgs-notes.md","shasum":"99537ac64e91e7aeedff9431d60a61d28249a78b","modified":1473486906471},{"_id":"source/_posts/bigint-template.md","shasum":"934fda5bea22b36e0606b10d33bc5df2f37d2487","modified":1462959204420},{"_id":"source/_posts/bzoj-1001.md","shasum":"72d9592ee87d155d313e7f628a8cebfae4aea2da","modified":1462959204420},{"_id":"source/_posts/bzoj-1176.md","shasum":"15b02ad8dd8e0ee24c61c6b0a165b2207065e63c","modified":1466431866375},{"_id":"source/_posts/bzoj-1008.md","shasum":"9e33d15285f7e920f9c945333df08bcb7bcc2c21","modified":1462959204420},{"_id":"source/_posts/bzoj-1251.md","shasum":"c08cd8320d570bccf0d3bc1be414e62b28b8a4da","modified":1462959204420},{"_id":"source/_posts/bzoj-1334.md","shasum":"abdb171b4bac613dca99191ef1801a96a998caec","modified":1477351995812},{"_id":"source/_posts/bzoj-1468.md","shasum":"0b82120a77b6175dff7f5aa518b23484188ffa05","modified":1466071797460},{"_id":"source/_posts/bzoj-1585.md","shasum":"8fbfb910f2698f366ee666295c4d8d6749d22046","modified":1466583292252},{"_id":"source/_posts/bzoj-1477.md","shasum":"c595afe04efabe234f97173104721f64efdbd233","modified":1462959204420},{"_id":"source/_posts/bzoj-1597.md","shasum":"90b890eb6f1937eeca51175e70935f65f36ff154","modified":1477352334716},{"_id":"source/_posts/bzoj-1706.md","shasum":"ab608ab18d6e990d5f08f0969c5102b3c699b970","modified":1475882328043},{"_id":"source/_posts/bzoj-1692.md","shasum":"7d031362d6e4cdaaa6bba2b6eb13706db8dc7efb","modified":1475156754344},{"_id":"source/_posts/bzoj-1711.md","shasum":"625edc5f73eabf5673add401b9f8242356034202","modified":1475917486235},{"_id":"source/_posts/bzoj-2038.md","shasum":"f2168817f10ce4efdc4e11ddb87533de4e0ba411","modified":1462959204420},{"_id":"source/_posts/bzoj-1756.md","shasum":"60bf2403886143b533d0a969f90c410a8550b425","modified":1462959204420},{"_id":"source/_posts/bzoj-2127.md","shasum":"5f423860c93ca99cf0134ec7057af3a5caa1cf77","modified":1466583936327},{"_id":"source/_posts/bzoj-2132.md","shasum":"f09e494406452a281f11baad78e64b72692cced6","modified":1466672219417},{"_id":"source/_posts/bzoj-2143.md","shasum":"3fb8100c81c0111db2d10080b9786aa065ae6b10","modified":1465888560611},{"_id":"source/_posts/bzoj-2152.md","shasum":"d123e9e36bf39b483ec5daf21b61b81649bb5640","modified":1466071815564},{"_id":"source/_posts/bzoj-2194.md","shasum":"28422db536e022d9d404eb6714a6ead40b23f7d2","modified":1465651961781},{"_id":"source/_posts/bzoj-2438.md","shasum":"a91564720a619f94894f8572d4551a53c46faebd","modified":1466843509077},{"_id":"source/_posts/bzoj-2296.md","shasum":"23212b789066f8b9bd854f2cb7b3ddea6585ec9e","modified":1462959204420},{"_id":"source/_posts/bzoj-2442.md","shasum":"09e6f50360804dfd5882d273bbb6300f2da95aa0","modified":1477352012360},{"_id":"source/_posts/bzoj-2456.md","shasum":"021110d045d68e07f7e18e35ac8d3940b7836493","modified":1466172511587},{"_id":"source/_posts/bzoj-2462.md","shasum":"1732c3114d698e1c3d622c6b1a3d172100e0812c","modified":1473810063694},{"_id":"source/_posts/bzoj-2580.md","shasum":"a73e63accb968c9992ae4c7e289994fcdbd507d5","modified":1474154745766},{"_id":"source/_posts/bzoj-2683.md","shasum":"926ec2d1b7000c24c1edd22d197180164cac76a8","modified":1466431930441},{"_id":"source/_posts/bzoj-2683/cdq.png","shasum":"a95d0b02b915f092df6656298add0f0fc9662341","modified":1462955792540},{"_id":"source/_posts/bzoj-2716.md","shasum":"fe2aec385e2971d42f1097e916fe964445aa424d","modified":1466824130905},{"_id":"source/_posts/bzoj-2820.md","shasum":"b893e9bbcea214b41bef4c502d833a930d123fdb","modified":1462959204420},{"_id":"source/_posts/bzoj-3156.md","shasum":"476a683d45bb01c6c6cca9af75e5f0c6f6c74734","modified":1477352022972},{"_id":"source/_posts/bzoj-3196.md","shasum":"2b72c0385e2a3174173ca2e75ca6d606c6696bf8","modified":1466300243903},{"_id":"source/_posts/bzoj-3230.md","shasum":"5882c46621fd0d914caa25ee49de7f163964c7b9","modified":1475191571909},{"_id":"source/_posts/bzoj-3262.md","shasum":"ad61bcd01d1a0afdc44e0e038123ff32c86a2e76","modified":1466341000696},{"_id":"source/_posts/bzoj-3277.md","shasum":"07b57370422ef563976726932df98adac3478691","modified":1475192434037},{"_id":"source/_posts/bzoj-3275.md","shasum":"a14dc375463cfb3df8cc97d3adf5b78c7ca85456","modified":1464016159116},{"_id":"source/_posts/bzoj-3280.md","shasum":"f379b4a1212f7781164d71625d49ad3124d1b523","modified":1473508473657},{"_id":"source/_posts/bzoj-3365.md","shasum":"3bfab6ccaa5e2dfd1fa3a6a4d65d68fb96a5b22a","modified":1466071781441},{"_id":"source/_posts/bzoj-3438.md","shasum":"7fa24e4ae32a471e08cf89604521923861bd42e8","modified":1466493507214},{"_id":"source/_posts/bzoj-3511.md","shasum":"a69c5a7b074d933e3eb29d1b2c8a24645520728d","modified":1462959204420},{"_id":"source/_posts/bzoj-3697.md","shasum":"3560e2748c810aec86cc770aab1371f8f33698a6","modified":1474808740919},{"_id":"source/_posts/bzoj-3894.md","shasum":"9cf338b78641a5cc1eb027d84506a587d7c9267d","modified":1466583943359},{"_id":"source/_posts/bzoj-3796.md","shasum":"d964d550ff1177bfbb1d19991f600624ab25824c","modified":1475192923083},{"_id":"source/_posts/bzoj-3940.md","shasum":"34e3c58a8bed87be2046f4b4da66f095f3353edd","modified":1473810460840},{"_id":"source/_posts/bzoj-4145.md","shasum":"1383833b1739216df566d16f25ab76e377e728a8","modified":1477352032208},{"_id":"source/_posts/bzoj-4247.md","shasum":"ecb5c5706b743d62fd19c3bcc03f4638b94e2be3","modified":1477352045720},{"_id":"source/_posts/bzoj-4318.md","shasum":"0004fbf6e758b707f24a98c3929912894626bdd0","modified":1464696387692},{"_id":"source/_posts/bzoj-4403.md","shasum":"0e503e9c28ace534c15b2b47576add9bd4027af5","modified":1462959204420},{"_id":"source/_posts/ceoi2008-order.md","shasum":"96b1a7c05854b6da645d341d870b6c958cac73a5","modified":1466582878396},{"_id":"source/_posts/ceoi2004-two.md","shasum":"99ab98de7fb06f9fdfca038c023d4ff8f74f8755","modified":1477352054116},{"_id":"source/_posts/cf-628d.md","shasum":"5bd19c9ec8ea646e78edcf23d15218c6060e1b47","modified":1477352319769},{"_id":"source/_posts/cf-716e/example.svg","shasum":"a1d6731f2ef7e43ae48e27345954c6cb24a216b0","modified":1474439170788},{"_id":"source/_posts/cf-716e.md","shasum":"34ad51b65867dd4a0c99349b191738070148aeb2","modified":1474440272852},{"_id":"source/_posts/chairman-tree-notes.md","shasum":"8be4f4b6d283778a78c6dc87d141029f34f57d51","modified":1462972004900},{"_id":"source/_posts/coci2015-divljak.md","shasum":"75aee7f3216c123eb41de62a2a657cf6fb2a9601","modified":1474239668919},{"_id":"source/_posts/codevs-1563.md","shasum":"90f4dda98f3aed528734d91eaa918ea58ad5d67d","modified":1466518742060},{"_id":"source/_posts/codevs-1345.md","shasum":"58546572e0bb94b562f55fdbf6649287a3107656","modified":1477352064784},{"_id":"source/_posts/codevs-2598.md","shasum":"9f5c7bea72bdd82e3f05c5e6284e8dd8e0aed8e8","modified":1477352072459},{"_id":"source/_posts/codevs-2822.md","shasum":"a5f2981e80882ae575f7c28d9552bddbe717915a","modified":1462959204420},{"_id":"source/_posts/codevs-3168-3162.md","shasum":"aafdf6bc35f4dcda18d9f89de0ae2ecb8c75c2c4","modified":1477352102283},{"_id":"source/_posts/codevs-3269.md","shasum":"b276f70ecd368aa72d5c1a48b680f475818b0d47","modified":1477352115991},{"_id":"source/_posts/codevs-3269-monotone-queue.md","shasum":"b445e3b6240f19aae1b165e94fb3e2fa17162499","modified":1477352123283},{"_id":"source/_posts/cogs-14.md","shasum":"df074c69b9f8cacedba8ccea146ac644e8201397","modified":1462959204420},{"_id":"source/_posts/cogs-396.md","shasum":"fbfd2fc22b9c83aa16792fa61d51d702b53461f7","modified":1462959204430},{"_id":"source/_posts/cogs-439.md","shasum":"2426244914406bd35b753d445bb5fcd3e01a5c30","modified":1462959204430},{"_id":"source/_posts/cogs-728.md","shasum":"c7fa068adf3bf1f5f5b4add16374b265ef21ca11","modified":1462959204430},{"_id":"source/_posts/cogs-727.md","shasum":"d3f3d51ba288685a52479e3847f4e84885fcdb3e","modified":1462959204430},{"_id":"source/_posts/cogs-729.md","shasum":"bb45c57f781ff5c8eb0e87b3edadf7b206b81c01","modified":1462959204430},{"_id":"source/_posts/cogs-734.md","shasum":"4a748f8ae51d4d1990b89ac8081e53d74fbc183c","modified":1462959204430},{"_id":"source/_posts/cogs-731.md","shasum":"f16c01e7c3da8aa233df4daee546f3024726d239","modified":1477352304985},{"_id":"source/_posts/cogs-738.md","shasum":"01a88085f9e1823b8fc63e04a617b85fc1551ade","modified":1462959204430},{"_id":"source/_posts/cogs-739.md","shasum":"4eb4f215432d85cc7bd93a357ee70d326f314504","modified":1462959204430},{"_id":"source/_posts/cogs-740.md","shasum":"e90060c6feb6273cd400258627f141214574dd8f","modified":1462959204430},{"_id":"source/_posts/cogs-742.md","shasum":"dc5b03c9e8b857ea345e0f906692847cc7c2508b","modified":1462959204430},{"_id":"source/_posts/cogs-741.md","shasum":"91a8b62bd42e7be33d94ae1a9624d5a0d7c2c9a3","modified":1462959204430},{"_id":"source/_posts/cogs-746.md","shasum":"aa46c716f60453fdbbfa4ff4ccdca515e90e25ae","modified":1462959204430},{"_id":"source/_posts/cqoi2011-inverse.md","shasum":"5e6e7e3d0c82e5814f994d8468de30766070c55b","modified":1466431853556},{"_id":"source/_posts/combinatorics-notes.md","shasum":"f3e5e1bf1d06c126032426103df6f1990368ad07","modified":1462959204430},{"_id":"source/_posts/cqoi2016-cuts.md","shasum":"96b727a740bc374fefd4b8ca7d1c09b5f20648c4","modified":1462959204430},{"_id":"source/_posts/cqoi2016-number.md","shasum":"bae7a7e7008769b1bd14b496961ce95efd9f76c7","modified":1477352136359},{"_id":"source/_posts/ctsc-apio-2016.md","shasum":"b8a08df409b774cf281797e8a8dc95e01de5624a","modified":1479656971201},{"_id":"source/_posts/ctsc1997-course.md","shasum":"48f7051612c8843ce79049b59c0fb88b0fbf557c","modified":1477352275933},{"_id":"source/_posts/ctsc1999-home.md","shasum":"978baaae9dd654467febabfa562eea00beb02859","modified":1462959204430},{"_id":"source/_posts/derangement-number.md","shasum":"1d85fe52fcf017157eeffc96e660b029b83cb31f","modified":1462959204430},{"_id":"source/_posts/dinic-notes.md","shasum":"ec041e36d2aa97dad861d9851524cb01f3b5ed1a","modified":1482585228817},{"_id":"source/_posts/docker-sandbox-judger.md","shasum":"8a5895d636752944fc5f8b83c17dd594f7209331","modified":1481635493048},{"_id":"source/_posts/edmonds-karp-notes.md","shasum":"edba11cb82da34ac8af87a4462724abe868e94e5","modified":1482635144773},{"_id":"source/_posts/euler-sieve.md","shasum":"bdd661e2b3f1d99f802c6179a97c7c31dd4f883d","modified":1462959204440},{"_id":"source/_posts/fft-to-ntt.md","shasum":"1876bb4ba0acf94f95333a06dfdaa8eae3f51cd8","modified":1466170692116},{"_id":"source/_posts/fft-notes.md","shasum":"b36068745daabad1be6474be5e84e86c38fceee7","modified":1482474049497},{"_id":"source/_posts/fjoi2007-wheel.md","shasum":"62ed81583cf9b21d3798a0f89b3e4d4fe56ac776","modified":1476696387229},{"_id":"source/_posts/gnu-debugger.md","shasum":"a39a3556d1965b8fc4ce3404e23c4aa5587ceca1","modified":1462959204440},{"_id":"source/_posts/haoi2006-cow.md","shasum":"de4e6dcca3e29acdc131063a61ca1f8fd1ee3be1","modified":1462959204440},{"_id":"source/_posts/haoi2006-sequence/1.svg","shasum":"0337ba40ba7e2733cc657b79636f5f06e5f7c9a3","modified":1481071178527},{"_id":"source/_posts/haoi2006-sequence/2.svg","shasum":"57a7cee258306ed3073e46a9e0e79f6485c8f100","modified":1481071191582},{"_id":"source/_posts/haoi2006-sequence.md","shasum":"deabe14357855cd51e4690ddabaea2eb1e1933f4","modified":1481070972380},{"_id":"source/_posts/haoi2007-cover.md","shasum":"c3892255d5e8a099d5b5ca12afd35abdb7822642","modified":1481618244905},{"_id":"source/_posts/haoi2007-ant.md","shasum":"2bd734af13a13d0361dc29d13a63b5120df22f8b","modified":1481619427004},{"_id":"source/_posts/haoi2007-lis.md","shasum":"d559fad8378784179e8605eec1b0c70c6f75e34c","modified":1480580725224},{"_id":"source/_posts/haoi2007-separation.md","shasum":"4b6aaca21dcf4324d4d22dd6983c52d1d1411709","modified":1480895559695},{"_id":"source/_posts/haoi2007-square.md","shasum":"a4a760a50dd8df40925bed1f51856373fcfccc64","modified":1480634217457},{"_id":"source/_posts/haoi2008-candy.md","shasum":"e408ba8c0c27c36c3fa2606474560055131c2412","modified":1479021877454},{"_id":"source/_posts/haoi2008-cir.md","shasum":"268b031e4e51141293fed8dc35b778c0e9d6c01f","modified":1479005811312},{"_id":"source/_posts/haoi2008-move.md","shasum":"f276822ba6612d78a2b2a3fb307a73134e8f61eb","modified":1481620097277},{"_id":"source/_posts/haoi2008-coins.md","shasum":"b2a5b3bebb8b9bd49ac5e76691ae32acd10e19bd","modified":1479006702698},{"_id":"source/_posts/haoi2008-name.md","shasum":"55056d53974b62ac7ba9c4daa55fb46bf2d7b125","modified":1477352144055},{"_id":"source/_posts/haoi2008-stick.md","shasum":"76f7a22c09f8394f2aff8a2f54bd36ce570a048c","modified":1479007911164},{"_id":"source/_posts/haoi2008-rank.md","shasum":"71444692107dffe7bcdb1a3aac4d63117c922c61","modified":1481620085081},{"_id":"source/_posts/haoi2011-problemb.md","shasum":"80f9d8191d53d49067ee4e5c654cdc60a8a53384","modified":1462959204440},{"_id":"source/_posts/haoi2016-chain.md","shasum":"b722f46a179a7fd0fd2293235b225a75c3343ef2","modified":1462959204440},{"_id":"source/_posts/haoi2015-t2.md","shasum":"b46b9260d7c4fd96c6f56b7faf8eb10a7507fc55","modified":1473500685141},{"_id":"source/_posts/hdu-2089.md","shasum":"52c4b8de67b50c5f4addd2d422c958164ed2e5fd","modified":1477352153582},{"_id":"source/_posts/hdu-5632.md","shasum":"e8b90a7fda59235e4c0a7de7416e0f6bd2c2eaa9","modified":1477352162698},{"_id":"source/_posts/hdu-5642.md","shasum":"65de14e383af7e37e49ab3a7c18f8acacab2f00e","modified":1477352172278},{"_id":"source/_posts/heoi2013-bag.md","shasum":"3d3544eca469964d0c67c98cc605e76bd654a445","modified":1477352200514},{"_id":"source/_posts/hdu-5906.md","shasum":"de080c085c1e5d051fc64319167bb951836391dc","modified":1475229652455},{"_id":"source/_posts/hnoi2004-language.md","shasum":"7c4a81764969730a17d818d80444428dc84d8179","modified":1473723911171},{"_id":"source/_posts/hnoi2008-cards.md","shasum":"a99c6c4f9bbf046575f4cf52eae0fdb272c1cc59","modified":1476673417128},{"_id":"source/_posts/hnoi2004-pet.md","shasum":"b2bda3d66ff145436b7eab827120e72edbae6c57","modified":1462959204440},{"_id":"source/_posts/hnoi2008-gt.md","shasum":"51d30d56860cf265cf1a21586d14ed5b7371d2e1","modified":1475880765853},{"_id":"source/_posts/hnoi2008-toy.md","shasum":"26405e1e114faeb135c6a647611853b9a3e34811","modified":1477352187662},{"_id":"source/_posts/hnoi2008-tree.md","shasum":"ba8997bd556bb160cc33b8978d55000e45c34b6e","modified":1476673607260},{"_id":"source/_posts/hnoi2010-chorus.md","shasum":"ef16ed9ed60a26fb7296c92f5456aff90b98849d","modified":1477352209310},{"_id":"source/_posts/hnoi2012-mine.md","shasum":"cce8a25d8ba4f48806c8b10b6ea947912bb72964","modified":1473292401367},{"_id":"source/_posts/hnoi2016-multiple.md","shasum":"5f8819ca3130cd4e04f7c49a5ff3c52b50fe67a9","modified":1462959204440},{"_id":"source/_posts/hnoi2016-network.md","shasum":"701e1dfb9e177e0b4857e359cc2b2e32392fd4cd","modified":1462959589490},{"_id":"source/_posts/hnoi2016-sequence.md","shasum":"584e140ef6c2aefe78304fcedce69218d3c90d55","modified":1462959204440},{"_id":"source/_posts/hnoi2016-tree.md","shasum":"d8e0634d20447cf11e6a3dc092629df943442b65","modified":1473486695350},{"_id":"source/_posts/ioi2008-island.md","shasum":"c556010ee83873a588f35bf672275d3f03fd55de","modified":1477402349876},{"_id":"source/_posts/hnoi2008-kingdom.md","shasum":"630ff7a9fe9730a54e7fb2af393bb3975bc30b87","modified":1476696323487},{"_id":"source/_posts/ioi2011-race.md","shasum":"e656c8dc53b1d87d99f3d3e9ef8425949a54dde0","modified":1466078515927},{"_id":"source/_posts/jsoi2007-cipher.md","shasum":"72d59d69cd1774e5ff8550950b7787d1c5245fae","modified":1475154361131},{"_id":"source/_posts/jsoi2007-generator.md","shasum":"389a27109369808043d691bfce41bc3fa3b5b754","modified":1473636489303},{"_id":"source/_posts/jsoi2007-repair.md","shasum":"b471ddac6cf3614bf4c70f7422bdc0c88a77fb79","modified":1479000357614},{"_id":"source/_posts/jsoi2007-mahjong.md","shasum":"7168f1c1c3915f6bdfbe63ab8fb1ad6eacd8e872","modified":1478997155260},{"_id":"source/_posts/jsoi2008-award.md","shasum":"8ac08f0cbca053ae3a9af3c3f8c7a333149e1ef9","modified":1476798062436},{"_id":"source/_posts/jsoi2008-dotr.md","shasum":"b0d21a9fcaf6e34cd3a1d55b6f4db4914e7165f7","modified":1477352221646},{"_id":"source/_posts/jsoi2008-maxnumber.md","shasum":"973b88d1287688eef3d8f99363a1db35399213db","modified":1462959204440},{"_id":"source/_posts/jsoi2008-starwar.md","shasum":"44f26d7aea8467915a733921932eb627c32c8657","modified":1476796800814},{"_id":"source/_posts/jsoi2008-prefix.md","shasum":"9d1e1e5bfc935b12dd2477dc09b31eeeda7651b8","modified":1476796235311},{"_id":"source/_posts/jsoi2009-game.md","shasum":"7e3bcdfbc619bd881e671216285cd1649f62b87a","modified":1462959204440},{"_id":"source/_posts/jsoi2009-game2.md","shasum":"982f4ff3511ef0b4262c197d007eafe92667d97e","modified":1474191031290},{"_id":"source/_posts/jsoi2016-flight.md","shasum":"9f52be4f9cddedb2ab7e6737ce2f387faa9147e6","modified":1462959238400},{"_id":"source/_posts/kmp-notes.md","shasum":"abea2437026ff62108abf1ac40611342c0dc6eb8","modified":1482806135355},{"_id":"source/_posts/jsoi2016-light.md","shasum":"58533f261da20e6409234f6aee1ea40049a1f35f","modified":1462959204440},{"_id":"source/_posts/link-cut-tree-notes.md","shasum":"d0dd589310e783f3cc72f2d4a558396dde355f78","modified":1462959204440},{"_id":"source/_posts/lyoi-pingfan/pfzl.lrc","shasum":"cd9495fcc11a3797b90d5b6e34676f412fa64709","modified":1479632878240},{"_id":"source/_posts/lyoi-pingfan.md","shasum":"93016cc4298799f4e355b1b3e19ce77d94dc86d4","modified":1479656921098},{"_id":"source/_posts/mo-algorithm-notes.md","shasum":"04963d986f2cbd596dfc9d92c1efdbb209e3afb7","modified":1462959204440},{"_id":"source/_posts/minimum-spanning-tree-notes.md","shasum":"5e376a19420ba0d04fbfc86ffb85254f8f33b464","modified":1462959204440},{"_id":"source/_posts/monotone-queue-notes.md","shasum":"fc7a11f33c6b9f425dde2c3b3c901e7018aca151","modified":1462959204440},{"_id":"source/_posts/node-devide-notes/tree1.svg","shasum":"4de32d5e3b22eb531886d0f9f475f2a9982ee471","modified":1481071614437},{"_id":"source/_posts/mul-inverse.md","shasum":"88b06571986b29765bc702445e03c7db387ed3b1","modified":1462959204450},{"_id":"source/_posts/node-devide-notes/tree2.svg","shasum":"407c61fdd3d63b87c5678d80c9b6213781d2cb1f","modified":1481071624189},{"_id":"source/_posts/node-devide-notes.md","shasum":"125c398ee1be3445dbbc96b8e724e9ac97c3b9d9","modified":1466152641034},{"_id":"source/_posts/noi2002-galaxy.md","shasum":"0b62ae091bdecd684968bd8eb0707890d71eeac1","modified":1462959204450},{"_id":"source/_posts/noi2006-profit.md","shasum":"cdf389673d9a8babd630e8c5bc247670b695bff4","modified":1462959204450},{"_id":"source/_posts/noi2003-editor.md","shasum":"6d6ccf7f089180de540cb75879f4589b5c1e8ee4","modified":1462959204450},{"_id":"source/_posts/noi2004-cashier.md","shasum":"0504fdf9c3754c9f1fa1b1be8befc3dcf0852794","modified":1462959204450},{"_id":"source/_posts/noi2008-candy/1.svg","shasum":"487bedd4ee907b6af27bc2dff608d7084da67f46","modified":1482459268920},{"_id":"source/_posts/noi2008-candy/2.ggb","shasum":"b72de255a5a79e92a5a220da592cc30818579ca7","modified":1482481329150},{"_id":"source/_posts/noi2008-candy/2.svg","shasum":"84a22ca72f6e0ff90dfce05b56f44e7ab66f3cc9","modified":1482480535076},{"_id":"source/_posts/noi2008-candy/3.ggb","shasum":"7155350e293077d4fd36bd65715ea693ed339c80","modified":1482480473665},{"_id":"source/_posts/noi2008-candy/4.ggb","shasum":"0c851a79d13d36a0bc06c1360ec5ca3b48e301a2","modified":1482481843625},{"_id":"source/_posts/noi2008-candy/5.ggb","shasum":"e80d5ff3511748769937e358ca9f213db78a3adc","modified":1482482981048},{"_id":"source/_posts/noi2008-candy/6.ggb","shasum":"b968f70e6224debb5e16b9ea4a1e39ebc2de4834","modified":1482484170031},{"_id":"source/_posts/noi2008-candy/7.ggb","shasum":"fbf0ec7e19ee13b534e9aa66ded3170ec449261e","modified":1482484224546},{"_id":"source/_posts/noi2008-candy.md","shasum":"ab7d37baeb1d12378e115a08a1d4a97c39af3e1d","modified":1482487256316},{"_id":"source/_posts/noi2011-type.md","shasum":"f84650491029914e9de402d6433b478d1caa32f0","modified":1473638033794},{"_id":"source/_posts/noi2012-random.md","shasum":"b0e78167c2a4168496fe6b70a1dc8d3b45962352","modified":1475883407010},{"_id":"source/_posts/noi2014-forest.md","shasum":"692c2d383b68f8c65f1a2b45c37cb788e7f76f47","modified":1468252483005},{"_id":"source/_posts/noi2014-sleep.md","shasum":"32c222899af7ba614509f0b5cb66bc0867154960","modified":1462959204450},{"_id":"source/_posts/noi2014-zoo.md","shasum":"48d488c5c348640989a59b2c84c2a60d8273ce10","modified":1468251707623},{"_id":"source/_posts/noi2015-dinner.md","shasum":"afbaf06fc29fcc73760e96692f67d386e51f7ffe","modified":1477352235002},{"_id":"source/_posts/noi2015-epic.md","shasum":"d9f2c20735718a4f922f1b7f0bf394fcbeb992a8","modified":1467336511308},{"_id":"source/_posts/noi2015-farm.md","shasum":"419b248d8bb0e510213977f23d5ef46b98526c8c","modified":1478001561067},{"_id":"source/_posts/noi2015-manager.md","shasum":"b718da5118bf865669f6505c4ac9acdba8339316","modified":1462959204450},{"_id":"source/_posts/noi2015-savour.md","shasum":"05ae6befa30e37183474e5a856a8fd2b95741b93","modified":1467336519440},{"_id":"source/_posts/noi2015-prog.md","shasum":"1f738de912a1b38d8bfc2d497e1b9c54236a13a4","modified":1478606807659},{"_id":"source/_posts/noi2016-excellent.md","shasum":"8d8033bffd7cc40a8a474d5914ff17c626524fc7","modified":1473118923830},{"_id":"source/_posts/noi2016-grid.md","shasum":"f86421c87bea57c995b00231fffadfd4fd54cecb","modified":1473638069201},{"_id":"source/_posts/noi2016-interval.md","shasum":"5e22b8b0f979a24af64e88dcc5ebbf8a75bddf16","modified":1473118751830},{"_id":"source/_posts/noip2000-cheng-ji-zui-da.md","shasum":"f98039cfa065e1662575945a0b1a582ec2ad2689","modified":1477351910525},{"_id":"source/_posts/noip2003-game.md","shasum":"6f382752e06de918287ed053ba5cc20db51b633a","modified":1477351904205},{"_id":"source/_posts/noip2006-energy.md","shasum":"2a1c5d16824f3e06c23b5f7cd692b187863a66bd","modified":1477351922329},{"_id":"source/_posts/noip2006-budget.md","shasum":"b350f36da264bb5fd90a5fee23019284efa9918c","modified":1477351822210},{"_id":"source/_posts/noip2010-flow.md","shasum":"7133e4ca1632ebbafbebee02cc749908e81af1f6","modified":1479029018684},{"_id":"source/_posts/noip2010-prison.md","shasum":"1c89f4fba3f01bec85a06ce8e5309a7e6d50f733","modified":1462959204450},{"_id":"source/_posts/noip2012-blockade.md","shasum":"dcbb2b7c28da18c0a662a6fd251f8d893461d8a4","modified":1479030258333},{"_id":"source/_posts/noip2012-drive.md","shasum":"e7df25f732858eea47e4ebbb206e9cc30ab5d277","modified":1479028462387},{"_id":"source/_posts/noip2012-classrooms.md","shasum":"3ec63cd7cf2caa054464e41e0e8428d52c234021","modified":1475917451595},{"_id":"source/_posts/noip2012-mod.md","shasum":"0fb6c0ef73a261e10a1b23b235c0492a247c1362","modified":1462959204450},{"_id":"source/_posts/noip2013-match.md","shasum":"a3b515c40a4d08f8abef8c1b26e0923df31b8d56","modified":1479024938455},{"_id":"source/_posts/noip2013-flower.md","shasum":"eac451fe25287a373570518cfab3666459c602ac","modified":1479026565336},{"_id":"source/_posts/noip2013-puzzle.md","shasum":"15b7b800cabdda94234aff34e9591e22974a4383","modified":1479033358177},{"_id":"source/_posts/noip2014-equation.md","shasum":"32741b3c9a8437f91b273e1ea4979fe4e6937319","modified":1476865586067},{"_id":"source/_posts/noip2014-bird.md","shasum":"76874bf8cf59797f6fd23a6c0dcfa3fc25d228c3","modified":1478606832691},{"_id":"source/_posts/noip2015-landlords.md","shasum":"383d0be32afdf22cbb8c522fea4ae2fcde6b7676","modified":1476865979622},{"_id":"source/_posts/noip2015-transport.md","shasum":"65287e79098fc97ed2f63ad521889c0e5cb853a5","modified":1476882449463},{"_id":"source/_posts/noip2015-substring.md","shasum":"8132adb345d5966190126eb464240285ca345188","modified":1478069428453},{"_id":"source/_posts/noip2016-angrybirds.md","shasum":"d4b424e95af568e449f201378bcccca21ffc3973","modified":1480425733905},{"_id":"source/_posts/noip2016-classroom.md","shasum":"a4730715dec75b04f15ebf35c7fc3e7c803c1a81","modified":1480404993407},{"_id":"source/_posts/noip2016-earthworm.md","shasum":"1b2fcb76d67ccbceab9b7a4fccbdd8d36e25f77c","modified":1480425082980},{"_id":"source/_posts/noip2016-problem.md","shasum":"3f2bfceef09b7568444107ae65ed6222db1f5f29","modified":1480425142493},{"_id":"source/_posts/noip2016-running/linear-backward1.svg","shasum":"f11ad00d6b6d9c4a9dbcdd756a54ac9f98aae87c","modified":1480402071309},{"_id":"source/_posts/noip2016-running/linear-forward1.svg","shasum":"21d1e9f4c290ba36e95ca3d1a3f03108f7e7d08c","modified":1480401570576},{"_id":"source/_posts/noip2016-running/linear-forward2.svg","shasum":"d828849ead2a7f7a3ac34250ec3e468dd053fe4c","modified":1480401597915},{"_id":"source/_posts/noip2016-toy.md","shasum":"5b73c18d444e50a23f5352203f26632af2830c2c","modified":1480404968883},{"_id":"source/_posts/noip2016-running.md","shasum":"4314316adc4ca81526daf243a8365e04f7224136","modified":1480404979183},{"_id":"source/_posts/noip2016.md","shasum":"a9273f495144f13620fd53d5e847c9f596becd2d","modified":1479656914658},{"_id":"source/_posts/npm-debug.log","shasum":"881c868bf599dd4f4753f8b868bec0bb7a2a6f51","modified":1466824292761},{"_id":"source/_posts/non-recursion-dfs-with-stack.md","shasum":"77777eea132ddbbc8f0201f6438267a80a414656","modified":1462959204450},{"_id":"source/_posts/number-theory-notes-1.md","shasum":"06a1c30f28a21e76f65bc5afc0d9766231d8af32","modified":1462959204450},{"_id":"source/_posts/poi2000-wir.md","shasum":"c7d42107d0fdf656828fda727b7c0207494f9dd3","modified":1473724314323},{"_id":"source/_posts/poi2005-kos.md","shasum":"7d2d41ca023967051b7c5e8262484cff78a75009","modified":1466591154146},{"_id":"source/_posts/poi2006-szk.md","shasum":"6eb519b750b4996e46308708f4676ef24bf623d3","modified":1466590859112},{"_id":"source/_posts/poi2008-blo.md","shasum":"60d3bdf871aedf1869912848eea175276493eff6","modified":1473332288939},{"_id":"source/_posts/poj-2728.md","shasum":"732694ea57c6eef6f36cb28708d0072913ef8f1e","modified":1462959204450},{"_id":"source/_posts/poj-1737.md","shasum":"09c4fec6b5a83f1b9b7b8161b0aab0ac1b24cbc3","modified":1462959204450},{"_id":"source/_posts/poj-3461.md","shasum":"226bd4eac18f3439dc754c946c995894cb74d640","modified":1462959204450},{"_id":"source/_posts/scoi2009-cake.md","shasum":"8573193bdcfc4f2a85224fd1791b00d1b91af94e","modified":1478956661779},{"_id":"source/_posts/scoi2007-repair.md","shasum":"e5cd2d95c22fd64d8f4362732d747292a4e17240","modified":1462959204450},{"_id":"source/_posts/scoi2009-game.md","shasum":"dd4f8b3206e56636eb53b7507b3b7c8ba0994438","modified":1478998078148},{"_id":"source/_posts/scoi2009-paint.md","shasum":"6650628febe53de448522a2028b19752256ee9bb","modified":1477351841406},{"_id":"source/_posts/scoi2009-windy.md","shasum":"227dc0a7195a3a327f2e3f5788dee664da2a3d83","modified":1477351833902},{"_id":"source/_posts/scoi2010-game.md","shasum":"81be4ae0bb7c1120e220a5177bea4877d19780f3","modified":1462959204450},{"_id":"source/_posts/scoi2011-candy.md","shasum":"3037949e9f52b0faac3b2ca5b4d7f40e64147dad","modified":1462959204450},{"_id":"source/_posts/scoi2015-flag.md","shasum":"d2273c0aa7434ce104123d934eed5ebc76ce7874","modified":1462959204450},{"_id":"source/_posts/scoi2012-name.md","shasum":"56ed15710897916cb0855611a326acf53bc7bb96","modified":1475155718840},{"_id":"source/_posts/scoi2015-light.md","shasum":"6f50e8af86425d00844a560e71538656754f9f6f","modified":1477351887454},{"_id":"source/_posts/scoi2015-matrix.md","shasum":"81f28e7cad4caf2a53201684e2eebc1961e7e42e","modified":1462959204450},{"_id":"source/_posts/scoi2015-message.md","shasum":"eaba94296389b994b29a45744ad81674723c1e31","modified":1462959204450},{"_id":"source/_posts/scoi2015-password.md","shasum":"ba24fd5191837df620e52e49246f6481006b0610","modified":1462959204450},{"_id":"source/_posts/sdoi2008-cave.md","shasum":"0665e52de3f255cafac2bdc5b5c8f9ee23deee5c","modified":1462959204450},{"_id":"source/_posts/sdoi2009-run.md","shasum":"239f7f7943172b90055db3a73dc898ba4a248a13","modified":1466511891867},{"_id":"source/_posts/sdoi2008-interval.md","shasum":"6d7c73c685e299bcefb7bb93dd4efa340d1ac0c6","modified":1472823498227},{"_id":"source/_posts/sdoi2010-goblin.md","shasum":"88700569b1ba9e8abf8a695bd17b762252927cb3","modified":1466409035404},{"_id":"source/_posts/sdoi2011-calc.md","shasum":"8bc38c373e311a2ca92f3f7ce36654a436d31f21","modified":1465790863358},{"_id":"source/_posts/sdoi2010-starrace.md","shasum":"7cdfa2fbc6b5703175d491f81869e84382baf68c","modified":1462959204450},{"_id":"source/_posts/sdoi2013-rforest.md","shasum":"a16ac45bc3f7d66afd0d348d8c30f9c4776906e5","modified":1476869061064},{"_id":"source/_posts/sdoi2014-journey.md","shasum":"2e11f80c5309333604309cd252acb87bcb39b70e","modified":1472823755641},{"_id":"source/_posts/sdoi2015-sequence.md","shasum":"2fe794b7d355bc493c80053ec8841812042c7acf","modified":1466170749686},{"_id":"source/_posts/sdoi2016-game/line.png","shasum":"30c24e553938d2c27b55779527825b2577088a7c","modified":1462955792590},{"_id":"source/_posts/sdoi2015-war.md","shasum":"4a6a234666ff45ea7c5069e6630519b646dac882","modified":1462959204460},{"_id":"source/_posts/sdoi2016-game/tree.png","shasum":"90bc10409b5ddf29a47ab554e220b1fb152d2f86","modified":1462955792590},{"_id":"source/_posts/sdoi2016-incantation.md","shasum":"1152f86db800b686d790898d6b9193c7d8712bbe","modified":1462959204460},{"_id":"source/_posts/sdoi2016-game.md","shasum":"f4688c431daa3a3b77b8ac3ec53c43f27ffb63de","modified":1462959204460},{"_id":"source/_posts/sdoi2016-pair.md","shasum":"9a707c8f327534044dac4b013a285184edd7d349","modified":1462959204460},{"_id":"source/_posts/sdoi2016-journey.md","shasum":"9a67291ff2e3d19a6acb34043bd649423974380f","modified":1477351780335},{"_id":"source/_posts/sdoi2016-permutation.md","shasum":"ac94de60fa9ed03ece26c466ef20698e935d6752","modified":1462959204460},{"_id":"source/_posts/sdoi2016-round1.md","shasum":"7e92ad517aff81a72afd6c6b393a7248ca7243d0","modified":1479656964533},{"_id":"source/_posts/sdoi2016-table.md","shasum":"4069652db069ab71e8a3b733a02022472201dad6","modified":1473486856729},{"_id":"source/_posts/shoi2007-vote.md","shasum":"600f0630bbe939bdf9bbc2c5c7809382a204b070","modified":1466492665384},{"_id":"source/_posts/shoi2007-tree.md","shasum":"408976b299bfef93fe74cfd816dc427929e313c2","modified":1466824073211},{"_id":"source/_posts/shoi2008-cactus.md","shasum":"865ec5c6af46e9aa3d97d2a0cf1871b06e2e5c85","modified":1477440165110},{"_id":"source/_posts/shoi2008-debt.md","shasum":"a270d590220f6e71746789e95b9d3acd767c82fe","modified":1476862555225},{"_id":"source/_posts/shoi2008-hannoi.md","shasum":"087cf760e04d33e7a17df8e17d40f105d28f287c","modified":1476861861733},{"_id":"source/_posts/shoi2008-traffic.md","shasum":"93cb98cb139e4fb449aa59256b5f6fee89ac2783","modified":1476858627266},{"_id":"source/_posts/shoi2008-john.md","shasum":"49c7e0d140440d5228ceb897df0f2069fd83c12d","modified":1476863627059},{"_id":"source/_posts/splay-notes-1.md","shasum":"b16bea4ec04052dc118bc0ff0450825ee17f600c","modified":1482823752333},{"_id":"source/_posts/splay-notes-2.md","shasum":"b7c1615a96dfff66ea8c6337d06c966a9223f69e","modified":1462959204460},{"_id":"source/_posts/splay-notes-3.md","shasum":"c2bcc200273ea0ae8fdaccd19a253f1ea35b3fdf","modified":1482823760009},{"_id":"source/_posts/splay-template/zyz.png","shasum":"dfd9927ef6410bf5e7eedd4af19f20b017bed0c5","modified":1482495457801},{"_id":"source/_posts/splay-template.md","shasum":"01c80469eca355dec7733035accf8eb1007aea4e","modified":1482495668207},{"_id":"source/_posts/scoi2007-lizard.md","shasum":"bbe131ab41e3ad9d89f12e81969a7c251c3d358e","modified":1472910683260},{"_id":"source/_posts/spoj-694.md","shasum":"4c02dff2a042a9c83e811f5f8536a361d53d798e","modified":1462959204460},{"_id":"source/_posts/suffix-array-notes.md","shasum":"a14a772250ef5d85308f76c1d08deb2199a705a1","modified":1462959204460},{"_id":"source/_posts/stl-in-oi.md","shasum":"34b0cdda3523f9d31ebf2e404ddd59f27d146eaf","modified":1468498796795},{"_id":"source/_posts/system-of-difference-constraints-notes.md","shasum":"cda796649d3175c93146609b99ba4e753d04c995","modified":1462959204460},{"_id":"source/_posts/tarjan-cut-notes.md","shasum":"314b0e4aea5e91da63fee4f6a449d562c4c3421a","modified":1482994401020},{"_id":"source/_posts/tarjan-scc-notes.md","shasum":"6f64d3531832684226875728ab1bbc4b0995caa5","modified":1482286100826},{"_id":"source/_posts/tjoi2013-lis.md","shasum":"85be6ae0b508baeb46540ffdd5ca250a522254ef","modified":1475883934938},{"_id":"source/_posts/tjoi2013-word.md","shasum":"03f1e85afbb5ba3e61596010715915b24de43fc8","modified":1475883942222},{"_id":"source/_posts/tjoi2015-chessboard.md","shasum":"4755bd1f5c721d893b8e31e3c8ce619ae45ea26f","modified":1477351756791},{"_id":"source/_posts/tyvj-3317.md","shasum":"229a79bbeb50f8efbcf84fea34aec24e3b27dccc","modified":1477351673532},{"_id":"source/_posts/uva-10253.md","shasum":"af4062ce79c9b4f080fe3c35d3be71ef13d0b36d","modified":1462959204460},{"_id":"source/_posts/uva-11021.md","shasum":"5c1c140b3d2a9dc0fa068195ae0ff3a51aaf3e4d","modified":1477351734763},{"_id":"source/_posts/uva-11137.md","shasum":"ab64769680e30fc5456f896dcd7413b5ec7474a2","modified":1477351709280},{"_id":"source/_posts/uva-11174.md","shasum":"343cb90133d9be62c263c27db889c0bf2945b918","modified":1462959204460},{"_id":"source/_posts/uva-11361.md","shasum":"4c2e014fa4d70f2eb75c75e8139fad18fe3c63d5","modified":1477351724619},{"_id":"source/_posts/uva-11375.md","shasum":"3ca8e6535aab2844777ae95ec8b8e10b2864f8f4","modified":1462959204460},{"_id":"source/_posts/uva-11538.md","shasum":"030938457fbe7ab2d5aec2148b7c03acfdf9513b","modified":1462959204460},{"_id":"source/_posts/uva-11538/cells.png","shasum":"3a162829c312a17639950c3620cd70799ed94a49","modified":1462955792600},{"_id":"source/_posts/uva-11806.md","shasum":"e7fe9a9f6f7bb8d32286243d4238f189b9d70734","modified":1462959204470},{"_id":"source/_posts/uva-1362.md","shasum":"6ed0875d87e133e428f77a35f3f4f075b29d3e37","modified":1477351694088},{"_id":"source/_posts/virtualbox-archlinux.md","shasum":"920b51fe7f50d524a368c55db06a84cba0f3df1e","modified":1462959204470},{"_id":"source/_posts/zjoi2004-swamp.md","shasum":"6a255e50f4f5448b3a92fe288954862926e5aa99","modified":1475881729487},{"_id":"source/_posts/zjoi2006-trans.md","shasum":"725146000e1f996a32a1e672e19cb60fc8d7c05f","modified":1464010935316},{"_id":"source/_posts/zjoi2007-chess.md","shasum":"5109dc27f895c80dda495b98392f2e9e51138dc4","modified":1481621022469},{"_id":"source/_posts/zjoi2007-semi.md","shasum":"34804692730f5a3da0032440deb294157e8f37e9","modified":1472946674898},{"_id":"source/_posts/zjoi2007-storage.md","shasum":"67989e9cadbec2172cf844d64d62fd421a57370e","modified":1477351684936},{"_id":"source/_posts/zjoi2008-antbuster.md","shasum":"31c4b1b566f5c4319586c929f4af12c72ea89a3d","modified":1464010030156},{"_id":"source/_posts/zjoi2008-bnb.md","shasum":"ac858ed7f59d732e10122e77ade78baa597169a1","modified":1479002028968},{"_id":"source/_posts/zjoi2008-party.md","shasum":"65c92b713af1a524097ff448a1df0ad004ebcc0b","modified":1479003183231},{"_id":"source/_posts/zjoi2009-ws.md","shasum":"a8570e70c6c8cbe1db3c9fcd61a57d73338e3305","modified":1466677416289},{"_id":"source/_posts/zjoi2010-network.md","shasum":"48bcc635e268cf66d01d9c129388be804bcc8413","modified":1466470152142},{"_id":"source/_posts/zjoi2014-force.md","shasum":"fc88dcd64579695a98932f026cacac9d956141d8","modified":1465695038354},{"_id":"source/about-me.md","shasum":"64fcf2735c0c1b62e25355489c4cf4fa6994a922","modified":1463747969758},{"_id":"source/friends.md","shasum":"1d4316c140821c23d82933c2cc4352c57ab61bcb","modified":1476539032349},{"_id":"source/_posts/docker-sandbox-judger/image.svg","shasum":"6636e4b99b06e88091fecbf1f184ead8c7159475","modified":1481634563080},{"_id":"source/_posts/noi2008-candy/3.svg","shasum":"b23b45b08ec89efce951bb74993a3552785b2fb6","modified":1482480485177},{"_id":"source/_posts/noi2008-candy/5.svg","shasum":"faf0ef012b9602fc7d191eefb46096c6703ed3c3","modified":1482482996268},{"_id":"source/_posts/noi2008-candy/4.svg","shasum":"f43da416f15c7ff2e1561e1a3bac7394a9a054fd","modified":1482481865556},{"_id":"source/_posts/noi2008-candy/6.svg","shasum":"4a8fc6c8636aa2eb311e7c4c87a5a165d7f4ea38","modified":1482484174887},{"_id":"source/_posts/noi2008-candy/7.svg","shasum":"249b838061bf13e3da200bd47bb42bd83c594799","modified":1482484231342},{"_id":"source/_posts/scoi2003-fold.md","shasum":"3aa6ac1189749d23245e8d9aa80da44c17eecd51","modified":1477351878502},{"_id":"source/_posts/virtualbox-archlinux/port.png","shasum":"bb684dd8b616413e3e0e27c5efce118249a54113","modified":1462955792600},{"_id":"source/tags/index.md","shasum":"e999413d6392c34156b5c6e9273f9069f9e6d92d","modified":1473486143025},{"_id":"themes/vno/LICENSE","shasum":"8c84b7a07cef17ed42b549a47eefd71bb97ae698","modified":1482498872106},{"_id":"themes/vno/README.md","shasum":"91538bc2b7ae1d0d8d8046020a5cee7fc8b7b087","modified":1482498872106},{"_id":"themes/vno/layout/_partial/baidu_tongji.ejs","shasum":"95884538b96d25aa73856e2f064832eec09810bd","modified":1482498872106},{"_id":"themes/vno/_config.yml","shasum":"a502619f85676ebdc941b355f55fd890e903c9fe","modified":1482544263701},{"_id":"themes/vno/layout/_partial/comments.ejs","shasum":"d7c4951e8ce9e03314cd809c4611f2637d12589b","modified":1482501390480},{"_id":"themes/vno/layout/_partial/date.ejs","shasum":"7acd28543c62c6a4cdd9a3e49bd1fb77f0e9ab78","modified":1482498872106},{"_id":"themes/vno/layout/_partial/footer.ejs","shasum":"3c4ea282363f11fe290e28708a6695416a46bd04","modified":1482502042236},{"_id":"themes/vno/layout/_partial/google_analytics.ejs","shasum":"eddc6b239bf82409856431d8f0bb5ad8d52ab464","modified":1482498872106},{"_id":"themes/vno/layout/_partial/head.ejs","shasum":"57c9e6a4c4d703252788e1ed5a4ade4cdef6a292","modified":1482544549831},{"_id":"themes/vno/layout/_partial/read-more.ejs","shasum":"ba32e41f121b596bebf65bf6de2a6cff757fb27e","modified":1482501541746},{"_id":"themes/vno/layout/_partial/search.ejs","shasum":"3ad5a4803ad303a9fe7e1575b05953cf5c2dd071","modified":1482545066731},{"_id":"themes/vno/layout/_partial/side-panel.ejs","shasum":"132dcac09cd07c75e43c8bd7e20830515c7a716a","modified":1482581529877},{"_id":"themes/vno/layout/_partial/social.ejs","shasum":"f323157fa9460cb0ec16a1e79ce3e5b6fd6f74bf","modified":1482544016110},{"_id":"themes/vno/layout/_partial/tags.ejs","shasum":"ffcc2844bf1fae8a766e807c316129774bd4ad43","modified":1482498872106},{"_id":"themes/vno/layout/index.ejs","shasum":"e9fb32f778c61145bb1d79fabc9649f876b9bac1","modified":1482499895830},{"_id":"themes/vno/layout/layout.ejs","shasum":"8786e69cf8d5b1b0eadb4637ff908d5ee89e41e9","modified":1482502057561},{"_id":"themes/vno/layout/page.ejs","shasum":"1953ea9eb7c6cb55b137b7d18c5a374f7489d333","modified":1482498872106},{"_id":"themes/vno/layout/post.ejs","shasum":"611286b31e724d59dbbc9723e034b55e3f392f83","modified":1482498872106},{"_id":"themes/vno/source/css/_partial/highlight.styl","shasum":"36eefe6332b86b66023a9884b754d305235846b4","modified":1482498872106},{"_id":"themes/vno/source/css/search.styl","shasum":"b7e15b4f28f46ff39b1bdbc7ed960135094c0cfd","modified":1482544454789},{"_id":"themes/vno/source/css/_animate.styl","shasum":"a2f854fbdc52a5657dd5e2b95cc96c0da32f3ea2","modified":1482498872106},{"_id":"themes/vno/source/css/_variables.styl","shasum":"8d7e3e75cf2e2806ba2aacde9ef9c3626929e3e2","modified":1482498872106},{"_id":"themes/vno/source/css/tomorrow.css","shasum":"5d7e34a8cf77a0e2ec66ce04139da68026fca564","modified":1482500054623},{"_id":"themes/vno/source/css/vno.styl","shasum":"fef9c6a4903e4da401f4ea0dd3a0f0636671240a","modified":1482545193933},{"_id":"themes/vno/source/fonts/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1482498872106},{"_id":"themes/vno/source/fonts/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1482498872106},{"_id":"themes/vno/source/fonts/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1482498872110},{"_id":"themes/vno/source/js/APlayer.min.js","shasum":"5d040dc50af42fec45538a10a7f826e739935278","modified":1482543668791},{"_id":"themes/vno/source/js/embed.js","shasum":"6738e9ee67e520f907e337253beca62c8f0544f7","modified":1482498872118},{"_id":"themes/vno/source/js/insight.js","shasum":"5c5a7ae896ea82682fab0c15405b0880bfa34eca","modified":1482544937012},{"_id":"themes/vno/source/js/main.js","shasum":"43e748aeb132037e27b27d8d1279a4b838d97b38","modified":1482498872118},{"_id":"themes/vno/source/fonts/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1482498872110},{"_id":"themes/vno/source/images/show/google-analytics.jpeg","shasum":"b10396a3162402ea2ff4b42b7b44b518450466e6","modified":1482498872114},{"_id":"source/_posts/virtualbox-archlinux/share.png","shasum":"8f7c7dcf96cf750b6e0098b07fe257cfd65d22f8","modified":1462955792610},{"_id":"source/_posts/splay-notes-1/splay.png","shasum":"ee64a4a43e084b0011003b743a680eb2ec2b9a13","modified":1462955792590},{"_id":"themes/vno/source/images/background-cover.jpg","shasum":"0b04e9bf7e89377952702a0be54569596770f49c","modified":1482498872110},{"_id":"themes/vno/source/images/show/article.jpeg","shasum":"1156f794ea83eae2e5fa485ee5bd3b5b314c957a","modified":1482498872114},{"_id":"themes/vno/source/images/show/baidu_tongji.jpeg","shasum":"76ecad909b266c2c557daaff1f65f7e6ec2135d5","modified":1482498872114},{"_id":"themes/vno/source/fonts/fontawesome-webfont.svg","shasum":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1482498872110},{"_id":"source/_posts/virtualbox-archlinux/network.png","shasum":"23bd9c4bd71642cd4176ae1737e545bc121724f2","modified":1462955792600},{"_id":"source/_posts/virtualbox-archlinux/hotkey.png","shasum":"aca0dac1c68edb971a77b72a0db588f3c034c426","modified":1462955792600},{"_id":"source/_posts/virtualbox-archlinux/terminal.png","shasum":"8960a9c80feac7fefd5894684fdd6d0a174ba426","modified":1462955792610},{"_id":"themes/vno/source/images/show/list.jpeg","shasum":"a49bee3ced7097084cee0b6cd67c935d3cb086ef","modified":1482498872118},{"_id":"source/_posts/virtualbox-archlinux/screenfetch.png","shasum":"edd38d6098ab0cb8d1c6bf35578379f4fd0de96d","modified":1462955792610},{"_id":"themes/vno/source/images/avatar.png","shasum":"c85cb21d1859376a4178d0e5124a441345dd2ebd","modified":1482500250158},{"_id":"themes/vno/source/images/show/home.png","shasum":"90bd2baeb8dfcfd9542cd689766d2bc88ef95ca1","modified":1482498872118},{"_id":"public/js/main.js","modified":1482545286160,"shasum":"43e748aeb132037e27b27d8d1279a4b838d97b38"},{"_id":"public/js/insight.js","modified":1482545286181,"shasum":"5c5a7ae896ea82682fab0c15405b0880bfa34eca"},{"_id":"public/js/embed.js","modified":1482545286185,"shasum":"6738e9ee67e520f907e337253beca62c8f0544f7"},{"_id":"public/js/APlayer.min.js","modified":1482545286187,"shasum":"5d040dc50af42fec45538a10a7f826e739935278"},{"_id":"public/images/show/list.jpeg","modified":1482545286195,"shasum":"a49bee3ced7097084cee0b6cd67c935d3cb086ef"},{"_id":"public/images/show/home.png","modified":1482545286208,"shasum":"90bd2baeb8dfcfd9542cd689766d2bc88ef95ca1"},{"_id":"public/images/show/google-analytics.jpeg","modified":1482545286214,"shasum":"b10396a3162402ea2ff4b42b7b44b518450466e6"},{"_id":"public/images/show/baidu_tongji.jpeg","modified":1482545286217,"shasum":"76ecad909b266c2c557daaff1f65f7e6ec2135d5"},{"_id":"public/images/show/article.jpeg","modified":1482545286221,"shasum":"1156f794ea83eae2e5fa485ee5bd3b5b314c957a"},{"_id":"public/images/background-cover.jpg","modified":1482545286225,"shasum":"0b04e9bf7e89377952702a0be54569596770f49c"},{"_id":"public/images/avatar.png","modified":1482545286231,"shasum":"c85cb21d1859376a4178d0e5124a441345dd2ebd"},{"_id":"public/fonts/fontawesome-webfont.woff","modified":1482545286239,"shasum":"04c3bf56d87a0828935bd6b4aee859995f321693"},{"_id":"public/fonts/fontawesome-webfont.ttf","modified":1482545286241,"shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f"},{"_id":"public/fonts/fontawesome-webfont.svg","modified":1482545286245,"shasum":"46fcc0194d75a0ddac0a038aee41b23456784814"},{"_id":"public/fonts/fontawesome-webfont.eot","modified":1482545286249,"shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e"},{"_id":"public/fonts/FontAwesome.otf","modified":1482545286251,"shasum":"b5b4f9be85f91f10799e87a083da1d050f842734"},{"_id":"public/css/vno.css","modified":1482545287002,"shasum":"ca59d0322543cc53685cdd97993803da08f8f74a"},{"_id":"public/css/tomorrow.css","modified":1482545287171,"shasum":"5d7e34a8cf77a0e2ec66ce04139da68026fca564"},{"_id":"public/css/search.css","modified":1482545287201,"shasum":"ad0ccc87abd4fccb83275745cc9eff3d8a9fc508"},{"_id":"public/virtualbox-archlinux/hotkey.png","modified":1482545287213,"shasum":"aca0dac1c68edb971a77b72a0db588f3c034c426"},{"_id":"public/virtualbox-archlinux/network.png","modified":1482545287217,"shasum":"23bd9c4bd71642cd4176ae1737e545bc121724f2"},{"_id":"public/virtualbox-archlinux/port.png","modified":1482545287219,"shasum":"bb684dd8b616413e3e0e27c5efce118249a54113"},{"_id":"public/virtualbox-archlinux/screenfetch.png","modified":1482545287222,"shasum":"edd38d6098ab0cb8d1c6bf35578379f4fd0de96d"},{"_id":"public/virtualbox-archlinux/share.png","modified":1482545287224,"shasum":"8f7c7dcf96cf750b6e0098b07fe257cfd65d22f8"},{"_id":"public/virtualbox-archlinux/terminal.png","modified":1482545287226,"shasum":"8960a9c80feac7fefd5894684fdd6d0a174ba426"},{"_id":"public/uva-11538/cells.png","modified":1482545287228,"shasum":"3a162829c312a17639950c3620cd70799ed94a49"},{"_id":"public/splay-template/zyz.png","modified":1482545287230,"shasum":"dfd9927ef6410bf5e7eedd4af19f20b017bed0c5"},{"_id":"public/splay-notes-1/splay.png","modified":1482545287232,"shasum":"ee64a4a43e084b0011003b743a680eb2ec2b9a13"},{"_id":"public/sdoi2016-game/line.png","modified":1482545287235,"shasum":"30c24e553938d2c27b55779527825b2577088a7c"},{"_id":"public/sdoi2016-game/tree.png","modified":1482545287237,"shasum":"90bc10409b5ddf29a47ab554e220b1fb152d2f86"},{"_id":"public/noip2016-running/linear-backward1.svg","modified":1482545287242,"shasum":"f11ad00d6b6d9c4a9dbcdd756a54ac9f98aae87c"},{"_id":"public/noip2016-running/linear-forward1.svg","modified":1482545287245,"shasum":"21d1e9f4c290ba36e95ca3d1a3f03108f7e7d08c"},{"_id":"public/noip2016-running/linear-forward2.svg","modified":1482545287247,"shasum":"d828849ead2a7f7a3ac34250ec3e468dd053fe4c"},{"_id":"public/noi2008-candy/1.svg","modified":1482545287248,"shasum":"487bedd4ee907b6af27bc2dff608d7084da67f46"},{"_id":"public/noi2008-candy/2.ggb","modified":1482545287250,"shasum":"b72de255a5a79e92a5a220da592cc30818579ca7"},{"_id":"public/noi2008-candy/2.svg","modified":1482545287251,"shasum":"84a22ca72f6e0ff90dfce05b56f44e7ab66f3cc9"},{"_id":"public/noi2008-candy/3.ggb","modified":1482545287253,"shasum":"7155350e293077d4fd36bd65715ea693ed339c80"},{"_id":"public/noi2008-candy/3.svg","modified":1482545287255,"shasum":"b23b45b08ec89efce951bb74993a3552785b2fb6"},{"_id":"public/noi2008-candy/4.ggb","modified":1482545287256,"shasum":"0c851a79d13d36a0bc06c1360ec5ca3b48e301a2"},{"_id":"public/noi2008-candy/4.svg","modified":1482545287258,"shasum":"f43da416f15c7ff2e1561e1a3bac7394a9a054fd"},{"_id":"public/noi2008-candy/5.ggb","modified":1482545287259,"shasum":"e80d5ff3511748769937e358ca9f213db78a3adc"},{"_id":"public/noi2008-candy/5.svg","modified":1482545287264,"shasum":"faf0ef012b9602fc7d191eefb46096c6703ed3c3"},{"_id":"public/noi2008-candy/6.ggb","modified":1482545287266,"shasum":"b968f70e6224debb5e16b9ea4a1e39ebc2de4834"},{"_id":"public/noi2008-candy/6.svg","modified":1482545287271,"shasum":"4a8fc6c8636aa2eb311e7c4c87a5a165d7f4ea38"},{"_id":"public/noi2008-candy/7.ggb","modified":1482545287276,"shasum":"fbf0ec7e19ee13b534e9aa66ded3170ec449261e"},{"_id":"public/noi2008-candy/7.svg","modified":1482545287281,"shasum":"249b838061bf13e3da200bd47bb42bd83c594799"},{"_id":"public/node-devide-notes/tree1.svg","modified":1482545287289,"shasum":"4de32d5e3b22eb531886d0f9f475f2a9982ee471"},{"_id":"public/node-devide-notes/tree2.svg","modified":1482545287290,"shasum":"407c61fdd3d63b87c5678d80c9b6213781d2cb1f"},{"_id":"public/lyoi-pingfan/pfzl.lrc","modified":1482545287291,"shasum":"cd9495fcc11a3797b90d5b6e34676f412fa64709"},{"_id":"public/haoi2006-sequence/1.svg","modified":1482545287292,"shasum":"0337ba40ba7e2733cc657b79636f5f06e5f7c9a3"},{"_id":"public/haoi2006-sequence/2.svg","modified":1482545287293,"shasum":"57a7cee258306ed3073e46a9e0e79f6485c8f100"},{"_id":"public/docker-sandbox-judger/image.svg","modified":1482545287294,"shasum":"6636e4b99b06e88091fecbf1f184ead8c7159475"},{"_id":"public/cut-tree-notes/cutTree.png","modified":1482545287296,"shasum":"12de28c1f402f876a3826dcd7bfc8525d555ce1e"},{"_id":"public/cf-716e/example.svg","modified":1482545287297,"shasum":"a1d6731f2ef7e43ae48e27345954c6cb24a216b0"},{"_id":"public/bzoj-2683/cdq.png","modified":1482545287298,"shasum":"a95d0b02b915f092df6656298add0f0fc9662341"},{"_id":"public/at-the-cross-of-time/mzr.lrc","modified":1482545287299,"shasum":"25283ad79892beb5c83c43d981fdd32fbee30466"},{"_id":"public/acam-notes/acam.svg","modified":1482545287300,"shasum":"443fe0f8ed15e6b9ef1aadeadef650b8ff57e031"},{"_id":"public/acam-notes/acam2.svg","modified":1482545287305,"shasum":"02f0702387bd40ee0980ea1da05b2eff5fd05ec8"},{"_id":"public/tags/index.html","modified":1482581571382,"shasum":"459b39b53c87d0548b8146d0b7fd7849414680a2"},{"_id":"public/friends/index.html","modified":1482581571421,"shasum":"26aa65f8ccd5846df8aeb3b87a64d93b96e82bbd"},{"_id":"public/about-me/index.html","modified":1482581571438,"shasum":"45abbd78fb7cba79bc3868ce10fbdc5b91db44b3"},{"_id":"public/splay-template/index.html","modified":1483060776256,"shasum":"07fe4e8951453cec7de878c5fecdfd6ef749477e"},{"_id":"public/noi2008-candy/index.html","modified":1482581571647,"shasum":"3cf4b584576f6a091355733aa8a27cf7192f2b7a"},{"_id":"public/docker-sandbox-judger/index.html","modified":1482581571698,"shasum":"63eed2770d7435c38211e84490c47dd1c3155113"},{"_id":"public/zjoi2007-chess/index.html","modified":1482581571733,"shasum":"02707f7bc3821a4529a01ec1ac592fa4587ff60c"},{"_id":"public/haoi2008-rank/index.html","modified":1482581571796,"shasum":"849a244ba230113fd97d2e40cae502b0301db697"},{"_id":"public/haoi2008-move/index.html","modified":1482581571853,"shasum":"b441f98fa0615387c0854a74c24b085638e46b82"},{"_id":"public/haoi2007-ant/index.html","modified":1482581571892,"shasum":"7a50ef540971c42a4113db143f7fc926910634f0"},{"_id":"public/haoi2007-cover/index.html","modified":1482581571937,"shasum":"4761e8d3ccb05d4a31190d0a957ed6e0c3d09d6b"},{"_id":"public/haoi2006-sequence/index.html","modified":1482581571997,"shasum":"bb8c3e1f5e590e48d121077d0928184bc9fda126"},{"_id":"public/haoi2007-separation/index.html","modified":1482581572051,"shasum":"11a70823ed7984505195212cd9a843edbf6cef20"},{"_id":"public/haoi2007-square/index.html","modified":1482581572106,"shasum":"03361f5c2bf221902b7d1673a1b8f1b5b18fa22b"},{"_id":"public/haoi2007-lis/index.html","modified":1482581572147,"shasum":"726c66ed0d3ed8a4b18e6284094c09a304f25dad"},{"_id":"public/noip2016-angrybirds/index.html","modified":1482581572212,"shasum":"872b10165cb7c557aca0154a0afd2115de5b4135"},{"_id":"public/noip2016-earthworm/index.html","modified":1482581572271,"shasum":"15d2507b4094e984c88c18f1734dbbbb535fed4e"},{"_id":"public/noip2016-problem/index.html","modified":1482581572317,"shasum":"36a4ba57ae99a7c3d5c6200324d967c1a7146ddd"},{"_id":"public/noip2016-classroom/index.html","modified":1482581572406,"shasum":"615ff61c3a99c82717485b781908bb0181e191bc"},{"_id":"public/noip2016-running/index.html","modified":1482581572503,"shasum":"5e940e023ae07d5b69688bad719255dcc7d46f9b"},{"_id":"public/noip2016-toy/index.html","modified":1482581572542,"shasum":"27becbe85279e3b4e8712a87d689f6337e077d0f"},{"_id":"public/noip2016/index.html","modified":1482581572573,"shasum":"8b5de897cf8a015c863720ad9d1e8867e1aef4e7"},{"_id":"public/lyoi-pingfan/index.html","modified":1482581572598,"shasum":"5c2e26b05a504c1a72f49d3c6d96d5df0cb72196"},{"_id":"public/noip2012-blockade/index.html","modified":1482581572657,"shasum":"b7c2b4e174680def32b13affd9370e348bbf33b7"},{"_id":"public/noip2010-flow/index.html","modified":1482581572700,"shasum":"56b78f28d628268e4ec58f89ea6ef37014ee2d2c"},{"_id":"public/noip2012-drive/index.html","modified":1482581572850,"shasum":"48293801dd9d8562784eff2988a217c1e2416659"},{"_id":"public/noip2013-puzzle/index.html","modified":1482581572963,"shasum":"0a2ce985914c668a6dc151f76df3097fab656d3a"},{"_id":"public/haoi2008-candy/index.html","modified":1482581573057,"shasum":"fb4ea6cc91ba13f4815a36724fbedc11961e8509"},{"_id":"public/haoi2008-stick/index.html","modified":1482581573120,"shasum":"d2b575379ba46d81a899280cefb18aca2c70bf5b"},{"_id":"public/haoi2008-coins/index.html","modified":1482581573175,"shasum":"ce0d63ab48869ad6fdff9761bf73a4cce97dca43"},{"_id":"public/haoi2008-cir/index.html","modified":1482581573236,"shasum":"0d41f42c0e4fcadf7779cf5f641080e71e0a2a55"},{"_id":"public/zjoi2008-party/index.html","modified":1482581573273,"shasum":"7725c236165d463700e57fd57a7097a95429159d"},{"_id":"public/zjoi2008-bnb/index.html","modified":1482581573304,"shasum":"9ebd19772df81ef77c1eb0035eabaead2a63852c"},{"_id":"public/jsoi2007-repair/index.html","modified":1482581573353,"shasum":"c0f2e90588ad6bad578f3baa063cccce7960ec18"},{"_id":"public/jsoi2007-mahjong/index.html","modified":1482581573396,"shasum":"6d0813b48ee059cbb8667e35161f6960f6e9b455"},{"_id":"public/scoi2009-game/index.html","modified":1482581573460,"shasum":"505e2e696a6530aedd1bae49efbf536758169c71"},{"_id":"public/scoi2009-cake/index.html","modified":1482581573503,"shasum":"34b99a29dbdb63b455752c2d0912cac0526318bf"},{"_id":"public/shoi2008-cactus/index.html","modified":1482581573573,"shasum":"d9ecb092fe91c30ca5e6e94cb22e28b911c0d7eb"},{"_id":"public/ioi2008-island/index.html","modified":1482581573658,"shasum":"080e07cd82af07f04d5690d4562aa9d87c2e2906"},{"_id":"public/noip2015-transport/index.html","modified":1482581573721,"shasum":"7c12d58cab2bce4515fb6eccf6b16351b174604e"},{"_id":"public/noip2015-substring/index.html","modified":1482581573786,"shasum":"4539eadec684470dcfacd68b78320b4308e6a788"},{"_id":"public/noip2015-landlords/index.html","modified":1482581573863,"shasum":"1991b0fe69ab341e5d40570901b86c3f633c2f60"},{"_id":"public/noip2014-equation/index.html","modified":1482581573904,"shasum":"95536acb3ed1f8cb4525d7823e29f3a561791e6a"},{"_id":"public/shoi2008-john/index.html","modified":1482581573935,"shasum":"ac30778a0228c88cd9521080943acb0582d30774"},{"_id":"public/shoi2008-debt/index.html","modified":1482581573992,"shasum":"889e3165fa31d456fa33b0445394e7f1a1db6e52"},{"_id":"public/shoi2008-hannoi/index.html","modified":1482581574033,"shasum":"658ebd75aedcd52d74c15d374aedb5d55260cfca"},{"_id":"public/shoi2008-traffic/index.html","modified":1482581574100,"shasum":"497036f4914c80acafa33194aa388920f64d948a"},{"_id":"public/jsoi2008-award/index.html","modified":1482581574168,"shasum":"0d8b0d55affb934a3736945524a45fd8b4f99a72"},{"_id":"public/jsoi2008-starwar/index.html","modified":1482581574213,"shasum":"833e3ac1df87d3e0a7918494e076c50ac1c67a80"},{"_id":"public/jsoi2008-prefix/index.html","modified":1482581574280,"shasum":"233e8dd4e64ec3176a3350cf8a315d44f33f5393"},{"_id":"public/hnoi2008-kingdom/index.html","modified":1482581574324,"shasum":"71b5ff1e0ec7a8fc9a938a37a5266f82d9114520"},{"_id":"public/hnoi2008-cards/index.html","modified":1482581574458,"shasum":"4bbea160674bea349aafaeda446e801926b9c83d"},{"_id":"public/fjoi2007-wheel/index.html","modified":1482581574690,"shasum":"adbb87fc32b1e3215c81c321a37e4868d50e6054"},{"_id":"public/noip2013-flower/index.html","modified":1482581574742,"shasum":"93256e788e202b36d57a95ab453c26668ba64fa9"},{"_id":"public/noip2013-match/index.html","modified":1482581574815,"shasum":"b1f07490c9c3237c4831e6af1627d7e0c7e4d2d1"},{"_id":"public/hnoi2008-tree/index.html","modified":1482581574891,"shasum":"2dddc0a0141854ad18d1be9f7f156815185ff488"},{"_id":"public/noip2014-bird/index.html","modified":1482581574996,"shasum":"55fbda7c54fed6997d2d0dc0a6372b784f9aa3dc"},{"_id":"public/noip2012-classrooms/index.html","modified":1482581575187,"shasum":"674127f1120a9b8da3e5f5cb1d769602053043a2"},{"_id":"public/tjoi2015-chessboard/index.html","modified":1482581575283,"shasum":"524b91829c71c47cea09a53b3279372da59e769f"},{"_id":"public/noi2012-random/index.html","modified":1482581575342,"shasum":"4c60e8119f654bb1e1d60573e84d4784ecdff197"},{"_id":"public/bzoj-1706/index.html","modified":1482581575418,"shasum":"3f273a5e7d032d1835d631a2f0a85d93863dc9a9"},{"_id":"public/zjoi2004-swamp/index.html","modified":1482581575476,"shasum":"88e8c116df4dcf98e059c440ca255365be3f86a6"},{"_id":"public/hnoi2008-gt/index.html","modified":1482581575530,"shasum":"c7540fbfdf43fb58e63aa7c2ab27e1b3ee10a2a0"},{"_id":"public/hdu-5906/index.html","modified":1482581575656,"shasum":"a04dae7cc2b99ef6e99e7025157ae924ef0e9afc"},{"_id":"public/bzoj-3796/index.html","modified":1482581575752,"shasum":"5565578f8c6601c44d8a62a2b5ebebdd0260841a"},{"_id":"public/bzoj-3277/index.html","modified":1482581575866,"shasum":"79426f3662ac7cadb82df2411a1d4df52a2f2893"},{"_id":"public/bzoj-3230/index.html","modified":1482581576000,"shasum":"484cb6acb6c3dead9be2975eb1652de974693ee9"},{"_id":"public/bzoj-1692/index.html","modified":1482581576109,"shasum":"6175810dffd18042d9672e551b0fbf1579565d1a"},{"_id":"public/scoi2012-name/index.html","modified":1482581576242,"shasum":"c2632dc9a5502274b10ab4bd616cded7f7b9c0fc"},{"_id":"public/ahoi2013-diff/index.html","modified":1482581576324,"shasum":"cafcb7fa5e63c6d4568766f0ac7eaee2d06480ba"},{"_id":"public/jsoi2007-cipher/index.html","modified":1482581576371,"shasum":"06a9aa448115ceb483e7ef27a852a9df0d5ad55e"},{"_id":"public/cf-716e/index.html","modified":1482581576446,"shasum":"129924db86334665fc977737f7821d05521ef8a7"},{"_id":"public/acam-notes/index.html","modified":1482806508162,"shasum":"76bb35a4ef6316fe3eb9ac7e7417463e7650afd8"},{"_id":"public/jsoi2009-game2/index.html","modified":1482581576568,"shasum":"e55202014e08edb24a7c6ab911b1e8cfe4e46775"},{"_id":"public/bzoj-3881/index.html","modified":1482581576639,"shasum":"7541f1db40eb7864fd8087011ca24947865d7862"},{"_id":"public/bzoj-2580/index.html","modified":1482581576682,"shasum":"52b28838f0d61d8cda684b5279ddd28e39f88d52"},{"_id":"public/bzoj-3940/index.html","modified":1482581576726,"shasum":"fbdc535d8669b1ac98bae823c843c35d8e2be1ab"},{"_id":"public/bzoj-2462/index.html","modified":1482581576767,"shasum":"2e9c93a5056783ecd118563c83695eb8f7cd42d3"},{"_id":"public/poi2000-wir/index.html","modified":1482581576815,"shasum":"15e25475ea63388a15514c9264cd10256940c8de"},{"_id":"public/hnoi2004-language/index.html","modified":1482581576851,"shasum":"804433822e49b5c4c2a67a6367b95de9c764bf77"},{"_id":"public/noi2011-type/index.html","modified":1482581576909,"shasum":"f363e148af28c0be7a1c2c95d6309abecb1e2839"},{"_id":"public/jsoi2007-generator/index.html","modified":1482581576949,"shasum":"0800e7fec988838ecd1da638b4a6ab1a8e712523"},{"_id":"public/tjoi2013-word/index.html","modified":1482581577007,"shasum":"d4af3bda44436a73061dc7af2b620d3bec6731e1"},{"_id":"public/tarjan-cut-notes/index.html","modified":1482994459175,"shasum":"08c15a4085146334cc233543052974404ca4d476"},{"_id":"public/noi2016-grid/index.html","modified":1482581577207,"shasum":"e61ac1a9c87869954f3686bc74e13ac7dd3be799"},{"_id":"public/poi2008-blo/index.html","modified":1482581577263,"shasum":"0f716457fae4ba93eb6940502baf70bfa2dff122"},{"_id":"public/hnoi2012-mine/index.html","modified":1482581577303,"shasum":"be95b4ac0d2e2fcd693358c2c8ac26582111cf75"},{"_id":"public/noi2016-excellent/index.html","modified":1482581577352,"shasum":"99edee019620bd223f331ff0467d15d77a84644e"},{"_id":"public/noi2016-interval/index.html","modified":1482581577397,"shasum":"fc187a4cb39bb74a4c425fdf52d1affabb466a4c"},{"_id":"public/sdoi2013-rforest/index.html","modified":1482581577479,"shasum":"41351b1b9f052eba214eda5dc2967af19ae227c5"},{"_id":"public/zjoi2007-semi/index.html","modified":1482581577541,"shasum":"5f6f590146134acac74b108ebd37291b36c05c80"},{"_id":"public/bzoj-3280/index.html","modified":1482581577605,"shasum":"489e7505cdedddfd4a3a631c07b6cd2f31e20ed4"},{"_id":"public/scoi2007-lizard/index.html","modified":1482581577662,"shasum":"5887d06ccdb319c17e188d6c8e7a0cde415f048b"},{"_id":"public/sdoi2014-journey/index.html","modified":1482581577722,"shasum":"9c27056d8cf33df1b02b01eaea508ba6f583f6d3"},{"_id":"public/sdoi2008-interval/index.html","modified":1482581577758,"shasum":"d9f564f3d4b16b10dc74ef600a519e414ba969b5"},{"_id":"public/at-the-cross-of-time/index.html","modified":1482581577799,"shasum":"5b4e3145af4f49cdd1cb1a678fb25ed812c7e08a"},{"_id":"public/noi2014-forest/index.html","modified":1482581577844,"shasum":"271c7d71cffa8fe5dcec72607367aa9b0110cb3a"},{"_id":"public/noi2014-zoo/index.html","modified":1482581577890,"shasum":"b30ecaed4cf15ef357697165f7e2c79dddbed76d"},{"_id":"public/bzoj-4145/index.html","modified":1482581577923,"shasum":"d6902288bd1e8afa388b3aa7e93ac2bd1968f256"},{"_id":"public/bzoj-4247/index.html","modified":1483060781618,"shasum":"725ae24d708f8efe4c67a0780a8949024f9043b0"},{"_id":"public/heoi2013-bag/index.html","modified":1483060781703,"shasum":"54dfb659fdcf5b892f47704924482ee51e1996a6"},{"_id":"public/jsoi2008-dotr/index.html","modified":1483060781667,"shasum":"be7e674a7f6e1d5ff2c2ef08ae31682f8166cab7"},{"_id":"public/scoi2009-paint/index.html","modified":1483060781736,"shasum":"ce60e45cd2b4133c33d6f1f828117d0d61310be2"},{"_id":"public/bzoj-1334/index.html","modified":1482581578105,"shasum":"9998205f31eaa19fcceeed80d87187f7f8236ddb"},{"_id":"public/hnoi2010-chorus/index.html","modified":1482581578140,"shasum":"7c2a44ead5605f26a66a8daad55bc68aba2266e8"},{"_id":"public/scoi2003-fold/index.html","modified":1482581578179,"shasum":"c82706e81578e91d3fdff343a0d3c36217e0fd24"},{"_id":"public/haoi2008-name/index.html","modified":1482581578241,"shasum":"7e3e41d7265da0a3b711b18f4a33d84347fabe18"},{"_id":"public/noi2015-dinner/index.html","modified":1482581578313,"shasum":"ef3d882effd0fbe5df3f73ca7dea2fbf8120bc8d"},{"_id":"public/noi2015-epic/index.html","modified":1482581578356,"shasum":"9b6810d3ed6d36416ea8e140218406c49584fe57"},{"_id":"public/noi2015-farm/index.html","modified":1482581578485,"shasum":"3622d25fd40ae418245057e2bcb13db96d6c991b"},{"_id":"public/noi2015-savour/index.html","modified":1482581578557,"shasum":"49025f8c9fb05c419cea61b00e940c5bb8f20739"},{"_id":"public/bzoj-2438/index.html","modified":1482581578600,"shasum":"2e62ddaf22497390e51df028e3e83eef62937cc4"},{"_id":"public/bzoj-2716/index.html","modified":1482581578667,"shasum":"6be8c389209a55e50c361ecee8449d457b066952"},{"_id":"public/shoi2007-tree/index.html","modified":1482581578708,"shasum":"a51115eeb889c643364488c25feabe2c6dea8df6"},{"_id":"public/zjoi2009-ws/index.html","modified":1482581578756,"shasum":"41424a450e8dbab22b140d9ccd98ea4396909495"},{"_id":"public/bzoj-2132/index.html","modified":1482581578804,"shasum":"76605d4ca8f177690c39b7f4217db14fb42f82b7"},{"_id":"public/poi2005-kos/index.html","modified":1482581578860,"shasum":"48c42a25bb9592171a261a2e7e02acc8e5318b1b"},{"_id":"public/poi2006-szk/index.html","modified":1482581578909,"shasum":"bffc3fdcccc6a017315fdcd9d62c20e7eb3b1768"},{"_id":"public/bzoj-1585/index.html","modified":1482581578962,"shasum":"2a50544c67621a2fdb9ac52c2696fbbc4d16a870"},{"_id":"public/ceoi2008-order/index.html","modified":1482581579018,"shasum":"1540709228014ee87b9ade75191930aba376d4a9"},{"_id":"public/bzoj-1711/index.html","modified":1482581579061,"shasum":"9137094bdaa1a16f42ba5240aff9e81985b2e66f"},{"_id":"public/sdoi2009-run/index.html","modified":1482581579114,"shasum":"bea8ca814016b279d47c0286296cb12e8fb1b935"},{"_id":"public/bzoj-3894/index.html","modified":1482581579168,"shasum":"67aa9eb20e1637395dc3207bab25a9e226f3096e"},{"_id":"public/bzoj-2127/index.html","modified":1482581579229,"shasum":"95711e936aabb85941332c474e031bdb4f4c558f"},{"_id":"public/bzoj-3438/index.html","modified":1482581579274,"shasum":"444e10b0ce61e35946401517b1850bbce3a859c9"},{"_id":"public/shoi2007-vote/index.html","modified":1482581579328,"shasum":"6cbc5dc3af032f48af32190c000fe24d0fbe1a72"},{"_id":"public/zjoi2010-network/index.html","modified":1482581579373,"shasum":"f36f9eee0768eb684e042228bde6d09c82655caa"},{"_id":"public/cqoi2011-inverse/index.html","modified":1482581579426,"shasum":"a95dd1483f3dcc28488a5a71a39cde0186238bbb"},{"_id":"public/bzoj-1176/index.html","modified":1482581579478,"shasum":"5aca13d0777b881266ff645439c4e4c6f15b44e9"},{"_id":"public/sdoi2010-goblin/index.html","modified":1482581579521,"shasum":"89553d6e272f143e65a52deadfa184f904f61e79"},{"_id":"public/bzoj-3262/index.html","modified":1482581579571,"shasum":"8bb9be1658a176d70a292e546cb8d9f3dbf0b8d3"},{"_id":"public/bzoj-3196/index.html","modified":1482581579678,"shasum":"0f2903c18959debd11a1a99b24cb03d977dc7c1d"},{"_id":"public/bzoj-2456/index.html","modified":1482581579719,"shasum":"cea22c1265e46ad7398276bf91c492df887b6eb5"},{"_id":"public/fft-to-ntt/index.html","modified":1482581579780,"shasum":"6f965537d8093b0bf5f7a32f9397393ab9905a1c"},{"_id":"public/node-devide-notes/index.html","modified":1482581579831,"shasum":"3bb99f7be2e26a1c0973d39881b608ff47b72090"},{"_id":"public/ioi2011-race/index.html","modified":1482581579873,"shasum":"4b566a015ed0b8fbc123e212af6031c84ec916a1"},{"_id":"public/bzoj-3365/index.html","modified":1482581579919,"shasum":"374c7b0015fc4687c4cf9fdf53df0b7e9d711a2f"},{"_id":"public/bzoj-3697/index.html","modified":1482581579968,"shasum":"c2d1919e1bd27815ec888fb8cae2bf8be575c8a8"},{"_id":"public/bzoj-2152/index.html","modified":1482581580016,"shasum":"cae0d9f055f2d2270b2bbee4491c2af1a5ba16f0"},{"_id":"public/bzoj-1468/index.html","modified":1482581580078,"shasum":"c632731bed0b52e7a43ebebb56694b088c2e6c96"},{"_id":"public/sdoi2011-calc/index.html","modified":1482581580139,"shasum":"4dc66936bac4e400f32e306f34cc2c2ee67cc0c3"},{"_id":"public/bsgs-notes/index.html","modified":1482581580272,"shasum":"a8a685f3ae14b0483a4e64c3e64c5d6238d7e6af"},{"_id":"public/sdoi2015-sequence/index.html","modified":1482581580345,"shasum":"271ec7ac025ed0b90edb741dbe985764b9347249"},{"_id":"public/zjoi2014-force/index.html","modified":1482581580399,"shasum":"18746b4e338da8e40ba753f8df5606953d713d29"},{"_id":"public/bzoj-2194/index.html","modified":1482581580458,"shasum":"313bec53b461d27f5177d864ef9be039203a0d31"},{"_id":"public/fft-notes/index.html","modified":1482581580615,"shasum":"b567e73a442fdd78132ff5047426a2544033e2cf"},{"_id":"public/uva-11021/index.html","modified":1482581580651,"shasum":"5f0183da3b1d8fa70de2abe153e456d82ea80d0a"},{"_id":"public/bzoj-4318/index.html","modified":1482581580709,"shasum":"b6c62d28773df0c2c7d33366e956fb0194d29e2f"},{"_id":"public/20160527-array/index.html","modified":1482581580760,"shasum":"6bb595ab7f28b95a4616c1bb6f0849282726ad98"},{"_id":"public/bzoj-3275/index.html","modified":1482581580813,"shasum":"257ca91813478293fff395b2ee0a8357b468629e"},{"_id":"public/zjoi2006-trans/index.html","modified":1482581580865,"shasum":"78631b527ffd9b9c40fac437cee8b4ae34746409"},{"_id":"public/zjoi2008-antbuster/index.html","modified":1482581580924,"shasum":"8bb6e7a10a50369b767b8951db24af47eb11ba4a"},{"_id":"public/bzoj-3156/index.html","modified":1482581580968,"shasum":"875b3ce1b74e544e2f3bea3eccc56b1d7fbeb481"},{"_id":"public/ceoi2004-two/index.html","modified":1482581581012,"shasum":"bf01db3a0684e14a8a301dd1cfd3bcbee5bf18c7"},{"_id":"public/bzoj-1597/index.html","modified":1482581581085,"shasum":"105603afb10cf5b8308bc1bfc4b0c599ef309cb3"},{"_id":"public/zjoi2007-storage/index.html","modified":1482581581197,"shasum":"bb31770f7e082807fb78089aaa2fc82ca99e22ef"},{"_id":"public/apio2010-commando/index.html","modified":1482581581275,"shasum":"b1ec7e941e0136eca6f04b953e521568e672093b"},{"_id":"public/hdu-5632/index.html","modified":1482581581330,"shasum":"a6f15f5d2a6d30c63bce0c5f2eaf522a15d07c0a"},{"_id":"public/scoi2009-windy/index.html","modified":1482581581361,"shasum":"8d4914e461ab6f8e4c0fc06b9f11a96647cf2580"},{"_id":"public/cf-628d/index.html","modified":1482581581407,"shasum":"68d8bddb1c4af82e6dbbc7b458faff69988107e5"},{"_id":"public/hdu-2089/index.html","modified":1482581581439,"shasum":"66b04b0797fac2f18345f04f1d788f55b0b4f8cc"},{"_id":"public/hdu-5642/index.html","modified":1482581581469,"shasum":"06a7534439ad8a182037af3f310987ed6aed52e7"},{"_id":"public/chairman-tree-notes/index.html","modified":1482581581526,"shasum":"33a5fe857ee8b51b89f2fff62b2a2886995c8efb"},{"_id":"public/hnoi2016-tree/index.html","modified":1482581581594,"shasum":"7b40d3612c8e403d5bfab51878403f74b0a125bb"},{"_id":"public/hnoi2016-network/index.html","modified":1482581581658,"shasum":"b75f955987de773f2e2766622f4ee5a683789260"},{"_id":"public/hnoi2016-multiple/index.html","modified":1482581581703,"shasum":"1744ccd5b03db368852f37facd737e2473c48c8e"},{"_id":"public/ctsc-apio-2016/index.html","modified":1482581581738,"shasum":"e2c3de7be2b61b765bb8f729824b4c2ba4a79a68"},{"_id":"public/mo-algorithm-notes/index.html","modified":1482581581773,"shasum":"0ca30ff03ba24fd78be885cf2b4862df1d07b221"},{"_id":"public/hnoi2016-sequence/index.html","modified":1482581581876,"shasum":"3736580f7f8e549f5fa2fee6b807332acf488d90"},{"_id":"public/haoi2016-chain/index.html","modified":1482581581981,"shasum":"dcc76d738710dec61dda9f9b8dd1ddc679283260"},{"_id":"public/jsoi2009-game/index.html","modified":1482581582051,"shasum":"782772d1bfd5235d9d9c5e667d7d1b9418472609"},{"_id":"public/hnoi2008-toy/index.html","modified":1482581582107,"shasum":"62c95d4fa2d0cd62fcd2067568645b306fcb1ba7"},{"_id":"public/jsoi2016-flight/index.html","modified":1482581582172,"shasum":"7ce54309b2546e01cdbd5d0ac4071107e6e1432a"},{"_id":"public/cqoi2016-number/index.html","modified":1482581582220,"shasum":"2b241b1a0a6d1c0986a9c08775f4dcc61a611d7b"},{"_id":"public/cqoi2016-cuts/index.html","modified":1482581582276,"shasum":"92d766e07ec66157bc5ff6c016ceaaba8180e192"},{"_id":"public/jsoi2016-light/index.html","modified":1482581582337,"shasum":"901eaf8daa8ff9778f363fc3fa6f0223dad167a7"},{"_id":"public/sdoi2016-table/index.html","modified":1482581582426,"shasum":"25e47c2660c7a70d6ff5ae27a3129a90586e7b89"},{"_id":"public/sdoi2016-journey/index.html","modified":1482581582501,"shasum":"93b89cf646f205dc82ddfe92c64716f87d984cdf"},{"_id":"public/sdoi2016-game/index.html","modified":1482581582575,"shasum":"def822b33fd6658b07b04b4d791064b585c6826f"},{"_id":"public/derangement-number/index.html","modified":1482581582605,"shasum":"cf1cf00c82eb2f1e7d5094ad599f4e3be64dccbe"},{"_id":"public/mul-inverse/index.html","modified":1482581582659,"shasum":"73affb6f3ae10bdb1c18d3e8b574d7c520ea22f6"},{"_id":"public/sdoi2016-permutation/index.html","modified":1482581582702,"shasum":"3137a05c4846cc1d9d9566dea519b38f7102a05b"},{"_id":"public/sdoi2016-incantation/index.html","modified":1482581582758,"shasum":"b5526b9242bfee0954c15b350a9db7121bb69cb0"},{"_id":"public/spoj-694/index.html","modified":1482581582823,"shasum":"3dcdecec71a3eed485117955c0eb70cc6d2db1cb"},{"_id":"public/suffix-array-notes/index.html","modified":1482581583013,"shasum":"d2ad8143b54844251a72a5f8ca97838644c221c6"},{"_id":"public/sdoi2016-round1/index.html","modified":1482581583062,"shasum":"2e9e6e69a505e0ec69531b43eb0dab5b9d007476"},{"_id":"public/poj-3461/index.html","modified":1482581583103,"shasum":"59a124d3f7d316e11339324044774ff38853c75d"},{"_id":"public/sdoi2016-pair/index.html","modified":1482581583170,"shasum":"541772dc61c5b33e52c2b2c8cb59f489b4bf94b5"},{"_id":"public/bzoj-4403/index.html","modified":1482581583217,"shasum":"61deb76c4819c99cc0f42783b799568883c581ac"},{"_id":"public/ahoi2014-story/index.html","modified":1482633935596,"shasum":"17a9fb7d0ed65e53a9f6a79f914f2da049f13142"},{"_id":"public/non-recursion-dfs-with-stack/index.html","modified":1482581583309,"shasum":"5eb2dc7b1e9027d7ce13fc3dd0a804a03e7d7daa"},{"_id":"public/euler-sieve/index.html","modified":1482581583376,"shasum":"8a134b97ef3d313414fbe1a3af52407238ad8849"},{"_id":"public/haoi2011-problemb/index.html","modified":1482581583439,"shasum":"4e12a9d06e606d62e0624d54920b517db4fe1663"},{"_id":"public/bzoj-2820/index.html","modified":1482581583519,"shasum":"3de444e3a5fcaebe278d5a481ab75ace65aafc77"},{"_id":"public/bzoj-3511/index.html","modified":1482581583573,"shasum":"e8c0272edca8923a6aab28ef1d63417e3742c9a5"},{"_id":"public/bzoj-1008/index.html","modified":1482581583617,"shasum":"71d1d96cd8c1fb58e71a693000d343a16517166d"},{"_id":"public/20160404-theory/index.html","modified":1482581583691,"shasum":"395063f13eae4f056868f26be3fa96e0da55aa1c"},{"_id":"public/tjoi2013-lis/index.html","modified":1482581583735,"shasum":"d295a2ca2da4d528c5cbec97c8b627171febe008"},{"_id":"public/bzoj-1001/index.html","modified":1482581583786,"shasum":"4da9db4540abea6a8c8c3a64c4bc57e79ff083d3"},{"_id":"public/noi2014-sleep/index.html","modified":1482581583834,"shasum":"0405be7c7dba1ec8f0908237c4b64884ff1f5287"},{"_id":"public/haoi2015-t2/index.html","modified":1482581583958,"shasum":"7b99062d410f41ea007d88e67be3393e666e3b00"},{"_id":"public/bzoj-2296/index.html","modified":1482581584005,"shasum":"d2edba8c219ed354eab1bb35daf829d824b6d89b"},{"_id":"public/bzoj-2038/index.html","modified":1482581584053,"shasum":"916850b62df6362f3a3ef38335a3312fef3a6942"},{"_id":"public/20160331-naive/index.html","modified":1482581584100,"shasum":"2be5f0ad2ef09d00cf5828fa4dd476e695f31319"},{"_id":"public/scoi2015-password/index.html","modified":1482581584182,"shasum":"acd03d19bbf0157dbd456208962b576014a48d3d"},{"_id":"public/scoi2015-light/index.html","modified":1482581584256,"shasum":"a39712cd12d3dd28e6608b3d8278783b64e3d070"},{"_id":"public/bzoj-2143/index.html","modified":1482581584311,"shasum":"241b1b95edfecffed61c24d9ff8e6f7479aab58c"},{"_id":"public/scoi2015-flag/index.html","modified":1482581584368,"shasum":"186e76ac705017cac14bdeba4934edb5827f8b3d"},{"_id":"public/scoi2015-message/index.html","modified":1482581584421,"shasum":"d0f0834d860653aa821e8e017256cf55139b2598"},{"_id":"public/scoi2015-matrix/index.html","modified":1482581584474,"shasum":"d7aed22be8d62db8b8ee99e3ce7d9aa44f138a9e"},{"_id":"public/20160318-color/index.html","modified":1482581584537,"shasum":"e650cc43b4f6930d298730a4a3f0b25a7ae47048"},{"_id":"public/20160319-candy/index.html","modified":1482581584575,"shasum":"6451108322c97bb0d09a4364a567dbe42089cdfe"},{"_id":"public/20160319-set/index.html","modified":1482581584630,"shasum":"f8c0668eaa88ba5c2db3cbadaa48ce629681bda1"},{"_id":"public/sdoi2008-cave/index.html","modified":1482581584696,"shasum":"f0f23fd24044dadb33d4c569e6edfaae11ed4965"},{"_id":"public/combinatorics-notes/index.html","modified":1482581584975,"shasum":"10aceeec8bc61a8e9410f77b36cca6344b14302e"},{"_id":"public/uva-10253/index.html","modified":1482581585029,"shasum":"6670d9e222effe87867cd6526beeb606dbe7d7cd"},{"_id":"public/uva-11361/index.html","modified":1482581585083,"shasum":"b5c9d0aa7a5fccadb10730cba7d4e2615f619d12"},{"_id":"public/bigint-template/index.html","modified":1482581585130,"shasum":"f71c8dc7849bde5272eaa4d682e4154cf9f4fc24"},{"_id":"public/uva-1362/index.html","modified":1482581585179,"shasum":"0a9be226684f5937d7e13a77594f1d01b0bb14e4"},{"_id":"public/poj-1737/index.html","modified":1482581585236,"shasum":"6db2e46b1f7e3b1f04bb23d3a0c1c4326c0651a0"},{"_id":"public/uva-11174/index.html","modified":1482581585295,"shasum":"eb437850b0fc919f2699c27980335ae8ed85ad60"},{"_id":"public/uva-11137/index.html","modified":1482581585329,"shasum":"cc509b154583a9cc59ed582f64d78f1dd381d66b"},{"_id":"public/uva-11375/index.html","modified":1482581585363,"shasum":"b02100bf6fbc04af4a81ab4a76fccd3f167e31e7"},{"_id":"public/uva-11538/index.html","modified":1482581585406,"shasum":"7d757eca50ed394d12c63a839fef68117f10ed7f"},{"_id":"public/uva-11806/index.html","modified":1482581585442,"shasum":"fe49e3a8ecaed510299cc56f379ad2597c1e37d1"},{"_id":"public/poj-2728/index.html","modified":1482581585494,"shasum":"ecffdbe244871b4e2ed4b98359eae4da6a18a727"},{"_id":"public/apio2009-atm/index.html","modified":1482581585572,"shasum":"87ed6015735deac4c55cd5c3906caf98e4fd8f1c"},{"_id":"public/noi2006-profit/index.html","modified":1482581585639,"shasum":"bc0b1c1c39e7cdf0dc92afdf627a21d5ebeac99d"},{"_id":"public/scoi2007-repair/index.html","modified":1482581585693,"shasum":"d6cbc55798ec3ba3bbc283dca8ab457705339d99"},{"_id":"public/ahoi2008-meet/index.html","modified":1482581585753,"shasum":"8522df2775b126b5a1114c81d65ec9bbb34d6629"},{"_id":"public/scoi2010-game/index.html","modified":1482581585788,"shasum":"6b86efc60408f2489dd249d4b049e053be012de4"},{"_id":"public/virtualbox-archlinux/index.html","modified":1482581585839,"shasum":"737d1793d3a0581dd54819528ab8d97fc4c0d83a"},{"_id":"public/noi2003-editor/index.html","modified":1482581585891,"shasum":"43efd055d8b91df92655420b486404b580093973"},{"_id":"public/scoi2011-candy/index.html","modified":1482581585949,"shasum":"70ac0fd64f065344805a221943dd46b4ce711305"},{"_id":"public/haoi2006-cow/index.html","modified":1482581585984,"shasum":"e3ac40f390320126791ae6fdeb650846b1a5b89d"},{"_id":"public/codevs-2822/index.html","modified":1482581586036,"shasum":"1de31a6bea5db68c8bb63b5048540bc906658544"},{"_id":"public/tarjan-scc-notes/index.html","modified":1482581586094,"shasum":"0b6861b22b7a5b6a9e954427cec13971617a8785"},{"_id":"public/sdoi2010-starrace/index.html","modified":1482581586169,"shasum":"ee0555e571258efdf93dfefe6a4abf77f87015eb"},{"_id":"public/sdoi2015-war/index.html","modified":1482581586303,"shasum":"97c9ad617c38289f7e29c46627a4ca40483c63c3"},{"_id":"public/cogs-741/index.html","modified":1482581586385,"shasum":"c29309cf44b6824a4f0cb72b34340018fc2b0055"},{"_id":"public/cogs-740/index.html","modified":1482581586475,"shasum":"422348b4034912b13d079e3af167eccec1a7ae81"},{"_id":"public/ctsc1999-home/index.html","modified":1482581586539,"shasum":"83b7473ab5c067b4fb4a00705bddfc7dfbbaf85f"},{"_id":"public/cogs-742/index.html","modified":1482581586580,"shasum":"1f509b1e538c8630a1445c34de596d3ea8a35c26"},{"_id":"public/cogs-739/index.html","modified":1482581586635,"shasum":"43a9b253b8693d0436b228d4571be0d4e16cdd71"},{"_id":"public/jsoi2008-maxnumber/index.html","modified":1482581586695,"shasum":"9685312c60dc3d42c685cac41d25ab9508bdde50"},{"_id":"public/edmonds-karp-notes/index.html","modified":1482635180429,"shasum":"17b0fa962b021ea92aa3745f2afcea813854b1e1"},{"_id":"public/noip2010-prison/index.html","modified":1482581586803,"shasum":"f43d464e19cc531447632378fe63b1f5ef97fdf9"},{"_id":"public/cogs-746/index.html","modified":1482581586853,"shasum":"82c01dc9beaa26e578b1ea39324c78bba7c6e401"},{"_id":"public/cogs-738/index.html","modified":1482581586906,"shasum":"40d7cb8dd82689e646253b64db400231773e0929"},{"_id":"public/cogs-734/index.html","modified":1482581586940,"shasum":"17f8628018c5e3f2f34e9d6bad2d53eef9ff8ee3"},{"_id":"public/cogs-439/index.html","modified":1482581586988,"shasum":"c9c31d6528db260ca10f5b9d025be047f5677e5e"},{"_id":"public/cogs-727/index.html","modified":1482581587031,"shasum":"ee7a0e6c56bc55f6b7c05a2c257d43ba2699f6ac"},{"_id":"public/cogs-731/index.html","modified":1482581587137,"shasum":"bc8a02628c6fcb9c6d2635135a3d72361967db70"},{"_id":"public/cogs-729/index.html","modified":1482581587192,"shasum":"d33ec1f5a0a5925267c6d7a67277cdeb49eb8f03"},{"_id":"public/cogs-396/index.html","modified":1482581587236,"shasum":"315642b827e876aca3b90837a437a2fdc5e4f9ac"},{"_id":"public/cogs-728/index.html","modified":1482581587284,"shasum":"b3be222c54dbbadb43937a335454fbe90452e702"},{"_id":"public/cogs-14/index.html","modified":1482581587345,"shasum":"927c2ba6389866849f424e4d2b37186e1d17055f"},{"_id":"public/bzoj-2683/index.html","modified":1482581587390,"shasum":"bfca7ce4165f7859659a3df8eb47dffd5573937e"},{"_id":"public/codevs-1563/index.html","modified":1482581587427,"shasum":"c01c71c99dd080e4c720e0ee55caf31d4a19ba73"},{"_id":"public/gnu-debugger/index.html","modified":1482581587477,"shasum":"e13633645e824cd10ad23779548acd22aa496cad"},{"_id":"public/dinic-notes/index.html","modified":1482585268122,"shasum":"506605ce14ee70a3be81d869b1d022ba4ace707f"},{"_id":"public/bzoj-1756/index.html","modified":1482581587709,"shasum":"d73fd1dfc2feb2747b2a81ff857182e83c9b1f03"},{"_id":"public/noi2004-cashier/index.html","modified":1482581587797,"shasum":"02f7eed21bbdc613c20eaf3cf19d0765c967e37d"},{"_id":"public/bzoj-1477/index.html","modified":1482581587869,"shasum":"ba222c594bff2c435e52d7d6e69b198926d60469"},{"_id":"public/noi2015-manager/index.html","modified":1482581587951,"shasum":"d3fb3e32948e53aaafa0efeda0714c2784c2c56d"},{"_id":"public/noi2015-prog/index.html","modified":1482581588026,"shasum":"c26f3e4f2f4b1f88e5755945170e31e5a16f2005"},{"_id":"public/number-theory-notes-1/index.html","modified":1482581588109,"shasum":"1456b79b36c29fa501226eedbcee351a3a500a53"},{"_id":"public/noip2012-mod/index.html","modified":1482581588161,"shasum":"23a482d0740e3b0b8d402f9de9be76c3b9035512"},{"_id":"public/link-cut-tree-notes/index.html","modified":1482823795090,"shasum":"02aaa1ad59d2a09c00889ab33c60262f130cbd24"},{"_id":"public/splay-notes-3/index.html","modified":1482823795152,"shasum":"819dc42634f22f3d156406ee56053e3a325357a3"},{"_id":"public/bzoj-1251/index.html","modified":1482823795199,"shasum":"c8b580e4ef93398557084823195ef98b3c1b9207"},{"_id":"public/noip2006-budget/index.html","modified":1482581588493,"shasum":"1516b31630bc548cb6ce1239161d7a330cdc1f86"},{"_id":"public/bzoj-2442/index.html","modified":1482581588550,"shasum":"6b270de947a42dfc9cde4ee768c0bc2bcd3342c0"},{"_id":"public/codevs-3269-monotone-queue/index.html","modified":1482581588598,"shasum":"cfffc3a3da1b028634410b8a8f888dcd2f54fd24"},{"_id":"public/monotone-queue-notes/index.html","modified":1482581588624,"shasum":"df61869ab6c7f6e9d3b34de2602c2336396edaf8"},{"_id":"public/codevs-1345/index.html","modified":1482581588654,"shasum":"8478516fbc3d4cb0098d284df98b21a5da70bcc8"},{"_id":"public/noip2003-game/index.html","modified":1482581588699,"shasum":"0d1ca251e13b26dbab7f1e52f3d4e7f4ffac024d"},{"_id":"public/noip2006-energy/index.html","modified":1482581588734,"shasum":"78114b44e08401cfe0510aece082ba556ebf5111"},{"_id":"public/tyvj-3317/index.html","modified":1482581588791,"shasum":"f5fe8ebc1a41d4f7da5e67140bc0665f0f8de204"},{"_id":"public/codevs-2598/index.html","modified":1482581588830,"shasum":"3aa366a6f8402509917b44e2e687ab70098826fd"},{"_id":"public/noip2000-cheng-ji-zui-da/index.html","modified":1482581588864,"shasum":"5992600ddb972fb9b288b9539a4988c5927013dd"},{"_id":"public/ctsc1997-course/index.html","modified":1482581588914,"shasum":"05ea95cdeadb5ba08903e848d1b61685d1d80085"},{"_id":"public/codevs-3168-3162/index.html","modified":1482581588967,"shasum":"a320794a2d93277aa8e5d6be409fdab3f612ebb3"},{"_id":"public/minimum-spanning-tree-notes/index.html","modified":1482581589045,"shasum":"a6f947db2f20083c74c225cdfb3eacdf6dee50e3"},{"_id":"public/system-of-difference-constraints-notes/index.html","modified":1482581589091,"shasum":"5c8e9223328b78ac6ff4e4e506213ad3b9c7c9b4"},{"_id":"public/kmp-notes/index.html","modified":1482892327905,"shasum":"9f311716e9be906992f1c8d03dc3839a9ab29fc5"},{"_id":"public/cut-tree-notes/index.html","modified":1482581589236,"shasum":"019036c18f706750c7a4a1eae25488d3c2570323"},{"_id":"public/stl-in-oi/index.html","modified":1482892328017,"shasum":"890f74fdd10f5bbe639b000b8456f52215ab84c7"},{"_id":"public/splay-notes-2/index.html","modified":1482823795973,"shasum":"e5034348975ba2225a463208e683444e4b85fe35"},{"_id":"public/splay-notes-1/index.html","modified":1482823796040,"shasum":"7b50533bfeeb573d9d002f1273caa07240079ba1"},{"_id":"public/hnoi2004-pet/index.html","modified":1482823796074,"shasum":"13ee97c886c32c558273e1d90fda867a809a7f96"},{"_id":"public/codevs-3269/index.html","modified":1482581589634,"shasum":"ec2af6d3c6bb2483ba44acb19e6aad749a3d0ec8"},{"_id":"public/noi2002-galaxy/index.html","modified":1482581589674,"shasum":"852ac0758c11925a2ebbbeda642af92f0b69f6d1"},{"_id":"public/archives/index.html","modified":1483060791466,"shasum":"0b25712aa4663cb727e6685fc108970aa62c1a78"},{"_id":"public/archives/page/2/index.html","modified":1483060791533,"shasum":"685a90f10b16de2633802b2d9c5c1f8553383708"},{"_id":"public/archives/page/3/index.html","modified":1483060791571,"shasum":"1bfa64f20b0a0d356054f9c80e0f036dc5cef8db"},{"_id":"public/archives/page/4/index.html","modified":1483060791617,"shasum":"b71a8d9ba898e95d2e3acbbfbc6ed3e5111908bc"},{"_id":"public/archives/page/5/index.html","modified":1483060791648,"shasum":"a2cc53ababf4c06a0c7ef8a3a1029d7d48f41e32"},{"_id":"public/archives/page/6/index.html","modified":1483060791698,"shasum":"1b83cc47adc5a79f0280f2fe00aa20240cbed4b4"},{"_id":"public/archives/page/7/index.html","modified":1483060791734,"shasum":"9893c46d51d692d1d284afd1fa715c5f137e73d4"},{"_id":"public/archives/page/8/index.html","modified":1483060791778,"shasum":"9ad4d6aa1350111b2a7da1ee1ff60594345b3d23"},{"_id":"public/archives/page/9/index.html","modified":1483060791823,"shasum":"a548624e45d6923a184ae67dda4a03e813ab3bdc"},{"_id":"public/archives/page/10/index.html","modified":1483060791869,"shasum":"bc4b3dac3acda45491d4af16acac6318f0ee8e2c"},{"_id":"public/archives/page/11/index.html","modified":1483060791905,"shasum":"43c5b9a47a1356172b8fa91905e9e7e5ea1d0b4b"},{"_id":"public/archives/page/12/index.html","modified":1483060791953,"shasum":"1a8250d9d2485c82b65cf28da624f4e462e94bde"},{"_id":"public/archives/page/13/index.html","modified":1483060791993,"shasum":"d73cb7f006f32a689c74bc41c91887bbfbfeb349"},{"_id":"public/archives/page/14/index.html","modified":1483060792025,"shasum":"394399489381975402d6a8227da368ba1ddb7ede"},{"_id":"public/archives/page/15/index.html","modified":1483060792074,"shasum":"a47d9f448e83f88b0acae12d9d0a59561b39e5dd"},{"_id":"public/archives/page/16/index.html","modified":1483060792114,"shasum":"110edf8507bfd094e09fae8b046474b9e704b85e"},{"_id":"public/archives/page/17/index.html","modified":1483060792164,"shasum":"31bcd11b0cbca9218272f971199d2fac25843a04"},{"_id":"public/archives/page/18/index.html","modified":1483060792212,"shasum":"c25231fecb44d180351eda92f76298f73014d5a0"},{"_id":"public/archives/page/19/index.html","modified":1483060792260,"shasum":"f9f8cef8c0441176584ab35ae59d7e831fe09f06"},{"_id":"public/archives/page/20/index.html","modified":1483060792301,"shasum":"0919274bca41c8daf2c2ea690ff643f246496265"},{"_id":"public/archives/page/21/index.html","modified":1483060792351,"shasum":"852a7fd08bbbd91a6fd2d7f8170aa7d1ea9ae608"},{"_id":"public/archives/page/22/index.html","modified":1483060792383,"shasum":"244a01dc1e36cb18983d490e2b471b88201fc1ae"},{"_id":"public/archives/page/23/index.html","modified":1483060792424,"shasum":"3a3076111c0d88e839429a2a0f7d6c4a486fe84a"},{"_id":"public/archives/page/24/index.html","modified":1483060792461,"shasum":"6a975ed48e1f8615ecf9f5a1b9bdd2a88ca219e3"},{"_id":"public/archives/page/25/index.html","modified":1483060792493,"shasum":"e208575c0056668ce919bde54712fb5396fb1f7b"},{"_id":"public/archives/page/26/index.html","modified":1483060792529,"shasum":"3bf600556b0388d2b58a28711495c421583a5d22"},{"_id":"public/archives/page/27/index.html","modified":1483060792557,"shasum":"0f8f049d6763808a4f9f6619abd67db078b15bbf"},{"_id":"public/archives/page/28/index.html","modified":1483060792587,"shasum":"2a0a3c1a706f99face5fa09b866407b0daf613c9"},{"_id":"public/archives/page/29/index.html","modified":1483060792622,"shasum":"ab929891095907bf475ff239d8d47e221b8f1ecf"},{"_id":"public/archives/2015/index.html","modified":1482892329408,"shasum":"7ea5f941eafad734085d80b376599a5dbdb03cfc"},{"_id":"public/archives/2015/11/index.html","modified":1482581593442,"shasum":"457b33b99ad7865eae16489970b8a328f07b9577"},{"_id":"public/archives/2015/12/index.html","modified":1482892329441,"shasum":"5a20cbc125070e35f0dd734783a56f05bd779765"},{"_id":"public/archives/2016/index.html","modified":1483060792727,"shasum":"d18a352eaf9a7a0dde38c77022da5d81d6da2bc9"},{"_id":"public/archives/2016/page/2/index.html","modified":1483060792782,"shasum":"f16bd9784d10dcc0fe0330814418d48706cba989"},{"_id":"public/archives/2016/page/3/index.html","modified":1483060792854,"shasum":"db2f3e09bf10b416bccdf08166dbb897a5083312"},{"_id":"public/archives/2016/page/4/index.html","modified":1483060792897,"shasum":"360abcd95c147f4aea3b5d1683b39223f0e74a9c"},{"_id":"public/archives/2016/page/5/index.html","modified":1483060792950,"shasum":"2b3430a824a9af2449fb97743b0cecdee649eb28"},{"_id":"public/archives/2016/page/6/index.html","modified":1483060792996,"shasum":"1db53de6633fd4cf5c16b5adfd1b75e7722213fc"},{"_id":"public/archives/2016/page/7/index.html","modified":1483060793050,"shasum":"a1f8d96b41a4e6181fefe40e5bd36f8305985d0a"},{"_id":"public/archives/2016/page/8/index.html","modified":1483060793089,"shasum":"62e2973b58d514579b59fe1fd8cf0c81ba318ec3"},{"_id":"public/archives/2016/page/9/index.html","modified":1483060793152,"shasum":"a71c1bc29e7d69147173b36a0b4d83f29166a5cd"},{"_id":"public/archives/2016/page/10/index.html","modified":1483060793194,"shasum":"d37cae60b0bee9dbf080aa276a5f7a9caeca39bd"},{"_id":"public/archives/2016/page/11/index.html","modified":1483060793241,"shasum":"e896d59d6061acbe94cbc0adc0f1aff0651ce488"},{"_id":"public/archives/2016/page/12/index.html","modified":1483060793297,"shasum":"918d2fc5175bc57a44c4b70d79a8679a5ea7a454"},{"_id":"public/archives/2016/page/13/index.html","modified":1483060793353,"shasum":"107a4c88f2b1ae3c38979fa10c5fda3f54f5e95b"},{"_id":"public/archives/2016/page/14/index.html","modified":1483060793404,"shasum":"8a06e1bc1941486755fa1978884ba79b6f6eeab7"},{"_id":"public/archives/2016/page/15/index.html","modified":1483060793450,"shasum":"89476fb1189fd6d7a8bc94478a539e4b932ed558"},{"_id":"public/archives/2016/page/16/index.html","modified":1483060793503,"shasum":"deac0c1bd818ba9e5d5a6e475047cd962dba3948"},{"_id":"public/archives/2016/page/17/index.html","modified":1483060793553,"shasum":"9015067b19025f2f11adfba4c3149529524b739c"},{"_id":"public/archives/2016/page/18/index.html","modified":1483060793619,"shasum":"413073540147aae8666fce5a19ed7a5db23af1ce"},{"_id":"public/archives/2016/page/19/index.html","modified":1483060793663,"shasum":"a48a23f6d44a0fcb470b8c213448bdf94bd5b194"},{"_id":"public/archives/2016/page/20/index.html","modified":1483060793725,"shasum":"88a0e0ef844d5314d49ff8eb5ec29e43da65b930"},{"_id":"public/archives/2016/page/21/index.html","modified":1483060793786,"shasum":"6d81fe8ea050e34289d91f7436c3c331c55e1a84"},{"_id":"public/archives/2016/page/22/index.html","modified":1483060793836,"shasum":"3b67fbd0154aaddb202e146246ebcf4fdac75e3a"},{"_id":"public/archives/2016/page/23/index.html","modified":1483060793874,"shasum":"3f6802e89b353b3527387b7037f017f6f5604bdd"},{"_id":"public/archives/2016/page/24/index.html","modified":1483060793923,"shasum":"7af883375102e5fb46f36559176c0272fef7ec6b"},{"_id":"public/archives/2016/page/25/index.html","modified":1483060793969,"shasum":"e2780569fd5e918898c4a50c912fa8180d72b226"},{"_id":"public/archives/2016/page/26/index.html","modified":1483060794004,"shasum":"224f0ebbcb1834fc0aa8177e317c31cca1998f6a"},{"_id":"public/archives/2016/page/27/index.html","modified":1483060794044,"shasum":"a09198342c68e47e34bf2d5c5729fc3e8dad54e3"},{"_id":"public/archives/2016/page/28/index.html","modified":1483060794090,"shasum":"87e8e9d97f9207b65fbddd03b7dfde5adb7707cf"},{"_id":"public/archives/2016/page/29/index.html","modified":1483060794110,"shasum":"0582d6a4a4a4b3e189af8d5edd5eb0baec336eee"},{"_id":"public/archives/2016/01/index.html","modified":1482823798562,"shasum":"bba827e2154441a778e924371e60e373884b0f13"},{"_id":"public/archives/2016/01/page/2/index.html","modified":1482581595290,"shasum":"c3d9844e905e27d5ce98cbb143a24e883a6cc0ce"},{"_id":"public/archives/2016/01/page/3/index.html","modified":1482581595321,"shasum":"bb47e5bd855368d7abb165dc2bd4e2d565f55dfc"},{"_id":"public/archives/2016/02/index.html","modified":1482581595360,"shasum":"488233f0c618ea96d18773f8eebc5c33dde47372"},{"_id":"public/archives/2016/02/page/2/index.html","modified":1482581595455,"shasum":"37affa137933005d6bc1df607388672787bd17fc"},{"_id":"public/archives/2016/02/page/3/index.html","modified":1482581595492,"shasum":"d965bcf850f0cc1ed41bf679937ecb5dfc9776fc"},{"_id":"public/archives/2016/03/index.html","modified":1482581595542,"shasum":"260c8a6d11885a059738173d9e9f71634ae6971d"},{"_id":"public/archives/2016/03/page/2/index.html","modified":1482581595573,"shasum":"61e69bdfe2188132b594a2a4deca89919fa30d74"},{"_id":"public/archives/2016/03/page/3/index.html","modified":1482581595658,"shasum":"1d5353270b16e6e753eafea1c86be2a2c4b7c7f5"},{"_id":"public/archives/2016/03/page/4/index.html","modified":1482581595684,"shasum":"dc1739d7a77f109af844e7b14a441248e1d2b941"},{"_id":"public/archives/2016/04/index.html","modified":1482581595735,"shasum":"a896765dfae7f9f50d0bc7e9f775b03791c39066"},{"_id":"public/archives/2016/04/page/2/index.html","modified":1482581595781,"shasum":"1f7c397cfe793a3352f55fdf13bea554666b7cc9"},{"_id":"public/archives/2016/04/page/3/index.html","modified":1482581595820,"shasum":"16208d424f6086ffdfbae92ffc018830cf967bd3"},{"_id":"public/archives/2016/04/page/4/index.html","modified":1482581595894,"shasum":"34a542e8de50a57ae7cc9bd808b5c5b2d8eac878"},{"_id":"public/archives/2016/05/index.html","modified":1482581595948,"shasum":"9f852445a7261a13f6a0bbea3c484ca3731b6871"},{"_id":"public/archives/2016/05/page/2/index.html","modified":1482581595997,"shasum":"b6da24f6d1117f3cc77f47db9ca22bde405b8ff9"},{"_id":"public/archives/2016/05/page/3/index.html","modified":1482581596010,"shasum":"a1432f104551c27057f3f9888040a5aabc71fd37"},{"_id":"public/archives/2016/06/index.html","modified":1482581596062,"shasum":"4ed243e8352364a93d5a3f30d97eb78ae2830f3f"},{"_id":"public/archives/2016/06/page/2/index.html","modified":1482581596142,"shasum":"ecfe95bf1ed23afdbd941ab96f4a49f67e80abea"},{"_id":"public/archives/2016/06/page/3/index.html","modified":1482581596175,"shasum":"a34a494507d03d8974ec907da88a19c06d2ca865"},{"_id":"public/archives/2016/06/page/4/index.html","modified":1482581596219,"shasum":"3848993eb5023d476ececfc1b027f9466472ddec"},{"_id":"public/archives/2016/07/index.html","modified":1483060794881,"shasum":"e3991349b8c349db0a37093b56530d369bb562c7"},{"_id":"public/archives/2016/07/page/2/index.html","modified":1482581596312,"shasum":"d910df8c1266fa68741316668e16464f647ee294"},{"_id":"public/archives/2016/08/index.html","modified":1482581596329,"shasum":"f1935427723bf249cb19474636261f737f5f4ae0"},{"_id":"public/archives/2016/09/index.html","modified":1482581596372,"shasum":"0ca1aa2b96f3c2ddd0c54f83acd16006ecb34946"},{"_id":"public/archives/2016/09/page/2/index.html","modified":1482581596407,"shasum":"4800b57b1567646c559fa182c352cac46586c054"},{"_id":"public/archives/2016/09/page/3/index.html","modified":1482581596472,"shasum":"82078022de009fb1df4ba736ba6e5762739abc6b"},{"_id":"public/archives/2016/09/page/4/index.html","modified":1482581596508,"shasum":"6158c9cd48d428e1486ffaeb0aafc694979a5d97"},{"_id":"public/archives/2016/10/index.html","modified":1482581596547,"shasum":"ee596c67547124ee77558a7a15f43a2273c97604"},{"_id":"public/archives/2016/10/page/2/index.html","modified":1482581596592,"shasum":"939cb9d18549fd23e3f5a9fc3c359aa836bbc8a1"},{"_id":"public/archives/2016/10/page/3/index.html","modified":1482581596618,"shasum":"3cf09236f6bb7f9330fe2badfe32a5bd926b483d"},{"_id":"public/archives/2016/11/index.html","modified":1482581596703,"shasum":"98c8e1baeab5448420525d94972e14b92479ee83"},{"_id":"public/archives/2016/11/page/2/index.html","modified":1482581596763,"shasum":"9060e0cb7b9f9d5c46c2cf299c04b81fd4c51362"},{"_id":"public/archives/2016/11/page/3/index.html","modified":1482581596783,"shasum":"8be745626c17cf06e47cc55f50783c6df932e6bd"},{"_id":"public/archives/2016/12/index.html","modified":1483060795316,"shasum":"c039245a15e71486c10c07a7b22988640f9fb67b"},{"_id":"public/archives/2016/12/page/2/index.html","modified":1483060795343,"shasum":"21a110efb2b460fd2279f5bc50f0cd162fd43b53"},{"_id":"public/categories/oi/index.html","modified":1483060795402,"shasum":"908bddd56248911a0ff12431a6d4f0cd8d64cf1e"},{"_id":"public/categories/oi/page/2/index.html","modified":1483060795471,"shasum":"acf32d7f4f6e71e133c118af0e19209dff6dcd58"},{"_id":"public/categories/oi/page/3/index.html","modified":1483060795534,"shasum":"450071fb5c19ac8f7739ba60b0530c110787498f"},{"_id":"public/categories/oi/page/4/index.html","modified":1483060795582,"shasum":"0e6dddbdecc3b3a3d6d79628eacfd35270f3278d"},{"_id":"public/categories/oi/page/5/index.html","modified":1483060795634,"shasum":"e678e17fd6c0a10fedffa13e27573b5db4671c0d"},{"_id":"public/categories/oi/page/6/index.html","modified":1483060795675,"shasum":"34c6d1a116879f6138a4e037332a9fa9d5f57b86"},{"_id":"public/categories/oi/page/7/index.html","modified":1483060795735,"shasum":"26a5854f3d84928090e010681bc3c127a2f84d1e"},{"_id":"public/categories/oi/page/8/index.html","modified":1483060795776,"shasum":"ef1511d5854c500326f2177f827c1b4068175fa5"},{"_id":"public/categories/oi/page/9/index.html","modified":1483060795838,"shasum":"67ea8e01c3374a4c69a158847d750e35758d4c9a"},{"_id":"public/categories/oi/page/10/index.html","modified":1483060795881,"shasum":"d53597508e3cc9daf22acea0dbefb1833c6eab73"},{"_id":"public/categories/oi/page/11/index.html","modified":1483060795931,"shasum":"bb6ce555b72d1e8af938525b21e597f2f8119751"},{"_id":"public/categories/oi/page/12/index.html","modified":1483060795988,"shasum":"ffb1ef1dca9fe69994cf49cd6c5e73befbab0220"},{"_id":"public/categories/oi/page/13/index.html","modified":1483060796029,"shasum":"e2eb0b0949540cca83430cffad5642c1b9746a52"},{"_id":"public/categories/oi/page/14/index.html","modified":1483060796092,"shasum":"5952a1557666619e0f30ead71982d69cb275bea1"},{"_id":"public/categories/oi/page/15/index.html","modified":1483060796140,"shasum":"faf623a59e80ee02b3a7eeb292e29ea632e69ef8"},{"_id":"public/categories/oi/page/16/index.html","modified":1483060796197,"shasum":"fd3b3c363fa5d5065227481e942f789212557e1f"},{"_id":"public/categories/oi/page/17/index.html","modified":1483060796256,"shasum":"3761ac35a58ae7b79ee64a5db3c0f4f78213e188"},{"_id":"public/categories/oi/page/18/index.html","modified":1483060796315,"shasum":"10b675b98c98424ee53b909a8c70fbfc07bda018"},{"_id":"public/categories/oi/page/19/index.html","modified":1483060796365,"shasum":"d1f61c7a02e5b298c74368bc3b672ba0e0fec1d1"},{"_id":"public/categories/oi/page/20/index.html","modified":1483060796432,"shasum":"0aede1e12e0316e2b86c2dbac12008c8368384d1"},{"_id":"public/categories/oi/page/21/index.html","modified":1483060796476,"shasum":"05d81a07f6f6587a13ca9ef70def48fd06fdacf7"},{"_id":"public/categories/oi/page/22/index.html","modified":1483060796524,"shasum":"bebafa4aaa3e04e6baa43b8828bb2cfd8dd483f6"},{"_id":"public/categories/oi/page/23/index.html","modified":1483060796571,"shasum":"3f4d1ddb206b3903f27163c9753fa6168c998de8"},{"_id":"public/categories/oi/page/24/index.html","modified":1483060796607,"shasum":"6e8eddc48340bce1d09958cd0920911427fb94ea"},{"_id":"public/categories/oi/page/25/index.html","modified":1483060796663,"shasum":"4073abb1925f003dfb8a627e8c0d621b34a81d4a"},{"_id":"public/categories/oi/page/26/index.html","modified":1483060796698,"shasum":"27473215f47f27cf35bc64f0899f4cfb62c67929"},{"_id":"public/categories/oi/page/27/index.html","modified":1483060796736,"shasum":"e9c2ca95c21013e4b0823ddf9da003ea8f1dc7a7"},{"_id":"public/categories/oi/page/28/index.html","modified":1483060796778,"shasum":"81451e60cd10ee3d89d5c5daa3bb9a2ca745935e"},{"_id":"public/categories/oi/page/29/index.html","modified":1483060796796,"shasum":"6301548ab05e811165c89844a74442abd7be8ca8"},{"_id":"public/categories/geek/index.html","modified":1482581591838,"shasum":"e5e1a097cfe93c6b81a5d11193ff9aba8e161a1b"},{"_id":"public/categories/diary/index.html","modified":1482581591862,"shasum":"39858f84d6c335e4ebb3328654ac9bb21aaf8e46"},{"_id":"public/index.html","modified":1483060796917,"shasum":"0868dc3c84a390c74ae92cc73dc945c5de7a2eaa"},{"_id":"public/page/2/index.html","modified":1483060796982,"shasum":"96f2c925b5d4f42f4c0482f41a6419ef01a89be9"},{"_id":"public/page/3/index.html","modified":1483060797041,"shasum":"591fd62c1b6c4c1bc77dee72ae7674831bd4b6c7"},{"_id":"public/page/4/index.html","modified":1483060797087,"shasum":"5a5905b8e71754d98fe4a8c190d82f1ca544a53a"},{"_id":"public/page/5/index.html","modified":1483060797141,"shasum":"6288233104f9823c627712edfb7becd64a43c9df"},{"_id":"public/page/6/index.html","modified":1483060797192,"shasum":"2e72d0c2448d4940732262b911976fb699ff6f00"},{"_id":"public/page/7/index.html","modified":1483060797240,"shasum":"694dbfb6ac140366b5dcb175254840a34d8e865b"},{"_id":"public/page/8/index.html","modified":1483060797295,"shasum":"04391f43cbfa4aa6f78fb2f59b02041ca34bacac"},{"_id":"public/page/9/index.html","modified":1483060797352,"shasum":"51142436e452b713a0d3bcf73443385f293e0990"},{"_id":"public/page/10/index.html","modified":1483060797408,"shasum":"d7db5f2496d715a31d760c658152d90b8139307e"},{"_id":"public/page/11/index.html","modified":1483060797455,"shasum":"50dba7feccf3192785fecee6da48916e0f141729"},{"_id":"public/page/12/index.html","modified":1483060797510,"shasum":"538789d401d05307622771aaac40024a6e36f8fb"},{"_id":"public/page/13/index.html","modified":1483060797556,"shasum":"fac44936edb7fcd40bbf6e62fdcca1258a2c964d"},{"_id":"public/page/14/index.html","modified":1483060797606,"shasum":"ee8e2de30366324332f3a797938af176a4f45cb4"},{"_id":"public/page/15/index.html","modified":1483060797659,"shasum":"87a325257768435852025faef44f3f76155495ba"},{"_id":"public/page/16/index.html","modified":1483060797714,"shasum":"1f03c621c4a8c16a40eb14ef714f23f712d1c3b2"},{"_id":"public/page/17/index.html","modified":1483060797764,"shasum":"2f4bd083eb00aeb05f6e30ba67bd22c349af8dd3"},{"_id":"public/page/18/index.html","modified":1483060797829,"shasum":"c10b080866282cb0b409450e0449ef6a020541b2"},{"_id":"public/page/19/index.html","modified":1483060797877,"shasum":"a2fa0d16d49de2771b2c9c923b6ab038f5bf202e"},{"_id":"public/page/20/index.html","modified":1483060797934,"shasum":"08a23e53647c457e10b0bc993bc360b186885fe2"},{"_id":"public/page/21/index.html","modified":1483060797980,"shasum":"85bd80cfa5c69458680c4cd9cef4098049934e61"},{"_id":"public/page/22/index.html","modified":1483060798035,"shasum":"a18c33fb7e3d6fa121f17c58465497f6d1e92225"},{"_id":"public/page/23/index.html","modified":1483060798074,"shasum":"913d5e313ccb0d5c971a2e04827cce35aaa49ddb"},{"_id":"public/page/24/index.html","modified":1483060798122,"shasum":"3424686d192d82702674f9a09f6194279fe9e9da"},{"_id":"public/page/25/index.html","modified":1483060798171,"shasum":"f40eefce00cad998fc6be3b7ba333233f0d3b6e4"},{"_id":"public/page/26/index.html","modified":1483060798206,"shasum":"7d9f674cdec6a0e158027b373893ab8f922c80a7"},{"_id":"public/page/27/index.html","modified":1483060798247,"shasum":"48b4bc5c145fc1fdb6f76d6c36ec9864ac937b3a"},{"_id":"public/page/28/index.html","modified":1483060798297,"shasum":"082fb0775ce3304e84b02b4cf50d5aa71cebd137"},{"_id":"public/page/29/index.html","modified":1483060798333,"shasum":"708443b02a2fb78b07a296e482393b0f579c4300"},{"_id":"public/content.json","modified":1483060798365,"shasum":"4392d5580914fb36dfeb058a611103e9951d55bf"},{"_id":"public/sitemap.xml","modified":1483060798378,"shasum":"5500308578fc227eca6aa6ed140f16a9d1b4da14"},{"_id":"public/tag//index.html","modified":1482581598286,"shasum":"ed31dc84b45cd5ebd38330395a1547a41db23ed0"},{"_id":"public/tag//page/2/index.html","modified":1482581598313,"shasum":"3bbed2665b95696b6a46c1f5f17dd9f640d118b3"},{"_id":"public/tag//index.html","modified":1482581598359,"shasum":"c0b368fbd61872de4c33afc45e59fbe13e6b12ed"},{"_id":"public/tag//page/2/index.html","modified":1482892334895,"shasum":"778afa0add0461416caa1d41009e2d3310e90702"},{"_id":"public/tag//index.html","modified":1482581598424,"shasum":"d69416e32e2c6a617513d2a490d1bc5922f6ffb0"},{"_id":"public/tag//index.html","modified":1483060798594,"shasum":"37eb1d4d2aefaa64c5c7dbbca7991663ca497d27"},{"_id":"public/tag//page/2/index.html","modified":1483060798653,"shasum":"d4d8eaf5a28ed74a5d2b29d91ed4f84f85691993"},{"_id":"public/tag//page/3/index.html","modified":1483060798701,"shasum":"a90451dd25c4ca6d86268daec181a42acda94174"},{"_id":"public/tag//page/4/index.html","modified":1483060798743,"shasum":"a54b5146b3f691d6d8c95366f17201f4cf09f613"},{"_id":"public/tag//index.html","modified":1482581598611,"shasum":"631f79d55902194c99c703f214d0147aa208a527"},{"_id":"public/tag//page/2/index.html","modified":1482892335174,"shasum":"df842e9da75d1d5aa7e543e00bb36c390965c028"},{"_id":"public/tag/bzoj/index.html","modified":1482581598670,"shasum":"e406ead91cf3dcaf6f42bff34d66d65b202b740d"},{"_id":"public/tag/bzoj/page/2/index.html","modified":1482581598718,"shasum":"014158a8b6add15811f1b1871b45464f53922790"},{"_id":"public/tag/bzoj/page/3/index.html","modified":1482581598751,"shasum":"53c4afadfc726ccff11c4ded77a1846ebd00f94f"},{"_id":"public/tag/bzoj/page/4/index.html","modified":1482581598790,"shasum":"6678cca7935949180a7df1e9edadc57ad818d136"},{"_id":"public/tag/bzoj/page/5/index.html","modified":1482581598830,"shasum":"840d0e69b2fcb43f306649096e0e9ec3d5e3d7a4"},{"_id":"public/tag/bzoj/page/6/index.html","modified":1482581598863,"shasum":"9cadf14913e721292f76c5668ece46fe99017f1f"},{"_id":"public/tag/bzoj/page/7/index.html","modified":1482581598921,"shasum":"6d872a37feb825f39da2b9dd3c65ffba1c324dde"},{"_id":"public/tag/bzoj/page/8/index.html","modified":1482581598953,"shasum":"4a76279af893586c4eb6fc541c69a702c8a71ce4"},{"_id":"public/tag/bzoj/page/9/index.html","modified":1482581598999,"shasum":"c01c5482b74c090ee90f8a3d7eb61ae25f758d0d"},{"_id":"public/tag/bzoj/page/10/index.html","modified":1482581599041,"shasum":"1cbcebaf99ca485cf7e3176c86828a62d862b149"},{"_id":"public/tag/bzoj/page/11/index.html","modified":1482581599084,"shasum":"6af27757263e592326d9868a015e13d41d234982"},{"_id":"public/tag/bzoj/page/12/index.html","modified":1482581599129,"shasum":"bb0a89ac534d768c58ec88cbadc2d2407be9cfc4"},{"_id":"public/tag/bzoj/page/13/index.html","modified":1482581599182,"shasum":"5da46b6ae78ae17630c61ffcd4def8f16335a2a9"},{"_id":"public/tag/bzoj/page/14/index.html","modified":1482581599248,"shasum":"48db356c3551d5ca0be8882d8efb8272d3e97b35"},{"_id":"public/tag/bzoj/page/15/index.html","modified":1482581599291,"shasum":"a005adba13fe41f0ae9e2aa67540b4fe257c05a0"},{"_id":"public/tag/bzoj/page/16/index.html","modified":1482581599344,"shasum":"9ebdf1eb20e2953cd3abe332df89d1bea72d860a"},{"_id":"public/tag/bzoj/page/17/index.html","modified":1482581599382,"shasum":"7956d85f0b85c71d0fa81965467e4e4c837087ac"},{"_id":"public/tag/bzoj/page/18/index.html","modified":1482892335942,"shasum":"c568b196159fe437ec9a9db8e7a9f81a97036a72"},{"_id":"public/tag/bzoj/page/19/index.html","modified":1482581599430,"shasum":"77c3f6a9ee2d360e373f3f0f45dcad201212e982"},{"_id":"public/tag/zjoi/index.html","modified":1482581599472,"shasum":"2ca6085212d26a649729bb41925c293ec3d35ecc"},{"_id":"public/tag/zjoi/page/2/index.html","modified":1482581599487,"shasum":"4472810c6712bcd09d30c8f58e6adbb3dda5e72a"},{"_id":"public/tag/fft/index.html","modified":1482581599521,"shasum":"7f75adb59d4baf69fece73537441537c413826ff"},{"_id":"public/tag//index.html","modified":1482581599565,"shasum":"158591388a315629fc6440aea9e771382c9a85cb"},{"_id":"public/tag//page/2/index.html","modified":1482581599621,"shasum":"1d3f0bdf6ea886d7e465cc1c3610e3b9321b329a"},{"_id":"public/tag//page/3/index.html","modified":1482581599660,"shasum":"effd51b8a40fba218cdf18cbf456e9d6e0d48cc3"},{"_id":"public/tag//page/4/index.html","modified":1482581599699,"shasum":"318751975f970f44e87b94aeb603aacd33c2ada7"},{"_id":"public/tag//page/5/index.html","modified":1482581599713,"shasum":"0903c9818a7755068ce69ab6386297d2c70b0293"},{"_id":"public/tag//index.html","modified":1482581599754,"shasum":"93803af0dd855471e4f14f7606bbfc9c6dde59f3"},{"_id":"public/tag//page/2/index.html","modified":1482581599803,"shasum":"2f3ba08c3a887d1b47ab75524314626673000757"},{"_id":"public/tag//page/3/index.html","modified":1482581599848,"shasum":"b773b51e9bc7f96bf3a34f1fc308b8517ed86d91"},{"_id":"public/tag//page/4/index.html","modified":1482581599888,"shasum":"451eeae568ff5f5d591c0b2b036718ea9d487840"},{"_id":"public/tag//page/5/index.html","modified":1482581599908,"shasum":"8ca235f7a9388b4df272590aaf5d71e4a1890b63"},{"_id":"public/tag/dinic/index.html","modified":1482581599947,"shasum":"ee58b655872426a71bc50732b2bc373b71838380"},{"_id":"public/tag/dinic/page/2/index.html","modified":1482581600000,"shasum":"921e2643fb654cfaf787907e7793f52e44e7db34"},{"_id":"public/tag/dinic/page/3/index.html","modified":1482581600035,"shasum":"01740797139053593c1763701dce8135dba8bdb1"},{"_id":"public/tag/dinic/page/4/index.html","modified":1482581600051,"shasum":"0139585a048c2d9cbc55266c216abea924d275a7"},{"_id":"public/tag//index.html","modified":1482581600103,"shasum":"a55f44e97ef46fc71a53d96ff7feee6685eddf0d"},{"_id":"public/tag//page/2/index.html","modified":1482581600137,"shasum":"8092b22fc6b8695942fbaebae7705acd5b40f514"},{"_id":"public/tag/edmonds-karp/index.html","modified":1482581600217,"shasum":"908bac0afd43ea96e531d2c9bda35fcf304bbd0b"},{"_id":"public/tag/edmonds-karp/page/2/index.html","modified":1482581600236,"shasum":"8092b22fc6b8695942fbaebae7705acd5b40f514"},{"_id":"public/tag//index.html","modified":1482581600280,"shasum":"1a897b9819b569edc9dbcdb6635d5bef2bfd45bd"},{"_id":"public/tag//page/2/index.html","modified":1482581600308,"shasum":"3d6715e3653d3b54cd13026e528d158808456d72"},{"_id":"public/tag/dp/index.html","modified":1482581600355,"shasum":"9a4a403d640ed2c097ddb9536fcee1936a7cb0e1"},{"_id":"public/tag/dp/page/2/index.html","modified":1482581600405,"shasum":"5c4419a61607aa25d5a3f8b21ec40a954d705137"},{"_id":"public/tag/dp/page/3/index.html","modified":1482581600438,"shasum":"7caeadeede3479c9509197450770228f81baba94"},{"_id":"public/tag/dp/page/4/index.html","modified":1482581600491,"shasum":"169276af99f2aacaaac8a7500b12dd83d3f4c5ef"},{"_id":"public/tag/dp/page/5/index.html","modified":1482581600531,"shasum":"0a6a54fd0fea671ab3ed9dc68ae421f8712c3800"},{"_id":"public/tag/dp/page/6/index.html","modified":1482581600564,"shasum":"ac4479824168b04972b0c20f7ee876567c26756c"},{"_id":"public/tag/dp/page/7/index.html","modified":1482581600596,"shasum":"254f85a0fe1f11309fda56da03191c82bfa68ef2"},{"_id":"public/tag//index.html","modified":1482581600640,"shasum":"742dd483ad6e914cc96b3c65f535312efc57814e"},{"_id":"public/tag//page/2/index.html","modified":1482581600653,"shasum":"e2db503b3c3618af1f874ce4bbf07ab35a79f24a"},{"_id":"public/tag/cogs/index.html","modified":1482581600700,"shasum":"3a1cd53e00b41583abe49e10222f8d73098dc013"},{"_id":"public/tag/cogs/page/2/index.html","modified":1482581600775,"shasum":"0893467b94454dcc4a8d793db8ff28ff9d55bc86"},{"_id":"public/tag/cogs/page/3/index.html","modified":1482581600852,"shasum":"b824adc796fcefbe1631f2df4c494771a1755f32"},{"_id":"public/tag/cogs/page/4/index.html","modified":1482581600876,"shasum":"3155ee70f64492944b78f2099ba0756366e4b0ee"},{"_id":"public/tag//index.html","modified":1482581600892,"shasum":"c36e7f5f77cd0620928805c9bcef8a5470c09673"},{"_id":"public/tag//index.html","modified":1482581600915,"shasum":"7699941ae22a6e57bd4e1312bee480f0f3b309ca"},{"_id":"public/tag//index.html","modified":1482581601030,"shasum":"784ad20d1b7741a99ea8afd5520735aa588e5ca4"},{"_id":"public/tag//index.html","modified":1482581601140,"shasum":"90d63299d55e54f7067cc2845feb13396e42e0a6"},{"_id":"public/tag//page/2/index.html","modified":1482581601175,"shasum":"5c8c756ac7c57d1e13660df2e281bde823085b6d"},{"_id":"public/tag//index.html","modified":1482581601230,"shasum":"8efa10ec3f24ae5438db10081375e16acb7a3bd6"},{"_id":"public/tag/tarjan/index.html","modified":1482581601348,"shasum":"94f67213f15a834c4030aff703bb194cbbd45fdd"},{"_id":"public/tag/tarjan/page/2/index.html","modified":1482581601390,"shasum":"bb1e4a5f3221e233b8d6709a3535fa8c8b1d7055"},{"_id":"public/tag//index.html","modified":1482581601429,"shasum":"7bb08e133b13c000f04e824584288911274476c5"},{"_id":"public/tag//index.html","modified":1482581601442,"shasum":"0f4bc5f60329d34dae4daf6f78304ca3adac83ec"},{"_id":"public/tag//index.html","modified":1482581601503,"shasum":"e4915be1527f8fc1c3ddda0a1d42f6cafd97af64"},{"_id":"public/tag//index.html","modified":1482581601565,"shasum":"6229e9e33a22387e2e67ede5c31db2959f895320"},{"_id":"public/tag/os-x/index.html","modified":1482581601615,"shasum":"e5e1a097cfe93c6b81a5d11193ff9aba8e161a1b"},{"_id":"public/tag/linux/index.html","modified":1482581601648,"shasum":"e5e1a097cfe93c6b81a5d11193ff9aba8e161a1b"},{"_id":"public/tag/archlinux/index.html","modified":1482581601667,"shasum":"e5e1a097cfe93c6b81a5d11193ff9aba8e161a1b"},{"_id":"public/tag/virtualbox/index.html","modified":1482581601703,"shasum":"e5e1a097cfe93c6b81a5d11193ff9aba8e161a1b"},{"_id":"public/tag//index.html","modified":1482581601730,"shasum":"e5e1a097cfe93c6b81a5d11193ff9aba8e161a1b"},{"_id":"public/tag/ssh/index.html","modified":1482581601751,"shasum":"e5e1a097cfe93c6b81a5d11193ff9aba8e161a1b"},{"_id":"public/tag/uva/index.html","modified":1482581601819,"shasum":"09746b650314bc34d3640a645485e3ac67cb2eaa"},{"_id":"public/tag/-dp/index.html","modified":1482581601870,"shasum":"abc2c6f650d516c4a5b8ff860f6e667fe9a311ea"},{"_id":"public/tag//index.html","modified":1482581601907,"shasum":"13fbd3ff2232f31408e22f4f5b8404072a4d099e"},{"_id":"public/tag//index.html","modified":1482581601950,"shasum":"f3e62755c1bd39b8fe300f7cec50092498631fe6"},{"_id":"public/tag//index.html","modified":1482581602004,"shasum":"ce5aa32f0e7f25a3585cca9ec587f97934abda28"},{"_id":"public/tag//index.html","modified":1482581602106,"shasum":"aff294ab0b66455b159ce72a5ba861e8900791d2"},{"_id":"public/tag//index.html","modified":1482581602164,"shasum":"ce0251b1efb2467b6528b835e356f64051a2f218"},{"_id":"public/tag/-dp/index.html","modified":1482581602251,"shasum":"ac9804b341250a12d7d0e2e9db176767faf2df00"},{"_id":"public/tag//index.html","modified":1482581602359,"shasum":"2720bdc8fa1e38d45050996cf705bc3bb8b82052"},{"_id":"public/tag//page/2/index.html","modified":1482581602374,"shasum":"b5311416c85b4528e7799811274c2a57c4005984"},{"_id":"public/tag//index.html","modified":1482581602396,"shasum":"5e5ed443ac1be0998d49f00485e6628f1ac4c823"},{"_id":"public/tag//index.html","modified":1482581602408,"shasum":"c69125c6ad921275d4657b01e340889af6bef0ea"},{"_id":"public/tag/-dp/index.html","modified":1482581602455,"shasum":"7623ca0c6bf25ebbd95e8053373d0c6250fe83b6"},{"_id":"public/tag/-dp/page/2/index.html","modified":1482581602470,"shasum":"2c0a99b5b332cdbfcb853dc429df1aeb736a74c2"},{"_id":"public/tag//index.html","modified":1482581602496,"shasum":"9eb894495b0b667448f672c25140c0bf3e722e02"},{"_id":"public/tag//index.html","modified":1482581602523,"shasum":"7c729a5ab0ee837919dabc074b8da05ae3cfcfcd"},{"_id":"public/tag//index.html","modified":1482581602544,"shasum":"0ae6bd9e494d9d7a63e9f0cc5bc0c9f15c95fd70"},{"_id":"public/tag//index.html","modified":1482581602557,"shasum":"0ae6bd9e494d9d7a63e9f0cc5bc0c9f15c95fd70"},{"_id":"public/tag/codevs/index.html","modified":1482581602604,"shasum":"a75c7984877c6ef0c90d526935d46de69d2a334d"},{"_id":"public/tag/codevs/page/2/index.html","modified":1482581602703,"shasum":"941c00d4987599c2a18301151e464ce72a912fe1"},{"_id":"public/tag/codevs/page/3/index.html","modified":1482581602791,"shasum":"edb7d55ede67132e19625956b6adfe732488307a"},{"_id":"public/tag/codevs/page/4/index.html","modified":1482892338194,"shasum":"c84406adabd7e9e13dac71c8f2411b4e9bed0e46"},{"_id":"public/tag/codevs/page/5/index.html","modified":1482581602913,"shasum":"45d19a7d6c8128be8ca7cdc0da377150a4be713a"},{"_id":"public/tag/tyvj/index.html","modified":1482581602968,"shasum":"1cd43149704ab0c6dc39185a074d0f92009bdac2"},{"_id":"public/tag/-dp/index.html","modified":1482581603029,"shasum":"68ea919f94b02436538654f15c9a946d21dfd75b"},{"_id":"public/tag/tjoi/index.html","modified":1482581603057,"shasum":"8452219de3cc8cb69e521c127146793f0c24e228"},{"_id":"public/tag/-dp/index.html","modified":1482581603077,"shasum":"ebe89d977fb13d2deb2a81d654c2cec98104757d"},{"_id":"public/tag//index.html","modified":1482581603120,"shasum":"9217a9afc55072fd549e34745289eb4bf15e15fd"},{"_id":"public/tag//page/2/index.html","modified":1482581603156,"shasum":"e8c1a3d1da172250a8d6376ad31d58c5b8ae0597"},{"_id":"public/tag//page/3/index.html","modified":1482581603200,"shasum":"809fde7cecc2121c37632e06747c497b576a2d0b"},{"_id":"public/tag/ac-/index.html","modified":1482581603237,"shasum":"8f4a62e7219bf1ce40749aedef702419c451938f"},{"_id":"public/tag/ac-/page/2/index.html","modified":1482581603251,"shasum":"8fd7992ccb3415d804407550a4820fe470b3374b"},{"_id":"public/tag//index.html","modified":1482581603268,"shasum":"c3dba93c9723484a95793016e226c55e458acb71"},{"_id":"public/tag/splay/index.html","modified":1482823806399,"shasum":"2922e15cb3141eb6d815a5e01bbec5c525770149"},{"_id":"public/tag/splay/page/2/index.html","modified":1482823806415,"shasum":"864f290447e14f8a73e019e1cb51345ff8903049"},{"_id":"public/tag//index.html","modified":1482581603413,"shasum":"eb6dd02f8085f7923567b52d3f5eb8d19f5fa965"},{"_id":"public/tag//page/2/index.html","modified":1482581603455,"shasum":"9fe1c1ac2e4cc818cd06ae3f893979fd90d29c59"},{"_id":"public/tag//index.html","modified":1482581603584,"shasum":"f48536eabb9e48f02fc44e57c3822ac6a4bef464"},{"_id":"public/tag//page/2/index.html","modified":1482823806528,"shasum":"125cb3fb3628c8a095aa48bbdced2429e74d5730"},{"_id":"public/tag//page/3/index.html","modified":1482823806544,"shasum":"a8c88ece2dfc11cd61e3fe97b20e103d59c67345"},{"_id":"public/tag//index.html","modified":1482581603823,"shasum":"5c81165e04c5e0287fe081c8b9e09c575a07190e"},{"_id":"public/tag//page/2/index.html","modified":1482581603852,"shasum":"ed0e11ec3231d443c8a76cf7cbbb02422f36b5be"},{"_id":"public/tag//page/3/index.html","modified":1482581603883,"shasum":"9c4a4e186a7d50302a0f113b0974719a1c4d331f"},{"_id":"public/tag//index.html","modified":1482581603915,"shasum":"c57ec548ada0dfb6daa156c6a46e8789f35f55f6"},{"_id":"public/tag//index.html","modified":1483060802747,"shasum":"c7192195bb51ac77721a0e2b03bab0596f33bd31"},{"_id":"public/tag//page/2/index.html","modified":1483060802788,"shasum":"ebdc05075878ed922ca1fa9819d214e876ced016"},{"_id":"public/tag//page/3/index.html","modified":1483060802826,"shasum":"12c70771c7a9e60df5c79d02bd5ad6042b0b5e25"},{"_id":"public/tag//index.html","modified":1482581604017,"shasum":"b9aa12ffe86434fe73f54586e94c4308786ff76e"},{"_id":"public/tag//index.html","modified":1482581604033,"shasum":"4a042bc1dc7cd7e8626266b6b700c7b3f61acf3c"},{"_id":"public/tag//index.html","modified":1482581604128,"shasum":"2e7feda370ddbbf41a903c2c82d6ee37403851eb"},{"_id":"public/tag//page/2/index.html","modified":1482581604161,"shasum":"b89df07abc84237041036a3f0c59f7ee91050f62"},{"_id":"public/tag//index.html","modified":1482581604203,"shasum":"c225d0a3003f8635c07f45441a13789d27463559"},{"_id":"public/tag/c/index.html","modified":1482581604259,"shasum":"68cbe1bdbd902042523ad354b12962de8eb25920"},{"_id":"public/tag/stl/index.html","modified":1482581604307,"shasum":"226755b87b87e2fba1ff37c32e846484f34cc54f"},{"_id":"public/tag/spoj/index.html","modified":1482581604349,"shasum":"8bc5eaac6ccad94dfb1a868d316952e708b6fa58"},{"_id":"public/tag/shoi/index.html","modified":1482581604446,"shasum":"acf14782b5f6e658bc5a7cc5d8ea5e23b98c0beb"},{"_id":"public/tag//index.html","modified":1482581604466,"shasum":"0fd4ab0c5f1eb63e740962d58b5b99c2bf962bc4"},{"_id":"public/tag//index.html","modified":1482581604480,"shasum":"45c3bb830eae135f8ac4aeae8cecfdeadf351332"},{"_id":"public/tag/cdq/index.html","modified":1482581604516,"shasum":"8d2a4194fb6bd14a2cb38cd77363701f1eb6d5aa"},{"_id":"public/tag//index.html","modified":1482581604547,"shasum":"5e395533b35e9c58aa3ed1c60f5422a3a3fd407c"},{"_id":"public/tag/sdoi/index.html","modified":1482581604602,"shasum":"62c6f0180e7aa42918f88eec12fe4f937af84b2c"},{"_id":"public/tag/sdoi/page/2/index.html","modified":1482581604635,"shasum":"2ce711cad5ff353a82b67a7e2cbeae144517ca12"},{"_id":"public/tag//index.html","modified":1482581604651,"shasum":"60671c643138f466a387d2426d85586305badb78"},{"_id":"public/tag//index.html","modified":1482581604668,"shasum":"60671c643138f466a387d2426d85586305badb78"},{"_id":"public/tag//index.html","modified":1482581604702,"shasum":"df4f2d2346826ef0be1799cb261f792d0a06fd33"},{"_id":"public/tag//index.html","modified":1482581604717,"shasum":"5c4df02226b3686b7e32583463dc7dd861e80437"},{"_id":"public/tag//index.html","modified":1482581604733,"shasum":"064012466c535b89485fa501ef4803421ed30c0a"},{"_id":"public/tag//index.html","modified":1482581604762,"shasum":"efbc299e2b5badc9ac64ec22d3df743d2fe9a330"},{"_id":"public/tag//index.html","modified":1482581604808,"shasum":"94dff3a746c49e06b40d83b296cfaeefeeda58fd"},{"_id":"public/tag/rmq/index.html","modified":1483060803651,"shasum":"4a0e7998bd16a4a84456c026a34137ea8015d9f6"},{"_id":"public/tag//index.html","modified":1482581604963,"shasum":"962b01034622eef2dfff55863a52c1bb450b64a9"},{"_id":"public/tag//index.html","modified":1482581605012,"shasum":"489750204f16b2628206a96b047cad98113a68e3"},{"_id":"public/tag/ntt/index.html","modified":1482581605064,"shasum":"dc1ba0affe0e359d386e02e10aadbfdd80b24480"},{"_id":"public/tag//index.html","modified":1482581605107,"shasum":"dc1ba0affe0e359d386e02e10aadbfdd80b24480"},{"_id":"public/tag//index.html","modified":1482581605199,"shasum":"3cc89ef17341de1f1d7d56d98c35ed31bed47eed"},{"_id":"public/tag//index.html","modified":1482581605230,"shasum":"bbfa1f81c2af09be6402687d6721e17d1b0b6d48"},{"_id":"public/tag//index.html","modified":1482581605271,"shasum":"44d9e9b09ef581789cfd84c99abff7b0c26cfc3a"},{"_id":"public/tag//index.html","modified":1482581605291,"shasum":"48a7215f628ac81bee60a064f8a4aa1b1aec12d9"},{"_id":"public/tag//index.html","modified":1482581605305,"shasum":"5a116430b98e54924f7a109cc53f32af65a369b8"},{"_id":"public/tag/exgcd/index.html","modified":1482581605324,"shasum":"509918ceef36be56e737ed132d3a5e81d2c74f16"},{"_id":"public/tag/bsgs/index.html","modified":1482581605343,"shasum":"4e5a815aee39844529242fe116e8be33c6b1febf"},{"_id":"public/tag//index.html","modified":1482581605371,"shasum":"d8bf1a6d3838625b36dbb5a5e0649a1830551f4c"},{"_id":"public/tag/link-cut-tree/index.html","modified":1482581605391,"shasum":"a9256691eff4789282c6892e52eb76d136ae3880"},{"_id":"public/tag/scoi/index.html","modified":1482581605435,"shasum":"8cb7dbba2e537fba8269f5f80f8d7db148f30dda"},{"_id":"public/tag/scoi/page/2/index.html","modified":1482581605465,"shasum":"1ffa92611b3bb4c7f5419cc3aec9374cb40ea0f4"},{"_id":"public/tag/set/index.html","modified":1482581605483,"shasum":"2a4d4d070362c13d15889f4305f6227e65741208"},{"_id":"public/tag//index.html","modified":1482581605518,"shasum":"f38f193bad286ff202fbf272e17e712489dc0be5"},{"_id":"public/tag//index.html","modified":1482581605588,"shasum":"44567e44208e0450c1261bb0e62d0563017be012"},{"_id":"public/tag/-dp/index.html","modified":1482581605663,"shasum":"fe3613e621d0853ad9993442acba80d67cb55666"},{"_id":"public/tag//index.html","modified":1482581605732,"shasum":"d85fb34ea19379216b0a81493e6950cd8b327d95"},{"_id":"public/tag//index.html","modified":1482581605784,"shasum":"0d785c878803dec8247a0503447845750c7553da"},{"_id":"public/tag//index.html","modified":1482581605845,"shasum":"e7891c918292d8eb155379a1c617a13f4711324d"},{"_id":"public/tag//index.html","modified":1482581605892,"shasum":"f3b6c9730ca8517ba6715c0970a42911f6e254a8"},{"_id":"public/tag//index.html","modified":1482581605957,"shasum":"1144ffee544600c8aa3906cf702cf79b9d23b4e6"},{"_id":"public/tag//index.html","modified":1482581605993,"shasum":"35434d278948126990469a6a0a9c6b07622e9279"},{"_id":"public/tag/dfs/index.html","modified":1482581606009,"shasum":"d5007583d05655f4e5a32b3a2f7b7edb433941f8"},{"_id":"public/tag/poj/index.html","modified":1482581606027,"shasum":"9fc8f7631e3dee0348396357ba4519da8e9f0a2d"},{"_id":"public/tag/kmp/index.html","modified":1482581606053,"shasum":"ad7ca1da27a2fbac8d3e236ca9bcce1d2af3d2ed"},{"_id":"public/tag/prim/index.html","modified":1482581606067,"shasum":"751e8c6c5cbb8fd8994d3f92f440ed210704ef2c"},{"_id":"public/tag//index.html","modified":1482581606079,"shasum":"50f33098608eecdf4a8baab76631970ec160d438"},{"_id":"public/tag//index.html","modified":1482581606091,"shasum":"50f33098608eecdf4a8baab76631970ec160d438"},{"_id":"public/tag/poi/index.html","modified":1482581606110,"shasum":"514b557186578a8301aa66bdd7f5657784ae49cf"},{"_id":"public/tag/noip/index.html","modified":1482581606175,"shasum":"a1c30317b648b91bd8b048180cda9e53dc47849a"},{"_id":"public/tag/noip/page/2/index.html","modified":1482581606217,"shasum":"aa1119f35e33bcea8eb02530b1587e8532590aa5"},{"_id":"public/tag/noip/page/3/index.html","modified":1482581606241,"shasum":"593ffaf466159fac62270f27bf54d6e4803d4fa4"},{"_id":"public/tag//index.html","modified":1482581606261,"shasum":"8899723e05368dcf5bc983b993a9bedae463332c"},{"_id":"public/tag//index.html","modified":1482581606277,"shasum":"826fc29a50c043311ae52fc2c336564886ffbb8a"},{"_id":"public/tag/floyd/index.html","modified":1482581606300,"shasum":"058ea252b3edf5ef8b3a00a349df15e68a62aa8f"},{"_id":"public/tag//index.html","modified":1482581606326,"shasum":"48c499f7b32c7db6943257ef7f3086a08796a49c"},{"_id":"public/tag/bfs/index.html","modified":1482581606350,"shasum":"bad1a5c9f6706113cfca6f4fdfb340b5401900b4"},{"_id":"public/tag/hash/index.html","modified":1482581606368,"shasum":"062ae387330766129d7cd31330ec8f7f811a6a2d"},{"_id":"public/tag/spfa/index.html","modified":1482581606382,"shasum":"9ca49ffb01754bdd20febd65381c00b2f6ec63c7"},{"_id":"public/tag//index.html","modified":1482581606396,"shasum":"6aabe0f30782bdf2ae865e4146ac927d23a26ce9"},{"_id":"public/tag//index.html","modified":1482581606423,"shasum":"829fa31565fae431f19afa26058b6135a00d4a20"},{"_id":"public/tag//index.html","modified":1482581606437,"shasum":"1128f03d23a424a9c13a85b6eb0a3be08a614674"},{"_id":"public/tag/vijos/index.html","modified":1482581606449,"shasum":"494b1259e8516aafdc9d35d4d8482c8717a69bea"},{"_id":"public/tag//index.html","modified":1482581606464,"shasum":"cd6117594c3c94f09c8eecc78ccacbec9f926541"},{"_id":"public/tag//index.html","modified":1482581606479,"shasum":"4b2b84e0992a7b1bfe150d381184b6891d24b16b"},{"_id":"public/tag/-dp/index.html","modified":1482581606497,"shasum":"20790f31f54b2c65305ba867b54147fa8003a045"},{"_id":"public/tag/noi/index.html","modified":1482581606548,"shasum":"94557124350336e1c6215e59a66d5f984073bd2c"},{"_id":"public/tag/noi/page/2/index.html","modified":1482581606588,"shasum":"1a01fe6e87764f9ac0852cc00ee770a32e49b5ae"},{"_id":"public/tag//index.html","modified":1482581606611,"shasum":"2591a6874ee277a6ed70f683d36dd100cab07ce6"},{"_id":"public/tag//index.html","modified":1482581606624,"shasum":"b22f618f54418b9a0988befe50c5894b1e014be9"},{"_id":"public/tag/map/index.html","modified":1482581606639,"shasum":"9825ff0a367b7662a6a998691e36fab963d88264"},{"_id":"public/tag//index.html","modified":1482581606654,"shasum":"0fb2bf9da77afc897f3794ddc99d1ab411818db4"},{"_id":"public/tag//index.html","modified":1482581606668,"shasum":"e5f01dbb87008b4cb32f56980534c308652ad798"},{"_id":"public/tag//index.html","modified":1482581606682,"shasum":"e5f01dbb87008b4cb32f56980534c308652ad798"},{"_id":"public/tag/lct/index.html","modified":1482581606703,"shasum":"057949cfc9e5c1988a894e1a0d86c37a0a3b4419"},{"_id":"public/tag//index.html","modified":1482581606716,"shasum":"7312cde2d5c1f49d7e712ed05bbc2f114855452b"},{"_id":"public/tag//index.html","modified":1482581606728,"shasum":"7312cde2d5c1f49d7e712ed05bbc2f114855452b"},{"_id":"public/tag//index.html","modified":1482581606760,"shasum":"391f2f996d5b29169f1c0d8505c01ec86dc4f63b"},{"_id":"public/tag//index.html","modified":1482581606790,"shasum":"982d877fb5e5fa64de282c584f5923453976c876"},{"_id":"public/tag//index.html","modified":1482581606809,"shasum":"4f4fe878e5fb39287dec2bd8fef9fe106f359a92"},{"_id":"public/tag/kruskal/index.html","modified":1482581606820,"shasum":"5875229821ef70cac4bb0403c64139bbe88dff89"},{"_id":"public/tag//index.html","modified":1482581606836,"shasum":"4438b27e157b14a85c19d7478ff38e354b4cbc95"},{"_id":"public/tag/jsoi/index.html","modified":1482581606870,"shasum":"7551d61191e1a3ef050a1949a5a9ff8ddbb9ee00"},{"_id":"public/tag/jsoi/page/2/index.html","modified":1482581606905,"shasum":"44da3a9d6c56401a80e0767360c0937fc3b35f81"},{"_id":"public/tag//index.html","modified":1482581606928,"shasum":"6b0c876a34ce325e0df6225d521f8ced442f7e40"},{"_id":"public/tag//index.html","modified":1482581606941,"shasum":"c478d76345c6f475a3c1f690f83b0e9008ddb9c6"},{"_id":"public/tag//index.html","modified":1482581606952,"shasum":"4268719081273c98e3b1662cacd535a48b59be2d"},{"_id":"public/tag//index.html","modified":1482581606966,"shasum":"e5d1e9f80efe7be28e65ee3a32ffb1789725df5f"},{"_id":"public/tag/ioi/index.html","modified":1482581606984,"shasum":"897d867f3852882fe561d74f5acd45a58e664afe"},{"_id":"public/tag//index.html","modified":1482581607003,"shasum":"39216a28c990ea589fe01cc3d9e9c78276deaae0"},{"_id":"public/tag/hnoi/index.html","modified":1482581607037,"shasum":"012b44b5fae8da8f7ebd4be052ec2d68e09b9d82"},{"_id":"public/tag/hnoi/page/2/index.html","modified":1482581607059,"shasum":"a23549ffab5adedcb97954be17f62d59b9d5c06c"},{"_id":"public/tag/dfs-/index.html","modified":1482581607073,"shasum":"c915489ed19cb457b2235a213f2f10c397eace6e"},{"_id":"public/tag/prufer-/index.html","modified":1482581607093,"shasum":"ee48eac0e563c5936c54735489080a74cfbdc3f7"},{"_id":"public/tag//index.html","modified":1482581607109,"shasum":"9df1faac33d635c429aee209fea92119874c89ac"},{"_id":"public/tag//index.html","modified":1482581607131,"shasum":"9df1faac33d635c429aee209fea92119874c89ac"},{"_id":"public/tag/burnside-/index.html","modified":1482581607158,"shasum":"b3cb22b108a3d8b5fa10d59092585beb78dddd81"},{"_id":"public/tag/trie/index.html","modified":1482581607203,"shasum":"59b403ad04c0d0b88dad9aae9fe5b8756958e2f0"},{"_id":"public/tag/heoi/index.html","modified":1482581607236,"shasum":"d00884fa5e810015c7d51189baffa6b736bed5ff"},{"_id":"public/tag/hdu/index.html","modified":1482581607297,"shasum":"e0f8a0fbf3e6f915248398a0808632d0064f7bfb"},{"_id":"public/tag/bestcoder/index.html","modified":1482581607347,"shasum":"cc1b4cfdbe32467e15a7c67ca4fafd64a3b0c3e7"},{"_id":"public/tag/haoi/index.html","modified":1482581607400,"shasum":"cd532b45add976f8a4f8d9e15947b76bf9d7d632"},{"_id":"public/tag/haoi/page/2/index.html","modified":1482581607437,"shasum":"8d431e85a1d018469fc813fca631cd590b38df64"},{"_id":"public/tag//index.html","modified":1482581607458,"shasum":"bd757aa3bf639ead90cbc258497710f523045614"},{"_id":"public/tag/gdb/index.html","modified":1482581607482,"shasum":"b382ab89e81fce6445e982d1204a62a0e09c8fb4"},{"_id":"public/tag//index.html","modified":1482581607496,"shasum":"b382ab89e81fce6445e982d1204a62a0e09c8fb4"},{"_id":"public/tag/fjoi/index.html","modified":1482581607511,"shasum":"251960453c12be7a946633568e7ec2f07ecbb17d"},{"_id":"public/tag//index.html","modified":1482581607528,"shasum":"8b9f080afac40f2f22bcf0e3365639dee7b7d401"},{"_id":"public/tag/docker/index.html","modified":1482581607542,"shasum":"69c3634f7416ad7c0a4cabe068fe4fa6633f2560"},{"_id":"public/tag//index.html","modified":1482581607556,"shasum":"69c3634f7416ad7c0a4cabe068fe4fa6633f2560"},{"_id":"public/tag/ctsc/index.html","modified":1482581607572,"shasum":"2d5a49ce30f9deb3a30d49714f1339d899db7e9a"},{"_id":"public/tag/-24-/index.html","modified":1482581607622,"shasum":"f6f778e54030301c17b0b98999ebd289a320fd91"},{"_id":"public/tag/-24-/page/2/index.html","modified":1482581607646,"shasum":"0d06b7b1508d705f01f023388f50da2cf1409914"},{"_id":"public/tag/cqoi/index.html","modified":1482581607673,"shasum":"967ab6133298a1e713d495ff62d2a44d9858ea75"},{"_id":"public/tag//index.html","modified":1482581607690,"shasum":"60b01ac3b97d6a95488095039431a16da30f5388"},{"_id":"public/tag//index.html","modified":1482581607704,"shasum":"c92fb0a9087ac8152cda5e555532f0dd8f45584e"},{"_id":"public/tag/usaco/index.html","modified":1482581607756,"shasum":"7dba1defa89423a424879621c5f8d5901a6a8c41"},{"_id":"public/tag/coci/index.html","modified":1482581607773,"shasum":"804764b475a5ce58906d24281a5a4a78ff156e48"},{"_id":"public/tag//index.html","modified":1482581607789,"shasum":"804764b475a5ce58906d24281a5a4a78ff156e48"},{"_id":"public/tag/codeforces/index.html","modified":1482581607811,"shasum":"7bd22759dd9770986992c1ef259d537c50158335"},{"_id":"public/tag/ceoi/index.html","modified":1482581607828,"shasum":"1bfe4f90b606cb42090275072f3584a213f6fe24"},{"_id":"public/tag/lucas-/index.html","modified":1482581607847,"shasum":"cf3d1e4a97c4ffab74a2bd0fb89afd0f67cd62fb"},{"_id":"public/tag//index.html","modified":1482581607876,"shasum":"a1689d778729789afa75314ddb970a2bef4d0807"},{"_id":"public/tag//index.html","modified":1482581607894,"shasum":"e653da798b336ea5c406a05caeb813ffb8d7771a"},{"_id":"public/tag//index.html","modified":1482581607912,"shasum":"855f61f998401929e112ce85a25fadd46337407f"},{"_id":"public/tag/dijkstra/index.html","modified":1482581607932,"shasum":"44ab3259bdae0fed99de79d91cb646189b7cfa95"},{"_id":"public/tag//index.html","modified":1482581607952,"shasum":"63088183393bfa430ad3bca864ea40cd684a6663"},{"_id":"public/tag/apio/index.html","modified":1482581607975,"shasum":"5b574bf13064d633c4604d8c680f905dd6de4766"},{"_id":"public/tag/dag/index.html","modified":1482581607992,"shasum":"1ba71ea8f2eb4bf5016bba2c718508f0857d4e36"},{"_id":"public/tag//index.html","modified":1482581608019,"shasum":"1ba71ea8f2eb4bf5016bba2c718508f0857d4e36"},{"_id":"public/tag/bellman-ford/index.html","modified":1482581608036,"shasum":"1ba71ea8f2eb4bf5016bba2c718508f0857d4e36"},{"_id":"public/tag/ahoi/index.html","modified":1482581608064,"shasum":"d97cfbdb8e9287f57a0ab201169714102977c31d"},{"_id":"public/tag//index.html","modified":1482581608085,"shasum":"00298a739dd8756e6d5041f1fef17a3e0c67adf4"},{"_id":"public/tag//index.html","modified":1482581608103,"shasum":"797c16360429b36f341c13f20063e01b55aa1322"},{"_id":"public/tag//index.html","modified":1482581608122,"shasum":"797c16360429b36f341c13f20063e01b55aa1322"},{"_id":"public/tag//index.html","modified":1482581608141,"shasum":"7101c89cf430d691277f128b8c69e568f894bc00"},{"_id":"public/tag//index.html","modified":1482581608170,"shasum":"bcbe096a50a63a31a8f4d51a00b4ad2b5bb58e21"},{"_id":"public/tag//index.html","modified":1482581608188,"shasum":"28224b0f91184550d37c068dca6423fedb41a419"},{"_id":"public/atom.xml","modified":1483060796857,"shasum":"d7f9548a79ff89fc2ddc3fcb2dc9a8d2c3d5484f"},{"_id":"source/_posts/kmp-notes/zyz.png","shasum":"dfd9927ef6410bf5e7eedd4af19f20b017bed0c5","modified":1482744939932},{"_id":"public/kmp-notes/zyz.png","modified":1482744970877,"shasum":"dfd9927ef6410bf5e7eedd4af19f20b017bed0c5"},{"_id":"public/acam-notes/kmp-notes/zyz.png","modified":1482806175806,"shasum":"dfd9927ef6410bf5e7eedd4af19f20b017bed0c5"},{"_id":"source/_posts/acam-notes/zyz.png","shasum":"dfd9927ef6410bf5e7eedd4af19f20b017bed0c5","modified":1482806066399},{"_id":"public/acam-notes/zyz.png","modified":1482806252036,"shasum":"dfd9927ef6410bf5e7eedd4af19f20b017bed0c5"},{"_id":"source/_posts/tree-chain-split-notes/1.svg","shasum":"0cb9b692551b4a57c404a90123f7de48afb98f9a","modified":1482885237906},{"_id":"source/_posts/tree-chain-split-notes.md","shasum":"89bedf92647872132b7d63c29a7eb141f01075aa","modified":1482892283484},{"_id":"source/_posts/tree-chain-split-notes/zyz.png","shasum":"dfd9927ef6410bf5e7eedd4af19f20b017bed0c5","modified":1482892264849},{"_id":"public/tree-chain-split-notes/1.svg","modified":1482892313157,"shasum":"0cb9b692551b4a57c404a90123f7de48afb98f9a"},{"_id":"public/tree-chain-split-notes/zyz.png","modified":1482892313160,"shasum":"dfd9927ef6410bf5e7eedd4af19f20b017bed0c5"},{"_id":"public/tree-chain-split-notes/index.html","modified":1482892327960,"shasum":"b54ca11722c9eee3a0d2caaef4e6d0d5fd8a138a"},{"_id":"source/_posts/tarjan-cut-notes/zyz.png","shasum":"dfd9927ef6410bf5e7eedd4af19f20b017bed0c5","modified":1482994430646},{"_id":"public/tarjan-cut-notes/zyz.png","modified":1482994454582,"shasum":"dfd9927ef6410bf5e7eedd4af19f20b017bed0c5"},{"_id":"source/_posts/rmq-template/zyz.png","shasum":"dfd9927ef6410bf5e7eedd4af19f20b017bed0c5","modified":1483060657070},{"_id":"source/_posts/rmq-template.md","shasum":"bfe5a26d89106e266298094c00877683335056a0","modified":1483060752231},{"_id":"public/rmq-template/zyz.png","modified":1483060776014,"shasum":"dfd9927ef6410bf5e7eedd4af19f20b017bed0c5"},{"_id":"public/rmq-template/index.html","modified":1483060776184,"shasum":"185793f70ce089e3062db4e8050c26159e215ff6"},{"_id":"public/archives/page/30/index.html","modified":1483060792633,"shasum":"06724e4979c5f725bee9e5da8836de435b87085b"},{"_id":"public/page/30/index.html","modified":1483060798350,"shasum":"64d1425dc64ff10f546dab92d558dad866e2e258"}],"Category":[{"name":"OI","_id":"cix2l6brs0001c2xl0l3y9lrn"},{"name":"Geek","_id":"cix2l6buf0035c2xl5d1a7yl0"},{"name":"Diary","_id":"cix2l6bzw00ahc2xlhdb7ev07"}],"Data":[],"Page":[{"title":"Tags","layout":"tags","_content":"","source":"tags/index.md","raw":"title: \"Tags\"\nlayout: \"tags\"\n---\n","date":"2016-09-10T05:42:23.025Z","updated":"2016-09-10T05:42:23.025Z","path":"tags/index.html","comments":1,"_id":"cix2l6bs5000dc2xlqqx6v3xv"},{"title":"Friends","date":"2016-01-18T13:08:05.000Z","_content":"\n<table width=\"100%\" id=\"oier\" style=\"text-align: center; \">\n<thead>\n<tr class=\"header\">\n<th><span>Link</span></th>\n<th><span>School</span></th>\n</tr>\n</thead>\n\n<tbody>\n<tr>\n<td>[sxb_201](http://blog.csdn.net/sxb_201)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Creation <span style=\"color: #FFA200; display: inline; \"><b>Au</b></span>gust](http://blog.csdn.net/creationaugust)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[yts1999](http://yts1999.coding.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Travis](http://travisbraps.top/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Erii](http://erii.moe)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[ws_fqk](http://blog.csdn.net/phenix_2015)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[ws_yzy](http://blog.csdn.net/ws_yzy)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[MagHSK](http://www.maghsk.cn/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Dashgua](http://dashgua.coding.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[MedalPluS](http://medalplus.com/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[FireStorm](http://blog.csdn.net/farestorm)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Loi_DQS](http://blog.csdn.net/loi_dqs)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[danihao123](http://danihao123.is-programmer.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Rapiz](https://www.zybuluo.com/rapiz/note/367932)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[changke](http://changke-blog.logdown.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Platypus](http://platypuspro.github.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Fancy](http://fancypei.github.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Franky](http://www.cnblogs.com/Franky-ln/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[CXCXCXC](http://www.cnblogs.com/CXCXCXC)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[sui](http://1115825064.github.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Fuxey](http://blog.csdn.net/fuxey)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Sengxian](http://www.sengxian.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[zean](http://blog.zean.xyz/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[lkMiles](http://lkmiles.lofter.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[FeLJ](http://www.felj.top/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[](http://chickger.pw/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[abclzr](http://www.cnblogs.com/abclzr)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[DaD3zZ](http://www.cnblogs.com/DaD3zZ-Beyonder/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[BeiYu](http://www.beiyu-is-too-naive.cc/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[ShallWe](http://shallwe2000.cc/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[frank_c1](http://www.acyume.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Krydom](http://krydom.com/)</td>\n<td><span></span></td>\n</tr>\n\n</tbody>\n\n</table>\n\n# LYOI 2016\n[Edge](http://blog.u-pt.pw) [ilern](http://ilern.coding.me/428/) [yqy](https://yqy.moe) [Sulfur6](http://sulfur6.top/) [Roller](http://roller.coding.me/heyheyhey/) [x_shuai](http://x_shuai.leanote.com/) [Gavin](http://gavin_blog.leanote.com/) [Grape](http://bbs.u-pt.pw)\n\n# \n\n[](http://www.18tilab.com/)\n\n[Arondight](http://arondight.me/)\n\n[Dimpurr](http://im.dimpurr.com/)\n","source":"friends.md","raw":"title: Friends\npermalink: friends/\ndate: 2016-01-18 21:08:05\n---\n\n<table width=\"100%\" id=\"oier\" style=\"text-align: center; \">\n<thead>\n<tr class=\"header\">\n<th><span>Link</span></th>\n<th><span>School</span></th>\n</tr>\n</thead>\n\n<tbody>\n<tr>\n<td>[sxb_201](http://blog.csdn.net/sxb_201)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Creation <span style=\"color: #FFA200; display: inline; \"><b>Au</b></span>gust](http://blog.csdn.net/creationaugust)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[yts1999](http://yts1999.coding.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Travis](http://travisbraps.top/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Erii](http://erii.moe)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[ws_fqk](http://blog.csdn.net/phenix_2015)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[ws_yzy](http://blog.csdn.net/ws_yzy)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[MagHSK](http://www.maghsk.cn/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Dashgua](http://dashgua.coding.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[MedalPluS](http://medalplus.com/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[FireStorm](http://blog.csdn.net/farestorm)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Loi_DQS](http://blog.csdn.net/loi_dqs)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[danihao123](http://danihao123.is-programmer.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Rapiz](https://www.zybuluo.com/rapiz/note/367932)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[changke](http://changke-blog.logdown.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Platypus](http://platypuspro.github.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Fancy](http://fancypei.github.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Franky](http://www.cnblogs.com/Franky-ln/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[CXCXCXC](http://www.cnblogs.com/CXCXCXC)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[sui](http://1115825064.github.io/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Fuxey](http://blog.csdn.net/fuxey)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Sengxian](http://www.sengxian.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[zean](http://blog.zean.xyz/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[lkMiles](http://lkmiles.lofter.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[FeLJ](http://www.felj.top/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[](http://chickger.pw/)</td>\n<td><span>-</span></td>\n</tr>\n\n<tr>\n<td>[abclzr](http://www.cnblogs.com/abclzr)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[DaD3zZ](http://www.cnblogs.com/DaD3zZ-Beyonder/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[BeiYu](http://www.beiyu-is-too-naive.cc/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[ShallWe](http://shallwe2000.cc/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[frank_c1](http://www.acyume.com/)</td>\n<td><span></span></td>\n</tr>\n\n<tr>\n<td>[Krydom](http://krydom.com/)</td>\n<td><span></span></td>\n</tr>\n\n</tbody>\n\n</table>\n\n# LYOI 2016\n[Edge](http://blog.u-pt.pw) [ilern](http://ilern.coding.me/428/) [yqy](https://yqy.moe) [Sulfur6](http://sulfur6.top/) [Roller](http://roller.coding.me/heyheyhey/) [x_shuai](http://x_shuai.leanote.com/) [Gavin](http://gavin_blog.leanote.com/) [Grape](http://bbs.u-pt.pw)\n\n# \n\n[](http://www.18tilab.com/)\n\n[Arondight](http://arondight.me/)\n\n[Dimpurr](http://im.dimpurr.com/)\n","updated":"2016-10-15T13:43:52.349Z","path":"friends/index.html","comments":1,"layout":"page","_id":"cix2l6bs8000ec2xl1qkqnf3u"},{"title":"About Me","date":"2015-11-22T21:36:32.000Z","_content":"\n OI ~~~~~~~~\n\n 2015  8  OI\n\n\n\n<!--  NOI  -->\n\n> \n","source":"about-me.md","raw":"title: About Me\npermalink: about-me/\ndate: 2015-11-23 05:36:32\n---\n\n OI ~~~~~~~~\n\n 2015  8  OI\n\n\n\n<!--  NOI  -->\n\n> \n","updated":"2016-05-20T12:39:29.758Z","path":"about-me/index.html","comments":1,"layout":"page","_id":"cix2l6bsa000fc2xlz82h6osx"}],"Post":[{"title":" - ","date":"2016-03-20T15:07:32.000Z","_content":"\n $ n $  $ 0 $ \n\n1.  $ x $ \n2.  $ x $ \n\n<!-- more -->\n\n### \n $ sum $  $ count $\n\n u \n\n$$ sum + (count - count(u)) * d_i - count(u) * d_i $$\n\n\n\n$$ sum + count * d_i - 2 * count(u) * d_i $$\n\n $ count(u) * d_i $  $ O(log ^ 2 n) $ \n\n### \n```c++\n#include <cstdio>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100000; \nconst int MAXM = 100000; \n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lchild, *rchild;\n\n\tint blackCount;\n\tint count, lazyCount, base;\n\tlong long sum;\n\n\tSegmentTree(int l, int r, SegmentTree *lchild, SegmentTree *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), blackCount(0), count(0), lazyCount(0), base(0), sum(0) {}\n\n\t~SegmentTree() {\n\t\tif (lchild) delete lchild;\n\t\tif (rchild) delete rchild;\n\t}\n\n\tvoid pushDown() {\n\t\tif (lazyCount) {\n\t\t\tif (lchild) lchild->lazyCount += lazyCount, lchild->count += lazyCount, lchild->sum += (long long)lchild->base * lazyCount;\n\t\t\tif (rchild) rchild->lazyCount += lazyCount, rchild->count += lazyCount, rchild->sum += (long long)rchild->base * lazyCount;\n\t\t\tlazyCount = 0;\n\t\t}\n\t}\n\n\tlong long querySum(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlong long result = 0;\n\t\t\tif (lchild) result += lchild->querySum(l, r);\n\t\t\tif (rchild) result += rchild->querySum(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint queryCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return count;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryCount(l, r);\n\t\t\tif (rchild) result += rchild->queryCount(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateCount(int l, int r, int delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) lazyCount += delta, count += delta, sum += (long long)delta * base;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tsum = count = 0;\n\t\t\tif (lchild) lchild->updateCount(l, r, delta), count += lchild->count, sum += lchild->sum;\n\t\t\tif (rchild) rchild->updateCount(l, r, delta), count += rchild->count, sum += rchild->sum;\n\t\t}\n\t}\n\n\tvoid setBase(int x, int base) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) this->base = base;\n\t\telse {\n\t\t\tif (lchild) lchild->setBase(x, base);\n\t\t\tif (rchild) rchild->setBase(x, base);\n\t\t\tthis->base = lchild->base + rchild->base;\n\t\t}\n\t}\n\n\tint queryBlackCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return blackCount;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryBlackCount(l, r);\n\t\t\tif (rchild) result += rchild->queryBlackCount(l, r);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateBlackCount(int x, int delta) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) blackCount += delta;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tblackCount = 0;\n\t\t\tif (lchild) lchild->updateBlackCount(x, delta), blackCount += lchild->blackCount;\n\t\t\tif (rchild) rchild->updateBlackCount(x, delta), blackCount += rchild->blackCount;\n\t\t}\n\t}\n};\n\nSegmentTree *buildSegmentTree(int l, int r) {\n\tif (l > r) return NULL;\n\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\telse return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) >> 1)), buildSegmentTree(l + ((r - l) >> 1) + 1, r));\n}\n\nstruct Tree;\nstruct Path;\n\nstruct Tree {\n\tTree *firstChild, *next, *parent, *maxSizeChild;\n\tbool visited, colored;\n\tPath *path;\n\tint size, depth, pos, posEnd;\n\tlong long cost, costPrefixSum;\n} trees[MAXN];\n\nstruct Path {\n\tTree *top;\n\tint length;\n\tPath(Tree *top) : top(top), length(1) {}\n};\n\ninline void addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n}\n\nint n, m, blackCount;\nlong long sum;\nSegmentTree *segment;\n\ninline void cut() {\n\tstd::stack<Tree *> s;\n\ts.push(&trees[0]);\n\ttrees[0].depth = 1;\n\ttrees[0].costPrefixSum = 0;\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tc->depth = t->depth + 1;\n\t\t\t\tc->costPrefixSum = t->costPrefixSum + c->cost;\n\t\t\t\ts.push(c);\n\t\t\t}\n\t\t} else {\n\t\t\tt->size = 1;\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) t->maxSizeChild = c;\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\ts.push(&trees[0]);\n\n\tint timeStamp = 0;\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tif (t->parent == NULL || t->parent->maxSizeChild != t) t->path = new Path(t);\n\t\t\telse t->path = t->parent->path, t->path->length++;\n\n\t\t\tt->pos = ++timeStamp;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\t\t} else {\n\t\t\tt->posEnd = timeStamp;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = buildSegmentTree(1, n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsegment->setBase(trees[i].pos, trees[i].cost);\n\t}\n}\n\ninline int queryDist(int u, int v) {\n\tif (u == v) return 0;\n\n\tTree *a = &trees[u], *b = &trees[v];\n\tint sum = 0;\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) std::swap(a, b);\n\t\tsum += segment->querySum(a->path->top->pos, a->pos);\n\t\t// printf(\"query(%d, %d)::sum = %d\\n\", u, v, sum);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) std::swap(a, b);\n\tsum += segment->querySum(a->pos, b->pos);\n\tsum -= a->cost;\n\n\treturn sum;\n}\n\ninline void updateToBlack(int u) {\n\tif (trees[u].colored) return;\n\ttrees[u].colored = true;\n\tsum += trees[u].costPrefixSum;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) {\n\t\tsegment->updateCount(t->path->top->pos, t->pos, 1);\n\t}\n\tsegment->updateBlackCount(trees[u].pos, 1);\n\tblackCount++;\n}\n\ninline long long queryAllDist(int u) {\n\tTree *t = &trees[u];\n\tint childBlackCount = segment->queryBlackCount(t->pos, t->posEnd);\n\tlong long tmp = 0;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) tmp += segment->querySum(t->path->top->pos, t->pos);\n\treturn sum + t->costPrefixSum * blackCount - 2 * tmp;\n}\n\nint main() {\n\t// freopen(\"color.in\", \"r\", stdin);\n\t// freopen(\"color.out\", \"w\", stdout);\n\t\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint parent;\n\t\tscanf(\"%d\", &parent);\n\n\t\taddRelation(i, parent);\n\t}\n\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%lld\", &trees[i].cost);\n\t}\n\n\tcut();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint t, u;\n\t\tscanf(\"%d %d\", &t, &u);\n\n\t\tif (t == 1) updateToBlack(u);\n\t\telse printf(\"%lld\\n\", queryAllDist(u));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n\n","source":"_posts/20160318-color.md","raw":"title:  - \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - \npermalink: 20160318-color\ndate: 2016-03-20 23:07:32\n---\n\n $ n $  $ 0 $ \n\n1.  $ x $ \n2.  $ x $ \n\n<!-- more -->\n\n### \n $ sum $  $ count $\n\n u \n\n$$ sum + (count - count(u)) * d_i - count(u) * d_i $$\n\n\n\n$$ sum + count * d_i - 2 * count(u) * d_i $$\n\n $ count(u) * d_i $  $ O(log ^ 2 n) $ \n\n### \n```c++\n#include <cstdio>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100000; \nconst int MAXM = 100000; \n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lchild, *rchild;\n\n\tint blackCount;\n\tint count, lazyCount, base;\n\tlong long sum;\n\n\tSegmentTree(int l, int r, SegmentTree *lchild, SegmentTree *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), blackCount(0), count(0), lazyCount(0), base(0), sum(0) {}\n\n\t~SegmentTree() {\n\t\tif (lchild) delete lchild;\n\t\tif (rchild) delete rchild;\n\t}\n\n\tvoid pushDown() {\n\t\tif (lazyCount) {\n\t\t\tif (lchild) lchild->lazyCount += lazyCount, lchild->count += lazyCount, lchild->sum += (long long)lchild->base * lazyCount;\n\t\t\tif (rchild) rchild->lazyCount += lazyCount, rchild->count += lazyCount, rchild->sum += (long long)rchild->base * lazyCount;\n\t\t\tlazyCount = 0;\n\t\t}\n\t}\n\n\tlong long querySum(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlong long result = 0;\n\t\t\tif (lchild) result += lchild->querySum(l, r);\n\t\t\tif (rchild) result += rchild->querySum(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint queryCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return count;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryCount(l, r);\n\t\t\tif (rchild) result += rchild->queryCount(l, r);\n\t\t\t// printf(\"sq(%d, %d) = %d\\n\", l, r, result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateCount(int l, int r, int delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) lazyCount += delta, count += delta, sum += (long long)delta * base;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tsum = count = 0;\n\t\t\tif (lchild) lchild->updateCount(l, r, delta), count += lchild->count, sum += lchild->sum;\n\t\t\tif (rchild) rchild->updateCount(l, r, delta), count += rchild->count, sum += rchild->sum;\n\t\t}\n\t}\n\n\tvoid setBase(int x, int base) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) this->base = base;\n\t\telse {\n\t\t\tif (lchild) lchild->setBase(x, base);\n\t\t\tif (rchild) rchild->setBase(x, base);\n\t\t\tthis->base = lchild->base + rchild->base;\n\t\t}\n\t}\n\n\tint queryBlackCount(int l, int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return blackCount;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tint result = 0;\n\t\t\tif (lchild) result += lchild->queryBlackCount(l, r);\n\t\t\tif (rchild) result += rchild->queryBlackCount(l, r);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid updateBlackCount(int x, int delta) {\n\t\tif (x > this->r || x < this->l) return;\n\t\telse if (x == this->l && x == this->r) blackCount += delta;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tblackCount = 0;\n\t\t\tif (lchild) lchild->updateBlackCount(x, delta), blackCount += lchild->blackCount;\n\t\t\tif (rchild) rchild->updateBlackCount(x, delta), blackCount += rchild->blackCount;\n\t\t}\n\t}\n};\n\nSegmentTree *buildSegmentTree(int l, int r) {\n\tif (l > r) return NULL;\n\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\telse return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) >> 1)), buildSegmentTree(l + ((r - l) >> 1) + 1, r));\n}\n\nstruct Tree;\nstruct Path;\n\nstruct Tree {\n\tTree *firstChild, *next, *parent, *maxSizeChild;\n\tbool visited, colored;\n\tPath *path;\n\tint size, depth, pos, posEnd;\n\tlong long cost, costPrefixSum;\n} trees[MAXN];\n\nstruct Path {\n\tTree *top;\n\tint length;\n\tPath(Tree *top) : top(top), length(1) {}\n};\n\ninline void addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n}\n\nint n, m, blackCount;\nlong long sum;\nSegmentTree *segment;\n\ninline void cut() {\n\tstd::stack<Tree *> s;\n\ts.push(&trees[0]);\n\ttrees[0].depth = 1;\n\ttrees[0].costPrefixSum = 0;\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tc->depth = t->depth + 1;\n\t\t\t\tc->costPrefixSum = t->costPrefixSum + c->cost;\n\t\t\t\ts.push(c);\n\t\t\t}\n\t\t} else {\n\t\t\tt->size = 1;\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) t->maxSizeChild = c;\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\ts.push(&trees[0]);\n\n\tint timeStamp = 0;\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\n\t\tif (!t->visited) {\n\t\t\tt->visited = true;\n\n\t\t\tif (t->parent == NULL || t->parent->maxSizeChild != t) t->path = new Path(t);\n\t\t\telse t->path = t->parent->path, t->path->length++;\n\n\t\t\tt->pos = ++timeStamp;\n\n\t\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\t\t} else {\n\t\t\tt->posEnd = timeStamp;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = buildSegmentTree(1, n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsegment->setBase(trees[i].pos, trees[i].cost);\n\t}\n}\n\ninline int queryDist(int u, int v) {\n\tif (u == v) return 0;\n\n\tTree *a = &trees[u], *b = &trees[v];\n\tint sum = 0;\n\twhile (a->path != b->path) {\n\t\tif (a->path->top->depth < b->path->top->depth) std::swap(a, b);\n\t\tsum += segment->querySum(a->path->top->pos, a->pos);\n\t\t// printf(\"query(%d, %d)::sum = %d\\n\", u, v, sum);\n\t\ta = a->path->top->parent;\n\t}\n\n\tif (a->pos > b->pos) std::swap(a, b);\n\tsum += segment->querySum(a->pos, b->pos);\n\tsum -= a->cost;\n\n\treturn sum;\n}\n\ninline void updateToBlack(int u) {\n\tif (trees[u].colored) return;\n\ttrees[u].colored = true;\n\tsum += trees[u].costPrefixSum;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) {\n\t\tsegment->updateCount(t->path->top->pos, t->pos, 1);\n\t}\n\tsegment->updateBlackCount(trees[u].pos, 1);\n\tblackCount++;\n}\n\ninline long long queryAllDist(int u) {\n\tTree *t = &trees[u];\n\tint childBlackCount = segment->queryBlackCount(t->pos, t->posEnd);\n\tlong long tmp = 0;\n\tfor (Tree *t = &trees[u]; t; t = t->path->top->parent) tmp += segment->querySum(t->path->top->pos, t->pos);\n\treturn sum + t->costPrefixSum * blackCount - 2 * tmp;\n}\n\nint main() {\n\t// freopen(\"color.in\", \"r\", stdin);\n\t// freopen(\"color.out\", \"w\", stdout);\n\t\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint parent;\n\t\tscanf(\"%d\", &parent);\n\n\t\taddRelation(i, parent);\n\t}\n\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%lld\", &trees[i].cost);\n\t}\n\n\tcut();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint t, u;\n\t\tscanf(\"%d %d\", &t, &u);\n\n\t\tif (t == 1) updateToBlack(u);\n\t\telse printf(\"%lld\\n\", queryAllDist(u));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n\n","slug":"20160318-color","published":1,"updated":"2016-05-11T09:33:24.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6brk0000c2xlfe4nxt7l"},{"title":"ZJOI2014 - FFT","date":"2016-06-11T13:27:00.000Z","_content":"\n\n\n$$ E_i = \\frac{F_i}{q_i} $$\n\n$$ F_j = \\sum\\limits_{i < j} \\frac{q_i q_j}{(i - j) ^ 2} - \\sum\\limits_{i > j} \\frac{q_i q_j}{(i - j) ^ 2}  $$\n\n $ E $\n\n<!-- more -->\n\n### \n[BZOJ 3527](http://www.lydsy.com/JudgeOnline/problem.php?id=3527)\n\n### \n\n\n$$ E_j = \\sum\\limits_{i < j} \\frac{q_i}{(i - j) ^ 2} - \\sum\\limits_{i > j} \\frac{q_i}{(i - j) ^ 2} $$\n\n $ E_j = A_j - B_j $ \n\n$$ A_j = \\sum\\limits_{i = 1} ^ {j - 1} \\frac{q_j}{(i - j) ^ 2} $$\n\n\n\n$$\ng(i) = \\begin{cases} \\frac{1}{i ^ 2} & i \\neq 0 \\\\ 0 & i = 0 \\end{cases}\n$$\n\n$$\nf(i) = \\begin{cases} q_i & i \\neq 0 \\\\ 0 & i = 0 \\end{cases}\n$$\n\n\n\n$$ A_j = \\sum\\limits_{i = 0} ^ {j} f(i) g(j - i) $$\n\n~~~~ FFT \n\n\n\n$$ A_j = \\sum\\limits_{i = j + 1} ^ {n} \\frac{q_j}{(i - j) ^ 2} $$\n\n [BZOJ 2194](bzoj-2194)  $ A $ \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_EXTENDED = 262144;\nconst long double PI = acos(-1);\n\nstruct FastFourierTransform {\n\tstd::complex<long double> omega[MAXN_EXTENDED], omegaInverse[MAXN_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tomega[i] = std::complex<long double>(cosl(2 * PI / n * i), sinl(2 * PI / n * i));\n\t\t\tomegaInverse[i] = std::conj(omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(std::complex<long double> *a, const int n, const std::complex<long double> *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[t], a[i]);\n\t\t}\n\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tconst int m = l / 2;\n\t\t\tfor (std::complex<long double> *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tconst std::complex<long double> t = omega[n / l * i] * p[i + m];\n\t\t\t\t\tp[i + m] = p[i] - t;\n\t\t\t\t\tp[i] += t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(std::complex<long double> *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(std::complex<long double> *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tfor (int i = 0; i < n; i++) a[i] /= n;\n\t}\n\n\tvoid multiply(std::complex<long double> *a, std::complex<long double> *b, const int n) {\n\t\tint size = 1;\n\t\twhile (size < n * 2) size *= 2;\n\n\t\t/*\n\t\tstatic std::complex<long double> c[MAXN_EXTENDED];\n\t\tfor (int i = 0; i < n; i++) c[i] = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int i = 0; i <= j; i++) {\n\t\t\t\tc[j] += a[i] * b[j - i];\n\t\t\t}\n\t\t}\n\n\t\tstd::copy(c, c + n, a);\n\t\treturn;\n\t\t*/\n\n\t\tinit(size);\n\n\t\tdft(a, size);\n\t\tdft(b, size);\n\n\t\tfor (int i = 0; i < size; i++) a[i] *= b[i];\n\n\t\tidft(a, size);\n\t}\n} fft;\n\nint n;\nlong double q[MAXN + 1];\n\ninline void calc(const long double *q, long double *E) {\n\tstatic std::complex<long double> f[MAXN_EXTENDED], g[MAXN_EXTENDED];\n\tstd::fill(f, f + MAXN_EXTENDED, 0);\n\tstd::fill(g, g + MAXN_EXTENDED, 0);\n\tstd::copy(q, q + n + 1, f);\n\tf[0] = g[0] = std::complex<long double>(0, 0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tg[i] = std::complex<long double>(1.0 / pow(i, 2), 0);\n\t}\n\n\tfft.multiply(f, g, n + 1);\n\tfor (int i = 1; i <= n; i++) E[i] = f[i].real();\n\n\t/*\n\tfor (int i = 0; i < (n + 1) * 2; i++) printf(\"* %lf\\n\", static_cast<double>(f[i].real()));\n\tputchar('\\n');\n\n\treturn;\n\n\tstatic std::complex<long double> r[MAXN_EXTENDED];\n\tfor (int j = 0; j <= n; j++) {\n\t\tr[j] = 0;\n\t\tfor (int i = 0; i <= j; i++) {\n\t\t\tr[j] += f[i] * g[j - i];\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= n; i++) printf(\"* %lf\\n\", static_cast<double>(r[i].real()));\n\tputchar('\\n');\n\n\tfor (int i = 1; i <= n; i++) E[i] = r[i].real();\n\t*/\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tdouble x;\n\t\tscanf(\"%lf\", &x);\n\t\tq[i] = x;\n\t}\n\n\tstatic long double E1[MAXN + 1], E2[MAXN + 1];\n\tcalc(q, E1);\n\tstd::reverse(q + 1, q + n + 1);\n\tcalc(q, E2);\n\n\tfor (int i = 1; i <= n; i++) printf(\"%.3lf\\n\", static_cast<double>(E1[i] - E2[n - i + 1]));\n\n\treturn 0;\n}\n```\n","source":"_posts/zjoi2014-force.md","raw":"title: ZJOI2014 - FFT\ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - FFT\n  - \npermalink: zjoi2014-force\ndate: 2016-06-11 21:27:00\n---\n\n\n\n$$ E_i = \\frac{F_i}{q_i} $$\n\n$$ F_j = \\sum\\limits_{i < j} \\frac{q_i q_j}{(i - j) ^ 2} - \\sum\\limits_{i > j} \\frac{q_i q_j}{(i - j) ^ 2}  $$\n\n $ E $\n\n<!-- more -->\n\n### \n[BZOJ 3527](http://www.lydsy.com/JudgeOnline/problem.php?id=3527)\n\n### \n\n\n$$ E_j = \\sum\\limits_{i < j} \\frac{q_i}{(i - j) ^ 2} - \\sum\\limits_{i > j} \\frac{q_i}{(i - j) ^ 2} $$\n\n $ E_j = A_j - B_j $ \n\n$$ A_j = \\sum\\limits_{i = 1} ^ {j - 1} \\frac{q_j}{(i - j) ^ 2} $$\n\n\n\n$$\ng(i) = \\begin{cases} \\frac{1}{i ^ 2} & i \\neq 0 \\\\ 0 & i = 0 \\end{cases}\n$$\n\n$$\nf(i) = \\begin{cases} q_i & i \\neq 0 \\\\ 0 & i = 0 \\end{cases}\n$$\n\n\n\n$$ A_j = \\sum\\limits_{i = 0} ^ {j} f(i) g(j - i) $$\n\n~~~~ FFT \n\n\n\n$$ A_j = \\sum\\limits_{i = j + 1} ^ {n} \\frac{q_j}{(i - j) ^ 2} $$\n\n [BZOJ 2194](bzoj-2194)  $ A $ \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_EXTENDED = 262144;\nconst long double PI = acos(-1);\n\nstruct FastFourierTransform {\n\tstd::complex<long double> omega[MAXN_EXTENDED], omegaInverse[MAXN_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tomega[i] = std::complex<long double>(cosl(2 * PI / n * i), sinl(2 * PI / n * i));\n\t\t\tomegaInverse[i] = std::conj(omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(std::complex<long double> *a, const int n, const std::complex<long double> *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[t], a[i]);\n\t\t}\n\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tconst int m = l / 2;\n\t\t\tfor (std::complex<long double> *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tconst std::complex<long double> t = omega[n / l * i] * p[i + m];\n\t\t\t\t\tp[i + m] = p[i] - t;\n\t\t\t\t\tp[i] += t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(std::complex<long double> *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(std::complex<long double> *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tfor (int i = 0; i < n; i++) a[i] /= n;\n\t}\n\n\tvoid multiply(std::complex<long double> *a, std::complex<long double> *b, const int n) {\n\t\tint size = 1;\n\t\twhile (size < n * 2) size *= 2;\n\n\t\t/*\n\t\tstatic std::complex<long double> c[MAXN_EXTENDED];\n\t\tfor (int i = 0; i < n; i++) c[i] = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int i = 0; i <= j; i++) {\n\t\t\t\tc[j] += a[i] * b[j - i];\n\t\t\t}\n\t\t}\n\n\t\tstd::copy(c, c + n, a);\n\t\treturn;\n\t\t*/\n\n\t\tinit(size);\n\n\t\tdft(a, size);\n\t\tdft(b, size);\n\n\t\tfor (int i = 0; i < size; i++) a[i] *= b[i];\n\n\t\tidft(a, size);\n\t}\n} fft;\n\nint n;\nlong double q[MAXN + 1];\n\ninline void calc(const long double *q, long double *E) {\n\tstatic std::complex<long double> f[MAXN_EXTENDED], g[MAXN_EXTENDED];\n\tstd::fill(f, f + MAXN_EXTENDED, 0);\n\tstd::fill(g, g + MAXN_EXTENDED, 0);\n\tstd::copy(q, q + n + 1, f);\n\tf[0] = g[0] = std::complex<long double>(0, 0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tg[i] = std::complex<long double>(1.0 / pow(i, 2), 0);\n\t}\n\n\tfft.multiply(f, g, n + 1);\n\tfor (int i = 1; i <= n; i++) E[i] = f[i].real();\n\n\t/*\n\tfor (int i = 0; i < (n + 1) * 2; i++) printf(\"* %lf\\n\", static_cast<double>(f[i].real()));\n\tputchar('\\n');\n\n\treturn;\n\n\tstatic std::complex<long double> r[MAXN_EXTENDED];\n\tfor (int j = 0; j <= n; j++) {\n\t\tr[j] = 0;\n\t\tfor (int i = 0; i <= j; i++) {\n\t\t\tr[j] += f[i] * g[j - i];\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= n; i++) printf(\"* %lf\\n\", static_cast<double>(r[i].real()));\n\tputchar('\\n');\n\n\tfor (int i = 1; i <= n; i++) E[i] = r[i].real();\n\t*/\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tdouble x;\n\t\tscanf(\"%lf\", &x);\n\t\tq[i] = x;\n\t}\n\n\tstatic long double E1[MAXN + 1], E2[MAXN + 1];\n\tcalc(q, E1);\n\tstd::reverse(q + 1, q + n + 1);\n\tcalc(q, E2);\n\n\tfor (int i = 1; i <= n; i++) printf(\"%.3lf\\n\", static_cast<double>(E1[i] - E2[n - i + 1]));\n\n\treturn 0;\n}\n```\n","slug":"zjoi2014-force","published":1,"updated":"2016-06-12T01:30:38.354Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bse000gc2xlqobyapd6"},{"title":"ZJOI2010 -  + ","date":"2016-06-21T00:48:00.000Z","_content":"\n $ C $  $ W $ $ 1 $ \n\n1. $ 1 $  $ N $ \n2.  $ 1 $  $ N $  $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 1834](http://www.lydsy.com/JudgeOnline/problem.php?id=1834)\n\n### \n\n\n**** $ W $  \n $ K $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 5000;\nconst int MAXK = 10;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c, *in;\n\tint l, d, f;\n\tbool q;\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\n\t\tq.push(&N[s]);\n\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->in = e;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\ninline void addEdge(const int s, const int t, const int c, const int w = 0) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, k;\n\tstatic struct Edge {\n\t\tint s, t, c, w;\n\t} E[MAXM];\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\tscanf(\"%d %d %d %d\", &e.s, &e.t, &e.c, &e.w);\n\t\taddEdge(e.s, e.t, e.c, 0);\n\t}\n\n\tint maxFlow = dinic(1, n, n + 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\taddEdge(e.s, e.t, INT_MAX, e.w);\n\t}\n\n\taddEdge(0, 1, k, 0);\n\n\tint flow, cost;\n\tedmondskarp(0, n, n + 1, flow, cost);\n\tprintf(\"%d %d\\n\", maxFlow, cost);\n\n\treturn 0;\n}\n```\n","source":"_posts/zjoi2010-network.md","raw":"title: ZJOI2010 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - \n  - Dinic\n  - \n  - Edmonds-Karp\npermalink: zjoi2010-network\ndate: 2016-06-21 08:48:00\n---\n\n $ C $  $ W $ $ 1 $ \n\n1. $ 1 $  $ N $ \n2.  $ 1 $  $ N $  $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 1834](http://www.lydsy.com/JudgeOnline/problem.php?id=1834)\n\n### \n\n\n**** $ W $  \n $ K $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 5000;\nconst int MAXK = 10;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c, *in;\n\tint l, d, f;\n\tbool q;\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\n\t\tq.push(&N[s]);\n\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->in = e;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\ninline void addEdge(const int s, const int t, const int c, const int w = 0) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, k;\n\tstatic struct Edge {\n\t\tint s, t, c, w;\n\t} E[MAXM];\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\tscanf(\"%d %d %d %d\", &e.s, &e.t, &e.c, &e.w);\n\t\taddEdge(e.s, e.t, e.c, 0);\n\t}\n\n\tint maxFlow = dinic(1, n, n + 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\taddEdge(e.s, e.t, INT_MAX, e.w);\n\t}\n\n\taddEdge(0, 1, k, 0);\n\n\tint flow, cost;\n\tedmondskarp(0, n, n + 1, flow, cost);\n\tprintf(\"%d %d\\n\", maxFlow, cost);\n\n\treturn 0;\n}\n```\n","slug":"zjoi2010-network","published":1,"updated":"2016-06-21T00:49:12.142Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bsm000qc2xlna0eomn7"},{"title":"ZJOI2009 - ","date":"2016-06-23T10:23:00.000Z","_content":"\nOrez  $ n \\times m $  Orez Orez \n\n<!-- more -->\n\n### \n[BZOJ 1412](http://www.lydsy.com/JudgeOnline/problem.php?id=1412)\n\n### \n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j) { return (i - 1) * m + j; }\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * m + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tif (x == 1) addEdge(s, id(i, j), INT_MAX);\n\t\t\telse if (x == 2) addEdge(id(i, j), t, INT_MAX);\n\n\t\t\tif (i != 1) addEdge(id(i - 1, j), id(i, j), 1);\n\t\t\tif (i != n) addEdge(id(i + 1, j), id(i, j), 1);\n\t\t\tif (j != 1) addEdge(id(i, j - 1), id(i, j), 1);\n\t\t\tif (j != m) addEdge(id(i, j + 1), id(i, j), 1);\n\t\t}\n\t}\n\n\tconst int maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/zjoi2009-ws.md","raw":"title: ZJOI2009 - \ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - \n  - Dinic\n  - \npermalink: zjoi2009-ws\ndate: 2016-06-23 18:23:00\n---\n\nOrez  $ n \\times m $  Orez Orez \n\n<!-- more -->\n\n### \n[BZOJ 1412](http://www.lydsy.com/JudgeOnline/problem.php?id=1412)\n\n### \n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j) { return (i - 1) * m + j; }\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * m + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tif (x == 1) addEdge(s, id(i, j), INT_MAX);\n\t\t\telse if (x == 2) addEdge(id(i, j), t, INT_MAX);\n\n\t\t\tif (i != 1) addEdge(id(i - 1, j), id(i, j), 1);\n\t\t\tif (i != n) addEdge(id(i + 1, j), id(i, j), 1);\n\t\t\tif (j != 1) addEdge(id(i, j - 1), id(i, j), 1);\n\t\t\tif (j != m) addEdge(id(i, j + 1), id(i, j), 1);\n\t\t}\n\t}\n\n\tconst int maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"zjoi2009-ws","published":1,"updated":"2016-06-23T10:23:36.289Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bt00012c2xlt1rs3zv1"},{"title":"ZJOI2008 - DP","date":"2016-11-13T02:00:00.000Z","_content":"\n $ k $ party  $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 1037](http://www.lydsy.com/JudgeOnline/problem.php?id=1037)\n\n### \n $ f(i, j, p, q) $  $ i $  $ j $  $ i $  $ p $  $ q $ \n\n $ i $ \n\n$$ f(i, j, p, q) \\rightarrow f(i + 1, j + 1, p + 1, \\max(q - 1, 0)) $$\n\n\n $ i $ \n\n$$ f(i, j, p, q) \\rightarrow f(i + 1, j, \\max(p - 1, 0), q + 1) $$\n\n $ \\sum\\limits_{p = 0} ^ k \\sum\\limits_{q = 0} ^ k f(n + m, n, p, q) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 150;\nconst int MAXK = 20;\nconst int MOD = 12345678;\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\t// f[i][j][p][q], left i, j boys, max(boys - girls) = p, max(girls - boys) = q\n\tstatic int f[MAXN * 2 + 1][MAXN + 1][MAXK + 2][MAXK + 2];\n\tf[0][0][0][0] = 1;\n\tfor (int i = 0; i < n + m; i++) {\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tfor (int p = 0; p <= k; p++) {\n\t\t\t\tfor (int q = 0; q <= k; q++) {\n\t\t\t\t\t// Add a boy\n\t\t\t\t\t(f[i + 1][j + 1][p + 1][std::max(q - 1, 0)] += f[i][j][p][q]) %= MOD;\n\t\t\t\t\t// Add a girl\n\t\t\t\t\t(f[i + 1][j][std::max(p - 1, 0)][q + 1] += f[i][j][p][q]) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int p = 0; p <= k; p++) for (int q = 0; q <= k; q++) (ans += f[n + m][n][p][q]) %= MOD;\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/zjoi2008-party.md","raw":"title: ZJOI2008 - DP\ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - DP\npermalink: zjoi2008-party\ndate: 2016-11-13 10:00:00\n---\n\n $ k $ party  $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 1037](http://www.lydsy.com/JudgeOnline/problem.php?id=1037)\n\n### \n $ f(i, j, p, q) $  $ i $  $ j $  $ i $  $ p $  $ q $ \n\n $ i $ \n\n$$ f(i, j, p, q) \\rightarrow f(i + 1, j + 1, p + 1, \\max(q - 1, 0)) $$\n\n\n $ i $ \n\n$$ f(i, j, p, q) \\rightarrow f(i + 1, j, \\max(p - 1, 0), q + 1) $$\n\n $ \\sum\\limits_{p = 0} ^ k \\sum\\limits_{q = 0} ^ k f(n + m, n, p, q) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 150;\nconst int MAXK = 20;\nconst int MOD = 12345678;\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\t// f[i][j][p][q], left i, j boys, max(boys - girls) = p, max(girls - boys) = q\n\tstatic int f[MAXN * 2 + 1][MAXN + 1][MAXK + 2][MAXK + 2];\n\tf[0][0][0][0] = 1;\n\tfor (int i = 0; i < n + m; i++) {\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tfor (int p = 0; p <= k; p++) {\n\t\t\t\tfor (int q = 0; q <= k; q++) {\n\t\t\t\t\t// Add a boy\n\t\t\t\t\t(f[i + 1][j + 1][p + 1][std::max(q - 1, 0)] += f[i][j][p][q]) %= MOD;\n\t\t\t\t\t// Add a girl\n\t\t\t\t\t(f[i + 1][j][std::max(p - 1, 0)][q + 1] += f[i][j][p][q]) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int p = 0; p <= k; p++) for (int q = 0; q <= k; q++) (ans += f[n + m][n][p][q]) %= MOD;\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"zjoi2008-party","published":1,"updated":"2016-11-13T02:13:03.231Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bt6001ac2xlgj1u2cir"},{"title":"ZJOI2008 - ","date":"2016-11-13T01:53:00.000Z","_content":"\n $ n $  $ 2, 1, 0 $\n\n<!-- more -->\n\n### \n[BZOJ 1034](http://www.lydsy.com/JudgeOnline/problem.php?id=1034)\n\n### \n A  B  B  A  B \n\n\n\n### \n```c++\n#include <cstdio>\n#include <set>\n\nconst int MAXN = 100000;\n\nint n;\n\ninline int solve(const int *a, const int *b) {\n\tstd::multiset<int> sa, sb;\n\tfor (int i = 0; i < n; i++) sa.insert(a[i]), sb.insert(b[i]);\n\n\tint ans = 0;\n\tfor (std::multiset<int>::iterator it = sa.begin(); it != sa.end(); ) {\n\t\tstd::multiset<int>::iterator target = sb.lower_bound(*it);\n\t\tif (target == sb.begin()) {\n\t\t\tit++;\n\t\t} else {\n\t\t\ttarget--;\n\t\t\tsb.erase(target);\n\t\t\tsa.erase(it++);\n\t\t\tans += 2;\n\t\t}\n\t}\n\n\tfor (std::multiset<int>::iterator it = sa.begin(); it != sa.end(); it++) {\n\t\tstd::multiset<int>::iterator target = sb.lower_bound(*it);\n\t\tif (*target == *it) sb.erase(target), ans++;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN], b[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &b[i]);\n\n\t/*\n\tstd::sort(a, a + n);\n\tstd::sort(b, b + n);\n\t*/\n\n\tprintf(\"%d %d\\n\", solve(a, b), n * 2 - solve(b, a));\n\t\n\treturn 0;\n}\n```","source":"_posts/zjoi2008-bnb.md","raw":"title: ZJOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - \npermalink: zjoi2008-bnb\ndate: 2016-11-13 09:53:00\n---\n\n $ n $  $ 2, 1, 0 $\n\n<!-- more -->\n\n### \n[BZOJ 1034](http://www.lydsy.com/JudgeOnline/problem.php?id=1034)\n\n### \n A  B  B  A  B \n\n\n\n### \n```c++\n#include <cstdio>\n#include <set>\n\nconst int MAXN = 100000;\n\nint n;\n\ninline int solve(const int *a, const int *b) {\n\tstd::multiset<int> sa, sb;\n\tfor (int i = 0; i < n; i++) sa.insert(a[i]), sb.insert(b[i]);\n\n\tint ans = 0;\n\tfor (std::multiset<int>::iterator it = sa.begin(); it != sa.end(); ) {\n\t\tstd::multiset<int>::iterator target = sb.lower_bound(*it);\n\t\tif (target == sb.begin()) {\n\t\t\tit++;\n\t\t} else {\n\t\t\ttarget--;\n\t\t\tsb.erase(target);\n\t\t\tsa.erase(it++);\n\t\t\tans += 2;\n\t\t}\n\t}\n\n\tfor (std::multiset<int>::iterator it = sa.begin(); it != sa.end(); it++) {\n\t\tstd::multiset<int>::iterator target = sb.lower_bound(*it);\n\t\tif (*target == *it) sb.erase(target), ans++;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN], b[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &b[i]);\n\n\t/*\n\tstd::sort(a, a + n);\n\tstd::sort(b, b + n);\n\t*/\n\n\tprintf(\"%d %d\\n\", solve(a, b), n * 2 - solve(b, a));\n\t\n\treturn 0;\n}\n```","slug":"zjoi2008-bnb","published":1,"updated":"2016-11-13T01:53:48.968Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6btc001gc2xl29n5zsfs"},{"title":"ZJOI2008 -  + ","date":"2016-05-23T13:26:00.000Z","_content":"\n[](https://www.zybuluo.com/Jerusalem/note/221811)\n\n<!-- more -->\n\n### \n[BZOJ 1033](http://www.lydsy.com/JudgeOnline/problem.php?id=1033)  \n[COGS 2048](http://cogs.top/cogs/problem/problem.php?pid=2048)\n\n### \n \n\n $ a $ $ b $ $ a $ $ b $\n\n\n\n$$\n\\begin{cases}\na \\leq r \\\\\nb \\gt r\n\\end{cases}\n$$\n\n\n\n\n\n**** \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <list>\n#include <algorithm>\n\ntypedef long double real;\n\nconst int MAXN = 8;\nconst int MAXM = 8;\nconst int MAXS = 20;\nconst int MAXT = 200000;\nconst real EPS = 1e-6;\n\nint n, m, s, d, r, t, time;\n\nstruct Map {\n\tint message;\n\tbool reachable;\n\n\tMap() : message(0), reachable(true) {}\n} map[MAXN + 1][MAXM + 1];\n\ntemplate <typename T>\nstruct Point {\n\tT x, y;\n\n\tPoint(const T x = 0, const T y = 0) : x(x), y(y) {}\n\n\tMap *operator->() const { return &map[static_cast<int>(x)][static_cast<int>(y)]; }\n\n\tPoint offset(const int id) const {\n\t\tswitch (id) {\n\t\t\tcase 0: return Point(x, y + 1);\n\t\t\tcase 1: return Point(x + 1, y);\n\t\t\tcase 2: return Point(x, y - 1);\n\t\t\tcase 3: return Point(x - 1, y);\n\t\t\tdefault: return *this;\n\t\t}\n\t}\n\n\tbool valid() const { return x >= 0 && x <= n && y >= 0 && y <= m; }\n\n\tbool operator==(const Point &p) const { return x == p.x && y == p.y; }\n};\n\ninline bool dcmp(const real a) { return fabs(a) <= EPS; }\ninline bool dcmp(const real a, const real b) { return dcmp(a - b); }\n\ninline bool isnan(const real x) { return x != x; }\ninline bool isinf(const real x) { return !isnan(x) && isnan(x - x); }\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ntemplate <typename Ta, typename Tb>\ninline real distance(const Point<Ta> a, const Point<Tb> b) {\n\treturn sqrt(static_cast<real>(sqr(a.x - b.x) + sqr(a.y - b.y)));\n}\n\nstruct Ant {\n\tPoint<int> position, lastPosition;\n\tint level;\n\tint hpLimit, hp;\n\tbool hasCake;\n\tint spawnTime;\n\n\tAnt(const int level) : position(0, 0), lastPosition(-1, -1), level(level), hpLimit(floor(4 * pow(1.1, level))), hp(hpLimit), hasCake(false), spawnTime(time) {\n\t\t// printf(\"spawn Ant(%d)\\n\", level);\n\t\tposition->reachable = false;\n\t}\n\n\tinline void moveTo(const Point<int> &nextPosition) {\n\t\tlastPosition = position;\n\t\tposition = nextPosition;\n\t\tif (lastPosition == position) return;\n\t\t// printf(\"moveTo(): from [%d, %d] to [%d, %d]\\n\", lastPosition.x, lastPosition.y, position.x, position.y);\n\t\tlastPosition->reachable = true;\n\t\tposition->reachable = false;\n\t}\n\n\tinline int age() const {\n\t\treturn time - spawnTime;\n\t}\n\n\tinline bool attackable(const Point<int> &p) {\n\t\tconst real dist = distance(position, p);\n\t\treturn dist < r || dcmp(dist, r);\n\t}\n};\n\nstruct Line {\n\treal k, b;\n\n\t/*\n\t * k != nan: y = kx + b\n\t * k == nan: x = b\n\t */\n\n\tLine(const Point<int> &p1, const Point<int> &p2) {\n\t\tconst real x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;\n\t\tif (x1 == x2) {\n\t\t\tk = NAN;\n\t\t\tb = x1;\n\t\t} else {\n\t\t\tk = (y2 - y1) / (x2 - x1);\n\t\t\tb = y1 - k * x1;\n\t\t}\n\t}\n\n\tLine(const real k, const Point<int> &p1) : k(isinf(k) ? NAN : k), b(isinf(k) ? p1.x : (p1.y - k * p1.x)) {}\n\n\tLine(const real k, const real b) : k(k), b(b) {}\n\n\tLine perpendicular(const Point<int> &p1) const {\n\t\tif (isnan(k)) return Line(0, p1.y);\n\t\telse return Line(-1.0 / k, p1);\n\t}\n};\n\nstruct Segment {\n\tPoint<int> p1, p2;\n\tLine line;\n\treal length;\n\n\tSegment(const Point<int> &p1, const Point<int> &p2) : p1(p1), p2(p2), line(p1, p2) {\n\t\tlength = distance(p1, p2);\n\t}\n};\n\nPoint<real> lineIntersection(const Line &a, const Line &b) {\n\tif (isnan(a.k) && isnan(b.k) || a.k == b.k) throw;\n\tif (isnan(a.k)) return Point<real>(a.b, a.b * b.k + b.b);\n\tif (isnan(b.k)) return Point<real>(b.b, b.b * a.k + a.b);\n\tconst real x = (b.b - a.b) / (a.k - b.k);\n\tconst real y = a.k * x + a.b;\n\treturn Point<real>(x, y);\n}\n\nbool pointOnSegment(const Point<real> &p, const Segment &s) {\n\treturn dcmp(distance(p, s.p1) + distance(p, s.p2) - s.length);\n}\n\nbool segmentCircleIntersection(const Segment &s, const Point<int> &p, const real r) {\n\tLine v = s.line.perpendicular(p);\n\tPoint<real> is = lineIntersection(v, s.line);\n\treal min, max;\n\tif (pointOnSegment(is, s)) {\n\t\tmin = distance(is, p);\n\t\tmax = std::max(distance(is, s.p1), distance(is, s.p2));\n\t} else {\n\t\tmin = distance(p, s.p1);\n\t\tmax = distance(p, s.p2);\n\t\tif (min > max) std::swap(min, max);\n\t}\n\n\treturn (min < r || dcmp(min, r)) && (max > r || dcmp(max, r));\n}\n\nstd::list<Ant> ants;\nstd::list<Ant>::iterator cakeOwner = ants.end();\nPoint<int> towers[MAXS];\n\ninline void spawn() {\n\tif (ants.size() < 6) {\n\t\tif (map[0][0].reachable == false) return;\n\n\t\tstatic int cnt = -1;\n\t\tcnt++;\n\t\tants.push_back(Ant(cnt / 6 + 1));\n\t}\n}\n\ninline void incMessage() {\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tit->position->message += it->hasCake ? 5 : 2;\n\t}\n}\n\ninline void move() {\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t// static int _cnt = 0;\n\t\t// _cnt++;\n\t\t// printf(\"move(): _cnt = %d\\n\", _cnt);\n\n\t\tint id = -1;\n\t\t// printf(\"move(): lastPosition = [%d, %d]\\n\", it->lastPosition.x, it->lastPosition.y);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint<int> newPosition = it->position.offset(i);\n\n\t\t\tif (!newPosition.valid()) continue;\n\t\t\tif (newPosition == it->lastPosition) continue;\n\t\t\tif (!newPosition->reachable) continue;\n\n\t\t\tif (id == -1 || newPosition->message > it->position.offset(id)->message) {\n\t\t\t\tid = i;\n\t\t\t}\n\t\t}\n\n\t\t// if (id != -1) printf(\"move(): checking moving to [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\n\t\tif (id != -1 && (it->age() + 1) % 5 == 0) {\n\t\t\t// printf(\"move(): special, before = [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\t\t\tPoint<int> newPosition;\n\t\t\tdo {\n\t\t\t\tid = (id - 1 + 4) % 4;\n\t\t\t\tnewPosition = it->position.offset(id);\n\t\t\t} while (!newPosition.valid() || !newPosition->reachable || newPosition == it->lastPosition);\n\t\t\t// printf(\"move(): special, after = [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\t\t}\n\n\t\tit->moveTo(it->position.offset(id));\n\t}\n}\n\ninline void getCake() {\n\tif (cakeOwner != ants.end()) return;\n\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tif (it->position == Point<int>(n, m)) {\n\t\t\tcakeOwner = it;\n\t\t\tit->hasCake = true;\n\t\t\tit->hp = std::min(it->hpLimit, it->hp + it->hpLimit / 2);\n\t\t\t// puts(\"getCake(): got\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\ninline void attack() {\n\tfor (int i = 0; i < s; i++) {\n\t\t// static int _cnt = 0;\n\t\t// _cnt++;\n\t\t// printf(\"attack(): _cnt = %d\\n\", _cnt);\n\n\t\tstd::list<Ant>::iterator target = ants.end();\n\t\tif (cakeOwner != ants.end() && cakeOwner->attackable(towers[i])) {\n\t\t\ttarget = cakeOwner;\n\t\t}\n\n\t\tif (target == ants.end()) {\n\t\t\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t\t\treal d = distance(it->position, towers[i]);\n\t\t\t\tif ((d < r || dcmp(d, r)) && (target == ants.end() || distance(it->position, towers[i]) < distance(target->position, towers[i]))) {\n\t\t\t\t\ttarget = it;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (target != ants.end()) {\n\t\t\ttarget->hp -= d;\n\t\t\tSegment s(towers[i], target->position);\n\t\t\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t\t\tif (it != target && segmentCircleIntersection(s, it->position, 0.5)) {\n\t\t\t\t\t// printf(\"attack(): _cnt = %d, through [%d, %d]\\n\", _cnt, it->position.x, it->position.y);\n\t\t\t\t\tit->hp -= d;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// if (it == target) printf(\"attack(): _cnt = %d, target [%d, %d]\\n\", _cnt, target->position.x, target->position.y);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void kill() {\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); ) {\n\t\tif (it->hp < 0) {\n\t\t\tit->position->reachable = true;\n\t\t\tif (it == cakeOwner) cakeOwner = ants.end();\n\t\t\tit = ants.erase(it);\n\t\t} else it++;\n\t}\n}\n\ninline bool check() {\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tif (it->position == Point<int>(0, 0) && it->hasCake) return false;\n\t}\n\n\treturn true;\n}\n\ninline void decMessage() {\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tif (map[i][j].message > 0) map[i][j].message--;\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"data.in\", \"r\", stdin);\n\n\tscanf(\"%d %d\\n%d %d %d\", &n, &m, &s, &d, &r);\n\tfor (int i = 0; i < s; i++) {\n\t\tscanf(\"%d %d\", &towers[i].x, &towers[i].y);\n\t\ttowers[i]->reachable = false;\n\t}\n\tscanf(\"%d\", &t);\n\n\ttime = 1;\n\tfor (; time <= t; time++) {\n\t\t// printf(\"main(): time = %d\\n\", time);\n\t\tspawn();\n\t\tincMessage();\n\t\tmove();\n\t\tgetCake();\n\t\tattack();\n\t\tkill();\n\t\tif (!check()) break;\n\t\tdecMessage();\n\n\t\t// for (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) printf(\"%d %d %d %d %d\\n\", it->age(), it->level, it->hp, it->position.y, it->position.x);\n\t\t// putchar('\\n');\n\t}\n\n\tif (time > t) puts(\"The game is going on\");\n\telse printf(\"Game over after %d seconds\\n\", time);\n\n\tprintf(\"%d\\n\", ants.size());\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) printf(\"%d %d %d %d %d\\n\", it->age(), it->level, it->hp, it->position.x, it->position.y);\n\n\tfclose(stdin);\n\n\treturn 0;\n}\n```\n","source":"_posts/zjoi2008-antbuster.md","raw":"title: ZJOI2008 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - ZJOI\n  - \n  - \n  - \npermalink: zjoi2008-antbuster\ndate: 2016-05-23 21:26:00\n---\n\n[](https://www.zybuluo.com/Jerusalem/note/221811)\n\n<!-- more -->\n\n### \n[BZOJ 1033](http://www.lydsy.com/JudgeOnline/problem.php?id=1033)  \n[COGS 2048](http://cogs.top/cogs/problem/problem.php?pid=2048)\n\n### \n \n\n $ a $ $ b $ $ a $ $ b $\n\n\n\n$$\n\\begin{cases}\na \\leq r \\\\\nb \\gt r\n\\end{cases}\n$$\n\n\n\n\n\n**** \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <list>\n#include <algorithm>\n\ntypedef long double real;\n\nconst int MAXN = 8;\nconst int MAXM = 8;\nconst int MAXS = 20;\nconst int MAXT = 200000;\nconst real EPS = 1e-6;\n\nint n, m, s, d, r, t, time;\n\nstruct Map {\n\tint message;\n\tbool reachable;\n\n\tMap() : message(0), reachable(true) {}\n} map[MAXN + 1][MAXM + 1];\n\ntemplate <typename T>\nstruct Point {\n\tT x, y;\n\n\tPoint(const T x = 0, const T y = 0) : x(x), y(y) {}\n\n\tMap *operator->() const { return &map[static_cast<int>(x)][static_cast<int>(y)]; }\n\n\tPoint offset(const int id) const {\n\t\tswitch (id) {\n\t\t\tcase 0: return Point(x, y + 1);\n\t\t\tcase 1: return Point(x + 1, y);\n\t\t\tcase 2: return Point(x, y - 1);\n\t\t\tcase 3: return Point(x - 1, y);\n\t\t\tdefault: return *this;\n\t\t}\n\t}\n\n\tbool valid() const { return x >= 0 && x <= n && y >= 0 && y <= m; }\n\n\tbool operator==(const Point &p) const { return x == p.x && y == p.y; }\n};\n\ninline bool dcmp(const real a) { return fabs(a) <= EPS; }\ninline bool dcmp(const real a, const real b) { return dcmp(a - b); }\n\ninline bool isnan(const real x) { return x != x; }\ninline bool isinf(const real x) { return !isnan(x) && isnan(x - x); }\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ntemplate <typename Ta, typename Tb>\ninline real distance(const Point<Ta> a, const Point<Tb> b) {\n\treturn sqrt(static_cast<real>(sqr(a.x - b.x) + sqr(a.y - b.y)));\n}\n\nstruct Ant {\n\tPoint<int> position, lastPosition;\n\tint level;\n\tint hpLimit, hp;\n\tbool hasCake;\n\tint spawnTime;\n\n\tAnt(const int level) : position(0, 0), lastPosition(-1, -1), level(level), hpLimit(floor(4 * pow(1.1, level))), hp(hpLimit), hasCake(false), spawnTime(time) {\n\t\t// printf(\"spawn Ant(%d)\\n\", level);\n\t\tposition->reachable = false;\n\t}\n\n\tinline void moveTo(const Point<int> &nextPosition) {\n\t\tlastPosition = position;\n\t\tposition = nextPosition;\n\t\tif (lastPosition == position) return;\n\t\t// printf(\"moveTo(): from [%d, %d] to [%d, %d]\\n\", lastPosition.x, lastPosition.y, position.x, position.y);\n\t\tlastPosition->reachable = true;\n\t\tposition->reachable = false;\n\t}\n\n\tinline int age() const {\n\t\treturn time - spawnTime;\n\t}\n\n\tinline bool attackable(const Point<int> &p) {\n\t\tconst real dist = distance(position, p);\n\t\treturn dist < r || dcmp(dist, r);\n\t}\n};\n\nstruct Line {\n\treal k, b;\n\n\t/*\n\t * k != nan: y = kx + b\n\t * k == nan: x = b\n\t */\n\n\tLine(const Point<int> &p1, const Point<int> &p2) {\n\t\tconst real x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;\n\t\tif (x1 == x2) {\n\t\t\tk = NAN;\n\t\t\tb = x1;\n\t\t} else {\n\t\t\tk = (y2 - y1) / (x2 - x1);\n\t\t\tb = y1 - k * x1;\n\t\t}\n\t}\n\n\tLine(const real k, const Point<int> &p1) : k(isinf(k) ? NAN : k), b(isinf(k) ? p1.x : (p1.y - k * p1.x)) {}\n\n\tLine(const real k, const real b) : k(k), b(b) {}\n\n\tLine perpendicular(const Point<int> &p1) const {\n\t\tif (isnan(k)) return Line(0, p1.y);\n\t\telse return Line(-1.0 / k, p1);\n\t}\n};\n\nstruct Segment {\n\tPoint<int> p1, p2;\n\tLine line;\n\treal length;\n\n\tSegment(const Point<int> &p1, const Point<int> &p2) : p1(p1), p2(p2), line(p1, p2) {\n\t\tlength = distance(p1, p2);\n\t}\n};\n\nPoint<real> lineIntersection(const Line &a, const Line &b) {\n\tif (isnan(a.k) && isnan(b.k) || a.k == b.k) throw;\n\tif (isnan(a.k)) return Point<real>(a.b, a.b * b.k + b.b);\n\tif (isnan(b.k)) return Point<real>(b.b, b.b * a.k + a.b);\n\tconst real x = (b.b - a.b) / (a.k - b.k);\n\tconst real y = a.k * x + a.b;\n\treturn Point<real>(x, y);\n}\n\nbool pointOnSegment(const Point<real> &p, const Segment &s) {\n\treturn dcmp(distance(p, s.p1) + distance(p, s.p2) - s.length);\n}\n\nbool segmentCircleIntersection(const Segment &s, const Point<int> &p, const real r) {\n\tLine v = s.line.perpendicular(p);\n\tPoint<real> is = lineIntersection(v, s.line);\n\treal min, max;\n\tif (pointOnSegment(is, s)) {\n\t\tmin = distance(is, p);\n\t\tmax = std::max(distance(is, s.p1), distance(is, s.p2));\n\t} else {\n\t\tmin = distance(p, s.p1);\n\t\tmax = distance(p, s.p2);\n\t\tif (min > max) std::swap(min, max);\n\t}\n\n\treturn (min < r || dcmp(min, r)) && (max > r || dcmp(max, r));\n}\n\nstd::list<Ant> ants;\nstd::list<Ant>::iterator cakeOwner = ants.end();\nPoint<int> towers[MAXS];\n\ninline void spawn() {\n\tif (ants.size() < 6) {\n\t\tif (map[0][0].reachable == false) return;\n\n\t\tstatic int cnt = -1;\n\t\tcnt++;\n\t\tants.push_back(Ant(cnt / 6 + 1));\n\t}\n}\n\ninline void incMessage() {\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tit->position->message += it->hasCake ? 5 : 2;\n\t}\n}\n\ninline void move() {\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t// static int _cnt = 0;\n\t\t// _cnt++;\n\t\t// printf(\"move(): _cnt = %d\\n\", _cnt);\n\n\t\tint id = -1;\n\t\t// printf(\"move(): lastPosition = [%d, %d]\\n\", it->lastPosition.x, it->lastPosition.y);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint<int> newPosition = it->position.offset(i);\n\n\t\t\tif (!newPosition.valid()) continue;\n\t\t\tif (newPosition == it->lastPosition) continue;\n\t\t\tif (!newPosition->reachable) continue;\n\n\t\t\tif (id == -1 || newPosition->message > it->position.offset(id)->message) {\n\t\t\t\tid = i;\n\t\t\t}\n\t\t}\n\n\t\t// if (id != -1) printf(\"move(): checking moving to [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\n\t\tif (id != -1 && (it->age() + 1) % 5 == 0) {\n\t\t\t// printf(\"move(): special, before = [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\t\t\tPoint<int> newPosition;\n\t\t\tdo {\n\t\t\t\tid = (id - 1 + 4) % 4;\n\t\t\t\tnewPosition = it->position.offset(id);\n\t\t\t} while (!newPosition.valid() || !newPosition->reachable || newPosition == it->lastPosition);\n\t\t\t// printf(\"move(): special, after = [%d, %d]\\n\", it->position.offset(id).x, it->position.offset(id).y);\n\t\t}\n\n\t\tit->moveTo(it->position.offset(id));\n\t}\n}\n\ninline void getCake() {\n\tif (cakeOwner != ants.end()) return;\n\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tif (it->position == Point<int>(n, m)) {\n\t\t\tcakeOwner = it;\n\t\t\tit->hasCake = true;\n\t\t\tit->hp = std::min(it->hpLimit, it->hp + it->hpLimit / 2);\n\t\t\t// puts(\"getCake(): got\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\ninline void attack() {\n\tfor (int i = 0; i < s; i++) {\n\t\t// static int _cnt = 0;\n\t\t// _cnt++;\n\t\t// printf(\"attack(): _cnt = %d\\n\", _cnt);\n\n\t\tstd::list<Ant>::iterator target = ants.end();\n\t\tif (cakeOwner != ants.end() && cakeOwner->attackable(towers[i])) {\n\t\t\ttarget = cakeOwner;\n\t\t}\n\n\t\tif (target == ants.end()) {\n\t\t\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t\t\treal d = distance(it->position, towers[i]);\n\t\t\t\tif ((d < r || dcmp(d, r)) && (target == ants.end() || distance(it->position, towers[i]) < distance(target->position, towers[i]))) {\n\t\t\t\t\ttarget = it;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (target != ants.end()) {\n\t\t\ttarget->hp -= d;\n\t\t\tSegment s(towers[i], target->position);\n\t\t\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); it++) {\n\t\t\t\tif (it != target && segmentCircleIntersection(s, it->position, 0.5)) {\n\t\t\t\t\t// printf(\"attack(): _cnt = %d, through [%d, %d]\\n\", _cnt, it->position.x, it->position.y);\n\t\t\t\t\tit->hp -= d;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// if (it == target) printf(\"attack(): _cnt = %d, target [%d, %d]\\n\", _cnt, target->position.x, target->position.y);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void kill() {\n\tfor (std::list<Ant>::iterator it = ants.begin(); it != ants.end(); ) {\n\t\tif (it->hp < 0) {\n\t\t\tit->position->reachable = true;\n\t\t\tif (it == cakeOwner) cakeOwner = ants.end();\n\t\t\tit = ants.erase(it);\n\t\t} else it++;\n\t}\n}\n\ninline bool check() {\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) {\n\t\tif (it->position == Point<int>(0, 0) && it->hasCake) return false;\n\t}\n\n\treturn true;\n}\n\ninline void decMessage() {\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tif (map[i][j].message > 0) map[i][j].message--;\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"data.in\", \"r\", stdin);\n\n\tscanf(\"%d %d\\n%d %d %d\", &n, &m, &s, &d, &r);\n\tfor (int i = 0; i < s; i++) {\n\t\tscanf(\"%d %d\", &towers[i].x, &towers[i].y);\n\t\ttowers[i]->reachable = false;\n\t}\n\tscanf(\"%d\", &t);\n\n\ttime = 1;\n\tfor (; time <= t; time++) {\n\t\t// printf(\"main(): time = %d\\n\", time);\n\t\tspawn();\n\t\tincMessage();\n\t\tmove();\n\t\tgetCake();\n\t\tattack();\n\t\tkill();\n\t\tif (!check()) break;\n\t\tdecMessage();\n\n\t\t// for (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) printf(\"%d %d %d %d %d\\n\", it->age(), it->level, it->hp, it->position.y, it->position.x);\n\t\t// putchar('\\n');\n\t}\n\n\tif (time > t) puts(\"The game is going on\");\n\telse printf(\"Game over after %d seconds\\n\", time);\n\n\tprintf(\"%d\\n\", ants.size());\n\tfor (std::list<Ant>::const_iterator it = ants.begin(); it != ants.end(); it++) printf(\"%d %d %d %d %d\\n\", it->age(), it->level, it->hp, it->position.x, it->position.y);\n\n\tfclose(stdin);\n\n\treturn 0;\n}\n```\n","slug":"zjoi2008-antbuster","published":1,"updated":"2016-05-23T13:27:10.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bth001mc2xl8pg2lfsl"},{"title":"ZJOI2007 -  DP","date":"2016-05-18T03:58:00.000Z","_content":"\n $ i $  $ P_i $  $ i $  $ C_i $ $ N $ $ 1 $  $ 1 $\n\n1.  $ i $  $ 1 $  $ x_i $ $ x_1 = 0 $\n2.  $ i $  $ p_i $\n3.  $ i $  $ c_i $\n\n + \n\n<!-- more -->\n\n### \n[BZOJ 1096](http://www.lydsy.com/JudgeOnline/problem.php?id=1096)  \n[COGS 367](http://cogs.top/cogs/problem/problem.php?pid=367)\n\n### \n $ S(i) $  $ i $  $ 1 $ $ s(i) $  $ i $ \n\n $ f(i) $  i \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + c(j + 1) + S(i) - S(j) - (s(i) - s(j)) \\times d(j + 1) \\} $$\n\n $ a $$ b $$ a > b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\nf(a) + c(a + 1) + S(i) - S(a) - (s(i) - s(a)) \\times d(a + 1) & < f(b) + c(b + 1) + S(i) - S(b) - (s(i) - s(b)) \\times d(b + 1) \\\\\nf(a) + c(a + 1) - S(a) - (s(i) - s(a)) \\times d(a + 1) & < f(b) + c(b + 1) - S(b) - (s(i) - s(b)) \\times d(b + 1) \\\\\nf(a) + c(a + 1) - S(a) - s(i) \\times d(a + 1) - s(a) \\times d(a + 1) & < f(b) + c(b + 1) - S(b) - s(i) \\times d(b + 1) - s(b) \\times d(b + 1) \\\\\n(f(a) + c(a + 1) - S(a) - s(a) \\times d(a + 1)) - (f(b) + c(b + 1) - S(b) - s(b) \\times d(b + 1)) & < s(i) \\times d(a + 1) - s(i) \\times d(b + 1) \\\\\n(f(a) + c(a + 1) - S(a) - s(a) \\times d(a + 1)) - (f(b) + c(b + 1) - S(b) - s(b) \\times d(b + 1)) \\over d(a + 1) - d(b + 1) & < s(i) \\\\\n\\end{align*}\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n \nconst int MAXN = 1000000;\n \nint n;\nlong long d[MAXN + 1], p[MAXN + 1], c[MAXN + 1];\nlong long s[MAXN + 1], S[MAXN + 1];\nlong long f[MAXN + 1];\n \ninline void prepare() {\n    std::reverse(p + 1, p + n + 1);\n    std::reverse(c + 1, c + n + 1);\n    for (int i = n; i >= 1; i--) d[i] -= d[i - 1];\n    std::reverse(d + 2, d + n + 1);\n    for (int i = 1; i <= n; i++) d[i] += d[i - 1];\n \n    for (int i = 1; i <= n; i++) {\n        s[i] = s[i - 1] + p[i];\n        S[i] = S[i - 1] + p[i] * d[i];\n    }\n}\n \n/*\ninline void force() {\n    std::fill(f, f + n + 1, LLONG_MAX);\n    f[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        int _j = -1;\n        for (int j = 0; j < i; j++) {\n            if (f[i] > f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]) {\n                f[i] = f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n                _j = j;\n            }\n        }\n        // printf(\"%d --> %d\\n\", i, _j);\n    }\n}\n*/\n \ninline long long x(const int i) { return f[i] + c[i + 1] - S[i] + s[i] * d[i + 1]; }\n \ninline double slope(const int a, const int b) {\n    // printf(\"slope(%d, %d) = %.4lf\\n\", a, b, double(x(a) - x(b)) / double(d[a + 1] - d[b + 1]));\n    return double(x(a) - x(b))\n         / double(d[a + 1] - d[b + 1]);\n}\n \ninline void dp() {\n    std::fill(f, f + n + 1, LLONG_MAX);\n    f[0] = 0;\n \n    static int q[MAXN + 1];\n    int *l = q, *r = q;\n    *r = 0;\n \n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) < s[i]) l++;\n \n        // if (l < r) {\n        //     printf(\"%lld %lld\\n\", f[*l] + c[*l + 1] + S[i] - S[*l] - (s[i] - s[*l]) * d[*l + 1], f[*(l + 1)] + c[*(l + 1) + 1] + S[i] - S[*(l + 1)] - (s[i] - s[*(l + 1)]) * d[*(l + 1) + 1]);\n        // }\n \n        int &j = *l;\n        f[i] = f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n        // printf(\"%d --> %d\\n\", i, j);\n \n        if (i < n) {\n            while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n            *++r = i;\n        }\n    }\n}\n \nint main() {\n    scanf(\"%d\", &n);\n \n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lld %lld %lld\", &d[i], &p[i], &c[i]);\n    }\n \n    prepare();\n \n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n \n    return 0;\n}\n```\n","source":"_posts/zjoi2007-storage.md","raw":"title: ZJOI2007 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - ZJOI\n  - \n  - \n  - DP\npermalink: zjoi2007-storage\ndate: 2016-05-18 11:58:00\n---\n\n $ i $  $ P_i $  $ i $  $ C_i $ $ N $ $ 1 $  $ 1 $\n\n1.  $ i $  $ 1 $  $ x_i $ $ x_1 = 0 $\n2.  $ i $  $ p_i $\n3.  $ i $  $ c_i $\n\n + \n\n<!-- more -->\n\n### \n[BZOJ 1096](http://www.lydsy.com/JudgeOnline/problem.php?id=1096)  \n[COGS 367](http://cogs.top/cogs/problem/problem.php?pid=367)\n\n### \n $ S(i) $  $ i $  $ 1 $ $ s(i) $  $ i $ \n\n $ f(i) $  i \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + c(j + 1) + S(i) - S(j) - (s(i) - s(j)) \\times d(j + 1) \\} $$\n\n $ a $$ b $$ a > b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\nf(a) + c(a + 1) + S(i) - S(a) - (s(i) - s(a)) \\times d(a + 1) & < f(b) + c(b + 1) + S(i) - S(b) - (s(i) - s(b)) \\times d(b + 1) \\\\\nf(a) + c(a + 1) - S(a) - (s(i) - s(a)) \\times d(a + 1) & < f(b) + c(b + 1) - S(b) - (s(i) - s(b)) \\times d(b + 1) \\\\\nf(a) + c(a + 1) - S(a) - s(i) \\times d(a + 1) - s(a) \\times d(a + 1) & < f(b) + c(b + 1) - S(b) - s(i) \\times d(b + 1) - s(b) \\times d(b + 1) \\\\\n(f(a) + c(a + 1) - S(a) - s(a) \\times d(a + 1)) - (f(b) + c(b + 1) - S(b) - s(b) \\times d(b + 1)) & < s(i) \\times d(a + 1) - s(i) \\times d(b + 1) \\\\\n(f(a) + c(a + 1) - S(a) - s(a) \\times d(a + 1)) - (f(b) + c(b + 1) - S(b) - s(b) \\times d(b + 1)) \\over d(a + 1) - d(b + 1) & < s(i) \\\\\n\\end{align*}\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n \nconst int MAXN = 1000000;\n \nint n;\nlong long d[MAXN + 1], p[MAXN + 1], c[MAXN + 1];\nlong long s[MAXN + 1], S[MAXN + 1];\nlong long f[MAXN + 1];\n \ninline void prepare() {\n    std::reverse(p + 1, p + n + 1);\n    std::reverse(c + 1, c + n + 1);\n    for (int i = n; i >= 1; i--) d[i] -= d[i - 1];\n    std::reverse(d + 2, d + n + 1);\n    for (int i = 1; i <= n; i++) d[i] += d[i - 1];\n \n    for (int i = 1; i <= n; i++) {\n        s[i] = s[i - 1] + p[i];\n        S[i] = S[i - 1] + p[i] * d[i];\n    }\n}\n \n/*\ninline void force() {\n    std::fill(f, f + n + 1, LLONG_MAX);\n    f[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        int _j = -1;\n        for (int j = 0; j < i; j++) {\n            if (f[i] > f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]) {\n                f[i] = f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n                _j = j;\n            }\n        }\n        // printf(\"%d --> %d\\n\", i, _j);\n    }\n}\n*/\n \ninline long long x(const int i) { return f[i] + c[i + 1] - S[i] + s[i] * d[i + 1]; }\n \ninline double slope(const int a, const int b) {\n    // printf(\"slope(%d, %d) = %.4lf\\n\", a, b, double(x(a) - x(b)) / double(d[a + 1] - d[b + 1]));\n    return double(x(a) - x(b))\n         / double(d[a + 1] - d[b + 1]);\n}\n \ninline void dp() {\n    std::fill(f, f + n + 1, LLONG_MAX);\n    f[0] = 0;\n \n    static int q[MAXN + 1];\n    int *l = q, *r = q;\n    *r = 0;\n \n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) < s[i]) l++;\n \n        // if (l < r) {\n        //     printf(\"%lld %lld\\n\", f[*l] + c[*l + 1] + S[i] - S[*l] - (s[i] - s[*l]) * d[*l + 1], f[*(l + 1)] + c[*(l + 1) + 1] + S[i] - S[*(l + 1)] - (s[i] - s[*(l + 1)]) * d[*(l + 1) + 1]);\n        // }\n \n        int &j = *l;\n        f[i] = f[j] + c[j + 1] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n        // printf(\"%d --> %d\\n\", i, j);\n \n        if (i < n) {\n            while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n            *++r = i;\n        }\n    }\n}\n \nint main() {\n    scanf(\"%d\", &n);\n \n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lld %lld %lld\", &d[i], &p[i], &c[i]);\n    }\n \n    prepare();\n \n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n \n    return 0;\n}\n```\n","slug":"zjoi2007-storage","published":1,"updated":"2016-10-24T23:28:04.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bto001xc2xlmookj6g2"},{"title":"ZJOI2007 - ","date":"2016-09-03T23:38:00.000Z","_content":"\n $ G = (V, E) $ Semi-Connected\n\n> $ \\forall u, v \\in V $ $ u \\rightarrow v $  $ v \\rightarrow u $ $ u $$ v $ $ u $  $ v $  $ v $  $ u $ \n\n $ G' = (V', E') $  $ V' \\subseteq V $$ E' $  $ E $  $ V' $  $ G' $  $ G $   \n $ G' $  $ G $  $ G' $  $ G' $  $ G $   \n $ G' $  $ G $  $ G' $  $ G $ \n\n $ G $ $ G $  $ K $ $ C $ $ C $  $ C $  $ X $ \n\n<!-- more -->\n\n### \n[BZOJ 1093](http://www.lydsy.com/JudgeOnline/problem.php?id=1093)\n\n### \n\n\n DAG  DP \n\n $ d(i) $  $ u \\rightarrow v $ $ d(v) = d(u) + s(v) $$ s(i) $  $ i $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <tr1/unordered_set>\n\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\nconst int MAXX = 100000000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tstruct SCC *s;\n\tNode *p;\n\tbool inStack, pushed, visited;\n\tint dfn, low, d, sum;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint size, inDegree, in, len, sum;\n} S[MAXN];\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n}\n\nint n, x;\n\ninline int tarjan() {\n\tint cnt = 0, ts = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\t\t\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tt.push(v);\n\t\t\t\tv->inStack = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->inStack) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, e->t->p = v, s.push(e->t);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tSCC *scc = &S[cnt++];\n\t\t\t\t\tscc->v.s = scc;\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->s = scc;\n\t\t\t\t\t\tscc->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\ninline void contract() {\n\tstd::tr1::unordered_set<unsigned long long> s;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\tunsigned long long x = (static_cast<unsigned long long>(e->s->s - S) << 32) | static_cast<unsigned long long>(e->t->s - S);\n\t\t\tif (e->s->s != e->t->s && !s.count(x)) {\n\t\t\t\ts.insert(x);\n\t\t\t\t// printf(\"[%ld, %ld]\\n\", e->s->s - S + 1, e->t->s - S + 1);\n\t\t\t\te->s->s->v.e = new Edge(&e->s->s->v, &e->t->s->v);\n\t\t\t\te->t->s->inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int dp(const int cnt) {\n\tstd::queue<Node *> q;\n\tfor (int i = 0; i < cnt; i++) {\n\t\t// printf(\"size[%d] = %d\\n\", i, S[i].size);\n\t\tif (S[i].inDegree == 0) q.push(&S[i].v);\n\t\tS[i].v.d = S[i].size;\n\t\tS[i].in = S[i].inDegree;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\te->t->d = std::max(e->t->d, v->d + e->t->s->size);\n\t\t\tif (!--e->t->s->in) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; i++) if (!S[i].v.e) ans = std::max(ans, S[i].v.d);\n\treturn ans;\n}\n\ninline int dpSum(const int cnt, const int d) {\n\tstd::queue<Node *> q;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].inDegree == 0) {\n\t\t\tq.push(&S[i].v);\n\t\t\tS[i].v.sum = 1;\n\t\t}\n\t\tS[i].in = S[i].inDegree;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->d == v->d + e->t->s->size) (e->t->sum += v->sum) %= x;\n\t\t\tif (!--e->t->s->in) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; i++) if (S[i].v.d == d) (ans += S[i].v.sum) %= x;\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d %d\", &n, &m, &x);\n\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tint cnt = tarjan();\n\tcontract();\n\n\tint d = dp(cnt);\n\n\tprintf(\"%d\\n\", d);\n\tprintf(\"%d\\n\", dpSum(cnt, d));\n\n\treturn 0;\n}\n```","source":"_posts/zjoi2007-semi.md","raw":"title: ZJOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - \n  - Tarjan\n  - \n  - DP\npermalink: zjoi2007-semi\ndate: 2016-09-04 07:38:00\n---\n\n $ G = (V, E) $ Semi-Connected\n\n> $ \\forall u, v \\in V $ $ u \\rightarrow v $  $ v \\rightarrow u $ $ u $$ v $ $ u $  $ v $  $ v $  $ u $ \n\n $ G' = (V', E') $  $ V' \\subseteq V $$ E' $  $ E $  $ V' $  $ G' $  $ G $   \n $ G' $  $ G $  $ G' $  $ G' $  $ G $   \n $ G' $  $ G $  $ G' $  $ G $ \n\n $ G $ $ G $  $ K $ $ C $ $ C $  $ C $  $ X $ \n\n<!-- more -->\n\n### \n[BZOJ 1093](http://www.lydsy.com/JudgeOnline/problem.php?id=1093)\n\n### \n\n\n DAG  DP \n\n $ d(i) $  $ u \\rightarrow v $ $ d(v) = d(u) + s(v) $$ s(i) $  $ i $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <tr1/unordered_set>\n\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\nconst int MAXX = 100000000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tstruct SCC *s;\n\tNode *p;\n\tbool inStack, pushed, visited;\n\tint dfn, low, d, sum;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint size, inDegree, in, len, sum;\n} S[MAXN];\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n}\n\nint n, x;\n\ninline int tarjan() {\n\tint cnt = 0, ts = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\t\t\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tt.push(v);\n\t\t\t\tv->inStack = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->inStack) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, e->t->p = v, s.push(e->t);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tSCC *scc = &S[cnt++];\n\t\t\t\t\tscc->v.s = scc;\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->s = scc;\n\t\t\t\t\t\tscc->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\ninline void contract() {\n\tstd::tr1::unordered_set<unsigned long long> s;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\tunsigned long long x = (static_cast<unsigned long long>(e->s->s - S) << 32) | static_cast<unsigned long long>(e->t->s - S);\n\t\t\tif (e->s->s != e->t->s && !s.count(x)) {\n\t\t\t\ts.insert(x);\n\t\t\t\t// printf(\"[%ld, %ld]\\n\", e->s->s - S + 1, e->t->s - S + 1);\n\t\t\t\te->s->s->v.e = new Edge(&e->s->s->v, &e->t->s->v);\n\t\t\t\te->t->s->inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int dp(const int cnt) {\n\tstd::queue<Node *> q;\n\tfor (int i = 0; i < cnt; i++) {\n\t\t// printf(\"size[%d] = %d\\n\", i, S[i].size);\n\t\tif (S[i].inDegree == 0) q.push(&S[i].v);\n\t\tS[i].v.d = S[i].size;\n\t\tS[i].in = S[i].inDegree;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\te->t->d = std::max(e->t->d, v->d + e->t->s->size);\n\t\t\tif (!--e->t->s->in) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; i++) if (!S[i].v.e) ans = std::max(ans, S[i].v.d);\n\treturn ans;\n}\n\ninline int dpSum(const int cnt, const int d) {\n\tstd::queue<Node *> q;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].inDegree == 0) {\n\t\t\tq.push(&S[i].v);\n\t\t\tS[i].v.sum = 1;\n\t\t}\n\t\tS[i].in = S[i].inDegree;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->d == v->d + e->t->s->size) (e->t->sum += v->sum) %= x;\n\t\t\tif (!--e->t->s->in) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < cnt; i++) if (S[i].v.d == d) (ans += S[i].v.sum) %= x;\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d %d\", &n, &m, &x);\n\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tint cnt = tarjan();\n\tcontract();\n\n\tint d = dp(cnt);\n\n\tprintf(\"%d\\n\", d);\n\tprintf(\"%d\\n\", dpSum(cnt, d));\n\n\treturn 0;\n}\n```","slug":"zjoi2007-semi","published":1,"updated":"2016-09-03T23:51:14.898Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6btt0027c2xlndsrl4r5"},{"title":"ZJOI2007 - ","date":"2016-12-13T09:23:00.000Z","_content":"\n $ N \\times M $  $ 01 $ \n\n<!-- more -->\n\n### \n[BZOJ 1057](http://www.lydsy.com/JudgeOnline/problem.php?id=1057)\n\n### \n\n\n\n\n\n\n $ O(nm) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 2000;\n\ninline int sqr(int x) {\n\treturn x * x;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN + 1][MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\t// for (int i = 1; i <= n; i++) f[i][0] = -1;\n\t// for (int j = 1; j <= m; j++) f[0][j] = -1;\n\n\tstatic int f[MAXN + 1][MAXN + 1], g[MAXN + 1][MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (j == 1 ||  a[i][j] == a[i][j - 1]) {\n\t\t\t\tf[i][j] = 1;\n\t\t\t} else {\n\t\t\t\tf[i][j] = f[i][j - 1] + 1;\n\t\t\t}\n\t\t\t// printf(\"f(%d, %d) = %d\\n\", i, j, f[i][j]);\n\t\t}\n\n\t\tfor (int j = m; j >= 1; j--) {\n\t\t\tif (j == m || a[i][j] == a[i][j + 1]) {\n\t\t\t\tg[i][j] = 1;\n\t\t\t} else {\n\t\t\t\tg[i][j] = g[i][j + 1] + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ansSquare = 1, ansRectangle = 1;\n\tfor (int j = 1; j <= m; j++) {\n\t\tint up = 0, left = 0, right = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (i == 1 || a[i][j] == a[i - 1][j]) {\n\t\t\t\tup = 1;\n\t\t\t\tleft = f[i][j];\n\t\t\t\tright = g[i][j];\n\t\t\t} else {\n\t\t\t\tup++;\n\t\t\t\tleft = std::min(left, f[i][j]);\n\t\t\t\tright = std::min(right, g[i][j]);\n\t\t\t}\n\n\t\t\t// printf(\"up = %d, left = %d, right = %d\\n\", up, left, right);\n\t\t\tansRectangle = std::max(ansRectangle, up * (left + right - 1));\n\t\t\tansSquare = std::max(ansSquare, sqr(std::min(up, left + right - 1)));\n\t\t}\n\t}\n\n\tprintf(\"%d\\n%d\\n\", ansSquare, ansRectangle);\n\n\treturn 0;\n}\n```","source":"_posts/zjoi2007-chess.md","raw":"title: ZJOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - ZJOI\n  - \npermalink: zjoi2007-chess\ndate: 2016-12-13 17:23:00\n---\n\n $ N \\times M $  $ 01 $ \n\n<!-- more -->\n\n### \n[BZOJ 1057](http://www.lydsy.com/JudgeOnline/problem.php?id=1057)\n\n### \n\n\n\n\n\n\n $ O(nm) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 2000;\n\ninline int sqr(int x) {\n\treturn x * x;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN + 1][MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\t// for (int i = 1; i <= n; i++) f[i][0] = -1;\n\t// for (int j = 1; j <= m; j++) f[0][j] = -1;\n\n\tstatic int f[MAXN + 1][MAXN + 1], g[MAXN + 1][MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (j == 1 ||  a[i][j] == a[i][j - 1]) {\n\t\t\t\tf[i][j] = 1;\n\t\t\t} else {\n\t\t\t\tf[i][j] = f[i][j - 1] + 1;\n\t\t\t}\n\t\t\t// printf(\"f(%d, %d) = %d\\n\", i, j, f[i][j]);\n\t\t}\n\n\t\tfor (int j = m; j >= 1; j--) {\n\t\t\tif (j == m || a[i][j] == a[i][j + 1]) {\n\t\t\t\tg[i][j] = 1;\n\t\t\t} else {\n\t\t\t\tg[i][j] = g[i][j + 1] + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ansSquare = 1, ansRectangle = 1;\n\tfor (int j = 1; j <= m; j++) {\n\t\tint up = 0, left = 0, right = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (i == 1 || a[i][j] == a[i - 1][j]) {\n\t\t\t\tup = 1;\n\t\t\t\tleft = f[i][j];\n\t\t\t\tright = g[i][j];\n\t\t\t} else {\n\t\t\t\tup++;\n\t\t\t\tleft = std::min(left, f[i][j]);\n\t\t\t\tright = std::min(right, g[i][j]);\n\t\t\t}\n\n\t\t\t// printf(\"up = %d, left = %d, right = %d\\n\", up, left, right);\n\t\t\tansRectangle = std::max(ansRectangle, up * (left + right - 1));\n\t\t\tansSquare = std::max(ansSquare, sqr(std::min(up, left + right - 1)));\n\t\t}\n\t}\n\n\tprintf(\"%d\\n%d\\n\", ansSquare, ansRectangle);\n\n\treturn 0;\n}\n```","slug":"zjoi2007-chess","published":1,"updated":"2016-12-13T09:23:42.469Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6btz002ic2xlzpejtfyv"},{"title":"ZJOI2006 -  + DP","date":"2016-05-23T13:41:00.000Z","_content":"\n $ A $  $ B $ $ n $  $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 1003](http://www.lydsy.com/JudgeOnline/problem.php?id=1003)  \n[COGS 1824](http://cogs.top/cogs/problem/problem.php?pid=1824)\n\n### \n\n\n $ c(l,\\ r) $  $ l $  $ r $  $ f(i) $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + k + c(j + 1,\\ i) \\} $$\n\n $ c(j + 1,\\ i) $  $ j + 1 $  $ i $ \n\n $ f(n) - k $ $ O(n ^ 2 m \\log m) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <utility>\n#include <functional>\n\nstruct Node;\nstruct Edge;\n\nconst int MAXN = 20;\nconst int MAXD = 100;\n\nstruct Node {\n\tEdge *e;\n\tint d;\n\tbool flag[MAXD], invalid;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *const s, Node *const t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v, const int w) {\n\tN[u].e = new Edge(&N[u], &N[v], w);\n\tN[v].e = new Edge(&N[v], &N[u], w);\n}\n\nint d, n, k, m, c[MAXD + 1][MAXD + 1];\nint f[MAXD + 1];\n\ninline int dijkstra(const int s, const int t) {\n\tfor (int i = 0; i < n; i++) N[i].d = INT_MAX;\n\n\tstd::priority_queue< std::pair<int, Node *>, std::vector< std::pair<int, Node *> >, std::greater< std::pair<int, Node *> > > q;\n\tN[s].d = 0;\n\tq.push(std::make_pair(0, &N[s]));\n\n\twhile (!q.empty()) {\n\t\tconst std::pair<int, Node *> p = q.top();\n\t\tq.pop();\n\n\t\tNode *v = p.second;\n\n\t\tif (v->d != p.first) continue;\n\t\tif (v->d > N[t].d) break;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->invalid) continue;\n\n\t\t\tif (e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\tq.push(std::make_pair(e->t->d, e->t));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn N[t].d;\n}\n\nint main() {\n\tscanf(\"%d %d %d %d\", &d, &n, &k, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint u, l, r;\n\t\tscanf(\"%d %d %d\", &u, &l, &r), u--, l--, r--;\n\t\tstd::fill(N[u].flag + l, N[u].flag + r + 1, true);\n\t}\n\n\tfor (int i = 1; i <= d; i++) {\n\t\tfor (int j = i; j <= d; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tN[k].invalid = false;\n\t\t\t\tfor (int l = i; l <= j; l++) {\n\t\t\t\t\tif (N[k].flag[l - 1]) {\n\t\t\t\t\t\tN[k].invalid = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc[i][j] = dijkstra(0, n - 1);\n\t\t\tif (c[i][j] != INT_MAX) c[i][j] *= (j - i + 1);\n\t\t\t// printf(\"%d\\n\", c[i][j]);\n\t\t}\n\t}\n\n\tstd::fill(f, f + d + 1, INT_MAX);\n\tf[0] = 0;\n\tfor (int i = 1; i <= d; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (c[j + 1][i] != INT_MAX) {\n\t\t\t\tf[i] = std::min(f[i], f[j] + k + c[j + 1][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", f[d] - k);\n\n\treturn 0;\n}\n```\n","source":"_posts/zjoi2006-trans.md","raw":"title: ZJOI2006 -  + DP\ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - ZJOI\n  - \n  - DP\npermalink: zjoi2006-trans\ndate: 2016-05-23 21:41:00\n---\n\n $ A $  $ B $ $ n $  $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 1003](http://www.lydsy.com/JudgeOnline/problem.php?id=1003)  \n[COGS 1824](http://cogs.top/cogs/problem/problem.php?pid=1824)\n\n### \n\n\n $ c(l,\\ r) $  $ l $  $ r $  $ f(i) $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + k + c(j + 1,\\ i) \\} $$\n\n $ c(j + 1,\\ i) $  $ j + 1 $  $ i $ \n\n $ f(n) - k $ $ O(n ^ 2 m \\log m) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <utility>\n#include <functional>\n\nstruct Node;\nstruct Edge;\n\nconst int MAXN = 20;\nconst int MAXD = 100;\n\nstruct Node {\n\tEdge *e;\n\tint d;\n\tbool flag[MAXD], invalid;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *const s, Node *const t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v, const int w) {\n\tN[u].e = new Edge(&N[u], &N[v], w);\n\tN[v].e = new Edge(&N[v], &N[u], w);\n}\n\nint d, n, k, m, c[MAXD + 1][MAXD + 1];\nint f[MAXD + 1];\n\ninline int dijkstra(const int s, const int t) {\n\tfor (int i = 0; i < n; i++) N[i].d = INT_MAX;\n\n\tstd::priority_queue< std::pair<int, Node *>, std::vector< std::pair<int, Node *> >, std::greater< std::pair<int, Node *> > > q;\n\tN[s].d = 0;\n\tq.push(std::make_pair(0, &N[s]));\n\n\twhile (!q.empty()) {\n\t\tconst std::pair<int, Node *> p = q.top();\n\t\tq.pop();\n\n\t\tNode *v = p.second;\n\n\t\tif (v->d != p.first) continue;\n\t\tif (v->d > N[t].d) break;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->invalid) continue;\n\n\t\t\tif (e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\tq.push(std::make_pair(e->t->d, e->t));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn N[t].d;\n}\n\nint main() {\n\tscanf(\"%d %d %d %d\", &d, &n, &k, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint u, l, r;\n\t\tscanf(\"%d %d %d\", &u, &l, &r), u--, l--, r--;\n\t\tstd::fill(N[u].flag + l, N[u].flag + r + 1, true);\n\t}\n\n\tfor (int i = 1; i <= d; i++) {\n\t\tfor (int j = i; j <= d; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tN[k].invalid = false;\n\t\t\t\tfor (int l = i; l <= j; l++) {\n\t\t\t\t\tif (N[k].flag[l - 1]) {\n\t\t\t\t\t\tN[k].invalid = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc[i][j] = dijkstra(0, n - 1);\n\t\t\tif (c[i][j] != INT_MAX) c[i][j] *= (j - i + 1);\n\t\t\t// printf(\"%d\\n\", c[i][j]);\n\t\t}\n\t}\n\n\tstd::fill(f, f + d + 1, INT_MAX);\n\tf[0] = 0;\n\tfor (int i = 1; i <= d; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (c[j + 1][i] != INT_MAX) {\n\t\t\t\tf[i] = std::min(f[i], f[j] + k + c[j + 1][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", f[d] - k);\n\n\treturn 0;\n}\n```\n","slug":"zjoi2006-trans","published":1,"updated":"2016-05-23T13:42:15.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bu4002oc2xlq9cdw8vy"},{"title":"ZJOI2004 - ","date":"2016-10-07T22:54:00.000Z","_content":"\n $ s $  $ t $  $ k $ \n\n<!-- more -->\n\n### \n[BZOJ 1898](www.lydsy.com/JudgeOnline/problem.php?id=1898)  \n[COGS 1469](http://cogs.pro/cogs/problem/problem.php?pid=1469)\n\n### \n $ k $  $ s $  $ t $ \n\n****\n\n $ \\mathrm{lcm}(2, 3, 4) = 12 $ $ 12 $  $ 12 $  $ k $  $ 12 $  $ 11 $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 50;\nconst int MAXM = 20;\nconst long long MAXK = 2e9;\nconst int CYCLE_LCM = 12;\nconst int MOD = 10000;\n\nstruct Matrix {\n\tint a[MAXN][MAXN];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < MAXN; i++) a[i][i] = 1;\n\t}\n\n\tint &operator()(const int i, const int j) { return a[i][j]; }\n\tconst int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res;\n\tfor (int i = 0; i < MAXN; i++) for (int j = 0; j < MAXN; j++) for (int k = 0; k < MAXN; k++) (res(i, j) += a(i, k) * b(k, j)) %= MOD;\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"swamp.in\", \"r\", stdin);\n\tfreopen(\"swamp.out\", \"w\", stdout);\n\n\tint n, m, st, ed, k;\n\tscanf(\"%d %d %d %d %d\", &n, &m, &st, &ed, &k);\n\n\tMatrix g;\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\tg(u, v)++;\n\t\tg(v, u)++;\n\t}\n\n\tMatrix gs[CYCLE_LCM];\n\tfor (int i = 0; i < CYCLE_LCM; i++) gs[i] = g;\n\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint cycle;\n\t\tscanf(\"%d\", &cycle);\n\t\tfor (int i = 0; i < cycle; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tfor (int j = i; j < CYCLE_LCM; j += cycle) {\n\t\t\t\tfor (int l = 0; l < n; l++) gs[j](x, l) = 0;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", g(i, j), j == n - 1 ? '\\n' : ' ');\n\tputs(\"-------------\");\n\tfor (int l = 0; l < CYCLE_LCM; l++) {\n\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", gs[l](i, j), j == n - 1 ? '\\n' : ' ');\n\t\tputs(\"-------------\");\n\t}\n#endif\n\n#ifndef FORCE\n\tMatrix prod(true);\n\tfor (int i = 0; i < CYCLE_LCM; i++) prod = prod * gs[i];\n\n\tMatrix res = pow(prod, k / CYCLE_LCM);\n\tfor (int i = 0; i < k % CYCLE_LCM; i++) res = res * gs[i];\n#else\n\tMatrix res(true);\n\tfor (int i = 0; i < k; i++) res = res * gs[i % CYCLE_LCM];\n#endif\n\n\tprintf(\"%d\\n\", res(st, ed));\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", res(i, j), j == n - 1 ? '\\n' : ' ');\n#endif\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/zjoi2004-swamp.md","raw":"title: ZJOI2004 - \ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - ZJOI\n  - \n  - DP\npermalink: zjoi2004-swamp\ndate: 2016-10-08 06:54:00\n---\n\n $ s $  $ t $  $ k $ \n\n<!-- more -->\n\n### \n[BZOJ 1898](www.lydsy.com/JudgeOnline/problem.php?id=1898)  \n[COGS 1469](http://cogs.pro/cogs/problem/problem.php?pid=1469)\n\n### \n $ k $  $ s $  $ t $ \n\n****\n\n $ \\mathrm{lcm}(2, 3, 4) = 12 $ $ 12 $  $ 12 $  $ k $  $ 12 $  $ 11 $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 50;\nconst int MAXM = 20;\nconst long long MAXK = 2e9;\nconst int CYCLE_LCM = 12;\nconst int MOD = 10000;\n\nstruct Matrix {\n\tint a[MAXN][MAXN];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < MAXN; i++) a[i][i] = 1;\n\t}\n\n\tint &operator()(const int i, const int j) { return a[i][j]; }\n\tconst int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res;\n\tfor (int i = 0; i < MAXN; i++) for (int j = 0; j < MAXN; j++) for (int k = 0; k < MAXN; k++) (res(i, j) += a(i, k) * b(k, j)) %= MOD;\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"swamp.in\", \"r\", stdin);\n\tfreopen(\"swamp.out\", \"w\", stdout);\n\n\tint n, m, st, ed, k;\n\tscanf(\"%d %d %d %d %d\", &n, &m, &st, &ed, &k);\n\n\tMatrix g;\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\tg(u, v)++;\n\t\tg(v, u)++;\n\t}\n\n\tMatrix gs[CYCLE_LCM];\n\tfor (int i = 0; i < CYCLE_LCM; i++) gs[i] = g;\n\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint cycle;\n\t\tscanf(\"%d\", &cycle);\n\t\tfor (int i = 0; i < cycle; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tfor (int j = i; j < CYCLE_LCM; j += cycle) {\n\t\t\t\tfor (int l = 0; l < n; l++) gs[j](x, l) = 0;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", g(i, j), j == n - 1 ? '\\n' : ' ');\n\tputs(\"-------------\");\n\tfor (int l = 0; l < CYCLE_LCM; l++) {\n\t\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", gs[l](i, j), j == n - 1 ? '\\n' : ' ');\n\t\tputs(\"-------------\");\n\t}\n#endif\n\n#ifndef FORCE\n\tMatrix prod(true);\n\tfor (int i = 0; i < CYCLE_LCM; i++) prod = prod * gs[i];\n\n\tMatrix res = pow(prod, k / CYCLE_LCM);\n\tfor (int i = 0; i < k % CYCLE_LCM; i++) res = res * gs[i];\n#else\n\tMatrix res(true);\n\tfor (int i = 0; i < k; i++) res = res * gs[i % CYCLE_LCM];\n#endif\n\n\tprintf(\"%d\\n\", res(st, ed));\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"%d%c\", res(i, j), j == n - 1 ? '\\n' : ' ');\n#endif\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"zjoi2004-swamp","published":1,"updated":"2016-10-07T23:08:49.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bu9002wc2xlllzj716i"},{"title":"OS X  Linux ","date":"2016-03-07T01:04:27.000Z","_content":"\nOS X  GNU/Linux  GNU/Linux  OS X  OS X  GNU/Linux   \n\n `VirtualBox`  Archlinux  OS X \n\n<!-- more -->\n\n##  OpenSSH\n Arch Linux \n\n OpenSSH\n\n```bash\nsudo pacman -S openssh\nsudo systemctl enable sshd\nsudo systemctl start sshd\n```\n\n## \nNAT\n\n![](virtualbox-archlinux/network.png)\n\n\n\n![](virtualbox-archlinux/port.png)\n\n `22` `1000`  OS X  `root`  `1000` \n\n Terminal \n\n```bash\nssh -p5280 127.0.0.1\n```\n\n## \n Virtualbox \n\n![](virtualbox-archlinux/share.png)\n\n\n\n### `rc.local` \n\nArchlinux  systemd  `rc.local` \n\n```bash\nsudo nano /usr/lib/systemd/system/rc-local.service\n```\n\n\n\n```ini\n[Unit]\nDescription=\"/etc/rc.local Compatibility\"\nAfter=vboxadd.service vboxadd-service.service\n\n[Service]\nType=forking\nExecStart=/etc/rc.local start\nTimeoutSec=0\nStandardInput=tty\nRemainAfterExit=yes\nSysVStartPriority=999\n\n[Install]\nWantedBy=multi-user.target\n```\n\n `rc.local` \n\n```bash\nsudo systemctl enable rc-local\n```\n\n### \n\n```bash\nsudo touch /etc/rc.local\nsudo chmod +x /etc/rc.local\nsudo nano /etc/rc.local\n```\n\n```bash\n#!/bin/bash\n\n/usr/bin/mount -t vboxsf Host /media/Host -o uid=1000,gid=1000\n/usr/bin/mount --bind /media/Host/Users/Menci /home/Menci\n\nexit 0\n```\n\n\n\n## SSH \n SSH \n\n```bash\nssh-keygen -b 1024 -t rsa\n```\n\n `~/.ssh` \n\n```bash\ncat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys\n```\n\n\n\n SSH \n\n##  Terminal \nTerminal  `Command + N` SSH \n\n### \n Terminal BasicBasic Linux `Shell`  SSH Shell \n\n![](virtualbox-archlinux/terminal.png)\n\n\n\n### \n\n\n\n\n![](virtualbox-archlinux/hotkey.png)\n\n\n\n## \n Terminal  `Command + B`\n\n![](virtualbox-archlinux/screenfetch.png)\n\n `screenfetch`\n","source":"_posts/virtualbox-archlinux.md","raw":"title: OS X  Linux \ncategories: Geek\ntags: \n  - OS X\n  - Linux\n  - Archlinux\n  - VirtualBox\n  - \n  - SSH\npermalink: virtualbox-archlinux\ndate: 2016-03-07 09:04:27\n---\n\nOS X  GNU/Linux  GNU/Linux  OS X  OS X  GNU/Linux   \n\n `VirtualBox`  Archlinux  OS X \n\n<!-- more -->\n\n##  OpenSSH\n Arch Linux \n\n OpenSSH\n\n```bash\nsudo pacman -S openssh\nsudo systemctl enable sshd\nsudo systemctl start sshd\n```\n\n## \nNAT\n\n![](virtualbox-archlinux/network.png)\n\n\n\n![](virtualbox-archlinux/port.png)\n\n `22` `1000`  OS X  `root`  `1000` \n\n Terminal \n\n```bash\nssh -p5280 127.0.0.1\n```\n\n## \n Virtualbox \n\n![](virtualbox-archlinux/share.png)\n\n\n\n### `rc.local` \n\nArchlinux  systemd  `rc.local` \n\n```bash\nsudo nano /usr/lib/systemd/system/rc-local.service\n```\n\n\n\n```ini\n[Unit]\nDescription=\"/etc/rc.local Compatibility\"\nAfter=vboxadd.service vboxadd-service.service\n\n[Service]\nType=forking\nExecStart=/etc/rc.local start\nTimeoutSec=0\nStandardInput=tty\nRemainAfterExit=yes\nSysVStartPriority=999\n\n[Install]\nWantedBy=multi-user.target\n```\n\n `rc.local` \n\n```bash\nsudo systemctl enable rc-local\n```\n\n### \n\n```bash\nsudo touch /etc/rc.local\nsudo chmod +x /etc/rc.local\nsudo nano /etc/rc.local\n```\n\n```bash\n#!/bin/bash\n\n/usr/bin/mount -t vboxsf Host /media/Host -o uid=1000,gid=1000\n/usr/bin/mount --bind /media/Host/Users/Menci /home/Menci\n\nexit 0\n```\n\n\n\n## SSH \n SSH \n\n```bash\nssh-keygen -b 1024 -t rsa\n```\n\n `~/.ssh` \n\n```bash\ncat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys\n```\n\n\n\n SSH \n\n##  Terminal \nTerminal  `Command + N` SSH \n\n### \n Terminal BasicBasic Linux `Shell`  SSH Shell \n\n![](virtualbox-archlinux/terminal.png)\n\n\n\n### \n\n\n\n\n![](virtualbox-archlinux/hotkey.png)\n\n\n\n## \n Terminal  `Command + B`\n\n![](virtualbox-archlinux/screenfetch.png)\n\n `screenfetch`\n","slug":"virtualbox-archlinux","published":1,"updated":"2016-05-11T09:33:24.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bue0034c2xl1ourfi98"},{"title":"UVa 1362Exploring Pyramids -  DP + ","date":"2016-03-14T08:32:16.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[UVa 1362](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4108)\n\n### \n $ f(i, j) $  $ S $  $ i $  $ j $ \n\n1.  $ i = j $ $ f(i, j) = 1 $\n2.  $ S(i) \\neq S(j) $ $ f(i, j) = 0 $\n\n $ k $ $ i = k = j $  $ (i, k) $  $ [k, j] $ \n\n \n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 300;\nconst long long MOD = 1000000000;\n\nchar str[MAXN + 1];\n\nlong long search(int i, int j, bool reset = false) {\n\tstatic long long mem[MAXN][MAXN];\n\tstatic bool calced[MAXN][MAXN];\n\n\tif (reset) {\n\t\tmemset(mem, 0, sizeof(mem));\n\t\tmemset(calced, 0, sizeof(calced));\n\t}\n\n\tlong long &ans = mem[i][j];\n\n\tif (calced[i][j]) return ans;\n\tcalced[i][j] = true;\n\n\tif (i == j) return ans = 1;\n\telse if (str[i] != str[j]) return ans = 0;\n\telse {\n\t\tans = 0;\n\t\tfor (int k = i + 2; k <= j; k++) {\n\t\t\tif (str[i] != str[k]) continue;\n\t\t\tans += search(i + 1, k - 1) * search(k, j) % MOD;\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tfor (; ~scanf(\"%s\", str); printf(\"%lld\\n\", search(0, strlen(str) - 1, true)));\n\treturn 0;\n}\n```\n","source":"_posts/uva-1362.md","raw":"title: UVa 1362Exploring Pyramids -  DP + \ncategories: OI\ntags: \n  - UVa\n  - \n  - DP\n  -  DP\n  - \npermalink: uva-1362\ndate: 2016-03-14 16:32:16\n---\n\n\n\n<!-- more -->\n\n### \n[UVa 1362](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4108)\n\n### \n $ f(i, j) $  $ S $  $ i $  $ j $ \n\n1.  $ i = j $ $ f(i, j) = 1 $\n2.  $ S(i) \\neq S(j) $ $ f(i, j) = 0 $\n\n $ k $ $ i = k = j $  $ (i, k) $  $ [k, j] $ \n\n \n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 300;\nconst long long MOD = 1000000000;\n\nchar str[MAXN + 1];\n\nlong long search(int i, int j, bool reset = false) {\n\tstatic long long mem[MAXN][MAXN];\n\tstatic bool calced[MAXN][MAXN];\n\n\tif (reset) {\n\t\tmemset(mem, 0, sizeof(mem));\n\t\tmemset(calced, 0, sizeof(calced));\n\t}\n\n\tlong long &ans = mem[i][j];\n\n\tif (calced[i][j]) return ans;\n\tcalced[i][j] = true;\n\n\tif (i == j) return ans = 1;\n\telse if (str[i] != str[j]) return ans = 0;\n\telse {\n\t\tans = 0;\n\t\tfor (int k = i + 2; k <= j; k++) {\n\t\t\tif (str[i] != str[k]) continue;\n\t\t\tans += search(i + 1, k - 1) * search(k, j) % MOD;\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tfor (; ~scanf(\"%s\", str); printf(\"%lld\\n\", search(0, strlen(str) - 1, true)));\n\treturn 0;\n}\n```\n","slug":"uva-1362","published":1,"updated":"2016-10-24T23:28:14.088Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bvb003jc2xl99n86m4q"},{"title":"UVa 11806Cheerleaders -  + ","date":"2016-03-11T14:10:34.000Z","_content":"\n $ M * N $  $ K $  $ \nM $  $ N $ \n\n<!-- more -->\n\n### \n[UVa \n11806](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2906)\n\n### \n1.  $ A $$ C $  $ M $ \n****\n2.  $ B $$ D $  $ N $ \n****\n3.  $ S $  $ M * N $ **** $ K $ \n\n\n $ S $  $ A $$ B $$ C $$ D $ \n\n\n\n$$\n\\begin{align*}\n& = |S| \\\\\n& - |A| - |B| - |C| - |D| \\\\\n& + |A{\\cup}B| + |B{\\cup}C| + |C{\\cup}D| + |D{\\cup}A| + |A{\\cup}C| + \n|B{\\cup}D| \\\\\n& - |A{\\cup}B{\\cup}C| - |B{\\cup}C{\\cup}D| - |A{\\cup}C{\\cup}D| - \n|A{\\cup}B{\\cup}D| \\\\\n& + |A{\\cup}B{\\cup}C{\\cup}D| \\\\\n\\end{align*}\n$$\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXT = 50;\nconst int MAXN = 20;\nconst int MAXK = 500;\nconst int p = 1000007;\n\nint combo[MAXK + 1][MAXK + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 0; i <= MAXK; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tcombo[i][j] = (combo[i - 1][j] + combo[i - \n1][j - 1]) % p;\n\t\t}\n\t}\n}\n\ninline long long C(int a, int b) {\n\treturn (long long)combo[a][b];\n}\n\ninline int solve(int m, int n, int k) {\n\tlong long ans = C(m * n, k);\n\n\t// |A| = |C| = C(m(n - 1), k)\n\t// |B| = |D| = C((m - 1)n, k)\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\n\t// |AB| = |BC| = |CD| = |DA| = C((m - 1)(n - 1), k)\n\t// |AC| = C(m(n - 2), k)\n\t// |BD| = C((m - 2)n, k)\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C(m * (n - 2), k), ans %= p;\n\tans += C((m - 2) * n, k), ans %= p;\n\n\t// |ABC| = |ADC| = C((m - 1)(n - 2), k)\n\t// |ABD| = |CBD| = C((m - 2)(n - 1), k)\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\n\t// |ABCD| = C((m - 2)(n - 2), k);\n\tans += C((m - 2) * (n - 2), k), ans %= p;\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 1; i <= t; i++) {\n\t\tint n, m, k;\n\t\tscanf(\"%d %d %d\", &m, &n, &k);\n\t\tprintf(\"Case %d: %d\\n\", i, solve(m, n, k));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11806.md","raw":"title: UVa 11806Cheerleaders -  + \ncategories: OI\ntags: \n  - UVa\n  - \n  - \n  - \npermalink: uva-11806\ndate: 2016-03-11 22:10:34\n---\n\n $ M * N $  $ K $  $ \nM $  $ N $ \n\n<!-- more -->\n\n### \n[UVa \n11806](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2906)\n\n### \n1.  $ A $$ C $  $ M $ \n****\n2.  $ B $$ D $  $ N $ \n****\n3.  $ S $  $ M * N $ **** $ K $ \n\n\n $ S $  $ A $$ B $$ C $$ D $ \n\n\n\n$$\n\\begin{align*}\n& = |S| \\\\\n& - |A| - |B| - |C| - |D| \\\\\n& + |A{\\cup}B| + |B{\\cup}C| + |C{\\cup}D| + |D{\\cup}A| + |A{\\cup}C| + \n|B{\\cup}D| \\\\\n& - |A{\\cup}B{\\cup}C| - |B{\\cup}C{\\cup}D| - |A{\\cup}C{\\cup}D| - \n|A{\\cup}B{\\cup}D| \\\\\n& + |A{\\cup}B{\\cup}C{\\cup}D| \\\\\n\\end{align*}\n$$\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXT = 50;\nconst int MAXN = 20;\nconst int MAXK = 500;\nconst int p = 1000007;\n\nint combo[MAXK + 1][MAXK + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 0; i <= MAXK; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tcombo[i][j] = (combo[i - 1][j] + combo[i - \n1][j - 1]) % p;\n\t\t}\n\t}\n}\n\ninline long long C(int a, int b) {\n\treturn (long long)combo[a][b];\n}\n\ninline int solve(int m, int n, int k) {\n\tlong long ans = C(m * n, k);\n\n\t// |A| = |C| = C(m(n - 1), k)\n\t// |B| = |D| = C((m - 1)n, k)\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C(m * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\tans -= C((m - 1) * n, k), ans += p, ans %= p;\n\n\t// |AB| = |BC| = |CD| = |DA| = C((m - 1)(n - 1), k)\n\t// |AC| = C(m(n - 2), k)\n\t// |BD| = C((m - 2)n, k)\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C((m - 1) * (n - 1), k), ans %= p;\n\tans += C(m * (n - 2), k), ans %= p;\n\tans += C((m - 2) * n, k), ans %= p;\n\n\t// |ABC| = |ADC| = C((m - 1)(n - 2), k)\n\t// |ABD| = |CBD| = C((m - 2)(n - 1), k)\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 1) * (n - 2), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\tans -= C((m - 2) * (n - 1), k), ans += p, ans %= p;\n\n\t// |ABCD| = C((m - 2)(n - 2), k);\n\tans += C((m - 2) * (n - 2), k), ans %= p;\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 1; i <= t; i++) {\n\t\tint n, m, k;\n\t\tscanf(\"%d %d %d\", &m, &n, &k);\n\t\tprintf(\"Case %d: %d\\n\", i, solve(m, n, k));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11806","published":1,"updated":"2016-05-11T09:33:24.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bvg003tc2xlxq8umis0"},{"title":"UVa 11538Chess Queen - ","date":"2016-03-12T02:47:13.000Z","_content":"\n $ N * M $ \n\n<!-- more -->\n\n### \n[UVa 11538](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2533)\n\n### \n\n\n $ f(a, b) $  $ a $  $ b $  $ a = 1 $ $ b $  $ b - 1 $ \n\n$$ f(1, b) = b(b - 1) $$\n\n\n\n$$\n\\begin{align}\nf(a, b) & = \\sum_{i = 1}^{a} b(b - 1) \\\\\n& = ab(b - 1) \\\\\n\\end{align}\n$$\n\n\n\n $ m  n $ $ m - n + 1 $  $ n $ $ n - 1 $ \n\n![ \nLibreOffice Calc \n](uva-11538/cells.png)\n\n $ m - n + 1 $  $ n $ **** $ f(m - n + 1, n) $\n\n\n\n$$ \\sum_{i = 1}^{n - 1} f(1, i) $$\n\n$ O(n) $ \n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} f(1, i) \\\\\n= & \\sum_{i = 1}^{n - 1} i(i - 1) \\\\\n= & \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n\\end{align}\n$$\n\n\n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n= & \\frac{(n - 1)n(2n - 1)}{6} - \\frac{n(n - 1)}{2} \\\\\n= & \\frac{n(n - 1)(2n - 4)}{6} \\\\\n= & \\frac{n(n - 1)(n - 2)}{3} \\\\\n\\end{align}\n$$\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 5000;\nconst int MAXN = 1000000;\n\ninline long long f(long long a, long long b) {\n\treturn a * (b - 1) * b;\n}\n\ninline long long g(long long n, long long m) {\n\t// m >= n\n\tif (m < n) std::swap(m, n);\n\tunsigned long long x = ((n - 1) * n * (n - 2)) / 3;\n\treturn f(m - n + 1, n) + x * 2;\n}\n\nint main() {\n\tint n, m;\n\twhile (~scanf(\"%d %d\", &n, &m), !(n == 0 && m == 0)) {\n\t\tprintf(\"%llu\\n\", f(n, m) + f(m, n) + g(n, m) * 2);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11538.md","raw":"title: UVa 11538Chess Queen - \ncategories: OI\ntags: \n  - UVa\n  - \n  - \n  - \npermalink: uva-11538\ndate: 2016-03-12 10:47:13\n---\n\n $ N * M $ \n\n<!-- more -->\n\n### \n[UVa 11538](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2533)\n\n### \n\n\n $ f(a, b) $  $ a $  $ b $  $ a = 1 $ $ b $  $ b - 1 $ \n\n$$ f(1, b) = b(b - 1) $$\n\n\n\n$$\n\\begin{align}\nf(a, b) & = \\sum_{i = 1}^{a} b(b - 1) \\\\\n& = ab(b - 1) \\\\\n\\end{align}\n$$\n\n\n\n $ m  n $ $ m - n + 1 $  $ n $ $ n - 1 $ \n\n![ \nLibreOffice Calc \n](uva-11538/cells.png)\n\n $ m - n + 1 $  $ n $ **** $ f(m - n + 1, n) $\n\n\n\n$$ \\sum_{i = 1}^{n - 1} f(1, i) $$\n\n$ O(n) $ \n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} f(1, i) \\\\\n= & \\sum_{i = 1}^{n - 1} i(i - 1) \\\\\n= & \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n\\end{align}\n$$\n\n\n\n$$\n\\begin{align}\n& \\sum_{i = 1}^{n - 1} i ^ 2 - \\sum_{i = 1}^{n - 1} i \\\\\n= & \\frac{(n - 1)n(2n - 1)}{6} - \\frac{n(n - 1)}{2} \\\\\n= & \\frac{n(n - 1)(2n - 4)}{6} \\\\\n= & \\frac{n(n - 1)(n - 2)}{3} \\\\\n\\end{align}\n$$\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 5000;\nconst int MAXN = 1000000;\n\ninline long long f(long long a, long long b) {\n\treturn a * (b - 1) * b;\n}\n\ninline long long g(long long n, long long m) {\n\t// m >= n\n\tif (m < n) std::swap(m, n);\n\tunsigned long long x = ((n - 1) * n * (n - 2)) / 3;\n\treturn f(m - n + 1, n) + x * 2;\n}\n\nint main() {\n\tint n, m;\n\twhile (~scanf(\"%d %d\", &n, &m), !(n == 0 && m == 0)) {\n\t\tprintf(\"%llu\\n\", f(n, m) + f(m, n) + g(n, m) * 2);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11538","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bvk0041c2xl9qn1uwdf"},{"title":"UVa 11375Matches - ","date":"2016-03-13T03:07:45.000Z","_content":"\n $ N $ \n\n<!-- more -->\n\n### \n[UVa 11375](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2370)\n\n### \n 0  $ f(i) $  $ i $  $ c(x) $  x \n\n 1 ~ 9 \n\n $ f(i) $  $ f(i + c(x)) $$ 0 \\leq x \\leq 9,i + c(x) \\leq 2000 $ $ f(i) $  $ x $ \n\n $ s(n) = \\sum\\limits_{i = 2}^{n}f(i) $  $ n \\geq 6 $  0\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXT = 100;\nconst int MAXN = 2000;\nconst int C[] = { 6, 2, 5, 5, 4, 5, 6, 3, 7, 6 };\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tconst std::vector<char> &v = x.v;\n\tfor (int i = v.size() - 1; i >= 0; i--) out << (char)(v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt r;\n\tr.v.reserve(std::max(a.v.size(), b.v.size()) + 1);\n\n\tbool flag = false;\n\tfor (int i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < a.v.size()) tmp += a.v[i];\n\t\tif (i < b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tr.v.push_back(tmp);\n\t}\n\tif (flag) r.v.push_back(1);\n\n\treturn r;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt f[MAXN + 1], sum[MAXN + 1];\n\ninline void makeTable() {\n\tfor (int i = 1; i < 10; i++) f[C[i]] += 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tif (i + C[j] <= MAXN) f[i + C[j]] += f[i];\n\t\t}\n\t}\n\n\tsum[2] = f[2];\n\tfor (int i = 3; i <= MAXN; i++) sum[i] = sum[i - 1] + f[i];\n}\n\nint main() {\n\tmakeTable();\n\n\tint n;\n\twhile (~scanf(\"%d\", &n)) {\n\t\tif (n == 0 || n == 1) puts(\"0\");\n\t\telse if (n < 6) std::cout << sum[n] << std::endl;\n\t\telse std::cout << sum[n] + 1 << std::endl;\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/uva-11375.md","raw":"title: UVa 11375Matches - \ncategories: OI\ntags: \n  - UVa\n  - \n  - \n  - \npermalink: uva-11375\ndate: 2016-03-13 11:07:45\n---\n\n $ N $ \n\n<!-- more -->\n\n### \n[UVa 11375](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2370)\n\n### \n 0  $ f(i) $  $ i $  $ c(x) $  x \n\n 1 ~ 9 \n\n $ f(i) $  $ f(i + c(x)) $$ 0 \\leq x \\leq 9,i + c(x) \\leq 2000 $ $ f(i) $  $ x $ \n\n $ s(n) = \\sum\\limits_{i = 2}^{n}f(i) $  $ n \\geq 6 $  0\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXT = 100;\nconst int MAXN = 2000;\nconst int C[] = { 6, 2, 5, 5, 4, 5, 6, 3, 7, 6 };\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tconst std::vector<char> &v = x.v;\n\tfor (int i = v.size() - 1; i >= 0; i--) out << (char)(v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt r;\n\tr.v.reserve(std::max(a.v.size(), b.v.size()) + 1);\n\n\tbool flag = false;\n\tfor (int i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < a.v.size()) tmp += a.v[i];\n\t\tif (i < b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tr.v.push_back(tmp);\n\t}\n\tif (flag) r.v.push_back(1);\n\n\treturn r;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt f[MAXN + 1], sum[MAXN + 1];\n\ninline void makeTable() {\n\tfor (int i = 1; i < 10; i++) f[C[i]] += 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tif (i + C[j] <= MAXN) f[i + C[j]] += f[i];\n\t\t}\n\t}\n\n\tsum[2] = f[2];\n\tfor (int i = 3; i <= MAXN; i++) sum[i] = sum[i - 1] + f[i];\n}\n\nint main() {\n\tmakeTable();\n\n\tint n;\n\twhile (~scanf(\"%d\", &n)) {\n\t\tif (n == 0 || n == 1) puts(\"0\");\n\t\telse if (n < 6) std::cout << sum[n] << std::endl;\n\t\telse std::cout << sum[n] + 1 << std::endl;\n\t}\n\treturn 0;\n}\n```\n","slug":"uva-11375","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bvx0047c2xlb4wcbgaw"},{"title":"UVa 11361Investigating Div-Sum Property -  DP","date":"2016-03-15T00:53:05.000Z","_content":"\n $ [a, b] $  $ x $ \n\n1. $ x $  $ k $ \n2. $ x $  $ k $ \n\n<!-- more -->\n\n### \n[UVa 11361](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2346)\n\n### \n $ {\\rm sum}(x) $  $ x $ $ g(x, m_1, m_2) $  $ [0, x] $  $ i $  $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $  $ i \\ {\\rm mod} \\ k = m_2 $ $ g(b, 0, 0) - g(a - 1, 0, 0) $\n\n $ f(n, m_1, m_2) $  $ n $  $ i $  $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $  $ i \\ {\\rm mod} \\ k = m_2 $ $ f $  1 ~ 9\n\n$ g $  $ x $  $ t $ $ [0, t) $  $ f $  $ x $\n\n$ k $  \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 99;\nconst int MAXX = 1 << 31;\nconst int MAXK = 9999;\nconst int MAXK_HEHE = 100;\n\nint k, pow10[12];\n\nlong long mem[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\nbool calced[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\n\ninline void makeTable() {\n\tpow10[0] = 1;\n\tfor (int i = 1; i <= 11; i++) pow10[i] = pow10[i - 1] * 10;\n}\n\ninline int length(int x) {\n\tint result = 0;\n\tdo result++; while (x /= 10);\n\treturn result;\n}\n\ninline int sum(int x) {\n\tint result = 0;\n\tdo result += x % 10; while (x /= 10);\n\treturn result;\n}\n\ninline int mod(int a, int b) {\n\treturn (a % b + b) % b;\n}\n\nint f(int x, int m1, int m2) {\n\tlong long &ans = mem[x][m1][m2];\n\tif (calced[x][m1][m2]) return ans;\n\tcalced[x][m1][m2] = true;\n\n\tans = 0;\n\tif (x == 1) {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tans += f(x - 1, mod(m1 - i, k), mod(m2 - i * pow10[x - 1] % k, k));\n\t\t}\n\t}\n\n\t// printf(\"f(%d, %d, %d) = %d\\n\", x, m1, m2, ans);\n\treturn ans;\n}\n\nint dp(int x, int m1, int m2) {\n\tint ans = 0;\n\tif (x < 10) {\n\t\tfor (int i = 0; i <= x; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tint n = length(x), first = x / pow10[n - 1];\n\t\tfor (int i = 0; i < first; i++) {\n\t\t\tans += f(n - 1, mod(m1 - i, k), mod(m2 - pow10[n - 1] * i, k));\n\t\t}\n\t\tans += dp(x % pow10[n - 1], mod(m1 - first, k), mod(m2 - pow10[n - 1] * first, k));\n\t}\n\n\treturn ans;\n}\n\n/*\ninline int solve(int x) {\n\tint n = length(x), left = 0;\n\tint ans = 0;\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tint curr = (x % pow10[i + 1]) / pow10[i];\n\t\t// printf(\"curr = %d\\n\", curr);\n\t\tfor (int j = 0; j < curr; j++) {\n\t\t\tint t = left * 10 + j;\n\t\t\t// printf(\"sum(t) = %d; %d\\n\", sum(t), t * pow10[i - 1]);\n\t\t\tans += f(i, mod(k - sum(t), k), mod(t * pow10[i] % k, k));\n\t\t}\n\t\tleft = left * 10 + curr;\n\t}\n\n\tfor (int i = 0; i <= x % 10; i++) {\n\t\tif ((x - i) % k == 0 && sum(x - i) % k == 0) ans++;\n\t}\n\n\treturn ans;\n}\n*/\n\ninline void cleanUp() {\n\tmemset(mem, 0, sizeof(mem));\n\tmemset(calced, 0, sizeof(calced));\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d %d\", &a, &b, &k);\n\t\tif (k >= 100) puts(\"0\"); // hehe\n\t\telse printf(\"%d\\n\", dp(b, 0, 0) - dp(a - 1, 0, 0));\n\t\tcleanUp();\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11361.md","raw":"title: UVa 11361Investigating Div-Sum Property -  DP\ncategories: OI\ntags: \n  - UVa\n  - \n  - \n  - DP\n  -  DP\npermalink: uva-11361\ndate: 2016-03-15 08:53:05\n---\n\n $ [a, b] $  $ x $ \n\n1. $ x $  $ k $ \n2. $ x $  $ k $ \n\n<!-- more -->\n\n### \n[UVa 11361](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2346)\n\n### \n $ {\\rm sum}(x) $  $ x $ $ g(x, m_1, m_2) $  $ [0, x] $  $ i $  $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $  $ i \\ {\\rm mod} \\ k = m_2 $ $ g(b, 0, 0) - g(a - 1, 0, 0) $\n\n $ f(n, m_1, m_2) $  $ n $  $ i $  $ {\\rm sum}(i) \\ {\\rm mod} \\ k = m_1 $  $ i \\ {\\rm mod} \\ k = m_2 $ $ f $  1 ~ 9\n\n$ g $  $ x $  $ t $ $ [0, t) $  $ f $  $ x $\n\n$ k $  \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 99;\nconst int MAXX = 1 << 31;\nconst int MAXK = 9999;\nconst int MAXK_HEHE = 100;\n\nint k, pow10[12];\n\nlong long mem[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\nbool calced[11][MAXK_HEHE + 1][MAXK_HEHE + 1];\n\ninline void makeTable() {\n\tpow10[0] = 1;\n\tfor (int i = 1; i <= 11; i++) pow10[i] = pow10[i - 1] * 10;\n}\n\ninline int length(int x) {\n\tint result = 0;\n\tdo result++; while (x /= 10);\n\treturn result;\n}\n\ninline int sum(int x) {\n\tint result = 0;\n\tdo result += x % 10; while (x /= 10);\n\treturn result;\n}\n\ninline int mod(int a, int b) {\n\treturn (a % b + b) % b;\n}\n\nint f(int x, int m1, int m2) {\n\tlong long &ans = mem[x][m1][m2];\n\tif (calced[x][m1][m2]) return ans;\n\tcalced[x][m1][m2] = true;\n\n\tans = 0;\n\tif (x == 1) {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tfor (int i = 0; i <= 9; i++) {\n\t\t\tans += f(x - 1, mod(m1 - i, k), mod(m2 - i * pow10[x - 1] % k, k));\n\t\t}\n\t}\n\n\t// printf(\"f(%d, %d, %d) = %d\\n\", x, m1, m2, ans);\n\treturn ans;\n}\n\nint dp(int x, int m1, int m2) {\n\tint ans = 0;\n\tif (x < 10) {\n\t\tfor (int i = 0; i <= x; i++) {\n\t\t\tif (i % k == m1 && i % k == m2) ans++;\n\t\t}\n\t} else {\n\t\tint n = length(x), first = x / pow10[n - 1];\n\t\tfor (int i = 0; i < first; i++) {\n\t\t\tans += f(n - 1, mod(m1 - i, k), mod(m2 - pow10[n - 1] * i, k));\n\t\t}\n\t\tans += dp(x % pow10[n - 1], mod(m1 - first, k), mod(m2 - pow10[n - 1] * first, k));\n\t}\n\n\treturn ans;\n}\n\n/*\ninline int solve(int x) {\n\tint n = length(x), left = 0;\n\tint ans = 0;\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tint curr = (x % pow10[i + 1]) / pow10[i];\n\t\t// printf(\"curr = %d\\n\", curr);\n\t\tfor (int j = 0; j < curr; j++) {\n\t\t\tint t = left * 10 + j;\n\t\t\t// printf(\"sum(t) = %d; %d\\n\", sum(t), t * pow10[i - 1]);\n\t\t\tans += f(i, mod(k - sum(t), k), mod(t * pow10[i] % k, k));\n\t\t}\n\t\tleft = left * 10 + curr;\n\t}\n\n\tfor (int i = 0; i <= x % 10; i++) {\n\t\tif ((x - i) % k == 0 && sum(x - i) % k == 0) ans++;\n\t}\n\n\treturn ans;\n}\n*/\n\ninline void cleanUp() {\n\tmemset(mem, 0, sizeof(mem));\n\tmemset(calced, 0, sizeof(calced));\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d %d\", &a, &b, &k);\n\t\tif (k >= 100) puts(\"0\"); // hehe\n\t\telse printf(\"%d\\n\", dp(b, 0, 0) - dp(a - 1, 0, 0));\n\t\tcleanUp();\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11361","published":1,"updated":"2016-10-24T23:28:44.619Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bw3004fc2xlhnehj6fi"},{"title":"UVa 11174Stand in a Line -  + ","date":"2016-03-13T09:20:34.000Z","_content":"\n $ N $$ N \\leq 40000 $\n\n<!-- more -->\n\n### \n[UVa 11174](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2115)\n\n### \n\n\n $ f(i) $  $ i $  $ s(i) $  $ i $ \n\n$ i $ \n\n$ i $ ********\n\n\n\n $ c(i) $  $ i $ \n\n$$ f(i) = \\prod\\limits_{j \\in c(i)}f(j) * \\frac{s(i) - 1}{\\prod\\limits_{j \\in c(i)}{s(i)}} $$\n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst long long MOD = 1000000007;\nconst int MAXN = 40000;\n\nstruct Tree {\n\tTree *firstChild, *parent, *next;\n\tint childCount, size;\n\tlong long ans;\n\n\tlong long solve();\n} trees[MAXN + 1];\n\nlong long fac[MAXN + 1], facInverse[MAXN + 1];\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nlong long inverse(long long num) {\n\tlong long g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn (x % MOD + MOD) % MOD;\n}\n\nvoid makeTable() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfacInverse[i] = inverse(fac[i]);\n\t}\n}\n\nvoid addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n\ttrees[parent].childCount++;\n}\n\nvoid cleanUp(int n) {\n\tmemset(trees, 0, sizeof(Tree) * (n + 1));\n}\n\nlong long Tree::solve() {\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tc->solve();\n\t\tsize += c->size;\n\t}\n\tsize++;\n\n\tans = fac[size - 1];\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tans = ans * c->ans % MOD;\n\t\tans = ans * facInverse[c->size] % MOD;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint child, parent;\n\t\t\tscanf(\"%d %d\", &child, &parent);\n\n\t\t\taddRelation(child, parent);\n\t\t}\n\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (trees[i].parent == NULL) addRelation(i, 0);\n\t\t}\n\n\t\tprintf(\"%lld\\n\", trees[0].solve());\n\t\tcleanUp(n);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11174.md","raw":"title: UVa 11174Stand in a Line -  + \ncategories: OI\ntags: \n  - UVa\n  - \n  - \n  - \n  - \n  - \n  - \npermalink: uva-11174\ndate: 2016-03-13 17:20:34\n---\n\n $ N $$ N \\leq 40000 $\n\n<!-- more -->\n\n### \n[UVa 11174](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2115)\n\n### \n\n\n $ f(i) $  $ i $  $ s(i) $  $ i $ \n\n$ i $ \n\n$ i $ ********\n\n\n\n $ c(i) $  $ i $ \n\n$$ f(i) = \\prod\\limits_{j \\in c(i)}f(j) * \\frac{s(i) - 1}{\\prod\\limits_{j \\in c(i)}{s(i)}} $$\n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst long long MOD = 1000000007;\nconst int MAXN = 40000;\n\nstruct Tree {\n\tTree *firstChild, *parent, *next;\n\tint childCount, size;\n\tlong long ans;\n\n\tlong long solve();\n} trees[MAXN + 1];\n\nlong long fac[MAXN + 1], facInverse[MAXN + 1];\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nlong long inverse(long long num) {\n\tlong long g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn (x % MOD + MOD) % MOD;\n}\n\nvoid makeTable() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tfacInverse[i] = inverse(fac[i]);\n\t}\n}\n\nvoid addRelation(int child, int parent) {\n\ttrees[child].parent = &trees[parent];\n\ttrees[child].next = trees[parent].firstChild;\n\ttrees[parent].firstChild = &trees[child];\n\ttrees[parent].childCount++;\n}\n\nvoid cleanUp(int n) {\n\tmemset(trees, 0, sizeof(Tree) * (n + 1));\n}\n\nlong long Tree::solve() {\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tc->solve();\n\t\tsize += c->size;\n\t}\n\tsize++;\n\n\tans = fac[size - 1];\n\tfor (Tree *c = firstChild; c; c = c->next) {\n\t\tans = ans * c->ans % MOD;\n\t\tans = ans * facInverse[c->size] % MOD;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor (int i = 0; i < t; i++) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint child, parent;\n\t\t\tscanf(\"%d %d\", &child, &parent);\n\n\t\t\taddRelation(child, parent);\n\t\t}\n\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (trees[i].parent == NULL) addRelation(i, 0);\n\t\t}\n\n\t\tprintf(\"%lld\\n\", trees[0].solve());\n\t\tcleanUp(n);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11174","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bw7004nc2xlooynpv96"},{"title":"UVa 11137Ingenuous Cubrency -  /  DP","date":"2016-03-13T03:56:43.000Z","_content":"\n $ N $$ N \\leq 1000 $ $ N $ \n\n<!-- more -->\n\n### \n[UVa 11137](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2078)\n\n### \n $ f(i, j) $  $ i $  $ j $  i  j $ i^3 $  $ x $  $ j + xi^3 \\leq 1000 $ $ f(i - 1, j) $  $ f(i, j + xi^3) $ $ f(21, n) $ \n\n 1000 \n\n\n\n### \n#### \n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXI][MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int j = 0; j <= MAXN; j++) {\n\t\t\tfor (int x = 0, tmp; (tmp = j + x * cube(i)) <= MAXN; x++) f[i][tmp] += f[i - 1][j];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[MAXI][n]);\n\t}\n\treturn 0;\n}\n```\n\n#### \n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int c = cube(i), j = c; j <= MAXN; j++) {\n\t\t\tf[j] += f[j - c];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[n]);\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/uva-11137.md","raw":"title: UVa 11137Ingenuous Cubrency -  /  DP\ncategories: OI\ntags: \n  - UVa\n  - \n  - \n  - DP\n  -  DP\npermalink: uva-11137\ndate: 2016-03-13 11:56:43\n---\n\n $ N $$ N \\leq 1000 $ $ N $ \n\n<!-- more -->\n\n### \n[UVa 11137](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=&problem=2078)\n\n### \n $ f(i, j) $  $ i $  $ j $  i  j $ i^3 $  $ x $  $ j + xi^3 \\leq 1000 $ $ f(i - 1, j) $  $ f(i, j + xi^3) $ $ f(21, n) $ \n\n 1000 \n\n\n\n### \n#### \n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXI][MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int j = 0; j <= MAXN; j++) {\n\t\t\tfor (int x = 0, tmp; (tmp = j + x * cube(i)) <= MAXN; x++) f[i][tmp] += f[i - 1][j];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[MAXI][n]);\n\t}\n\treturn 0;\n}\n```\n\n#### \n```cpp\n#include <cstdio>\n\nconst int MAXN = 10000;\nconst int MAXI = 21;\n\nunsigned long long f[MAXN + 1];\n\ninline int cube(int x) {\n\treturn x * x * x;\n}\n\ninline void makeTable() {\n\tf[0] = 1;\n\tfor (int i = 1; i <= MAXI; i++) {\n\t\tfor (int c = cube(i), j = c; j <= MAXN; j++) {\n\t\t\tf[j] += f[j - c];\n\t\t}\n\t}\n}\n\nint main() {\n\tmakeTable();\n\n\tfor (int n; ~scanf(\"%d\", &n); ) {\n\t\tprintf(\"%llu\\n\", f[n]);\n\t}\n\treturn 0;\n}\n```\n","slug":"uva-11137","published":1,"updated":"2016-10-24T23:28:29.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bwd004zc2xlezvta4ib"},{"title":"UVa 11021Tribles - ","date":"2016-05-31T12:05:00.000Z","_content":"\n $ k $  Tribles Trible  Trible  $ p_i $  $ i $  Tribles $ m $  Tribles \n\n<!-- more -->\n\n### \n[UVa 11021](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=481&page=show_problem&problem=1962)  \n[COGS 1487](http://cogs.top/cogs/problem/problem.php?pid=1487)\n\n### \n $ f(i) $  Trible  $ i $  $ x $  Trible  $ i $  $ f(i) ^ x $\n\n Trible  $ n $  Tribles  $ i - 1 $ \n\n $ f(0) = 1 $\n\n$$ f(i) = \\sum\\limits_{j = 0} ^ {n - 1} f(i - 1) ^ j \\times p(j) $$\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXK = 1000;\nconst int MAXM = 1000;\n\nint main() {\n\tint t, n, k, m;\n\tscanf(\"%d\", &t);\n\tfor (int i = 1; i <= t; i++) {\n\t\tscanf(\"%d %d %d\", &n, &k, &m);\n\t\tstatic double p[MAXN], f[MAXK + 1];\n\t\tfor (int i = 0; i < n; i++) scanf(\"%lf\", &p[i]);\n\t\tstd::fill(f, f + m + 1, 0);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tf[i] += p[j] * pow(f[i - 1], j);\n\t\t\t}\n\t\t}\n\t\tprintf(\"Case #%d: %.7lf\\n\", i, pow(f[m], k));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/uva-11021.md","raw":"title: UVa 11021Tribles - \ncategories: OI\ntags: \n  - UVa\n  - COGS\n  - DP\n  - \n  - \npermalink: uva-11021\ndate: 2016-05-31 20:05:00\n---\n\n $ k $  Tribles Trible  Trible  $ p_i $  $ i $  Tribles $ m $  Tribles \n\n<!-- more -->\n\n### \n[UVa 11021](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=481&page=show_problem&problem=1962)  \n[COGS 1487](http://cogs.top/cogs/problem/problem.php?pid=1487)\n\n### \n $ f(i) $  Trible  $ i $  $ x $  Trible  $ i $  $ f(i) ^ x $\n\n Trible  $ n $  Tribles  $ i - 1 $ \n\n $ f(0) = 1 $\n\n$$ f(i) = \\sum\\limits_{j = 0} ^ {n - 1} f(i - 1) ^ j \\times p(j) $$\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXK = 1000;\nconst int MAXM = 1000;\n\nint main() {\n\tint t, n, k, m;\n\tscanf(\"%d\", &t);\n\tfor (int i = 1; i <= t; i++) {\n\t\tscanf(\"%d %d %d\", &n, &k, &m);\n\t\tstatic double p[MAXN], f[MAXK + 1];\n\t\tfor (int i = 0; i < n; i++) scanf(\"%lf\", &p[i]);\n\t\tstd::fill(f, f + m + 1, 0);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tf[i] += p[j] * pow(f[i - 1], j);\n\t\t\t}\n\t\t}\n\t\tprintf(\"Case #%d: %.7lf\\n\", i, pow(f[m], k));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"uva-11021","published":1,"updated":"2016-10-24T23:28:54.763Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bwg0057c2xlf1vl8ful"},{"title":"UVa 10253Series-Parallel Networks -  + ","date":"2016-03-15T07:35:55.000Z","_content":"\n\n\n1. \n2.  $ G1 $  $ G2 $ \n3.  $ G1 $  $ G2 $  $ G1 $  $ G2 $ \n\n $ N $ \n\n<!-- more -->\n\n### \n[UVa 10253](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1194)\n\n### \n\n\n $ N $  $ f(n) $    $ n $ ****\n\n $ k $  $ i $ $ k $  $ f(i) $  $ k $  $ \\binom{f(i) + k - 1}{k} $\n\n $ f(n) * 2 $ $ n = 1 $  $ 1 $\n\n### \n```c++\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 30;\n\nlong long solve(int n);\nvoid search(std::vector<int> &v, int t, int r);\n\nlong long C(long long n, long long m) {\n\tlong long result = 1;\n\tfor (int k = 1; k <= m; k++) {\n\t\tresult = result * (n - k + 1) / k;\n\t}\n\treturn result;\n}\n\nlong long process(std::vector<int> &v) {\n\tlong long ans = 1;\n\tint count = 0, last = 0;\n\tfor (int i = 0; i < (int)v.size(); i++) {\n\t\tif (last != v[i] && last != 0) {\n\t\t\tans *= C(solve(last) + count - 1, count);\n\t\t\tcount = 1;\n\t\t} else {\n\t\t\tcount++;\n\t\t}\n\n\t\tlast = v[i];\n\t}\n\n\tans *= C(solve(last) + count - 1, count);\n\n\t// printf(\"process = %lld\\n\", ans);\n\treturn ans;\n}\n\nlong long divide(std::vector<int> &v, int r, int t = 1) {\n\tif (r == 0) {\n\t\tif (v.size() == 1) return 0;\n\t\t// for (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) printf(\"%d \", *p);\n\t\t// putchar('\\n');\n\t\t// return 0;\n\t\treturn process(v);\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = t; i <= r; i++) {\n\t\tv.push_back(i);\n\t\tans += divide(v, r - i, i);\n\t\tv.pop_back();\n\t}\n\n\treturn ans;\n}\n\nlong long solve(int n) {\n\tstatic long long mem[MAXN];\n\tstatic bool calced[MAXN];\n\tlong long &ans = mem[n - 1];\n\t\n\tif (calced[n - 1]) return ans;\n\tcalced[n - 1] = true;\n\n\tif (n == 1) return ans = 1;\n\n\tstd::vector<int> v;\n\tans = divide(v, n);\n\n\t// printf(\"f(%d) = %lld\\n\", n, ans);\n\treturn ans;\n}\n\nint main() {\n\tfor (int n; ~scanf(\"%d\", &n) && n != 0; printf(\"%lld\\n\", n == 1 ? 1 : solve(n) * 2));\n\treturn 0;\n}\n```\n","source":"_posts/uva-10253.md","raw":"title: UVa 10253Series-Parallel Networks -  + \ncategories: OI\ntags: \n  - UVa\n  - \n  - \n  - \n  - \n  - \n  - \npermalink: uva-10253\ndate: 2016-03-15 15:35:55\n---\n\n\n\n1. \n2.  $ G1 $  $ G2 $ \n3.  $ G1 $  $ G2 $  $ G1 $  $ G2 $ \n\n $ N $ \n\n<!-- more -->\n\n### \n[UVa 10253](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1194)\n\n### \n\n\n $ N $  $ f(n) $    $ n $ ****\n\n $ k $  $ i $ $ k $  $ f(i) $  $ k $  $ \\binom{f(i) + k - 1}{k} $\n\n $ f(n) * 2 $ $ n = 1 $  $ 1 $\n\n### \n```c++\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 30;\n\nlong long solve(int n);\nvoid search(std::vector<int> &v, int t, int r);\n\nlong long C(long long n, long long m) {\n\tlong long result = 1;\n\tfor (int k = 1; k <= m; k++) {\n\t\tresult = result * (n - k + 1) / k;\n\t}\n\treturn result;\n}\n\nlong long process(std::vector<int> &v) {\n\tlong long ans = 1;\n\tint count = 0, last = 0;\n\tfor (int i = 0; i < (int)v.size(); i++) {\n\t\tif (last != v[i] && last != 0) {\n\t\t\tans *= C(solve(last) + count - 1, count);\n\t\t\tcount = 1;\n\t\t} else {\n\t\t\tcount++;\n\t\t}\n\n\t\tlast = v[i];\n\t}\n\n\tans *= C(solve(last) + count - 1, count);\n\n\t// printf(\"process = %lld\\n\", ans);\n\treturn ans;\n}\n\nlong long divide(std::vector<int> &v, int r, int t = 1) {\n\tif (r == 0) {\n\t\tif (v.size() == 1) return 0;\n\t\t// for (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) printf(\"%d \", *p);\n\t\t// putchar('\\n');\n\t\t// return 0;\n\t\treturn process(v);\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = t; i <= r; i++) {\n\t\tv.push_back(i);\n\t\tans += divide(v, r - i, i);\n\t\tv.pop_back();\n\t}\n\n\treturn ans;\n}\n\nlong long solve(int n) {\n\tstatic long long mem[MAXN];\n\tstatic bool calced[MAXN];\n\tlong long &ans = mem[n - 1];\n\t\n\tif (calced[n - 1]) return ans;\n\tcalced[n - 1] = true;\n\n\tif (n == 1) return ans = 1;\n\n\tstd::vector<int> v;\n\tans = divide(v, n);\n\n\t// printf(\"f(%d) = %lld\\n\", n, ans);\n\treturn ans;\n}\n\nint main() {\n\tfor (int n; ~scanf(\"%d\", &n) && n != 0; printf(\"%lld\\n\", n == 1 ? 1 : solve(n) * 2));\n\treturn 0;\n}\n```\n","slug":"uva-10253","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bwl005fc2xl4445crj9"},{"title":"Tyvj 3317 -  DP","id":"18","updated":"2016-01-19T13:05:08.000Z","date":"2016-01-11T21:29:30.000Z","_content":"\nn2  n  10000\n\n$$\\cases{0< XL1 & C1 \\\\ L1< XL2 & C2 \\\\ L2< XL3 & C3}$$\n\nL1L2L3C1C2C3($1  L1 < L2 < L3  10^9$, $1  C1 < C2 < C3  10^9$) L3\n\n\n\n\n\n<!-- more -->\n\n### \n[Tyvj 3317](http://tyvj.cn/p/3317)  \n[CodeVS 1349](http://codevs.cn/problem/1349/)\n\n### \n $a[i]$ `0`  `i`  $f[i]$  `s`  `i` \n\n$$ f[i] = \\min\\{f[k]+cost(k,i),k{\\in}[s,i) \\ {\\rm and} \\ a[i]-a[k]L3\\} $$\n\n\n\n$$ f[s] = 0 $$\n\n### \n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10000;\n\nint n, a[MAXN], s, t;\nint L1, L2, L3, C1, C2, C3;\n\nint ans[MAXN];\nbool calced[MAXN];\n\ninline int cost(int s, int t) {\n\tint L = a[t - 1] - a[s - 1];\n\tif (L > L3) return INT_MAX;\n\telse if (L > L2) return C3;\n\telse if (L > L1) return C2;\n\telse return C1;\n}\n\nint search(int i) {\n\tif (i == s) return 0;\n\n\tif (!calced[i - 1]) {\n\t\tans[i - 1] = INT_MAX;\n\t\tfor (int k = s; k < i; k++) {\n\t\t\tif (cost(k, i) == INT_MAX) continue;\n\t\t\tans[i - 1] = std::min(ans[i - 1], search(k) + cost(k, i));\n\t\t}\n\t\tcalced[i - 1] = true;\n\t}\n\n\treturn ans[i - 1];\n}\n\nint main() {\n\tscanf(\"%d %d %d %d %d %d\", &L1, &L2, &L3, &C1, &C2, &C3);\n\tscanf(\"%d\\n%d %d\", &n, &s, &t);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tif (s > t) std::swap(s, t);\n\n\tprintf(\"%d\\n\", search(t));\n\n\treturn 0;\n}\n```\n","source":"_posts/tyvj-3317.md","raw":"title: Tyvj 3317 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - Tyvj\n  -  DP\npermalink: tyvj-3317\nid: 18\nupdated: '2016-01-19 21:05:08'\ndate: 2016-01-12 05:29:30\n---\n\nn2  n  10000\n\n$$\\cases{0< XL1 & C1 \\\\ L1< XL2 & C2 \\\\ L2< XL3 & C3}$$\n\nL1L2L3C1C2C3($1  L1 < L2 < L3  10^9$, $1  C1 < C2 < C3  10^9$) L3\n\n\n\n\n\n<!-- more -->\n\n### \n[Tyvj 3317](http://tyvj.cn/p/3317)  \n[CodeVS 1349](http://codevs.cn/problem/1349/)\n\n### \n $a[i]$ `0`  `i`  $f[i]$  `s`  `i` \n\n$$ f[i] = \\min\\{f[k]+cost(k,i),k{\\in}[s,i) \\ {\\rm and} \\ a[i]-a[k]L3\\} $$\n\n\n\n$$ f[s] = 0 $$\n\n### \n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10000;\n\nint n, a[MAXN], s, t;\nint L1, L2, L3, C1, C2, C3;\n\nint ans[MAXN];\nbool calced[MAXN];\n\ninline int cost(int s, int t) {\n\tint L = a[t - 1] - a[s - 1];\n\tif (L > L3) return INT_MAX;\n\telse if (L > L2) return C3;\n\telse if (L > L1) return C2;\n\telse return C1;\n}\n\nint search(int i) {\n\tif (i == s) return 0;\n\n\tif (!calced[i - 1]) {\n\t\tans[i - 1] = INT_MAX;\n\t\tfor (int k = s; k < i; k++) {\n\t\t\tif (cost(k, i) == INT_MAX) continue;\n\t\t\tans[i - 1] = std::min(ans[i - 1], search(k) + cost(k, i));\n\t\t}\n\t\tcalced[i - 1] = true;\n\t}\n\n\treturn ans[i - 1];\n}\n\nint main() {\n\tscanf(\"%d %d %d %d %d %d\", &L1, &L2, &L3, &C1, &C2, &C3);\n\tscanf(\"%d\\n%d %d\", &n, &s, &t);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tif (s > t) std::swap(s, t);\n\n\tprintf(\"%d\\n\", search(t));\n\n\treturn 0;\n}\n```\n","slug":"tyvj-3317","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bws005rc2xlo2896nrc"},{"title":"TJOI2015 -  DP + ","date":"2016-10-07T23:39:00.000Z","_content":"\n $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 4000](http://www.lydsy.com/JudgeOnline/problem.php?id=4000)  \n[COGS 1979](http://cogs.pro/cogs/problem/problem.php?pid=1979)\n\n### \n\n\n $ f(i, j) $  $ i $  $ i $  $ j $ \n\n $ O(m ^ 3 \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 1000000;\nconst int MAXM = 6;\nconst int MAXSTATUS = 1 << 6;\n\nstruct Matrix {\n\tunsigned int a[MAXSTATUS][MAXSTATUS];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < MAXSTATUS; i++) a[i][i] = true;\n\t}\n\n\tunsigned int &operator()(const int i, const int j) { return a[i][j]; }\n\tconst unsigned int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXSTATUS; i++) for (int j = 0; j < MAXSTATUS; j++) for (int k = 0; k < MAXSTATUS; k++) res(i, j) += a(i, k) * b(k, j);\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\n#ifdef DBG\ninline void print(const int x, const int m) {\n\tfor (int i = 0; i < m; i++) putchar((x & (1 << i)) ? '1' : '0');\n\t// putchar('\\n');\n}\n#endif\n\nint m, w, pos;\n\ninline void apply(const bool *tpl, const int j, bool *target) {\n\tfor (int k = 0; k < w; k++) {\n\t\tif (j - pos + k >= 0 && j - pos + k < m && tpl[k]) target[j - pos + k] = true;\n\t}\n}\n\nint main() {\n\tfreopen(\"tjoi2015_board.in\", \"r\", stdin);\n\tfreopen(\"tjoi2015_board.out\", \"w\", stdout);\n\n\tint n;\n\tscanf(\"%d %d %d %d\", &n, &m, &w, &pos);\n\n\tstatic bool attack[3][MAXM];\n\tfor (int i = 0; i < 3; i++) for (int j = 0; j < w; j++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tattack[i][j] = x;\n\t}\n\tattack[1][pos] = false;\n\n\tstatic bool valid[MAXSTATUS];\n\tfor (int i = 0; i < (1 << m); i++) {\n\t\tstatic bool tmp[MAXM];\n\t\tfor (int k = 0; k < m; k++) tmp[k] = false;\n\t\tvalid[i] = true;\n\n\t\tfor (int j = 0; j < m; j++) if (i & (1 << j)) apply(attack[1], j, tmp);\n\n\t\tfor (int j = 0; j < m; j++) if (i & (1 << j) && tmp[j]) {\n\t\t\tvalid[i] = false;\n\t\t\tbreak;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(valid[i] ? \"valid: \" : \"invalid: \");\n\t\tprint(i, m);\n\t\tputchar('\\n');\n#endif\n\t}\n\n\tstatic bool near[MAXSTATUS][MAXSTATUS];\n\tfor (int i = 0; i < (1 << m); i++) for (int j = 0; j < (1 << m); j++) {\n\t\tif (!valid[i] || !valid[j]) {\n\t\t\tnear[i][j] = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnear[i][j] = true;\n\t\tstatic bool tmpA[MAXM], tmpB[MAXM];\n\t\tfor (int k = 0; k < m; k++) tmpA[k] = tmpB[k] = false;\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (!(i & (1 << k))) continue;\n\t\t\tapply(attack[2], k, tmpB);\n\t\t}\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (!(j & (1 << k))) continue;\n\t\t\tapply(attack[0], k, tmpA);\n\t\t}\n\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (((i & (1 << k)) && tmpA[k]) || ((j & (1 << k)) && tmpB[k])) {\n\t\t\t\tnear[i][j] = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(near[i][j] ? \"valid: \" : \"invalid: \");\n\t\tprint(i, m);\n\t\tputchar(' ');\n\t\tprint(j, m);\n\t\tputchar('\\n');\n\n\t\tif (valid[i] && valid[j]) printf(\"near[%d][%d] = %d\\n\", i, j, static_cast<int>(near[i][j]));\n#endif\n\t}\n\n#ifdef DBG\n\tstatic unsigned int f[MAXN + 1][MAXSTATUS];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\tif (!valid[j]) continue;\n\t\t\tfor (int k = 0; k < (1 << m); k++) {\n\t\t\t\tif (!valid[k]) continue;\n\t\t\t\tif (near[k][j]) f[i][j] += f[i - 1][k];\n\t\t\t}\n\n\t\t\tprintf(\"f(%d, [\", i);\n\t\t\tprint(j, m);\n\t\t\tprintf(\"] = %u\\n\", f[i][j]);\n\t\t}\n\t}\n\n\tunsigned int ansCheck = 0;\n\tfor (int i = 0; i < MAXSTATUS; i++) ansCheck += f[n][i];\n#endif\n\n\tMatrix shift(false);\n\tfor (int i = 0; i < (1 << m); i++) {\n\t\tif (valid[i]) {\n\t\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\t\tif (valid[j]) {\n\t\t\t\t\tif (near[j][i]) {\n\t\t\t\t\t\tshift(j, i) = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tMatrix init(false);\n\tinit(0, 0) = 1;\n\n#ifndef FORCE\n\tMatrix res = pow(shift, n) * init;\n#else\n\tMatrix res(true);\n\tfor (int i = 1; i <= n; i++) {\n\t\tres = res * shift;\n#ifdef DBG\n\t\tfor (int i = 0; i < MAXSTATUS; i++) for (int j = 0; j < MAXSTATUS; j++) printf(\"%d%c\", res(i, j), j == MAXSTATUS - 1 ? '\\n' : ' ');\n#endif\n\t}\n\tres = res * init;\n#endif\n\n\tunsigned int ans = 0;\n\tfor (int i = 0; i < MAXSTATUS; i++) ans += res(i, 0);\n\tprintf(\"%u\\n\", ans);\n\n#ifdef DBG\n\tprintf(\"ansCheck = %u\\n\", ansCheck);\n#endif\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/tjoi2015-chessboard.md","raw":"title: TJOI2015 -  DP + \ncategories: OI\ntags: \n  - BZOJ\n  - TJOI\n  -  DP\n  - \npermalink: tjoi2015-chessboard\ndate: 2016-10-08 07:39:00\n---\n\n $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 4000](http://www.lydsy.com/JudgeOnline/problem.php?id=4000)  \n[COGS 1979](http://cogs.pro/cogs/problem/problem.php?pid=1979)\n\n### \n\n\n $ f(i, j) $  $ i $  $ i $  $ j $ \n\n $ O(m ^ 3 \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 1000000;\nconst int MAXM = 6;\nconst int MAXSTATUS = 1 << 6;\n\nstruct Matrix {\n\tunsigned int a[MAXSTATUS][MAXSTATUS];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < MAXSTATUS; i++) a[i][i] = true;\n\t}\n\n\tunsigned int &operator()(const int i, const int j) { return a[i][j]; }\n\tconst unsigned int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXSTATUS; i++) for (int j = 0; j < MAXSTATUS; j++) for (int k = 0; k < MAXSTATUS; k++) res(i, j) += a(i, k) * b(k, j);\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\n#ifdef DBG\ninline void print(const int x, const int m) {\n\tfor (int i = 0; i < m; i++) putchar((x & (1 << i)) ? '1' : '0');\n\t// putchar('\\n');\n}\n#endif\n\nint m, w, pos;\n\ninline void apply(const bool *tpl, const int j, bool *target) {\n\tfor (int k = 0; k < w; k++) {\n\t\tif (j - pos + k >= 0 && j - pos + k < m && tpl[k]) target[j - pos + k] = true;\n\t}\n}\n\nint main() {\n\tfreopen(\"tjoi2015_board.in\", \"r\", stdin);\n\tfreopen(\"tjoi2015_board.out\", \"w\", stdout);\n\n\tint n;\n\tscanf(\"%d %d %d %d\", &n, &m, &w, &pos);\n\n\tstatic bool attack[3][MAXM];\n\tfor (int i = 0; i < 3; i++) for (int j = 0; j < w; j++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tattack[i][j] = x;\n\t}\n\tattack[1][pos] = false;\n\n\tstatic bool valid[MAXSTATUS];\n\tfor (int i = 0; i < (1 << m); i++) {\n\t\tstatic bool tmp[MAXM];\n\t\tfor (int k = 0; k < m; k++) tmp[k] = false;\n\t\tvalid[i] = true;\n\n\t\tfor (int j = 0; j < m; j++) if (i & (1 << j)) apply(attack[1], j, tmp);\n\n\t\tfor (int j = 0; j < m; j++) if (i & (1 << j) && tmp[j]) {\n\t\t\tvalid[i] = false;\n\t\t\tbreak;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(valid[i] ? \"valid: \" : \"invalid: \");\n\t\tprint(i, m);\n\t\tputchar('\\n');\n#endif\n\t}\n\n\tstatic bool near[MAXSTATUS][MAXSTATUS];\n\tfor (int i = 0; i < (1 << m); i++) for (int j = 0; j < (1 << m); j++) {\n\t\tif (!valid[i] || !valid[j]) {\n\t\t\tnear[i][j] = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnear[i][j] = true;\n\t\tstatic bool tmpA[MAXM], tmpB[MAXM];\n\t\tfor (int k = 0; k < m; k++) tmpA[k] = tmpB[k] = false;\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (!(i & (1 << k))) continue;\n\t\t\tapply(attack[2], k, tmpB);\n\t\t}\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (!(j & (1 << k))) continue;\n\t\t\tapply(attack[0], k, tmpA);\n\t\t}\n\n\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (((i & (1 << k)) && tmpA[k]) || ((j & (1 << k)) && tmpB[k])) {\n\t\t\t\tnear[i][j] = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(near[i][j] ? \"valid: \" : \"invalid: \");\n\t\tprint(i, m);\n\t\tputchar(' ');\n\t\tprint(j, m);\n\t\tputchar('\\n');\n\n\t\tif (valid[i] && valid[j]) printf(\"near[%d][%d] = %d\\n\", i, j, static_cast<int>(near[i][j]));\n#endif\n\t}\n\n#ifdef DBG\n\tstatic unsigned int f[MAXN + 1][MAXSTATUS];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\tif (!valid[j]) continue;\n\t\t\tfor (int k = 0; k < (1 << m); k++) {\n\t\t\t\tif (!valid[k]) continue;\n\t\t\t\tif (near[k][j]) f[i][j] += f[i - 1][k];\n\t\t\t}\n\n\t\t\tprintf(\"f(%d, [\", i);\n\t\t\tprint(j, m);\n\t\t\tprintf(\"] = %u\\n\", f[i][j]);\n\t\t}\n\t}\n\n\tunsigned int ansCheck = 0;\n\tfor (int i = 0; i < MAXSTATUS; i++) ansCheck += f[n][i];\n#endif\n\n\tMatrix shift(false);\n\tfor (int i = 0; i < (1 << m); i++) {\n\t\tif (valid[i]) {\n\t\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\t\tif (valid[j]) {\n\t\t\t\t\tif (near[j][i]) {\n\t\t\t\t\t\tshift(j, i) = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tMatrix init(false);\n\tinit(0, 0) = 1;\n\n#ifndef FORCE\n\tMatrix res = pow(shift, n) * init;\n#else\n\tMatrix res(true);\n\tfor (int i = 1; i <= n; i++) {\n\t\tres = res * shift;\n#ifdef DBG\n\t\tfor (int i = 0; i < MAXSTATUS; i++) for (int j = 0; j < MAXSTATUS; j++) printf(\"%d%c\", res(i, j), j == MAXSTATUS - 1 ? '\\n' : ' ');\n#endif\n\t}\n\tres = res * init;\n#endif\n\n\tunsigned int ans = 0;\n\tfor (int i = 0; i < MAXSTATUS; i++) ans += res(i, 0);\n\tprintf(\"%u\\n\", ans);\n\n#ifdef DBG\n\tprintf(\"ansCheck = %u\\n\", ansCheck);\n#endif\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"tjoi2015-chessboard","published":1,"updated":"2016-10-24T23:29:16.791Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bwx0060c2xlw6q2naa2"},{"title":"TJOI2013 - AC ","date":"2016-09-11T23:07:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 3172](http://www.lydsy.com/JudgeOnline/problem.php?id=3172)\n\n### \nAC  AC  AC \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int MAXN = 1e6 + 200;\nconst int CHARSET_SIZE = 'z' - '`' + 1;\nconst char BASE_CHAR = '`';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *next, *fail;\n\t\tbool isWord;\n#ifdef DBG\n\t\tchar ch;\n#endif\n\t\tint ans;\n\n\t\tNode(const bool isWord = false) : next(NULL), fail(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply() {\n\t\t\tans++;\n\t\t\tif (next) next->apply();\n\t\t}\n\t} *root;\n\n\tTrie() : root(new Node()) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n#ifdef DBG\n\t\tv = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = &(*v)->c[*p];\n\t\t\t(*v)->ch = *p + 'a';\n\t\t}\n#endif\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root;\n\t\troot->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\twhile (v != root && !v->c[*p]) v = v->fail;\n\t\t\tv = v->c[*p] ? v->c[*p] : root;\n\t\t\tif (v->isWord) v->apply();\n\t\t\telse if (v->next) v->next->apply();\n\t\t}\n\t}\n} t;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic char s[MAXN + 1];\n\tchar *p = s;\n\n\tstatic Trie::Node *node[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tint len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR, *p++ = s[i];\n\t\t*p++ = 0;\n\t\tnode[i] = t.insert(s, s + len);\n\t}\n\n\t*--p = 0;\n\t// for (char *c = s; c != p; c++) putchar(*c + BASE_CHAR);\n\n\tt.build();\n\tt.exec(s, p);\n\n\tfor (int i = 0; i < n; i++) printf(\"%d\\n\", node[i]->ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/tjoi2013-word.md","raw":"title: TJOI2013 - AC \ncategories: OI\ntags: \n  - BZOJ\n  - TJOI\n  - \n  - AC \npermalink: tjoi2013-word\ndate: 2016-09-12 07:07:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 3172](http://www.lydsy.com/JudgeOnline/problem.php?id=3172)\n\n### \nAC  AC  AC \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int MAXN = 1e6 + 200;\nconst int CHARSET_SIZE = 'z' - '`' + 1;\nconst char BASE_CHAR = '`';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *next, *fail;\n\t\tbool isWord;\n#ifdef DBG\n\t\tchar ch;\n#endif\n\t\tint ans;\n\n\t\tNode(const bool isWord = false) : next(NULL), fail(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply() {\n\t\t\tans++;\n\t\t\tif (next) next->apply();\n\t\t}\n\t} *root;\n\n\tTrie() : root(new Node()) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n#ifdef DBG\n\t\tv = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = &(*v)->c[*p];\n\t\t\t(*v)->ch = *p + 'a';\n\t\t}\n#endif\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root;\n\t\troot->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\twhile (v != root && !v->c[*p]) v = v->fail;\n\t\t\tv = v->c[*p] ? v->c[*p] : root;\n\t\t\tif (v->isWord) v->apply();\n\t\t\telse if (v->next) v->next->apply();\n\t\t}\n\t}\n} t;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic char s[MAXN + 1];\n\tchar *p = s;\n\n\tstatic Trie::Node *node[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tint len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR, *p++ = s[i];\n\t\t*p++ = 0;\n\t\tnode[i] = t.insert(s, s + len);\n\t}\n\n\t*--p = 0;\n\t// for (char *c = s; c != p; c++) putchar(*c + BASE_CHAR);\n\n\tt.build();\n\tt.exec(s, p);\n\n\tfor (int i = 0; i < n; i++) printf(\"%d\\n\", node[i]->ans);\n\n\treturn 0;\n}\n```\n","slug":"tjoi2013-word","published":1,"updated":"2016-10-07T23:45:42.222Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bx10068c2xl0hniccz4"},{"title":"TJOI2013 -  + ","date":"2016-04-03T14:49:33.000Z","_content":"\n $ 1 $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 3173](http://www.lydsy.com/JudgeOnline/problem.php?id=3173)\n\n### \n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tT v;\n\t\tint s;\n\t\tbool b;\n\n\t\tNode(Node *p, Node **r, const T &v, bool b = false) : p(p), r(r), v(v), s(1), b(b) {}\n\n\t\t~Node() {\n\t\t\tif (c[L]) delete c[L];\n\t\t\tif (c[R]) delete c[R];\n\t\t}\n\n\t\tRelation relation() const {\n\t\t\treturn this == p->c[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\ts = (c[L] ? c[L]->s : 0) + (c[R] ? c[R]->s : 0) + 1;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *o = p;\n\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\t\t\tp = o->p;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tvoid splay(const Node *t = NULL) {\n\t\t\twhile (p != t) {\n\t\t\t\tif (p->p == t) rotate();\n\t\t\t\telse if (p->relation() == relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn c[L] ? c[L]->s : 0;\n\t\t}\n\t} *r;\n\n\tSplay() : r(NULL) {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\t~Splay() {\n\t\tdelete r;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &r, *p = NULL;\n\t\twhile (*v) p = *v, p->s++, v = &p->c[x];\n\t\t*v = new Node(p, &r, 0, true);\n\t}\n\n\tNode *select(int k) {\n\t\tNode *v = r;\n\t\tfor (int x = k + 1; x != v->rank() + 1; ) {\n\t\t\tif (x < v->rank() + 1) v = v->c[L];\n\t\t\telse x -= v->rank() + 1, v = v->c[R];\n\t\t}\n\t\treturn v;\n\t}\n\n\tvoid insert(int i, const T &v) {\n\t\tNode *a = select(i), *b = select(i + 1);\n\t\ta->splay(), b->splay(a);\n\t\tb->c[L] = new Node(b, &r, v), b->s++, b->s++;\n\t}\n\n\tvoid dfs(Node *v, T *a, int &i) {\n\t\tif (!v) return;\n\t\tdfs(v->c[L], a, i), v->b || (a[v->v - 1] = ++i), dfs(v->c[R], a, i);\n\t}\n\n\tvoid fetch(T *a) {\n\t\tint i = 0;\n\t\tdfs(r, a, i);\n\t}\n};\n\nint n, a[MAXN];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(const int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(const int i, const int v) {\n\t\tfor (int j = i; j <= n; j += lowbit(j)) a[j - 1] = std::max(a[j - 1], v);\n\t}\n\n\tint query(const int i) {\n\t\tint x = 0;\n\t\tfor (int j = i; j > 0; j -= lowbit(j)) x = std::max(x, a[j - 1]);\n\t\treturn x;\n\t}\n} b;\n\nSplay<int> s;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int x = 1, i; x <= n; x++) {\n\t\tscanf(\"%d\", &i), s.insert(i, x);\n\t}\n\n\ts.fetch(a);\n\n\tfor (int i = 0, l = 0; i < n; i++) {\n\t\tint t = b.query(a[i] - 1) + 1;\n\t\tb.update(a[i], t);\n\t\tprintf(\"%d\\n\", l = std::max(l, t));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/tjoi2013-lis.md","raw":"title: TJOI2013 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - TJOI\n  - \n  - Splay\n  - \npermalink: tjoi2013-lis\ndate: 2016-04-03 22:49:33\n---\n\n $ 1 $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 3173](http://www.lydsy.com/JudgeOnline/problem.php?id=3173)\n\n### \n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tT v;\n\t\tint s;\n\t\tbool b;\n\n\t\tNode(Node *p, Node **r, const T &v, bool b = false) : p(p), r(r), v(v), s(1), b(b) {}\n\n\t\t~Node() {\n\t\t\tif (c[L]) delete c[L];\n\t\t\tif (c[R]) delete c[R];\n\t\t}\n\n\t\tRelation relation() const {\n\t\t\treturn this == p->c[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\ts = (c[L] ? c[L]->s : 0) + (c[R] ? c[R]->s : 0) + 1;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *o = p;\n\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\t\t\tp = o->p;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tvoid splay(const Node *t = NULL) {\n\t\t\twhile (p != t) {\n\t\t\t\tif (p->p == t) rotate();\n\t\t\t\telse if (p->relation() == relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn c[L] ? c[L]->s : 0;\n\t\t}\n\t} *r;\n\n\tSplay() : r(NULL) {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\t~Splay() {\n\t\tdelete r;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &r, *p = NULL;\n\t\twhile (*v) p = *v, p->s++, v = &p->c[x];\n\t\t*v = new Node(p, &r, 0, true);\n\t}\n\n\tNode *select(int k) {\n\t\tNode *v = r;\n\t\tfor (int x = k + 1; x != v->rank() + 1; ) {\n\t\t\tif (x < v->rank() + 1) v = v->c[L];\n\t\t\telse x -= v->rank() + 1, v = v->c[R];\n\t\t}\n\t\treturn v;\n\t}\n\n\tvoid insert(int i, const T &v) {\n\t\tNode *a = select(i), *b = select(i + 1);\n\t\ta->splay(), b->splay(a);\n\t\tb->c[L] = new Node(b, &r, v), b->s++, b->s++;\n\t}\n\n\tvoid dfs(Node *v, T *a, int &i) {\n\t\tif (!v) return;\n\t\tdfs(v->c[L], a, i), v->b || (a[v->v - 1] = ++i), dfs(v->c[R], a, i);\n\t}\n\n\tvoid fetch(T *a) {\n\t\tint i = 0;\n\t\tdfs(r, a, i);\n\t}\n};\n\nint n, a[MAXN];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(const int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(const int i, const int v) {\n\t\tfor (int j = i; j <= n; j += lowbit(j)) a[j - 1] = std::max(a[j - 1], v);\n\t}\n\n\tint query(const int i) {\n\t\tint x = 0;\n\t\tfor (int j = i; j > 0; j -= lowbit(j)) x = std::max(x, a[j - 1]);\n\t\treturn x;\n\t}\n} b;\n\nSplay<int> s;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int x = 1, i; x <= n; x++) {\n\t\tscanf(\"%d\", &i), s.insert(i, x);\n\t}\n\n\ts.fetch(a);\n\n\tfor (int i = 0, l = 0; i < n; i++) {\n\t\tint t = b.query(a[i] - 1) + 1;\n\t\tb.update(a[i], t);\n\t\tprintf(\"%d\\n\", l = std::max(l, t));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"tjoi2013-lis","published":1,"updated":"2016-10-07T23:45:34.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bx5006gc2xlw3kpv4jw"},{"title":"Tarjan ","date":"2016-03-03T13:12:23.000Z","_content":"\n********************\n\nTarjan  $ O(n + m) $ \n\n<!-- more -->\n\n### \nTarjan  DFS\n\n\n\n$ {\\rm dfn}(u) $  $ u $ \n\n$ {\\rm low}(u) $  $ u $  $ u $  $ {\\rm dfn} $  $ {\\rm dfn} $\n\n### \n1.  DFS\n2.  $ {\\rm dfn} $  $ {\\rm low} $ \n3.  $ v $ \n4.  $ u $  $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $\n5.  $ u $  $ u $  DFS $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low(u)}) $\n6.  $ {\\rm low}(v) = {\\rm dfn}(v) $ $ v $ \n\n### \n $ v $  $ u $ \n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $$\n\n $ v $  $ u $  $ v $ \n\n $ u $  $ u $  DFS\n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low}(u)) $$\n\n $ u $  $ v $  $ {\\rm low}(u) $  $ v $  $ u $  $ v $ \n\n\n\n$$ {\\rm low}(v) = {\\rm dfn}(v) $$\n\n\n\n $ {\\rm low} $ $ {\\rm low} $ \n\n### \n DFS `s` Tarjan  `t`\n\n\n\n```cpp\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tConnected *connected;\n\tint dfn, low;\n\tbool inStack, visited, pushed;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n} connecteds[MAXN];\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n```\n","source":"_posts/tarjan-scc-notes.md","raw":"title: Tarjan \ncategories: OI\ntags: \n  - \n  - \n  - \n  - Tarjan\n  - \npermalink: tarjan-scc-notes\ndate: 2016-03-03 21:12:23\n---\n\n********************\n\nTarjan  $ O(n + m) $ \n\n<!-- more -->\n\n### \nTarjan  DFS\n\n\n\n$ {\\rm dfn}(u) $  $ u $ \n\n$ {\\rm low}(u) $  $ u $  $ u $  $ {\\rm dfn} $  $ {\\rm dfn} $\n\n### \n1.  DFS\n2.  $ {\\rm dfn} $  $ {\\rm low} $ \n3.  $ v $ \n4.  $ u $  $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $\n5.  $ u $  $ u $  DFS $ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low(u)}) $\n6.  $ {\\rm low}(v) = {\\rm dfn}(v) $ $ v $ \n\n### \n $ v $  $ u $ \n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm dfn}(u)) $$\n\n $ v $  $ u $  $ v $ \n\n $ u $  $ u $  DFS\n\n$$ {\\rm low}(v) = \\min({\\rm low}(v), {\\rm low}(u)) $$\n\n $ u $  $ v $  $ {\\rm low}(u) $  $ v $  $ u $  $ v $ \n\n\n\n$$ {\\rm low}(v) = {\\rm dfn}(v) $$\n\n\n\n $ {\\rm low} $ $ {\\rm low} $ \n\n### \n DFS `s` Tarjan  `t`\n\n\n\n```cpp\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tConnected *connected;\n\tint dfn, low;\n\tbool inStack, visited, pushed;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n} connecteds[MAXN];\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n```\n","slug":"tarjan-scc-notes","published":1,"updated":"2016-12-21T02:08:20.826Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bxb006qc2xl3n527i9r"},{"title":"Tarjan ","date":"2016-09-08T11:45:00.000Z","_content":"\n $ v $  $ v $ ****\n\n<!-- more -->\n\n### \n$ \\mathrm{dfn}(u) $  $ u $ \n\n$ \\mathrm{low}(u) $  $ u $  $ u $  $ \\mathrm{dfn} $  $ \\mathrm{dfn} $\n\n### \n Tarjan \n\n1.  DFS\n2.  $ \\mathrm{dfn} $  $ \\mathrm{low} $ \n3.  $ v $ \n4.  $ u $  $ \\mathrm{low}(v) = \\min(\\mathrm{low}(v), \\mathrm{dfn}(u)) $\n5.  $ u $  $ u $  DFS $ \\mathrm{low}(v) = \\min(\\mathrm{low}(v), \\mathrm{low(u)}) $\n6.  $ u $ $ v $ $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $ $ u $ \n7. \n\n### \n> \n\n\n\n>  $ u $ $ v $ $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $ $ u $ \n\n$ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $ $ v $  $ u $ \n\n### \nCodeVS 5524\n\n 2016  12  29 \n\n![zyz ](tarjan-cut-notes/zyz.png)\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 20000;\n\nstruct Node\n{\n\tstruct Edge *firstEdge;\n\tNode *fa;\n\tint dfn, low;\n\tbool vis, isCut;\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\ninline void addEdge(int s, int t)\n{\n\tN[s].firstEdge = new Edge(&N[s], &N[t]);\n\tN[t].firstEdge = new Edge(&N[t], &N[s]);\n}\n\ninline int tarjan(Node *v)\n{\n\tstatic int ts = 0;\n\tv->dfn = v->low = ++ts;\n\tv->vis = true;\n\n\tint res = 0, childCnt = 0;\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (!e->to->vis)\n\t\t{\n\t\t\te->to->fa = v;\n\t\t\tres += tarjan(e->to);\n\t\t\tv->low = std::min(v->low, e->to->low);\n\n\t\t\tif (v->fa)\n\t\t\t{\n\t\t\t\t//  v\n\t\t\t\tif (e->to->low >= v->dfn) v->isCut = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// \n\t\t\t\t// \n\t\t\t\tif (++childCnt == 2) v->isCut = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//  DFS \n\t\t\tv->low = std::min(v->low, e->to->dfn);\n\t\t}\n\t}\n\n\tif (v->isCut) res++;\n\n\treturn res;\n}\n\nint main()\n{\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (!N[i].vis) ans += tarjan(&N[i]);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (Edge *&e = N[i].firstEdge, *next; e; next = e->next, delete e, e = next);\n\t\tN[i].vis = N[i].isCut = false;\n\t\tN[i].dfn = N[i].low = 0;\n\t\tN[i].fa = NULL;\n\t}\n\n\treturn 0;\n}\n```\n\n\n\n```c++\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low;\n\tbool v, pushed, flag;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint ts = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\t\tstd::stack<Node *> s;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->low = v->dfn = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, s.push(e->t), e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != &N[i]) for (Edge *e = v->e; e; e = e->next) if (e->t->low >= v->dfn && e->t->p == v) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n                \n\t\t\t\tif (v->flag) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t\t\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) cnt++;\n\t\tN[i].flag = cnt >= 2;\n\t}\n\n\treturn cnt;\n}\n```\n","source":"_posts/tarjan-cut-notes.md","raw":"title: Tarjan \ncategories: OI\ntags: \n  - \n  - \n  - \n  - Tarjan\n  - \npermalink: tarjan-cut-notes\ndate: 2016-09-08 19:45:00\n---\n\n $ v $  $ v $ ****\n\n<!-- more -->\n\n### \n$ \\mathrm{dfn}(u) $  $ u $ \n\n$ \\mathrm{low}(u) $  $ u $  $ u $  $ \\mathrm{dfn} $  $ \\mathrm{dfn} $\n\n### \n Tarjan \n\n1.  DFS\n2.  $ \\mathrm{dfn} $  $ \\mathrm{low} $ \n3.  $ v $ \n4.  $ u $  $ \\mathrm{low}(v) = \\min(\\mathrm{low}(v), \\mathrm{dfn}(u)) $\n5.  $ u $  $ u $  DFS $ \\mathrm{low}(v) = \\min(\\mathrm{low}(v), \\mathrm{low(u)}) $\n6.  $ u $ $ v $ $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $ $ u $ \n7. \n\n### \n> \n\n\n\n>  $ u $ $ v $ $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $ $ u $ \n\n$ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $ $ v $  $ u $ \n\n### \nCodeVS 5524\n\n 2016  12  29 \n\n![zyz ](tarjan-cut-notes/zyz.png)\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 20000;\n\nstruct Node\n{\n\tstruct Edge *firstEdge;\n\tNode *fa;\n\tint dfn, low;\n\tbool vis, isCut;\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\ninline void addEdge(int s, int t)\n{\n\tN[s].firstEdge = new Edge(&N[s], &N[t]);\n\tN[t].firstEdge = new Edge(&N[t], &N[s]);\n}\n\ninline int tarjan(Node *v)\n{\n\tstatic int ts = 0;\n\tv->dfn = v->low = ++ts;\n\tv->vis = true;\n\n\tint res = 0, childCnt = 0;\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (!e->to->vis)\n\t\t{\n\t\t\te->to->fa = v;\n\t\t\tres += tarjan(e->to);\n\t\t\tv->low = std::min(v->low, e->to->low);\n\n\t\t\tif (v->fa)\n\t\t\t{\n\t\t\t\t//  v\n\t\t\t\tif (e->to->low >= v->dfn) v->isCut = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// \n\t\t\t\t// \n\t\t\t\tif (++childCnt == 2) v->isCut = true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//  DFS \n\t\t\tv->low = std::min(v->low, e->to->dfn);\n\t\t}\n\t}\n\n\tif (v->isCut) res++;\n\n\treturn res;\n}\n\nint main()\n{\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (!N[i].vis) ans += tarjan(&N[i]);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfor (Edge *&e = N[i].firstEdge, *next; e; next = e->next, delete e, e = next);\n\t\tN[i].vis = N[i].isCut = false;\n\t\tN[i].dfn = N[i].low = 0;\n\t\tN[i].fa = NULL;\n\t}\n\n\treturn 0;\n}\n```\n\n\n\n```c++\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low;\n\tbool v, pushed, flag;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint ts = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\t\tstd::stack<Node *> s;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->low = v->dfn = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, s.push(e->t), e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != &N[i]) for (Edge *e = v->e; e; e = e->next) if (e->t->low >= v->dfn && e->t->p == v) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n                \n\t\t\t\tif (v->flag) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t\t\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) cnt++;\n\t\tN[i].flag = cnt >= 2;\n\t}\n\n\treturn cnt;\n}\n```\n","slug":"tarjan-cut-notes","published":1,"updated":"2016-12-29T06:53:21.020Z","_id":"cix2l6bxg0071c2xlyuso9bu9","comments":1,"layout":"post","photos":[],"link":""},{"title":"","date":"2016-01-01T16:18:34.000Z","_content":"\n $x_i-x_j>=d$ \n\n<!-- more -->\n\n### \n\n\n `from``to` `$` \n\n```php\nif ($to > $from + w) {\n    $to = $from + w;\n}\n```\n\n\n\n```php\n$to - $from >= w\n```\n\n********\n\n****\n\n### \n $x_i-x_j>=d$ `j`  `i`  `d`\n\n $x_i-x_j>=d$ `-1` $x_j-x_i<=-d$ `i`  `j`  `-d`\n\n `dist`  `0` `dist`  `dist` \n\n Bellman-Ford  Bellman-Ford  `n - 1` ****\n\n Bellman-Ford  `n` ****\n\n### \n[CodeVS 4416](http://codevs.cn/problem/4416/) - FFF \n\n `n`  $x_i-x_j<=d$  $x_i-x_j>=d$  $x_1$  $x_n$  `-1` $x_1$  $x_n$  `-2`\n\n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 10000;\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tbool inQueue;\n\tint dist;\n\tint count;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nint n, m, k;\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].edges = new Edge(&nodes[from], &nodes[to], w);\n}\n\ninline bool bellmanFord() {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\t\tnode->inQueue = false;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->dist > node->dist + edge->w) {\n\t\t\t\tedge->to->dist = node->dist + edge->w;\n\n\t\t\t\tif (!edge->to->inQueue) {\n\t\t\t\t\tedge->to->inQueue = true;\n\t\t\t\t\tedge->to->count++;\n\t\t\t\t\tq.push(edge->to);\n\n\t\t\t\t\tif (edge->to->count > n) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].dist = INT_MAX;\n\t}\n\n\tnodes[0].dist = 0;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(a, b, d);\n\t\t// $b - $a <= d\n\t\t// $a + d >= $b\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(b, a, -d);\n\t\t// $b - $a >= d\n\t\t// $a - $b <= -d\n\t\t// $b + -d >= $a\n\t}\n\n\tif (!bellmanFord()) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tif (nodes[n - 1].dist == INT_MAX) {\n\t\t\tputs(\"-2\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", nodes[n - 1].dist);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/system-of-difference-constraints-notes.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - \npermalink: system-of-difference-constraints-notes\ndate: 2016-01-02 00:18:34\n---\n\n $x_i-x_j>=d$ \n\n<!-- more -->\n\n### \n\n\n `from``to` `$` \n\n```php\nif ($to > $from + w) {\n    $to = $from + w;\n}\n```\n\n\n\n```php\n$to - $from >= w\n```\n\n********\n\n****\n\n### \n $x_i-x_j>=d$ `j`  `i`  `d`\n\n $x_i-x_j>=d$ `-1` $x_j-x_i<=-d$ `i`  `j`  `-d`\n\n `dist`  `0` `dist`  `dist` \n\n Bellman-Ford  Bellman-Ford  `n - 1` ****\n\n Bellman-Ford  `n` ****\n\n### \n[CodeVS 4416](http://codevs.cn/problem/4416/) - FFF \n\n `n`  $x_i-x_j<=d$  $x_i-x_j>=d$  $x_1$  $x_n$  `-1` $x_1$  $x_n$  `-2`\n\n```C++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 10000;\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tbool inQueue;\n\tint dist;\n\tint count;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nint n, m, k;\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].edges = new Edge(&nodes[from], &nodes[to], w);\n}\n\ninline bool bellmanFord() {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[0]);\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\t\tnode->inQueue = false;\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->dist > node->dist + edge->w) {\n\t\t\t\tedge->to->dist = node->dist + edge->w;\n\n\t\t\t\tif (!edge->to->inQueue) {\n\t\t\t\t\tedge->to->inQueue = true;\n\t\t\t\t\tedge->to->count++;\n\t\t\t\t\tq.push(edge->to);\n\n\t\t\t\t\tif (edge->to->count > n) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].dist = INT_MAX;\n\t}\n\n\tnodes[0].dist = 0;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(a, b, d);\n\t\t// $b - $a <= d\n\t\t// $a + d >= $b\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint a, b, d;\n\t\tscanf(\"%d %d %d\", &a, &b, &d);\n\t\ta--, b--;\n\n\t\taddEdge(b, a, -d);\n\t\t// $b - $a >= d\n\t\t// $a - $b <= -d\n\t\t// $b + -d >= $a\n\t}\n\n\tif (!bellmanFord()) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tif (nodes[n - 1].dist == INT_MAX) {\n\t\t\tputs(\"-2\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", nodes[n - 1].dist);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"system-of-difference-constraints-notes","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bxj0079c2xlkqk26ysx"},{"title":"","date":"2016-04-12T11:29:14.000Z","_content":"\n OI   \n\n<!-- more -->\n\n### \n $ s $  $ 0 $  $ {\\rm length}(s) $\n\n$ {\\rm suffix}(i) $  $ s $  $ i $  $ s[i] $ ~ $ s[n - 1] $ \n\n  \n ASCII  ASCII   \n  \n\n\n****\n\n$ {\\rm SA}[] $  $ s $ $ {\\rm SA}[i] $  $ i $ \n\n$ {\\rm rank}[] $  $ {\\rm SA}[] $ $ {\\rm rank}[i] $  $ {\\rm suffix}(i) $  $ {\\rm rank}[{\\rm SA}[i]] = i $ $ i $  $ i $\n\n$ {\\rm height}[] $ Longest Common PrefixLCP\n\n$$\n{\\rm height}[i] =\n\\begin{cases}\n0 & i = 0 \\\\\n{\\rm LCP}({\\rm suffix}({\\rm SA}[i]), {\\rm suffix}({\\rm SA}[i - 1])) & i > 0 \\\\\n\\end{cases}\n$$\n\n $ {\\rm height}[i] $  $ x $ $ k \\in [0, x) $  $ s[{\\rm SA}[i] + k] = s[{\\rm SA}[i - 1] + k] $\n\n### \n#### \n $ O(n ^ 2 \\log n) $\n\n**** $ O(n) $  $ O(n) $ \n\n#####  Hash \n Hash BKDRHash  $ O(n) $  $ O(1) $  Hash \n\n LCP  $ O(n \\log n \\log n) $\n\n Hash  `std::set` Hash \n\n#### \n**** $ i $  $ 2 ^ k $ \n\n `\"heheda\"` $ 2 ^ 0 = 1 $ \n\n| $ s[i]          $ | h | e | h | e | d | a |\n|:-----------------:|:-:|:-:|:-:|:-:|:-:|:-:|\n| $ {\\rm rank}[i] $ | 3 | 2 | 3 | 2 | 1 | 0 |\n\n $ 2 ^ 1 = 2 $  $ i $  $ 2 ^ 0 = 1 $  $ i $ **** $ i + 2 ^ 0 = i + 1 $  $ 2 ^ 0 = 1 $  $ i $ ****\n\n $ i + 2 ^ 0 \\geq n $  $ -1 $\n\n| $ s[i]            $ | h | e | h | e | d | a  |\n|:-------------------:|:-:|:-:|:-:|:-:|:-:|:--:|\n| $ {\\rm first}[i]  $ | 3 | 2 | 3 | 2 | 1 | 0  |\n| $ {\\rm second}[i] $ | 2 | 3 | 2 | 1 | 0 | -1 |\n| $ {\\rm rank}[i]   $ | 4 | 3 | 4 | 2 | 1 | 0  |\n\n $ 2 ^ 2 = 4 $ \n\n| $ s[i]            $ | h | e | h | e | d  | a  |\n|:-------------------:|:-:|:-:|:-:|:-:|:--:|:--:|\n| $ {\\rm first}[i]  $ | 4 | 3 | 4 | 2 | 1  | 0  |\n| $ {\\rm second}[i] $ | 4 | 2 | 1 | 0 | -1 | -1 |\n| $ {\\rm rank}[i]   $ | 5 | 3 | 4 | 2 | 1  | 0  |\n\n $ {\\rm rank}[] $  $ O(\\log n) $  $ {\\rm rank}[] $ \n\n $ O(n \\log n \\log n) $ Hash  $ [-1, n) $  $ O(n) $  $ O(n \\log n) $\n\n##### \n\n $ [0, n) $ \n\n```c++\nstatic int set[MAXN];\nstd::copy(a, a + n, set);\nstd::sort(set, set + n);\nint *end = std::unique(set, set + n);\nfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n```\n\n`fir`  `sec` `buc`  $ [-1, n) $\n\n```c++\nstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n```\n\n\n\n```c++\nfor (int i = 0; i < n; i++) buc[a[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n```\n\n $ O(\\log n) $ \n\n```c++\nfor (int t = 1; t < n; t <<= 1)\n```\n\n\n\n```c++\nfor (int i = 0; i < n; i++) fir[i] = rk[i];\nfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n```\n\n$ {\\rm tmp}[i] $  $ i $ ****\n\n```c++\nstd::fill(buc - 1, buc + n, 0);\nfor (int i = 0; i < n; i++) buc[sec[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n```\n\n $ {\\rm tmp}[] $  $ {\\rm tmp}[] $ \n\n```c++\nstd::fill(buc - 1, buc + n, 0);\nfor (int i = 0; i < n; i++) buc[fir[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n```\n\n $ {\\rm SA}[] $  $ {\\rm rank}[] $\n\n1.  $ 0 $\n2. \n3.  $ + 1 $\n\n```c++\nfor (int j = 0, i, last = -1; j < n; j++) {\n\ti = sa[j];\n\tif (last == -1) rk[i] = 0;\n\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\telse rk[i] = rk[last] + 1;\n\tlast = i;\n}\n```\n\n DC3\n\n### \n $ {\\rm height}[] $  $ {\\rm height}[] $ $ O(n ^ 2) $\n\n#### \n $ h(i) $  $ i $  $ {\\rm rank}[i] > 0 $ \n\n$$\n\\begin{align}\nh(i) &= {\\rm LCP}({\\rm suffix}(i), {\\rm suffix}({\\rm SA}[{\\rm rank}[i] - 1])) \\\\\n&= {\\rm height}[{\\rm rank}[i]] \\\\\n\\end{align}\n$$\n\n $ h(i) $\n\n$$ h(i) \\geq h(i - 1) - 1 $$\n\n $ h(i - 1) < 1 $  $ h(i - 1) \\geq 1 $ \n\n $ u = {\\rm suffix}(i) $$ v = {\\rm suffix}({\\rm SA}[{\\rm rank}[i] - 1]) $ $ i $   \n $ u' = {\\rm suffix}(i - 1) $$ v' = {\\rm suffix}({\\rm SA}[{\\rm rank}[i - 1] - 1]) $ $ i - 1 $ \n\n $ {\\rm LCP}(u, v) \\geq {\\rm LCP}(u', v') - 1 $\n\n `\"heheheda\"` \n\n| $ i $ |   $ u $  |   $ v $  | $ {\\rm LCP}(u, v) $ |\n|:-----:|---------:|---------:|:-------------------:|\n|   1   | heheheda |   heheda |          4          |\n|   2   |  eheheda |    eheda |          3          |\n|   3   |   heheda |     heda |          2          |\n|   4   |    eheda |      eda |          1          |\n|   5   |     heda |  eheheda |          0          |\n|   6   |      eda |       da |          0          |\n|   7   |       da |        a |          0          |\n|   8   |        a |        - |          -          |\n\n $ h(i - 1) \\geq 1 $ $ u' $  $ v' $  $ {\\rm LCP}(u', v') - 1 $ $ u $  $ v $\t $ u $  $ v $ $ {\\rm LCP}(u, v) $ \n\n#### \n $ {\\rm height}[{\\rm SA}[i]] $   \n $ k = {\\rm height}[{\\rm rank}[i - 1]] $ $ h(i - 1) $ $ {\\rm height}[{\\rm rank}[i]] $ $ k $  $ 1 $ $ n $ $ O(n) $  \n $ O(n \\log n) $ \n\n```c++\nfor (int i = 0, k = 0; i < n; i++) {\n\tif (rk[i] == 0) k = 0;\n\telse {\n\t\tif (k > 0) k--;\n\t\tint j = sa[rk[i] - 1];\n\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t}\n\tht[rk[i]] = k;\n}\n```\n\n$ {\\rm height}[0] $ \n\n### \n $ {\\rm height}[] $\n\n************\n\n $ {\\rm height} $ \n\nRange Minimum/Maximum QueryRMQSparse TableST $ O(n \\log n) $  $ O(1) $ \n\n#### \n $ {\\rm st}[i][t] $  $ [i, i + 2 ^ t] $  $ {\\rm LCP}(i, i + 2 ^ t) $\n\n```c++\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = ht[i + 1];\n\tfor (int t = 1; (1 << t) < n; t++) {\n\t\tfor (int i = 0, j = (1 << t); i < n; i++) {\n\t\t\tif (i + j >= n) break;\n\t\t\tst[i][t] = std::min(st[i][t - 1], st[i + (1 << (t - 1))][t - 1]);\n\t\t}\n\t}\n}\n\ninline int lcp(int a, int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a == b) return n - a;\n\telse {\n\t\tint t = (int)floor(log2(b - a));\n\t\treturn std::min(st[a][t], st[b - (1 << t)][t]);\n\t}\n}\n```\n\n### \n```c++\nint n, a[MAXN], sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXLOGN + 1];\n\ninline void suffixArray() {\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n}\n```\n","source":"_posts/suffix-array-notes.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - \npermalink: suffix-array-notes\ndate: 2016-04-12 19:29:14\n---\n\n OI   \n\n<!-- more -->\n\n### \n $ s $  $ 0 $  $ {\\rm length}(s) $\n\n$ {\\rm suffix}(i) $  $ s $  $ i $  $ s[i] $ ~ $ s[n - 1] $ \n\n  \n ASCII  ASCII   \n  \n\n\n****\n\n$ {\\rm SA}[] $  $ s $ $ {\\rm SA}[i] $  $ i $ \n\n$ {\\rm rank}[] $  $ {\\rm SA}[] $ $ {\\rm rank}[i] $  $ {\\rm suffix}(i) $  $ {\\rm rank}[{\\rm SA}[i]] = i $ $ i $  $ i $\n\n$ {\\rm height}[] $ Longest Common PrefixLCP\n\n$$\n{\\rm height}[i] =\n\\begin{cases}\n0 & i = 0 \\\\\n{\\rm LCP}({\\rm suffix}({\\rm SA}[i]), {\\rm suffix}({\\rm SA}[i - 1])) & i > 0 \\\\\n\\end{cases}\n$$\n\n $ {\\rm height}[i] $  $ x $ $ k \\in [0, x) $  $ s[{\\rm SA}[i] + k] = s[{\\rm SA}[i - 1] + k] $\n\n### \n#### \n $ O(n ^ 2 \\log n) $\n\n**** $ O(n) $  $ O(n) $ \n\n#####  Hash \n Hash BKDRHash  $ O(n) $  $ O(1) $  Hash \n\n LCP  $ O(n \\log n \\log n) $\n\n Hash  `std::set` Hash \n\n#### \n**** $ i $  $ 2 ^ k $ \n\n `\"heheda\"` $ 2 ^ 0 = 1 $ \n\n| $ s[i]          $ | h | e | h | e | d | a |\n|:-----------------:|:-:|:-:|:-:|:-:|:-:|:-:|\n| $ {\\rm rank}[i] $ | 3 | 2 | 3 | 2 | 1 | 0 |\n\n $ 2 ^ 1 = 2 $  $ i $  $ 2 ^ 0 = 1 $  $ i $ **** $ i + 2 ^ 0 = i + 1 $  $ 2 ^ 0 = 1 $  $ i $ ****\n\n $ i + 2 ^ 0 \\geq n $  $ -1 $\n\n| $ s[i]            $ | h | e | h | e | d | a  |\n|:-------------------:|:-:|:-:|:-:|:-:|:-:|:--:|\n| $ {\\rm first}[i]  $ | 3 | 2 | 3 | 2 | 1 | 0  |\n| $ {\\rm second}[i] $ | 2 | 3 | 2 | 1 | 0 | -1 |\n| $ {\\rm rank}[i]   $ | 4 | 3 | 4 | 2 | 1 | 0  |\n\n $ 2 ^ 2 = 4 $ \n\n| $ s[i]            $ | h | e | h | e | d  | a  |\n|:-------------------:|:-:|:-:|:-:|:-:|:--:|:--:|\n| $ {\\rm first}[i]  $ | 4 | 3 | 4 | 2 | 1  | 0  |\n| $ {\\rm second}[i] $ | 4 | 2 | 1 | 0 | -1 | -1 |\n| $ {\\rm rank}[i]   $ | 5 | 3 | 4 | 2 | 1  | 0  |\n\n $ {\\rm rank}[] $  $ O(\\log n) $  $ {\\rm rank}[] $ \n\n $ O(n \\log n \\log n) $ Hash  $ [-1, n) $  $ O(n) $  $ O(n \\log n) $\n\n##### \n\n $ [0, n) $ \n\n```c++\nstatic int set[MAXN];\nstd::copy(a, a + n, set);\nstd::sort(set, set + n);\nint *end = std::unique(set, set + n);\nfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n```\n\n`fir`  `sec` `buc`  $ [-1, n) $\n\n```c++\nstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n```\n\n\n\n```c++\nfor (int i = 0; i < n; i++) buc[a[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n```\n\n $ O(\\log n) $ \n\n```c++\nfor (int t = 1; t < n; t <<= 1)\n```\n\n\n\n```c++\nfor (int i = 0; i < n; i++) fir[i] = rk[i];\nfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n```\n\n$ {\\rm tmp}[i] $  $ i $ ****\n\n```c++\nstd::fill(buc - 1, buc + n, 0);\nfor (int i = 0; i < n; i++) buc[sec[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n```\n\n $ {\\rm tmp}[] $  $ {\\rm tmp}[] $ \n\n```c++\nstd::fill(buc - 1, buc + n, 0);\nfor (int i = 0; i < n; i++) buc[fir[i]]++;\nfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\nfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n```\n\n $ {\\rm SA}[] $  $ {\\rm rank}[] $\n\n1.  $ 0 $\n2. \n3.  $ + 1 $\n\n```c++\nfor (int j = 0, i, last = -1; j < n; j++) {\n\ti = sa[j];\n\tif (last == -1) rk[i] = 0;\n\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\telse rk[i] = rk[last] + 1;\n\tlast = i;\n}\n```\n\n DC3\n\n### \n $ {\\rm height}[] $  $ {\\rm height}[] $ $ O(n ^ 2) $\n\n#### \n $ h(i) $  $ i $  $ {\\rm rank}[i] > 0 $ \n\n$$\n\\begin{align}\nh(i) &= {\\rm LCP}({\\rm suffix}(i), {\\rm suffix}({\\rm SA}[{\\rm rank}[i] - 1])) \\\\\n&= {\\rm height}[{\\rm rank}[i]] \\\\\n\\end{align}\n$$\n\n $ h(i) $\n\n$$ h(i) \\geq h(i - 1) - 1 $$\n\n $ h(i - 1) < 1 $  $ h(i - 1) \\geq 1 $ \n\n $ u = {\\rm suffix}(i) $$ v = {\\rm suffix}({\\rm SA}[{\\rm rank}[i] - 1]) $ $ i $   \n $ u' = {\\rm suffix}(i - 1) $$ v' = {\\rm suffix}({\\rm SA}[{\\rm rank}[i - 1] - 1]) $ $ i - 1 $ \n\n $ {\\rm LCP}(u, v) \\geq {\\rm LCP}(u', v') - 1 $\n\n `\"heheheda\"` \n\n| $ i $ |   $ u $  |   $ v $  | $ {\\rm LCP}(u, v) $ |\n|:-----:|---------:|---------:|:-------------------:|\n|   1   | heheheda |   heheda |          4          |\n|   2   |  eheheda |    eheda |          3          |\n|   3   |   heheda |     heda |          2          |\n|   4   |    eheda |      eda |          1          |\n|   5   |     heda |  eheheda |          0          |\n|   6   |      eda |       da |          0          |\n|   7   |       da |        a |          0          |\n|   8   |        a |        - |          -          |\n\n $ h(i - 1) \\geq 1 $ $ u' $  $ v' $  $ {\\rm LCP}(u', v') - 1 $ $ u $  $ v $\t $ u $  $ v $ $ {\\rm LCP}(u, v) $ \n\n#### \n $ {\\rm height}[{\\rm SA}[i]] $   \n $ k = {\\rm height}[{\\rm rank}[i - 1]] $ $ h(i - 1) $ $ {\\rm height}[{\\rm rank}[i]] $ $ k $  $ 1 $ $ n $ $ O(n) $  \n $ O(n \\log n) $ \n\n```c++\nfor (int i = 0, k = 0; i < n; i++) {\n\tif (rk[i] == 0) k = 0;\n\telse {\n\t\tif (k > 0) k--;\n\t\tint j = sa[rk[i] - 1];\n\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t}\n\tht[rk[i]] = k;\n}\n```\n\n$ {\\rm height}[0] $ \n\n### \n $ {\\rm height}[] $\n\n************\n\n $ {\\rm height} $ \n\nRange Minimum/Maximum QueryRMQSparse TableST $ O(n \\log n) $  $ O(1) $ \n\n#### \n $ {\\rm st}[i][t] $  $ [i, i + 2 ^ t] $  $ {\\rm LCP}(i, i + 2 ^ t) $\n\n```c++\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = ht[i + 1];\n\tfor (int t = 1; (1 << t) < n; t++) {\n\t\tfor (int i = 0, j = (1 << t); i < n; i++) {\n\t\t\tif (i + j >= n) break;\n\t\t\tst[i][t] = std::min(st[i][t - 1], st[i + (1 << (t - 1))][t - 1]);\n\t\t}\n\t}\n}\n\ninline int lcp(int a, int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a == b) return n - a;\n\telse {\n\t\tint t = (int)floor(log2(b - a));\n\t\treturn std::min(st[a][t], st[b - (1 << t)][t]);\n\t}\n}\n```\n\n### \n```c++\nint n, a[MAXN], sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXLOGN + 1];\n\ninline void suffixArray() {\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n}\n```\n","slug":"suffix-array-notes","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bxn007hc2xlvkjf70g7"},{"title":"STL  OI ","id":"8","updated":"2016-02-17T02:35:37.000Z","date":"2015-12-23T21:43:15.000Z","_content":"\n OI  C++CPascal C++   Standard Template Library STLSTL  STLNOI  2011  C++  STL STL C++ \n\n<!-- more -->\n\n### \n> STL containersiteratorsallocatoradaptersalgorithmsfunctors\n\n\n\n### \nnamespace C++  Menci  Fuxey  `work()`  `Menci::work()`  `Fuxey::work()`\n\nSTL  `std` \n\n STL  `sort` \n\n```cpp\nstd::sort(a, a + n);\n```\n\n `std::sort`  `sort(a, a + n)`   \n `using` \n\n```cpp\nusing std::sort;\n```\n\n `max`  STL  `max`   \n `using namespace` \n\n```cpp\nusing namespace std;\n```\n\n### \nSTL  `<algorithm>` \n\n##### \nSTL  `sort`  `stable_sort``sort`  $O(n {\\log} n)$`stable_sort`  $O(n {\\log} n)$\n\n`sort` `stable_sort`  `sort`\n\n `sort` `stable_sort` \n\n [l, r)  `sort(l, r)` l  r ********\n\n****STL  a  n  [a, a + n) a  0a + n  n ****\n\n`sort` \n\n```cpp\nbool compare(int a, int b) {\n    return a > b;\n}\n\nstd::sort(a, a + n, &compare);\n```\n\n nn <= 100000****\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint n;\nint a[MAXN];\n\nbool compare(int a, int b) {\n    return a > b;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tstd::sort(a, a + n, &compare);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d\\n\", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n****************\n\n********\n\n```cpp\nstruct student_t {\n    unsigned int id;\n    long double score;\n \n    bool operator<(const student_t &other) const {\n        return score < other.score;\n    }\n} students[MAXN];\n \nbool compare(const student_t &student1, const student_t &student2) {\n    return student1.score < student2.score;\n}\n \nstd::sort(students, students + n, &compare);\n```\n\n `operator<`   \n `compare` ********\n\n `const`  `&` \n\n##### \n\n `unique`  `sort`  `unique` \n\n```cpp\nstd::sort(a, a + n);\nstd::unique(a, a + n);\n```\n\n`unique` \n\n```cpp\nint count = std::unique(a, a + n) - a;\n```\n\n nn <= 100000\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n \nconst int MAXN = 100000;\n \nint n;\nint a[MAXN];\n \nint main() {\n    scanf(\"%d\", &n);\n \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n \n    std::sort(a, a + n);\n    int count = std::unique(a, a + n) - a;\n \n    for (int i = 0; i < count; i++) {\n        printf(\"%d\\n\", a[i]);\n    }\n \n    return 0;\n}\n```\n\n##### \n\n `max`  `min` \n\n```cpp\nint a = -1, b = 890;\nx = std::max(a, b); //  890\ny = std::min(a, b); //  -1\n```\n\n##### \n\nSTL `lower_bound``upper_bound``binary_search` `lower_bound` \n\n`lower_bound` ********\n\n`upper_bound` ********\n\n`binary_search`  `true`  `false`\n\n$O({\\log}n)$\n\n```cpp\nint a[8] = { -9, 5, -1, 2, 7, 1, -2, 2 }, n = 8;\n\nstd::sort(a, a + n);\n\n// a = { -9, -2, -1, 1, 2, 2, 5, 7 }\n\nint *p1 = std::lower_bound(a, a + n, 1);\n// p1  a  4  a[3] = 1\n\nint *p2 = std::lower_bound(a, a + n, 2);\n// p2  a  5  a[4] = 2\n\nint *p3 = std::upper_bound(a, a + n, 2);\n// p3  a  7  a[6] = 5\n\nint *p4 = std::lower_bound(a, a + n, 8);\n// p4 = a + n a  8  *p4 \n\nbool flag = std::binary_search(a, a + n, 3);\n// flag = false  a  3\n```\n\n##### \n `swap` \n\n```cpp\nint a = -1, b = 1;\nstd::swap(a, b);\n\n// a = 1, b = -1\n```\n\n### \n STL \n\n```cpp\nstd::CONTAINER<T>::iterator p;\n```\n\n `p` `CONTAINER`  `vector``set` `T` \n\n `begin()` **** `end()` ******** `[begin(), end())`**** `end()``end()`  `end()` \n\n STL \n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n**** `vector[i]`  `vector.begin() + i` `set` \n\n `++`  `--` \n\n `p` `*p`  `->` \n\n\n\n```cpp\nfor (std::CONTAINER<T>::iterator p = C.begin(); p != C.end(); p++) {\n    std::cout << *p << std::endl;\n}\n```\n\n### \n\n#####  vector\nSTL  `<vector>` **** `vector`\n\n `vector` `int` 0\n\n```cpp\nstd::vector<int> v;\n```\n\n `vector` `int` n\n\n```cpp\nstd::vector<int> v(n);\n```\n\n`vector`  `begin()`  `end()`********\n\n v \n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n `size()`  `vector`  `resize()`  `vector` \n\n `push_back()`  `pop_back()`  `vector` ****$O(1)$\n\n `insert()` $O(n)$\n\n `erase()` $O(n)$\n\n```cpp\nstd::vector<int> v;\n// v.size() = 0\n\nv.push_back(23333);\n// v.size() = 1, v = { 23333 }\n\nv.insert(v.begin() + 0, 890);\n// v.size() = 2, v = { 890, 23333 }\n\nv.insert(v.begin() + 1, 12345);\n// v.size() = 3, v = { 890, 12345, 23333 }\n\nv.erase(v.begin() + 0);\n// v.size() = 2, v = { 12345, 23333 }\n\nfor (nt i = 0; i < v.size(); i++) {\n    printf(\"%d\\n\", v[i]);\n}\n//  1234523333\n\nv.pop_back();\n// v.size() = 1, v = { 12345 }\n```\n\n `vector`  `vector`  $O(n)$ \n\n#####  set\nSTL  `<set>` **** `set`**** `set` ****\n\n `int` \n\n```cpp\nstd::set<int> s;\n```\n\n `insert()` $O({\\log}n)$\n\n `erase()` ********$O({\\log}n)$\n\n`set`  `lower_bound()`  `find()` \n\n `set` ****`set`  `set<T>::iterator` `T` \n\n```cpp\nstd::set<int> s;\n\ns.insert(23333);\ns.insert(23333); // \ns.insert(66666);\ns.insert(890);\ns.insert(-1);\n// s.size() = 4, s = { -1, 890, 23333, 66666 }\n\ns.erase(66666);\n// s.size() = 3, s = { -1, 890, 23333 }\n\nstd::set<int>::iterator p1 = s.lower_bound(555);\n// *p1 = 890\n\nstd::set<int>::iterator p2 = s.find(555);\n// p2 = s.end() 555\n\ns.erase(p1);\n// s.size() = 2, s = { -1, 23333 }\n\nfor (std::set<int>::iterator p = s.begin(); p != s.end(); p++) {\n    printf(\"%d\\n\", *p);\n}\n//  -123333\n```\n\n STL \n\n#####  string\nSTL  `<string>`  `string` \n\n `cin`  `cout` \n\n `find()`  0 \n\n `c_str()`  `string`  `const char *`  C \n\n```cpp\nstd::string s = \"Menci\";\n\nint pos = s.find(\"23333\");\n// pos = string::npos 23333\n\npos = s.find(\"ci\");\n// pos = 3 4 \n\nchar ch = s[0];\n// ch = 'M'\n\nstd::cout << s << std::endl;\nputs(s.c_str());\n//  Menci\n```\n\n#####  queue\nSTL  `<queue>` FIFO `queue`\n\n `push()` \n\n `front()` \n\n `pop()` \n\n `empty()` \n\n```cpp\nstd::queue<int> q;\n\nbool flag = q.empty();\n// flag = true\n\nq.push(23333);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.front());\n    q.pop();\n}\n//  2333366666\n```\n\n#####  stack\nSTL  `<stack>` LIFO `stack`\n\n `push()` \n\n `top()` \n\n `pop()` \n\n `empty()` \n\n```cpp\nstd::stack<int> s;\n\nbool flag = s.empty();\n// flag = true\n\ns.push(23333);\ns.push(66666);\n\nwhile (!s.empty()) {\n    printf(\"%d\\n\", s.top());\n    s.pop();\n}\n//  6666623333\n```\n\n#####  priority_queue\nSTL  `<queue>`  `priority_queue`****\n\n `push()` $O({\\log}n)$\n\n `top()` ****$O(1)$\n\n `pop()` ****$O({\\log}n)$\n\n `empty()` \n\n```cpp\nstd::priority_queue<int> q;\n\nbool flag = q.empty();\n// flag = true\n\nq.push(23333);\nq.push(-1);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.top());\n    q.pop();\n}\n//  6666623333-1\n```\n\n`priority_queue` **** `priority_queue` ****\n\n```cpp\nstd::priority_queue<T, std::vector<T>, std::greater<T> > q;\n```\n\n `T`  `int``std::greater<T>`  `>>` \n","source":"_posts/stl-in-oi.md","raw":"title: STL  OI \ncategories: OI\ntags: \n  - C++\n  - STL\npermalink: stl-in-oi\nid: 8\nupdated: '2016-02-17 10:35:37'\ndate: 2015-12-24 05:43:15\n---\n\n OI  C++CPascal C++   Standard Template Library STLSTL  STLNOI  2011  C++  STL STL C++ \n\n<!-- more -->\n\n### \n> STL containersiteratorsallocatoradaptersalgorithmsfunctors\n\n\n\n### \nnamespace C++  Menci  Fuxey  `work()`  `Menci::work()`  `Fuxey::work()`\n\nSTL  `std` \n\n STL  `sort` \n\n```cpp\nstd::sort(a, a + n);\n```\n\n `std::sort`  `sort(a, a + n)`   \n `using` \n\n```cpp\nusing std::sort;\n```\n\n `max`  STL  `max`   \n `using namespace` \n\n```cpp\nusing namespace std;\n```\n\n### \nSTL  `<algorithm>` \n\n##### \nSTL  `sort`  `stable_sort``sort`  $O(n {\\log} n)$`stable_sort`  $O(n {\\log} n)$\n\n`sort` `stable_sort`  `sort`\n\n `sort` `stable_sort` \n\n [l, r)  `sort(l, r)` l  r ********\n\n****STL  a  n  [a, a + n) a  0a + n  n ****\n\n`sort` \n\n```cpp\nbool compare(int a, int b) {\n    return a > b;\n}\n\nstd::sort(a, a + n, &compare);\n```\n\n nn <= 100000****\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint n;\nint a[MAXN];\n\nbool compare(int a, int b) {\n    return a > b;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tstd::sort(a, a + n, &compare);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d\\n\", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n****************\n\n********\n\n```cpp\nstruct student_t {\n    unsigned int id;\n    long double score;\n \n    bool operator<(const student_t &other) const {\n        return score < other.score;\n    }\n} students[MAXN];\n \nbool compare(const student_t &student1, const student_t &student2) {\n    return student1.score < student2.score;\n}\n \nstd::sort(students, students + n, &compare);\n```\n\n `operator<`   \n `compare` ********\n\n `const`  `&` \n\n##### \n\n `unique`  `sort`  `unique` \n\n```cpp\nstd::sort(a, a + n);\nstd::unique(a, a + n);\n```\n\n`unique` \n\n```cpp\nint count = std::unique(a, a + n) - a;\n```\n\n nn <= 100000\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n \nconst int MAXN = 100000;\n \nint n;\nint a[MAXN];\n \nint main() {\n    scanf(\"%d\", &n);\n \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n \n    std::sort(a, a + n);\n    int count = std::unique(a, a + n) - a;\n \n    for (int i = 0; i < count; i++) {\n        printf(\"%d\\n\", a[i]);\n    }\n \n    return 0;\n}\n```\n\n##### \n\n `max`  `min` \n\n```cpp\nint a = -1, b = 890;\nx = std::max(a, b); //  890\ny = std::min(a, b); //  -1\n```\n\n##### \n\nSTL `lower_bound``upper_bound``binary_search` `lower_bound` \n\n`lower_bound` ********\n\n`upper_bound` ********\n\n`binary_search`  `true`  `false`\n\n$O({\\log}n)$\n\n```cpp\nint a[8] = { -9, 5, -1, 2, 7, 1, -2, 2 }, n = 8;\n\nstd::sort(a, a + n);\n\n// a = { -9, -2, -1, 1, 2, 2, 5, 7 }\n\nint *p1 = std::lower_bound(a, a + n, 1);\n// p1  a  4  a[3] = 1\n\nint *p2 = std::lower_bound(a, a + n, 2);\n// p2  a  5  a[4] = 2\n\nint *p3 = std::upper_bound(a, a + n, 2);\n// p3  a  7  a[6] = 5\n\nint *p4 = std::lower_bound(a, a + n, 8);\n// p4 = a + n a  8  *p4 \n\nbool flag = std::binary_search(a, a + n, 3);\n// flag = false  a  3\n```\n\n##### \n `swap` \n\n```cpp\nint a = -1, b = 1;\nstd::swap(a, b);\n\n// a = 1, b = -1\n```\n\n### \n STL \n\n```cpp\nstd::CONTAINER<T>::iterator p;\n```\n\n `p` `CONTAINER`  `vector``set` `T` \n\n `begin()` **** `end()` ******** `[begin(), end())`**** `end()``end()`  `end()` \n\n STL \n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n**** `vector[i]`  `vector.begin() + i` `set` \n\n `++`  `--` \n\n `p` `*p`  `->` \n\n\n\n```cpp\nfor (std::CONTAINER<T>::iterator p = C.begin(); p != C.end(); p++) {\n    std::cout << *p << std::endl;\n}\n```\n\n### \n\n#####  vector\nSTL  `<vector>` **** `vector`\n\n `vector` `int` 0\n\n```cpp\nstd::vector<int> v;\n```\n\n `vector` `int` n\n\n```cpp\nstd::vector<int> v(n);\n```\n\n`vector`  `begin()`  `end()`********\n\n v \n\n```cpp\nstd::sort(v.begin(), v.end());\n```\n\n `size()`  `vector`  `resize()`  `vector` \n\n `push_back()`  `pop_back()`  `vector` ****$O(1)$\n\n `insert()` $O(n)$\n\n `erase()` $O(n)$\n\n```cpp\nstd::vector<int> v;\n// v.size() = 0\n\nv.push_back(23333);\n// v.size() = 1, v = { 23333 }\n\nv.insert(v.begin() + 0, 890);\n// v.size() = 2, v = { 890, 23333 }\n\nv.insert(v.begin() + 1, 12345);\n// v.size() = 3, v = { 890, 12345, 23333 }\n\nv.erase(v.begin() + 0);\n// v.size() = 2, v = { 12345, 23333 }\n\nfor (nt i = 0; i < v.size(); i++) {\n    printf(\"%d\\n\", v[i]);\n}\n//  1234523333\n\nv.pop_back();\n// v.size() = 1, v = { 12345 }\n```\n\n `vector`  `vector`  $O(n)$ \n\n#####  set\nSTL  `<set>` **** `set`**** `set` ****\n\n `int` \n\n```cpp\nstd::set<int> s;\n```\n\n `insert()` $O({\\log}n)$\n\n `erase()` ********$O({\\log}n)$\n\n`set`  `lower_bound()`  `find()` \n\n `set` ****`set`  `set<T>::iterator` `T` \n\n```cpp\nstd::set<int> s;\n\ns.insert(23333);\ns.insert(23333); // \ns.insert(66666);\ns.insert(890);\ns.insert(-1);\n// s.size() = 4, s = { -1, 890, 23333, 66666 }\n\ns.erase(66666);\n// s.size() = 3, s = { -1, 890, 23333 }\n\nstd::set<int>::iterator p1 = s.lower_bound(555);\n// *p1 = 890\n\nstd::set<int>::iterator p2 = s.find(555);\n// p2 = s.end() 555\n\ns.erase(p1);\n// s.size() = 2, s = { -1, 23333 }\n\nfor (std::set<int>::iterator p = s.begin(); p != s.end(); p++) {\n    printf(\"%d\\n\", *p);\n}\n//  -123333\n```\n\n STL \n\n#####  string\nSTL  `<string>`  `string` \n\n `cin`  `cout` \n\n `find()`  0 \n\n `c_str()`  `string`  `const char *`  C \n\n```cpp\nstd::string s = \"Menci\";\n\nint pos = s.find(\"23333\");\n// pos = string::npos 23333\n\npos = s.find(\"ci\");\n// pos = 3 4 \n\nchar ch = s[0];\n// ch = 'M'\n\nstd::cout << s << std::endl;\nputs(s.c_str());\n//  Menci\n```\n\n#####  queue\nSTL  `<queue>` FIFO `queue`\n\n `push()` \n\n `front()` \n\n `pop()` \n\n `empty()` \n\n```cpp\nstd::queue<int> q;\n\nbool flag = q.empty();\n// flag = true\n\nq.push(23333);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.front());\n    q.pop();\n}\n//  2333366666\n```\n\n#####  stack\nSTL  `<stack>` LIFO `stack`\n\n `push()` \n\n `top()` \n\n `pop()` \n\n `empty()` \n\n```cpp\nstd::stack<int> s;\n\nbool flag = s.empty();\n// flag = true\n\ns.push(23333);\ns.push(66666);\n\nwhile (!s.empty()) {\n    printf(\"%d\\n\", s.top());\n    s.pop();\n}\n//  6666623333\n```\n\n#####  priority_queue\nSTL  `<queue>`  `priority_queue`****\n\n `push()` $O({\\log}n)$\n\n `top()` ****$O(1)$\n\n `pop()` ****$O({\\log}n)$\n\n `empty()` \n\n```cpp\nstd::priority_queue<int> q;\n\nbool flag = q.empty();\n// flag = true\n\nq.push(23333);\nq.push(-1);\nq.push(66666);\n\nwhile (!q.empty()) {\n    printf(\"%d\\n\", q.top());\n    q.pop();\n}\n//  6666623333-1\n```\n\n`priority_queue` **** `priority_queue` ****\n\n```cpp\nstd::priority_queue<T, std::vector<T>, std::greater<T> > q;\n```\n\n `T`  `int``std::greater<T>`  `>>` \n","slug":"stl-in-oi","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bxr007qc2xl5tc05r1b"},{"title":"SPOJ 694Distinct Substrings - ","date":"2016-04-12T13:40:06.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[SPOJ 694](http://www.spoj.com/problems/DISUBSTR/)\n\n### \n $ i $  $ i - 1 $  $ {\\rm height}[i] $ \n\n 1 \n\n$$ \\sum\\limits_{i = 1} ^ { {\\rm len}(s)} ({\\rm len}({\\rm suffix}(i)) - {\\rm height}[i]) $$\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXT = 20;\nconst int MAXN = 1000;\nconst int CHARSET_SIZE = 256;\n\nchar s[MAXN];\nint n, sa[MAXN + 1], rk[MAXN + 1], ht[MAXN + 1];\n\ninline void suffixArray() {\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN + 1], _buc[MAXN + 2], *buc = _buc + 1;\n\tstd::fill(sa + 1, sa + n + 1, 0);\n\tstd::fill(rk + 1, rk + n + 1, 0);\n\tstd::fill(ht + 1, ht + n + 1, 0);\n\tstd::fill(fir, fir + n, 0);\n\tstd::fill(sec, sec + n, 0);\n\tstd::fill(tmp + 1, tmp + n + 1, 0);\n\tstd::fill(buc, buc + MAXN + 1, 0);\n\n\tfor (int i = 0; i < n; i++) buc[(int)s[i]]++;\n\tfor (int i = 0; i < CHARSET_SIZE; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i + 1] = buc[(int)s[i] - 1] + 1;\n\n\tfor (int t = 1; t <= n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i + 1];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? 0 : fir[i + t];\n\n\t\tstd::fill(buc, buc + n + 1, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i <= n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc, buc + n + 1, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i <= n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = n, i; j > 0; j--) i = tmp[j], sa[buc[fir[i]]--] = i + 1;\n\n\t\tfor (int i = 1; i <= n; i++) rk[sa[i]] = i;\n\t\tfor (int j = 1, i, last = 0; j <= n; j++, last = i) {\n\t\t\ti = sa[j] - 1;\n\t\t\tif (last && fir[i] == fir[last] && sec[i] == sec[last]) rk[i + 1] = rk[last + 1];\n\t\t}\n\t}\n\n\tfor (int i = 1, t = 0; i <= n; i++) {\n\t\tif (rk[i] == 1) continue;\n\t\tint j = sa[rk[i] - 1];\n\t\tif (t > 0) t--;\n\t\twhile (s[i + t - 1] == s[j + t - 1]) t++;\n\t\tht[rk[i]] = t;\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tsuffixArray();\n\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tans += (n - i + 1) - ht[i];\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/spoj-694.md","raw":"title: SPOJ 694Distinct Substrings - \ncategories: OI\ntags: \n  - SPOJ\n  - \n  - \npermalink: spoj-694\ndate: 2016-04-12 21:40:06\n---\n\n\n\n<!-- more -->\n\n### \n[SPOJ 694](http://www.spoj.com/problems/DISUBSTR/)\n\n### \n $ i $  $ i - 1 $  $ {\\rm height}[i] $ \n\n 1 \n\n$$ \\sum\\limits_{i = 1} ^ { {\\rm len}(s)} ({\\rm len}({\\rm suffix}(i)) - {\\rm height}[i]) $$\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXT = 20;\nconst int MAXN = 1000;\nconst int CHARSET_SIZE = 256;\n\nchar s[MAXN];\nint n, sa[MAXN + 1], rk[MAXN + 1], ht[MAXN + 1];\n\ninline void suffixArray() {\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN + 1], _buc[MAXN + 2], *buc = _buc + 1;\n\tstd::fill(sa + 1, sa + n + 1, 0);\n\tstd::fill(rk + 1, rk + n + 1, 0);\n\tstd::fill(ht + 1, ht + n + 1, 0);\n\tstd::fill(fir, fir + n, 0);\n\tstd::fill(sec, sec + n, 0);\n\tstd::fill(tmp + 1, tmp + n + 1, 0);\n\tstd::fill(buc, buc + MAXN + 1, 0);\n\n\tfor (int i = 0; i < n; i++) buc[(int)s[i]]++;\n\tfor (int i = 0; i < CHARSET_SIZE; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i + 1] = buc[(int)s[i] - 1] + 1;\n\n\tfor (int t = 1; t <= n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i + 1];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? 0 : fir[i + t];\n\n\t\tstd::fill(buc, buc + n + 1, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i <= n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc, buc + n + 1, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i <= n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = n, i; j > 0; j--) i = tmp[j], sa[buc[fir[i]]--] = i + 1;\n\n\t\tfor (int i = 1; i <= n; i++) rk[sa[i]] = i;\n\t\tfor (int j = 1, i, last = 0; j <= n; j++, last = i) {\n\t\t\ti = sa[j] - 1;\n\t\t\tif (last && fir[i] == fir[last] && sec[i] == sec[last]) rk[i + 1] = rk[last + 1];\n\t\t}\n\t}\n\n\tfor (int i = 1, t = 0; i <= n; i++) {\n\t\tif (rk[i] == 1) continue;\n\t\tint j = sa[rk[i] - 1];\n\t\tif (t > 0) t--;\n\t\twhile (s[i + t - 1] == s[j + t - 1]) t++;\n\t\tht[rk[i]] = t;\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tsuffixArray();\n\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tans += (n - i + 1) - ht[i];\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"spoj-694","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bxy007wc2xlbfr6msqp"},{"title":"Splay  + ","date":"2016-12-23T12:13:00.000Z","_content":"\n\n\n\n\n![zyz ](splay-template/zyz.png)\n\n<!--  Ahhhh  Rachel  () -->\n\n<!-- more -->\n\n```c++\n#include <cstdio>\n#include <climits>\n\nstruct Splay\n{\n\tstruct Node\n\t{\n\t\t// root \n\t\tNode *fa, *ch[2], **root;\n\t\t// x \n\t\t// size \n\t\t// cnt  x \n\t\tint x, size, cnt;\n\n\t\tNode(Node **root, Node *fa, int x) : root(root), fa(fa), x(x), cnt(1), size(1)\n\t\t{\n\t\t\tch[0] = ch[1] = NULL; // \n\t\t}\n\n\t\t//  0  1\n\t\tint relation()\n\t\t{\n\t\t\treturn this == fa->ch[0] ? 0 : 1;\n\t\t}\n\n\t\tvoid maintain()\n\t\t{\n\t\t\tsize = cnt;\n\t\t\tif (ch[0]) size += ch[0]->size;\n\t\t\tif (ch[1]) size += ch[1]->size;\n\t\t}\n\n\t\tvoid rotate()\n\t\t{\n\t\t\t// \n\t\t\tNode *old = fa;\n\t\t\t// \n\t\t\tint r = relation();\n\n\t\t\t//  <--> \n\t\t\tfa = old->fa;\n\t\t\tif (old->fa)\n\t\t\t{\n\t\t\t\t// \n\t\t\t\told->fa->ch[old->relation()] = this;\n\t\t\t}\n\n\t\t\t//  <--> \n\t\t\tif (ch[r ^ 1])\n\t\t\t{\n\t\t\t\tch[r ^ 1]->fa = old;\n\t\t\t}\n\t\t\told->ch[r] = ch[r ^ 1]; //  ch[r ^ 1]  this->ch[r ^ 1]\n\n\t\t\t//  \n\t\t\told->fa = this;\n\t\t\tch[r ^ 1] = old;\n\n\t\t\t// \n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\t// \n\t\t\tif (fa == NULL)\n\t\t\t{\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\t// \n\t\t// target  NULL\n\t\tvoid splay(Node *target = NULL)\n\t\t{\n\t\t\twhile (fa != target) // while ()\n\t\t\t{\n\t\t\t\tif (fa->fa == target) // \n\t\t\t\t{\n\t\t\t\t\trotate();\n\t\t\t\t}\n\t\t\t\telse if (fa->relation() == relation()) // \n\t\t\t\t{\n\t\t\t\t\tfa->rotate();\n\t\t\t\t\trotate();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trotate();\n\t\t\t\t\trotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//  precursor  predecessor\n\t\tNode *pred()\n\t\t{\n\t\t\t// \n\t\t\tNode *v = ch[0];\n\t\t\twhile (v->ch[1]) v = v->ch[1];\n\t\t\treturn v;\n\t\t}\n\n\t\t//  successor\n\t\tNode *succ()\n\t\t{\n\t\t\t// \n\t\t\tNode *v = ch[1];\n\t\t\twhile (v->ch[0]) v = v->ch[0];\n\t\t\treturn v;\n\t\t}\n\n\t\t// \n\t\tint rank()\n\t\t{\n\t\t\treturn ch[0] ? ch[0]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL)\n\t{\n\t\tinsert(INT_MAX);\n\t\tinsert(INT_MIN);\n\t}\n\n\tNode *insert(int x)\n\t{\n\t\t// v \n\t\t// \n\t\t//  v \n\t\t// \n\t\t//\n\t\t// fa \n\t\tNode **v = &root, *fa = NULL;\n\t\twhile (*v != NULL && (*v)->x != x) //  x \n\t\t{\n\t\t\tfa = *v;    //  v \n\t\t\tfa->size++; // \n\t\t\t\n\t\t\t// \n\t\t\tif (x < fa->x)\n\t\t\t{\n\t\t\t\tv = &fa->ch[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tv = &fa->ch[1];\n\t\t\t}\n\t\t}\n\n\t\tif (*v != NULL)\n\t\t{\n\t\t\t(*v)->cnt++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t(*v) = new Node(&root, fa, x);\n\t\t}\n\n\t\t(*v)->splay();\n\n\t\t// *v  v \n\t\t// \n\t\treturn root;\n\t}\n\n\tNode *find(int x)\n\t{\n\t\t// \n\t\tNode *v = root;\n\t\twhile (v != NULL && v->x != x)\n\t\t{\n\t\t\tif (x < v->x)\n\t\t\t{\n\t\t\t\tv = v->ch[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tv = v->ch[1];\n\t\t\t}\n\t\t}\n\n\t\tif (v) v->splay();\n\t\treturn v;\n\t}\n\n\t// \n\tvoid erase(Node *v)\n\t{\n\t\tNode *pred = v->pred(), *succ = v->succ();\n\t\tpred->splay();\n\t\tsucc->splay(pred); // \n\n\t\t//  v v \n\t\t\n\t\tif (v->size > 1)\n\t\t{\n\t\t\t//  x\n\t\t\tv->size--;\n\t\t\tv->cnt--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdelete succ->ch[0]; //  delete new  delete  new \n\t\t\tsucc->ch[0] = NULL; // \n\t\t}\n\n\t\t// \n\t\tsucc->size--;\n\t\tpred->size--;\n\t}\n\n\t// \n\tvoid erase(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (!v) return; // \n\t\t\n\t\terase(v);\n\t}\n\n\t// \n\tint pred(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (v == NULL)\n\t\t{\n\t\t\tv = insert(x);\n\t\t\tint res = v->pred()->x;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn v->pred()->x;\n\t\t}\n\t}\n\n\t// \n\tint succ(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (v == NULL)\n\t\t{\n\t\t\tv = insert(x);\n\t\t\tint res = v->succ()->x;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn v->succ()->x;\n\t\t}\n\t}\n\n\t// \n\tint rank(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (v == NULL)\n\t\t{\n\t\t\tv = insert(x);\n\t\t\t//  v \n\t\t\tint res = v->rank(); //  +1\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//  v \n\t\t\treturn v->rank();\n\t\t}\n\t}\n\n\t//  k \n\tint select(int k)\n\t{\n\t\tNode *v = root;\n\t\twhile (!(k >= v->rank() && k < v->rank() + v->cnt))\n\t\t{\n\t\t\tif (k < v->rank())\n\t\t\t{\n\t\t\t\t//  k \n\t\t\t\tv = v->ch[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tk -= v->rank() + v->cnt;\n\t\t\t\tv = v->ch[1];\n\t\t\t}\n\t\t}\n\t\tv->splay();\n\t\treturn v->x;\n\t}\n} splay;\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\twhile (n--)\n\t{\n\t\tint opt, x;\n\t\tscanf(\"%d %d\", &opt, &x);\n\t\tif (opt == 1)\n\t\t{\n\t\t\tsplay.insert(x);\n\t\t}\n\t\telse if (opt == 2)\n\t\t{\n\t\t\tsplay.erase(x);\n\t\t}\n\t\telse if (opt == 3)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.rank(x));\n\t\t}\n\t\telse if (opt == 4)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.select(x));\n\t\t}\n\t\telse if (opt == 5)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t}\n\t\telse if (opt == 6)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t}\n\t}\n\treturn 0;\n}\n```","source":"_posts/splay-template.md","raw":"title: Splay  + \ncategories: OI\ntags: \n  - Splay\n  - \n  - \n  - \npermalink: splay-template\ndate: 2016-12-23 20:13:00\n---\n\n\n\n\n\n![zyz ](splay-template/zyz.png)\n\n<!--  Ahhhh  Rachel  () -->\n\n<!-- more -->\n\n```c++\n#include <cstdio>\n#include <climits>\n\nstruct Splay\n{\n\tstruct Node\n\t{\n\t\t// root \n\t\tNode *fa, *ch[2], **root;\n\t\t// x \n\t\t// size \n\t\t// cnt  x \n\t\tint x, size, cnt;\n\n\t\tNode(Node **root, Node *fa, int x) : root(root), fa(fa), x(x), cnt(1), size(1)\n\t\t{\n\t\t\tch[0] = ch[1] = NULL; // \n\t\t}\n\n\t\t//  0  1\n\t\tint relation()\n\t\t{\n\t\t\treturn this == fa->ch[0] ? 0 : 1;\n\t\t}\n\n\t\tvoid maintain()\n\t\t{\n\t\t\tsize = cnt;\n\t\t\tif (ch[0]) size += ch[0]->size;\n\t\t\tif (ch[1]) size += ch[1]->size;\n\t\t}\n\n\t\tvoid rotate()\n\t\t{\n\t\t\t// \n\t\t\tNode *old = fa;\n\t\t\t// \n\t\t\tint r = relation();\n\n\t\t\t//  <--> \n\t\t\tfa = old->fa;\n\t\t\tif (old->fa)\n\t\t\t{\n\t\t\t\t// \n\t\t\t\told->fa->ch[old->relation()] = this;\n\t\t\t}\n\n\t\t\t//  <--> \n\t\t\tif (ch[r ^ 1])\n\t\t\t{\n\t\t\t\tch[r ^ 1]->fa = old;\n\t\t\t}\n\t\t\told->ch[r] = ch[r ^ 1]; //  ch[r ^ 1]  this->ch[r ^ 1]\n\n\t\t\t//  \n\t\t\told->fa = this;\n\t\t\tch[r ^ 1] = old;\n\n\t\t\t// \n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\t// \n\t\t\tif (fa == NULL)\n\t\t\t{\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\t// \n\t\t// target  NULL\n\t\tvoid splay(Node *target = NULL)\n\t\t{\n\t\t\twhile (fa != target) // while ()\n\t\t\t{\n\t\t\t\tif (fa->fa == target) // \n\t\t\t\t{\n\t\t\t\t\trotate();\n\t\t\t\t}\n\t\t\t\telse if (fa->relation() == relation()) // \n\t\t\t\t{\n\t\t\t\t\tfa->rotate();\n\t\t\t\t\trotate();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trotate();\n\t\t\t\t\trotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//  precursor  predecessor\n\t\tNode *pred()\n\t\t{\n\t\t\t// \n\t\t\tNode *v = ch[0];\n\t\t\twhile (v->ch[1]) v = v->ch[1];\n\t\t\treturn v;\n\t\t}\n\n\t\t//  successor\n\t\tNode *succ()\n\t\t{\n\t\t\t// \n\t\t\tNode *v = ch[1];\n\t\t\twhile (v->ch[0]) v = v->ch[0];\n\t\t\treturn v;\n\t\t}\n\n\t\t// \n\t\tint rank()\n\t\t{\n\t\t\treturn ch[0] ? ch[0]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL)\n\t{\n\t\tinsert(INT_MAX);\n\t\tinsert(INT_MIN);\n\t}\n\n\tNode *insert(int x)\n\t{\n\t\t// v \n\t\t// \n\t\t//  v \n\t\t// \n\t\t//\n\t\t// fa \n\t\tNode **v = &root, *fa = NULL;\n\t\twhile (*v != NULL && (*v)->x != x) //  x \n\t\t{\n\t\t\tfa = *v;    //  v \n\t\t\tfa->size++; // \n\t\t\t\n\t\t\t// \n\t\t\tif (x < fa->x)\n\t\t\t{\n\t\t\t\tv = &fa->ch[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tv = &fa->ch[1];\n\t\t\t}\n\t\t}\n\n\t\tif (*v != NULL)\n\t\t{\n\t\t\t(*v)->cnt++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t(*v) = new Node(&root, fa, x);\n\t\t}\n\n\t\t(*v)->splay();\n\n\t\t// *v  v \n\t\t// \n\t\treturn root;\n\t}\n\n\tNode *find(int x)\n\t{\n\t\t// \n\t\tNode *v = root;\n\t\twhile (v != NULL && v->x != x)\n\t\t{\n\t\t\tif (x < v->x)\n\t\t\t{\n\t\t\t\tv = v->ch[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tv = v->ch[1];\n\t\t\t}\n\t\t}\n\n\t\tif (v) v->splay();\n\t\treturn v;\n\t}\n\n\t// \n\tvoid erase(Node *v)\n\t{\n\t\tNode *pred = v->pred(), *succ = v->succ();\n\t\tpred->splay();\n\t\tsucc->splay(pred); // \n\n\t\t//  v v \n\t\t\n\t\tif (v->size > 1)\n\t\t{\n\t\t\t//  x\n\t\t\tv->size--;\n\t\t\tv->cnt--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdelete succ->ch[0]; //  delete new  delete  new \n\t\t\tsucc->ch[0] = NULL; // \n\t\t}\n\n\t\t// \n\t\tsucc->size--;\n\t\tpred->size--;\n\t}\n\n\t// \n\tvoid erase(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (!v) return; // \n\t\t\n\t\terase(v);\n\t}\n\n\t// \n\tint pred(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (v == NULL)\n\t\t{\n\t\t\tv = insert(x);\n\t\t\tint res = v->pred()->x;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn v->pred()->x;\n\t\t}\n\t}\n\n\t// \n\tint succ(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (v == NULL)\n\t\t{\n\t\t\tv = insert(x);\n\t\t\tint res = v->succ()->x;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn v->succ()->x;\n\t\t}\n\t}\n\n\t// \n\tint rank(int x)\n\t{\n\t\tNode *v = find(x);\n\t\tif (v == NULL)\n\t\t{\n\t\t\tv = insert(x);\n\t\t\t//  v \n\t\t\tint res = v->rank(); //  +1\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//  v \n\t\t\treturn v->rank();\n\t\t}\n\t}\n\n\t//  k \n\tint select(int k)\n\t{\n\t\tNode *v = root;\n\t\twhile (!(k >= v->rank() && k < v->rank() + v->cnt))\n\t\t{\n\t\t\tif (k < v->rank())\n\t\t\t{\n\t\t\t\t//  k \n\t\t\t\tv = v->ch[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tk -= v->rank() + v->cnt;\n\t\t\t\tv = v->ch[1];\n\t\t\t}\n\t\t}\n\t\tv->splay();\n\t\treturn v->x;\n\t}\n} splay;\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\twhile (n--)\n\t{\n\t\tint opt, x;\n\t\tscanf(\"%d %d\", &opt, &x);\n\t\tif (opt == 1)\n\t\t{\n\t\t\tsplay.insert(x);\n\t\t}\n\t\telse if (opt == 2)\n\t\t{\n\t\t\tsplay.erase(x);\n\t\t}\n\t\telse if (opt == 3)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.rank(x));\n\t\t}\n\t\telse if (opt == 4)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.select(x));\n\t\t}\n\t\telse if (opt == 5)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t}\n\t\telse if (opt == 6)\n\t\t{\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t}\n\t}\n\treturn 0;\n}\n```","slug":"splay-template","published":1,"updated":"2016-12-23T12:21:08.207Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6by10082c2xlwm1twirx"},{"title":"Splay ","date":"2016-01-19T12:02:00.000Z","_content":"\nSplay  Splay  Splay \n\n[Splay  + ](/splay-template)\n\n<!-- more -->\n\n### \n0 1 \n\n `count` \n```cpp\nenum Relation {\n\tL = 0, R = 1\n};\n\nstruct Node {\n\tNode *child[2], *parent, **root;\n\tT value;\n\tint size, count;\n}\n```\n\n### Splay \n `NULL` \n\n```cpp\nvoid splay(Node *targetParent = NULL) {\n\twhile (parent != targetParent) {\n\t\tif (parent->parent == targetParent) rotate();\n\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\telse rotate(), rotate();\n\t}\n}\n```\n\n###  / \n `Splay` \n\n```cpp\nNode *pred() {\n\tsplay();\n\tNode *v = child[L];\n\twhile (v->child[R]) v = v->child[R];\n\treturn v;\n}\n\nNode *succ() {\n\tsplay();\n\tNode *v = child[R];\n\twhile (v->child[L]) v = v->child[L];\n\treturn v;\n}\n```\n\n### \n `k` **`k`  `[rank + 1, rank + count]`**\n\n```cpp\nNode *select(int k) {\n\tk++;\n\tNode *v = root;\n\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\tif (k < v->rank() + 1) {\n\t\t\tv = v->child[L];\n\t\t} else {\n\t\t\tk -= v->rank() + v->count;\n\t\t\tv = v->child[R];\n\t\t}\n\t}\n\tv->splay();\n\treturn v;\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size, count;\n\n\t\tNode(Node *parent, const T &value, Node **root) : parent(parent), value(value), root(root), count(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + count;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tif (value < v->value) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\n\t\tif (!v) return NULL;\n\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->maintain();\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) {\n\t\t\t\ttarget = &parent->child[L];\n\t\t\t} else {\n\t\t\t\ttarget = &parent->child[R];\n\t\t\t}\n\t\t}\n\n\t\t*target = new Node(parent, value, &root);\n\t\t(*target)->splay();\n\n\t\treturn root;\n\t}\n\n\tvoid erase(const T &value) {\n\t\terase(find(value));\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count != 1) {\n\t\t\tv->splay();\n\t\t\tv->count--;\n\t\t\tv->maintain();\n\t\t\treturn;\n\t\t}\n\n\t\tNode *pred = v->pred();\n\t\tNode *succ = v->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint ans = v->rank();\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + v->count;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->pred()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->pred()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->succ()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->succ()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n};\n\nint n;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth) {\n\tif (v->child[Splay<int, INT_MAX>::L]) dfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d\\n\", v->value);\n\tif (v->child[Splay<int, INT_MAX>::R]) dfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint command, x;\n\t\tscanf(\"%d %d\", &command, &x);\n\t\tif (command == 1) {\n\t\t\tsplay.insert(x);\n\t\t} else if (command == 2) {\n\t\t\tsplay.erase(x);\n\t\t} else if (command == 3) {\n\t\t\tprintf(\"%d\\n\", splay.rank(x));\n\t\t} else if (command == 4) {\n\t\t\tprintf(\"%d\\n\", splay.select(x)->value);\n\t\t} else if (command == 5) {\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t} else if (command == 6) {\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/splay-notes-3.md","raw":"title: Splay \ncategories: OI\ntags: \n  - Splay\n  - \n  - \n  - \npermalink: splay-notes-3\ndate: 2016-01-19 20:02:00\n---\n\nSplay  Splay  Splay \n\n[Splay  + ](/splay-template)\n\n<!-- more -->\n\n### \n0 1 \n\n `count` \n```cpp\nenum Relation {\n\tL = 0, R = 1\n};\n\nstruct Node {\n\tNode *child[2], *parent, **root;\n\tT value;\n\tint size, count;\n}\n```\n\n### Splay \n `NULL` \n\n```cpp\nvoid splay(Node *targetParent = NULL) {\n\twhile (parent != targetParent) {\n\t\tif (parent->parent == targetParent) rotate();\n\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\telse rotate(), rotate();\n\t}\n}\n```\n\n###  / \n `Splay` \n\n```cpp\nNode *pred() {\n\tsplay();\n\tNode *v = child[L];\n\twhile (v->child[R]) v = v->child[R];\n\treturn v;\n}\n\nNode *succ() {\n\tsplay();\n\tNode *v = child[R];\n\twhile (v->child[L]) v = v->child[L];\n\treturn v;\n}\n```\n\n### \n `k` **`k`  `[rank + 1, rank + count]`**\n\n```cpp\nNode *select(int k) {\n\tk++;\n\tNode *v = root;\n\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\tif (k < v->rank() + 1) {\n\t\t\tv = v->child[L];\n\t\t} else {\n\t\t\tk -= v->rank() + v->count;\n\t\t\tv = v->child[R];\n\t\t}\n\t}\n\tv->splay();\n\treturn v;\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size, count;\n\n\t\tNode(Node *parent, const T &value, Node **root) : parent(parent), value(value), root(root), count(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + count;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tif (value < v->value) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\n\t\tif (!v) return NULL;\n\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->maintain();\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) {\n\t\t\t\ttarget = &parent->child[L];\n\t\t\t} else {\n\t\t\t\ttarget = &parent->child[R];\n\t\t\t}\n\t\t}\n\n\t\t*target = new Node(parent, value, &root);\n\t\t(*target)->splay();\n\n\t\treturn root;\n\t}\n\n\tvoid erase(const T &value) {\n\t\terase(find(value));\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count != 1) {\n\t\t\tv->splay();\n\t\t\tv->count--;\n\t\t\tv->maintain();\n\t\t\treturn;\n\t\t}\n\n\t\tNode *pred = v->pred();\n\t\tNode *succ = v->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint ans = v->rank();\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (!(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + v->count;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->pred()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->pred()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->succ()->value;\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tconst T &ans = v->succ()->value;\n\t\t\terase(v);\n\t\t\treturn ans;\n\t\t}\n\t}\n};\n\nint n;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth) {\n\tif (v->child[Splay<int, INT_MAX>::L]) dfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d\\n\", v->value);\n\tif (v->child[Splay<int, INT_MAX>::R]) dfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint command, x;\n\t\tscanf(\"%d %d\", &command, &x);\n\t\tif (command == 1) {\n\t\t\tsplay.insert(x);\n\t\t} else if (command == 2) {\n\t\t\tsplay.erase(x);\n\t\t} else if (command == 3) {\n\t\t\tprintf(\"%d\\n\", splay.rank(x));\n\t\t} else if (command == 4) {\n\t\t\tprintf(\"%d\\n\", splay.select(x)->value);\n\t\t} else if (command == 5) {\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t} else if (command == 6) {\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"splay-notes-3","published":1,"updated":"2016-12-27T07:29:20.009Z","_id":"cix2l6byh0088c2xl22ay970e","comments":1,"layout":"post","photos":[],"link":""},{"title":"Splay ","id":"7","updated":"2016-01-19T13:07:35.000Z","date":"2015-12-22T21:44:41.000Z","_content":"\n Splay  Splay  /  Splay \n\n<!-- more -->\n\n### \nSplay  Splay  Splay **** Splay\n\n Splay **** `lazy-tag` \n\n```cpp\nstruct node_t {\n\tnode_t *lchild, *rchild, *parent, **root;\n\tT value;\n\tuint size;\n\tbool reversed;\n\tbool bound;\n}\n```\n\n `reversed`  Splay`bound`  Splay  `MIN`  `MAX` \n\n### de\n Splay `build()`********\n\n```cpp\nvoid build(const T *a, uint n) {\n\troot = build(a, 1, n, NULL);\n\n\tnode_t **lbound = &root, *lbound_parent = NULL;\n\twhile (*lbound) {\n\t\tlbound_parent = *lbound;\n\t\tlbound_parent->size++;\n\t\tlbound = &(*lbound)->lchild;\n\t}\n\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\tnode_t **rbound = &root, *rbound_parent = NULL;\n\twhile (*rbound) {\n\t\trbound_parent = *rbound;\n\t\trbound_parent->size++;\n\t\trbound = &(*rbound)->rchild;\n\t}\n\t*rbound = new node_t(rbound_parent, &root, 0, true);\n}\n\nnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\tif (l > r) {\n\t\treturn NULL;\n\t}\n\n\tuint mid = l + ((r - l) >> 1);\n\t\t\n\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\tif (l != r) {\n\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\tnode->maintain();\n\t}\n\n\treturn node;\n}\n```\n\n****\n\n****Splay ****** Splay ** Splay \n\n### de\n `lazy-tag`  Splay \n\n```cpp\nnode_t *pushdown() {\n\tif (reversed) {\n\t\tstd::swap(lchild, rchild);\n\n\t\tif (lchild) {\n\t\t\tlchild->reversed ^= 1;\n\t\t}\n\n\t\tif (rchild) {\n\t\t\trchild->reversed ^= 1;\n\t\t}\n\n\t\treversed = false;\n\t}\n\n\treturn this;\n}\n```\n`^= 1` \n\n### de\n `select()`  Splay  `k` \n\n```cpp\nnode_t *select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (k != node->pushdown()->lsize() + 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay();\n}\n```\n\n****`while`  `node->lsize()`  `node` ****\n\n### de\n `select()` ****\n\n Splay \n\n1.  `Splay` ****\n2.  `Splay` ****\n3. \n\n********\n\n```cpp\nnode_t *select(uint l, uint r) {\n\tnode_t *lbound = select(l - 1);\n\tnode_t *rbound = select(r + 1);\n\n\tlbound->splay();\n\trbound->splay(&lbound->rchild);\n\n\treturn rbound->lchild;\n}\n```\n\n### de\n\n\n\n\n```cpp\nvoid reverse(uint l, uint r) {\n\tnode_t *range = select(l, r);\n\trange->reversed ^= 1;\n}\n```\n\n### de\n `fetch()` \n\n```C++\nvoid fetch(T *a) {\n\tdfs(a, root);\n}\n\nvoid dfs(T *&a, node_t *node) {\n\tif (node) {\n\t\tnode->pushdown();\n\n\t\tdfs(a, node->lchild);\n\n\t\tif (!node->bound) {\n\t\t\t*a++ = node->value;\n\t\t}\n\n\t\tdfs(a, node->rchild);\n\t}\n}\n```\n\n `pushdown()` \n\n### \n****\n\n `pushdown()`** `relation()`**\n\n```C++\nvoid rotate() {\n\tparent->pushdown();\n\tpushdown();\n\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n`Splay`  `pushdown()` `relation()`\n\n```C++\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tparent->pushdown();\n\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\n}\n```\n\n `select()`  `dfs()`  `pushdown()`\n\n### Tyvj / BZOJ \n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\nconst uint MAXM = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T>\nstruct splay_t {\n\tstruct node_t {\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tT value;\n\t\tuint size;\n\t\tbool reversed;\n\t\tbool bound;\n\n\t\tnode_t(node_t *parent, node_t **root, const T &value, bool bound = false) : parent(parent), lchild(NULL), rchild(NULL), root(root), value(value), size(1), reversed(false), bound(bound) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tnode_t *pushdown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(lchild, rchild);\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tparent->pushdown();\n\t\t\tpushdown();\n\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tparent->pushdown();\n\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\t} *root;\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tvoid build(const T *a, uint n) {\n\t\troot = build(a, 1, n, NULL);\n\n\t\tnode_t **lbound = &root, *lbound_parent = NULL;\n\t\twhile (*lbound) {\n\t\t\tlbound_parent = *lbound;\n\t\t\tlbound_parent->size++;\n\t\t\tlbound = &(*lbound)->lchild;\n\t\t}\n\t\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\t\tnode_t **rbound = &root, *rbound_parent = NULL;\n\t\twhile (*rbound) {\n\t\t\trbound_parent = *rbound;\n\t\t\trbound_parent->size++;\n\t\t\trbound = &(*rbound)->rchild;\n\t\t}\n\t\t*rbound = new node_t(rbound_parent, &root, 0, true);\n\t}\n\n\tnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\t\tif (l > r) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tuint mid = l + ((r - l) >> 1);\n\t\t\n\t\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\t\tif (l != r) {\n\t\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\t\tnode->maintain();\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tnode_t *select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (k != node->pushdown()->lsize() + 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay();\n\t}\n\n\tnode_t *select(uint l, uint r) {\n\t\tnode_t *lbound = select(l - 1);\n\t\tnode_t *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(&lbound->rchild);\n\n\t\treturn rbound->lchild;\n\t}\n\n\tvoid reverse(uint l, uint r) {\n\t\tnode_t *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfs(a, root);\n\t}\n\n\tvoid dfs(T *&a, node_t *node) {\n\t\tif (node) {\n\t\t\tnode->pushdown();\n\n\t\t\tdfs(a, node->lchild);\n\n\t\t\tif (!node->bound) {\n\t\t\t\t*a++ = node->value;\n\t\t\t}\n\t\t\t\n\t\t\tdfs(a, node->rchild);\n\t\t}\n\t}\n};\n\nvoid dfs(splay_t<uint>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<uint>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n, m;\nsplay_t<uint> splay;\nuint a[MAXN];\n\nint main() {\n\tscanf(\"%u %u\", &n, &m);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\ta[i] = i + 1;\n\t}\n\n\tsplay.build(a, n);\n\n\tfor (uint i = 0; i < m; i++) {\n\t\tuint l, r;\n\t\tscanf(\"%u %u\", &l, &r);\n\t\tsplay.reverse(l, r);\n\t}\n\n\tsplay.fetch(a);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tprintf(\"%u \", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n### \n Splay  Splay ","source":"_posts/splay-notes-2.md","raw":"title: Splay \ncategories: OI\ntags: \n  - BZOJ\n  - Splay\n  - \n  - \n  - \npermalink: splay-notes-2\nid: 7\nupdated: '2016-01-19 21:07:35'\ndate: 2015-12-23 05:44:41\n---\n\n Splay  Splay  /  Splay \n\n<!-- more -->\n\n### \nSplay  Splay  Splay **** Splay\n\n Splay **** `lazy-tag` \n\n```cpp\nstruct node_t {\n\tnode_t *lchild, *rchild, *parent, **root;\n\tT value;\n\tuint size;\n\tbool reversed;\n\tbool bound;\n}\n```\n\n `reversed`  Splay`bound`  Splay  `MIN`  `MAX` \n\n### de\n Splay `build()`********\n\n```cpp\nvoid build(const T *a, uint n) {\n\troot = build(a, 1, n, NULL);\n\n\tnode_t **lbound = &root, *lbound_parent = NULL;\n\twhile (*lbound) {\n\t\tlbound_parent = *lbound;\n\t\tlbound_parent->size++;\n\t\tlbound = &(*lbound)->lchild;\n\t}\n\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\tnode_t **rbound = &root, *rbound_parent = NULL;\n\twhile (*rbound) {\n\t\trbound_parent = *rbound;\n\t\trbound_parent->size++;\n\t\trbound = &(*rbound)->rchild;\n\t}\n\t*rbound = new node_t(rbound_parent, &root, 0, true);\n}\n\nnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\tif (l > r) {\n\t\treturn NULL;\n\t}\n\n\tuint mid = l + ((r - l) >> 1);\n\t\t\n\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\tif (l != r) {\n\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\tnode->maintain();\n\t}\n\n\treturn node;\n}\n```\n\n****\n\n****Splay ****** Splay ** Splay \n\n### de\n `lazy-tag`  Splay \n\n```cpp\nnode_t *pushdown() {\n\tif (reversed) {\n\t\tstd::swap(lchild, rchild);\n\n\t\tif (lchild) {\n\t\t\tlchild->reversed ^= 1;\n\t\t}\n\n\t\tif (rchild) {\n\t\t\trchild->reversed ^= 1;\n\t\t}\n\n\t\treversed = false;\n\t}\n\n\treturn this;\n}\n```\n`^= 1` \n\n### de\n `select()`  Splay  `k` \n\n```cpp\nnode_t *select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (k != node->pushdown()->lsize() + 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay();\n}\n```\n\n****`while`  `node->lsize()`  `node` ****\n\n### de\n `select()` ****\n\n Splay \n\n1.  `Splay` ****\n2.  `Splay` ****\n3. \n\n********\n\n```cpp\nnode_t *select(uint l, uint r) {\n\tnode_t *lbound = select(l - 1);\n\tnode_t *rbound = select(r + 1);\n\n\tlbound->splay();\n\trbound->splay(&lbound->rchild);\n\n\treturn rbound->lchild;\n}\n```\n\n### de\n\n\n\n\n```cpp\nvoid reverse(uint l, uint r) {\n\tnode_t *range = select(l, r);\n\trange->reversed ^= 1;\n}\n```\n\n### de\n `fetch()` \n\n```C++\nvoid fetch(T *a) {\n\tdfs(a, root);\n}\n\nvoid dfs(T *&a, node_t *node) {\n\tif (node) {\n\t\tnode->pushdown();\n\n\t\tdfs(a, node->lchild);\n\n\t\tif (!node->bound) {\n\t\t\t*a++ = node->value;\n\t\t}\n\n\t\tdfs(a, node->rchild);\n\t}\n}\n```\n\n `pushdown()` \n\n### \n****\n\n `pushdown()`** `relation()`**\n\n```C++\nvoid rotate() {\n\tparent->pushdown();\n\tpushdown();\n\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n`Splay`  `pushdown()` `relation()`\n\n```C++\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tparent->pushdown();\n\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\n}\n```\n\n `select()`  `dfs()`  `pushdown()`\n\n### Tyvj / BZOJ \n\n```cpp\n#include <cstdio>\n#include <algorithm>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\nconst uint MAXM = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T>\nstruct splay_t {\n\tstruct node_t {\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tT value;\n\t\tuint size;\n\t\tbool reversed;\n\t\tbool bound;\n\n\t\tnode_t(node_t *parent, node_t **root, const T &value, bool bound = false) : parent(parent), lchild(NULL), rchild(NULL), root(root), value(value), size(1), reversed(false), bound(bound) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tnode_t *pushdown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(lchild, rchild);\n\n\t\t\t\tif (lchild) {\n\t\t\t\t\tlchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\tif (rchild) {\n\t\t\t\t\trchild->reversed ^= 1;\n\t\t\t\t}\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tparent->pushdown();\n\t\t\tpushdown();\n\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tparent->pushdown();\n\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\t} *root;\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tvoid build(const T *a, uint n) {\n\t\troot = build(a, 1, n, NULL);\n\n\t\tnode_t **lbound = &root, *lbound_parent = NULL;\n\t\twhile (*lbound) {\n\t\t\tlbound_parent = *lbound;\n\t\t\tlbound_parent->size++;\n\t\t\tlbound = &(*lbound)->lchild;\n\t\t}\n\t\t*lbound = new node_t(lbound_parent, &root, 0, true);\n\n\n\t\tnode_t **rbound = &root, *rbound_parent = NULL;\n\t\twhile (*rbound) {\n\t\t\trbound_parent = *rbound;\n\t\t\trbound_parent->size++;\n\t\t\trbound = &(*rbound)->rchild;\n\t\t}\n\t\t*rbound = new node_t(rbound_parent, &root, 0, true);\n\t}\n\n\tnode_t *build(const T *a, uint l, uint r, node_t *parent) {\n\t\tif (l > r) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tuint mid = l + ((r - l) >> 1);\n\t\t\n\t\tnode_t *node = new node_t(parent, &root, a[mid - 1]);\n\t\tif (l != r) {\n\t\t\tnode->lchild = build(a, l, mid - 1, node);\n\t\t\tnode->rchild = build(a, mid + 1, r, node);\n\t\t\tnode->maintain();\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tnode_t *select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (k != node->pushdown()->lsize() + 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay();\n\t}\n\n\tnode_t *select(uint l, uint r) {\n\t\tnode_t *lbound = select(l - 1);\n\t\tnode_t *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(&lbound->rchild);\n\n\t\treturn rbound->lchild;\n\t}\n\n\tvoid reverse(uint l, uint r) {\n\t\tnode_t *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfs(a, root);\n\t}\n\n\tvoid dfs(T *&a, node_t *node) {\n\t\tif (node) {\n\t\t\tnode->pushdown();\n\n\t\t\tdfs(a, node->lchild);\n\n\t\t\tif (!node->bound) {\n\t\t\t\t*a++ = node->value;\n\t\t\t}\n\t\t\t\n\t\t\tdfs(a, node->rchild);\n\t\t}\n\t}\n};\n\nvoid dfs(splay_t<uint>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<uint>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n, m;\nsplay_t<uint> splay;\nuint a[MAXN];\n\nint main() {\n\tscanf(\"%u %u\", &n, &m);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\ta[i] = i + 1;\n\t}\n\n\tsplay.build(a, n);\n\n\tfor (uint i = 0; i < m; i++) {\n\t\tuint l, r;\n\t\tscanf(\"%u %u\", &l, &r);\n\t\tsplay.reverse(l, r);\n\t}\n\n\tsplay.fetch(a);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tprintf(\"%u \", a[i]);\n\t}\n\n\treturn 0;\n}\n```\n\n### \n Splay  Splay ","slug":"splay-notes-2","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6byn008ec2xlcm86l0z4"},{"title":"Splay ","date":"2015-12-19T21:36:24.000Z","_content":"\n Splay FireStorm [Splay](http://blog.csdn.net/farestorm/article/details/49153565)\n\n[Splay  + ](/splay-template)\n\n<!-- more -->\n\n### Splay ?\nSplay Tree$O({\\log} n)$ Splay\n\n### \nSplay  Splay <  <  Splay \n\n```cpp\nstruct node_t {\n\tT value;\n\tnode_t *lchild, *rchild, *parent, **root;\n\tuint size;\n};\n```\n `root` **** Splay `size`  Splay  `size`\n\n### \n `node_t` \n```cpp\nnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n~node_t() {\n\tif (lchild) {\n\t\tdelete lchild;\n\t}\n\n\tif (rchild) {\n\t\tdelete rchild;\n\t}\n}\n\nnode_t *grandparent() {\n\treturn !parent ? NULL : parent->parent;\n}\n\nnode_t *&child(uint x) {\n\treturn !x ? lchild : rchild;\n}\n\nuint relation() {\n\treturn this == parent->lchild ? 0 : 1;\n}\n\nuint maintain() {\n\tsize = lsize() + rsize() + 1;\n}\n\nuint lsize() {\n\treturn lchild ? lchild->size : 0;\n}\n\nuint rsize() {\n\treturn rchild ? rchild->size : 0;\n}\n```\n `node_t` \n\n `0` `1``relation()`  `child()`  `x` ****\n\n`maintain()`  Splay ****\n\n### \n Splay  `rotate()` ****\n\n1.  Splay \n2.  `size` \n3. `*root`  Splay \n\n\n\n1. ****\n2. ********\n3. ****\n4.  `*root`\n\n FireStorm [Splay](http://blog.csdn.net/farestorm/article/details/49153565)\n![splay](splay-notes-1/splay.png)\n\n\n```cpp\nvoid rotate() {\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n### Splay \nSplay \n\n `Splay` `Splay` \n\n1. \n2. ********\n3. \n\n\n```cpp\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\t\n}\n```\n\n### \n\n\n `target` `target`  `target`  `target`  `NULL`\n\n `Splay` \n\n\n```cpp\nnode_t *insert(const T &value) {\n\tnode_t **target = &root, *parent = NULL;\n\n\twhile (*target) {\n\t\tparent = *target;\n\t\tparent->size++;\n\n\t\tif (value < (*target)->value) {\n\t\t\ttarget = &(*target)->lchild;\n\t\t} else {\n\t\t\ttarget = &(*target)->rchild;\n\t\t}\n\t}\n\n\t*target = new node_t(value, parent, &root);\n\treturn (*target)->splay();\n}\n```\n\n**** Splay ****\n```cpp\nsplay_t() : root(NULL) {\n\tinsert(MIN);\n\tinsert(MAX);\n}\n```\n### \n `NULL`\n\n********\n\n `Splay` \n\n\n```cpp\nnode_t *find(const T &value) {\n\tnode_t *node = root;\n\twhile (node && value != node->value) {\n\t\tif (value < node->value) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\tif (node) {\n\t\treturn node->pred()->succ()->splay();\n\t} else {\n\t\treturn NULL;\n\t}\n}\n```\n\n### \n****\n\n Splay  `Splay`  `size + 1`  `1` \n\n `1`  `0`\n\n\n```cpp\nuint rank(const T &value) {\n\treturn find(value)->lsize();\n}\n```\n\n### \n**** `k` \n\nSplay \n\n1. \n2. ** Splay ** `k - 1`\n3.  `k`  `k` ********\n\n `Splay` \n\n\n```cpp\nconst T &select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (node->lsize() != k - 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay()->value;\n}\n```\n\n###  / \n********\n\n Splay \n\n1.  `Splay` \n2. ****************\n3.  1\n\n `Splay` \n\n\n```cpp\nnode_t *pred() {\n\tnode_t *pred = this;\n\n\twhile (pred->value == this->value) {\n\t\tpred->splay();\n\t\tpred = pred->lchild;\n\n\t\twhile (pred->rchild) {\n\t\t\tpred = pred->rchild;\n\t\t}\n\t}\n\n\treturn pred->splay();\n}\n\nnode_t *succ() {\n\tnode_t *succ = this;\n\n\twhile (succ->value == this->value) {\n\t\tsucc->splay();\n\t\tsucc = succ->rchild;\n\n\t\twhile (succ->lchild) {\n\t\t\tsucc = succ->lchild;\n\t\t}\n\t}\n\n\treturn succ->splay();\n}\n```\n\n###  / \n `x`  `x`  `x`  `x` \n\n\n\n1. \n2.  1 \n\n\n```cpp\nconst T &pred(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->pred()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->pred()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n\nconst T &succ(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->succ()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->succ()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n```\n\n###  / \nSplay \n\nSplay \n\n1.  `Splay` \n2.  `Splay` ****\n3. ****\n4.  `size`\n\n\n```cpp\nvoid erase(const T &value) {\n\tnode_t *node = find(value);\n\terase(node);\n}\n\nvoid erase(const T &l, const T &r) {\n\terase(find(l), find(r));\n}\n\nvoid erase(node_t *l, node_t *r = NULL) {\n\tif (!r) {\n\t\tr = l;\n\t}\n\n\tnode_t *pred = l->pred();\n\tnode_t *succ = r->succ();\n\n\tpred->splay();\n\tsucc->splay(&pred->rchild);\n\n\tdelete succ->lchild;\n\tsucc->lchild = NULL;\n\n\tsucc->maintain();\n\tpred->maintain();\n}\n```\n\n### Tyvj / BZOJ / CodeVS \n```cpp\n#include <cstdio>\n#include <climits>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T, T MIN, T MAX>\nstruct splay_t {\n\tstruct node_t {\n\t\tT value;\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tuint size;\n\n\t\tnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\n\t\t\tnode_t *pred() {\n\t\t\t\tnode_t *pred = this;\n\n\t\t\t\twhile (pred->value == this->value) {\n\t\t\t\t\tpred->splay();\n\t\t\t\t\tpred = pred->lchild;\n\n\t\t\t\t\twhile (pred->rchild) {\n\t\t\t\t\t\tpred = pred->rchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn pred->splay();\n\t\t\t}\n\n\t\t\tnode_t *succ() {\n\t\t\t\tnode_t *succ = this;\n\n\t\t\t\twhile (succ->value == this->value) {\n\t\t\t\t\tsucc->splay();\n\t\t\t\t\tsucc = succ->rchild;\n\n\t\t\t\t\twhile (succ->lchild) {\n\t\t\t\t\t\tsucc = succ->lchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn succ->splay();\n\t\t\t}\n\t} *root;\n\n\tsplay_t() : root(NULL) {\n\t\tinsert(MIN);\n\t\tinsert(MAX);\n\t}\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tnode_t *insert(const T &value) {\n\t\tnode_t **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\n\t\t\tif (value < (*target)->value) {\n\t\t\t\ttarget = &(*target)->lchild;\n\t\t\t} else {\n\t\t\t\ttarget = &(*target)->rchild;\n\t\t\t}\n\t\t}\n\n\t\t*target = new node_t(value, parent, &root);\n\t\treturn (*target)->splay();\n\t}\n\n\tnode_t *find(const T &value) {\n\t\tnode_t *node = root;\n\t\twhile (node && value != node->value) {\n\t\t\tif (value < node->value) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\tif (node) {\n\t\t\treturn node->pred()->succ()->splay();\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tuint rank(const T &value) {\n\t\treturn find(value)->lsize();\n\t}\n\n\tconst T &select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (node->lsize() != k - 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay()->value;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->pred()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->pred()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->succ()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->succ()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid erase(const T &value) {\n\t\tnode_t *node = find(value);\n\t\terase(node);\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\terase(find(l), find(r));\n\t}\n\n\tvoid erase(node_t *l, node_t *r = NULL) {\n\t\tif (!r) {\n\t\t\tr = l;\n\t\t}\n\n\t\tnode_t *pred = l->pred();\n\t\tnode_t *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(&pred->rchild);\n\n\t\tdelete succ->lchild;\n\t\tsucc->lchild = NULL;\n\n\t\tsucc->maintain();\n\t\tpred->maintain();\n\t}\n};\n\nvoid dfs(splay_t<int, INT_MIN, INT_MAX>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<int, INT_MIN, INT_MAX>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n;\nsplay_t<int, INT_MIN, INT_MAX> splay;\n\nint main() {\n\tscanf(\"%u\", &n);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tuint command;\n\t\tint x;\n\t\tscanf(\"%u %d\", &command, &x);\n\n\t\tswitch (command) {\n\t\tcase 1:\n\t\t\tsplay.insert(x);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tsplay.erase(x);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tprintf(\"%u\\n\", splay.rank(x));\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tprintf(\"%d\\n\", splay.select(x));\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/splay-notes-1.md","raw":"title: Splay \ncategories: OI\ntags: \n  - BZOJ\n  - Splay\n  - \n  - \n  - \npermalink: splay-notes-1\ndate: 2015-12-20 05:36:24\n---\n\n Splay FireStorm [Splay](http://blog.csdn.net/farestorm/article/details/49153565)\n\n[Splay  + ](/splay-template)\n\n<!-- more -->\n\n### Splay ?\nSplay Tree$O({\\log} n)$ Splay\n\n### \nSplay  Splay <  <  Splay \n\n```cpp\nstruct node_t {\n\tT value;\n\tnode_t *lchild, *rchild, *parent, **root;\n\tuint size;\n};\n```\n `root` **** Splay `size`  Splay  `size`\n\n### \n `node_t` \n```cpp\nnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n~node_t() {\n\tif (lchild) {\n\t\tdelete lchild;\n\t}\n\n\tif (rchild) {\n\t\tdelete rchild;\n\t}\n}\n\nnode_t *grandparent() {\n\treturn !parent ? NULL : parent->parent;\n}\n\nnode_t *&child(uint x) {\n\treturn !x ? lchild : rchild;\n}\n\nuint relation() {\n\treturn this == parent->lchild ? 0 : 1;\n}\n\nuint maintain() {\n\tsize = lsize() + rsize() + 1;\n}\n\nuint lsize() {\n\treturn lchild ? lchild->size : 0;\n}\n\nuint rsize() {\n\treturn rchild ? rchild->size : 0;\n}\n```\n `node_t` \n\n `0` `1``relation()`  `child()`  `x` ****\n\n`maintain()`  Splay ****\n\n### \n Splay  `rotate()` ****\n\n1.  Splay \n2.  `size` \n3. `*root`  Splay \n\n\n\n1. ****\n2. ********\n3. ****\n4.  `*root`\n\n FireStorm [Splay](http://blog.csdn.net/farestorm/article/details/49153565)\n![splay](splay-notes-1/splay.png)\n\n\n```cpp\nvoid rotate() {\n\tnode_t *old = parent;\n\tuint x = relation();\n\n\tif (grandparent()) {\n\t\tgrandparent()->child(old->relation()) = this;\n\t}\n\tparent = grandparent();\n\n\told->child(x) = child(x ^ 1);\n\tif (child(x ^ 1)) {\n\t\tchild(x ^ 1)->parent = old;\n\t}\n\n\tchild(x ^ 1) = old;\n\told->parent = this;\n\n\told->maintain();\n\tmaintain();\n\n\tif (!parent) {\n\t\t*root = this;\n\t}\n}\n```\n\n### Splay \nSplay \n\n `Splay` `Splay` \n\n1. \n2. ********\n3. \n\n\n```cpp\nnode_t *splay(node_t **target = NULL) {\n\tif (!target) {\n\t\ttarget = root;\n\t}\n\n\twhile (this != *target) {\n\t\tif (parent == *target) {\n\t\t\trotate();\n\t\t} else if (relation() == parent->relation()) {\n\t\t\tparent->rotate(), rotate();\n\t\t} else {\n\t\t\trotate(), rotate();\n\t\t}\n\t}\n\n\treturn *target;\t\n}\n```\n\n### \n\n\n `target` `target`  `target`  `target`  `NULL`\n\n `Splay` \n\n\n```cpp\nnode_t *insert(const T &value) {\n\tnode_t **target = &root, *parent = NULL;\n\n\twhile (*target) {\n\t\tparent = *target;\n\t\tparent->size++;\n\n\t\tif (value < (*target)->value) {\n\t\t\ttarget = &(*target)->lchild;\n\t\t} else {\n\t\t\ttarget = &(*target)->rchild;\n\t\t}\n\t}\n\n\t*target = new node_t(value, parent, &root);\n\treturn (*target)->splay();\n}\n```\n\n**** Splay ****\n```cpp\nsplay_t() : root(NULL) {\n\tinsert(MIN);\n\tinsert(MAX);\n}\n```\n### \n `NULL`\n\n********\n\n `Splay` \n\n\n```cpp\nnode_t *find(const T &value) {\n\tnode_t *node = root;\n\twhile (node && value != node->value) {\n\t\tif (value < node->value) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\tif (node) {\n\t\treturn node->pred()->succ()->splay();\n\t} else {\n\t\treturn NULL;\n\t}\n}\n```\n\n### \n****\n\n Splay  `Splay`  `size + 1`  `1` \n\n `1`  `0`\n\n\n```cpp\nuint rank(const T &value) {\n\treturn find(value)->lsize();\n}\n```\n\n### \n**** `k` \n\nSplay \n\n1. \n2. ** Splay ** `k - 1`\n3.  `k`  `k` ********\n\n `Splay` \n\n\n```cpp\nconst T &select(uint k) {\n\tk++;\n\tnode_t *node = root;\n\twhile (node->lsize() != k - 1) {\n\t\tif (k < node->lsize() + 1) {\n\t\t\tnode = node->lchild;\n\t\t} else {\n\t\t\tk -= node->lsize() + 1;\n\t\t\tnode = node->rchild;\n\t\t}\n\t}\n\n\treturn node->splay()->value;\n}\n```\n\n###  / \n********\n\n Splay \n\n1.  `Splay` \n2. ****************\n3.  1\n\n `Splay` \n\n\n```cpp\nnode_t *pred() {\n\tnode_t *pred = this;\n\n\twhile (pred->value == this->value) {\n\t\tpred->splay();\n\t\tpred = pred->lchild;\n\n\t\twhile (pred->rchild) {\n\t\t\tpred = pred->rchild;\n\t\t}\n\t}\n\n\treturn pred->splay();\n}\n\nnode_t *succ() {\n\tnode_t *succ = this;\n\n\twhile (succ->value == this->value) {\n\t\tsucc->splay();\n\t\tsucc = succ->rchild;\n\n\t\twhile (succ->lchild) {\n\t\t\tsucc = succ->lchild;\n\t\t}\n\t}\n\n\treturn succ->splay();\n}\n```\n\n###  / \n `x`  `x`  `x`  `x` \n\n\n\n1. \n2.  1 \n\n\n```cpp\nconst T &pred(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->pred()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->pred()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n\nconst T &succ(const T &value) {\n\tnode_t *node = find(value);\n\n\tif (node) {\n\t\treturn node->succ()->value;\n\t} else {\n\t\tnode = insert(value);\n\t\tconst T &result = node->succ()->value;\n\t\terase(node);\n\t\treturn result;\n\t}\n}\n```\n\n###  / \nSplay \n\nSplay \n\n1.  `Splay` \n2.  `Splay` ****\n3. ****\n4.  `size`\n\n\n```cpp\nvoid erase(const T &value) {\n\tnode_t *node = find(value);\n\terase(node);\n}\n\nvoid erase(const T &l, const T &r) {\n\terase(find(l), find(r));\n}\n\nvoid erase(node_t *l, node_t *r = NULL) {\n\tif (!r) {\n\t\tr = l;\n\t}\n\n\tnode_t *pred = l->pred();\n\tnode_t *succ = r->succ();\n\n\tpred->splay();\n\tsucc->splay(&pred->rchild);\n\n\tdelete succ->lchild;\n\tsucc->lchild = NULL;\n\n\tsucc->maintain();\n\tpred->maintain();\n}\n```\n\n### Tyvj / BZOJ / CodeVS \n```cpp\n#include <cstdio>\n#include <climits>\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100000;\n\nvoid print(void *node);\n\ntemplate <typename T, T MIN, T MAX>\nstruct splay_t {\n\tstruct node_t {\n\t\tT value;\n\t\tnode_t *lchild, *rchild, *parent, **root;\n\t\tuint size;\n\n\t\tnode_t(const T &value, node_t *parent, node_t **root) : value(value), parent(parent), lchild(NULL), rchild(NULL), size(1), root(root) {}\n\n\t\t~node_t() {\n\t\t\tif (lchild) {\n\t\t\t\tdelete lchild;\n\t\t\t}\n\n\t\t\tif (rchild) {\n\t\t\t\tdelete rchild;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *grandparent() {\n\t\t\treturn !parent ? NULL : parent->parent;\n\t\t}\n\n\t\tnode_t *&child(uint x) {\n\t\t\treturn !x ? lchild : rchild;\n\t\t}\n\n\t\tuint relation() {\n\t\t\treturn this == parent->lchild ? 0 : 1;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = lsize() + rsize() + 1;\n\t\t}\n\n\t\tuint lsize() {\n\t\t\treturn lchild ? lchild->size : 0;\n\t\t}\n\n\t\tuint rsize() {\n\t\t\treturn rchild ? rchild->size : 0;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tnode_t *old = parent;\n\t\t\tuint x = relation();\n\n\t\t\tif (grandparent()) {\n\t\t\t\tgrandparent()->child(old->relation()) = this;\n\t\t\t}\n\t\t\tparent = grandparent();\n\n\t\t\told->child(x) = child(x ^ 1);\n\t\t\tif (child(x ^ 1)) {\n\t\t\t\tchild(x ^ 1)->parent = old;\n\t\t\t}\n\n\t\t\tchild(x ^ 1) = old;\n\t\t\told->parent = this;\n\n\t\t\told->maintain();\n\t\t\tmaintain();\n\n\t\t\tif (!parent) {\n\t\t\t\t*root = this;\n\t\t\t}\n\t\t}\n\n\t\tnode_t *splay(node_t **target = NULL) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = root;\n\t\t\t}\n\n\t\t\twhile (this != *target) {\n\t\t\t\tif (parent == *target) {\n\t\t\t\t\trotate();\n\t\t\t\t} else if (relation() == parent->relation()) {\n\t\t\t\t\tparent->rotate(), rotate();\n\t\t\t\t} else {\n\t\t\t\t\trotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn *target;\n\t\t}\n\n\t\t\tnode_t *pred() {\n\t\t\t\tnode_t *pred = this;\n\n\t\t\t\twhile (pred->value == this->value) {\n\t\t\t\t\tpred->splay();\n\t\t\t\t\tpred = pred->lchild;\n\n\t\t\t\t\twhile (pred->rchild) {\n\t\t\t\t\t\tpred = pred->rchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn pred->splay();\n\t\t\t}\n\n\t\t\tnode_t *succ() {\n\t\t\t\tnode_t *succ = this;\n\n\t\t\t\twhile (succ->value == this->value) {\n\t\t\t\t\tsucc->splay();\n\t\t\t\t\tsucc = succ->rchild;\n\n\t\t\t\t\twhile (succ->lchild) {\n\t\t\t\t\t\tsucc = succ->lchild;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn succ->splay();\n\t\t\t}\n\t} *root;\n\n\tsplay_t() : root(NULL) {\n\t\tinsert(MIN);\n\t\tinsert(MAX);\n\t}\n\n\t~splay_t() {\n\t\tdelete root;\n\t}\n\n\tnode_t *insert(const T &value) {\n\t\tnode_t **target = &root, *parent = NULL;\n\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->size++;\n\n\t\t\tif (value < (*target)->value) {\n\t\t\t\ttarget = &(*target)->lchild;\n\t\t\t} else {\n\t\t\t\ttarget = &(*target)->rchild;\n\t\t\t}\n\t\t}\n\n\t\t*target = new node_t(value, parent, &root);\n\t\treturn (*target)->splay();\n\t}\n\n\tnode_t *find(const T &value) {\n\t\tnode_t *node = root;\n\t\twhile (node && value != node->value) {\n\t\t\tif (value < node->value) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\tif (node) {\n\t\t\treturn node->pred()->succ()->splay();\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tuint rank(const T &value) {\n\t\treturn find(value)->lsize();\n\t}\n\n\tconst T &select(uint k) {\n\t\tk++;\n\t\tnode_t *node = root;\n\t\twhile (node->lsize() != k - 1) {\n\t\t\tif (k < node->lsize() + 1) {\n\t\t\t\tnode = node->lchild;\n\t\t\t} else {\n\t\t\t\tk -= node->lsize() + 1;\n\t\t\t\tnode = node->rchild;\n\t\t\t}\n\t\t}\n\n\t\treturn node->splay()->value;\n\t}\n\n\tconst T &pred(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->pred()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->pred()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tconst T &succ(const T &value) {\n\t\tnode_t *node = find(value);\n\n\t\tif (node) {\n\t\t\treturn node->succ()->value;\n\t\t} else {\n\t\t\tnode = insert(value);\n\t\t\tconst T &result = node->succ()->value;\n\t\t\terase(node);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tvoid erase(const T &value) {\n\t\tnode_t *node = find(value);\n\t\terase(node);\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\terase(find(l), find(r));\n\t}\n\n\tvoid erase(node_t *l, node_t *r = NULL) {\n\t\tif (!r) {\n\t\t\tr = l;\n\t\t}\n\n\t\tnode_t *pred = l->pred();\n\t\tnode_t *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(&pred->rchild);\n\n\t\tdelete succ->lchild;\n\t\tsucc->lchild = NULL;\n\n\t\tsucc->maintain();\n\t\tpred->maintain();\n\t}\n};\n\nvoid dfs(splay_t<int, INT_MIN, INT_MAX>::node_t *node, uint depth = 0) {\n\tif (node) {\n\t\tdfs(node->rchild, depth + 1);\n\t\t\n\t\tfor (uint i = 0; i < depth; i++) {\n\t\t\tputchar(' ');\n\t\t}\n\t\tprintf(\"%d : %u\\n\", node->value, node->size);\n\t\t\n\t\tdfs(node->lchild, depth + 1);\n\t}\n}\n\nvoid print(void *node) {\n\tputs(\"------------------------------------------\");\n\tdfs((splay_t<int, INT_MIN, INT_MAX>::node_t *)node);\n\tputs(\"------------------------------------------\");\n}\n\nuint n;\nsplay_t<int, INT_MIN, INT_MAX> splay;\n\nint main() {\n\tscanf(\"%u\", &n);\n\n\tfor (uint i = 0; i < n; i++) {\n\t\tuint command;\n\t\tint x;\n\t\tscanf(\"%u %d\", &command, &x);\n\n\t\tswitch (command) {\n\t\tcase 1:\n\t\t\tsplay.insert(x);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tsplay.erase(x);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tprintf(\"%u\\n\", splay.rank(x));\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tprintf(\"%d\\n\", splay.select(x));\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tprintf(\"%d\\n\", splay.pred(x));\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tprintf(\"%d\\n\", splay.succ(x));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"splay-notes-1","published":1,"updated":"2016-12-27T07:29:12.333Z","_id":"cix2l6byq008lc2xlii69cjiz","comments":1,"layout":"post","photos":[],"link":""},{"title":"SHOI2008 - ","date":"2016-10-19T06:30:00.000Z","_content":"\n $ 2 $  $ C $  $ 2C $  $ 3C - 2 $ \n\n\n1. `Close r1 c1 r2 c2` $ (r_1, c_1) $  $ (r_2, c_2) $ \n2. `Open r1 c1 r2 c2` $ (r_1, c_1) $  $ (r_2, c_2) $ \n3. `Ask r1 c1 r2 c2` $ (r_1, c_1) $  $ (r_2, c_2) $ \n\n<!-- more -->\n\n### \n[BZOJ 1018](http://www.lydsy.com/JudgeOnline/problem.php?id=1018)\n\n### \n $ (i, 0) $  $ (i, 1) $  $ i $ \n\n $ [l, r] $  $ (l, 0), (l, 1) $  $ (r, 0), (r, 1) $ \n\n $ i $  $ [l = i, r = i] $  $ (l, 0) $  $ (r, 1) $$ (l, 1) $  $ (r, 0) $ \n\n $ [l, m] $  $ [m + 1, r] $  $ m \\leftrightarrow m + 1 $ \n\n $ [l, r] $  $ l $  $ l' $  $ r $  $ r' $ $ [l', r'] $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint n;\nbool right[MAXN][2], middle[MAXN + 1];\n\nstruct Connectivity {\n\tbool a[2][2];\n\n\tConnectivity(const bool init) {\n\t\ta[0][0] = a[0][1] = a[1][0] = a[1][1] = init;\n\t}\n\n\tbool &operator()(const int i, const int j) { return a[i][j]; }\n\tbool operator()(const int i, const int j) const { return a[i][j]; }\n\n\toperator bool() const { return a[0][0] || a[0][1] || a[1][0] || a[1][1]; }\n};\n\nConnectivity merge(Connectivity a, Connectivity b, const int mid) {\n\tConnectivity res(false);\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tres(i, j) |= a(i, k) && right[mid][k] && b(k, j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tConnectivity conn;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), conn(l == r) {}\n\n\tvoid update(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (this->l == this->r) {\n\t\t\tconn(0, 0) = conn(1, 1) = true;\n\t\t\tconn(0, 1) = conn(1, 0) = middle[mid];\n\t\t\treturn;\n\t\t} else if (!(l <= this->l && r >= this->r)) {\n\t\t\tlc->update(l, r);\n\t\t\trc->update(l, r);\n\t\t} else if (this->l == this->r - 1) lc->update(l, r), rc->update(l, r);\n\t\tconn = merge(lc->conn, rc->conn, mid);\n\t}\n\n\tConnectivity query(const int l, const int r) {\n\t\tif (l <= this->l && r >= this->r) return conn;\n\t\telse if (r <= mid) return lc->query(l, r);\n\t\telse if (l > mid) return rc->query(l, r);\n\t\telse return merge(lc->query(l, r), rc->query(l, r), mid);\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segment;\n\ninline void update(int r1, int c1, int r2, int c2, const bool val) {\n\tif (r1 == r2) {\n\t\tright[std::min(c1, c2)][r1] = val;\n\t} else {\n\t\tmiddle[c1] = val;\n\t}\n\tsegment->update(std::min(c1, c2), std::max(c1, c2));\n}\n\ninline bool query(int r1, int c1, int r2, int c2) {\n\tint l, r;\n\n\tl = 1, r = c1;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2;\n\t\tConnectivity res = segment->query(mid, c1);\n\t\tif (res(0, r1) || res(1, r1)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\tconst int lpos = l;\n\tConnectivity lconn = segment->query(lpos, c1);\n\n\tl = c2, r = n;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tConnectivity res = segment->query(c2, mid);\n\t\tif (res(r2, 0) || res(r2, 1)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\tconst int rpos = l;\n\tConnectivity rconn = segment->query(c2, rpos);\n\n\tConnectivity conn = segment->query(lpos, rpos);\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (lconn(i, r1) && rconn(r2, j) && conn(i, j)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tsegment = SegmentTree::build(1, n);\n\n\tchar cmd[5];\n\twhile (~scanf(\"%s\", cmd)) {\n\t\tif (cmd[0] == 'E') break;\n\t\telse if (cmd[0] == 'O') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tupdate(r1 - 1, c1, r2 - 1, c2, true);\n\t\t} else if (cmd[0] == 'C') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tupdate(r1 - 1, c1, r2 - 1, c2, false);\n\t\t} else if (cmd[0] == 'A') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tif (c1 > c2) std::swap(c1, c2), std::swap(r1, r2);\n\t\t\tputs(query(r1 - 1, c1, r2 - 1, c2) ? \"Y\" : \"N\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/shoi2008-traffic.md","raw":"title: SHOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - \npermalink: shoi2008-traffic\ndate: 2016-10-19 14:30:00\n---\n\n $ 2 $  $ C $  $ 2C $  $ 3C - 2 $ \n\n\n1. `Close r1 c1 r2 c2` $ (r_1, c_1) $  $ (r_2, c_2) $ \n2. `Open r1 c1 r2 c2` $ (r_1, c_1) $  $ (r_2, c_2) $ \n3. `Ask r1 c1 r2 c2` $ (r_1, c_1) $  $ (r_2, c_2) $ \n\n<!-- more -->\n\n### \n[BZOJ 1018](http://www.lydsy.com/JudgeOnline/problem.php?id=1018)\n\n### \n $ (i, 0) $  $ (i, 1) $  $ i $ \n\n $ [l, r] $  $ (l, 0), (l, 1) $  $ (r, 0), (r, 1) $ \n\n $ i $  $ [l = i, r = i] $  $ (l, 0) $  $ (r, 1) $$ (l, 1) $  $ (r, 0) $ \n\n $ [l, m] $  $ [m + 1, r] $  $ m \\leftrightarrow m + 1 $ \n\n $ [l, r] $  $ l $  $ l' $  $ r $  $ r' $ $ [l', r'] $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint n;\nbool right[MAXN][2], middle[MAXN + 1];\n\nstruct Connectivity {\n\tbool a[2][2];\n\n\tConnectivity(const bool init) {\n\t\ta[0][0] = a[0][1] = a[1][0] = a[1][1] = init;\n\t}\n\n\tbool &operator()(const int i, const int j) { return a[i][j]; }\n\tbool operator()(const int i, const int j) const { return a[i][j]; }\n\n\toperator bool() const { return a[0][0] || a[0][1] || a[1][0] || a[1][1]; }\n};\n\nConnectivity merge(Connectivity a, Connectivity b, const int mid) {\n\tConnectivity res(false);\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tres(i, j) |= a(i, k) && right[mid][k] && b(k, j);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tConnectivity conn;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), conn(l == r) {}\n\n\tvoid update(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (this->l == this->r) {\n\t\t\tconn(0, 0) = conn(1, 1) = true;\n\t\t\tconn(0, 1) = conn(1, 0) = middle[mid];\n\t\t\treturn;\n\t\t} else if (!(l <= this->l && r >= this->r)) {\n\t\t\tlc->update(l, r);\n\t\t\trc->update(l, r);\n\t\t} else if (this->l == this->r - 1) lc->update(l, r), rc->update(l, r);\n\t\tconn = merge(lc->conn, rc->conn, mid);\n\t}\n\n\tConnectivity query(const int l, const int r) {\n\t\tif (l <= this->l && r >= this->r) return conn;\n\t\telse if (r <= mid) return lc->query(l, r);\n\t\telse if (l > mid) return rc->query(l, r);\n\t\telse return merge(lc->query(l, r), rc->query(l, r), mid);\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segment;\n\ninline void update(int r1, int c1, int r2, int c2, const bool val) {\n\tif (r1 == r2) {\n\t\tright[std::min(c1, c2)][r1] = val;\n\t} else {\n\t\tmiddle[c1] = val;\n\t}\n\tsegment->update(std::min(c1, c2), std::max(c1, c2));\n}\n\ninline bool query(int r1, int c1, int r2, int c2) {\n\tint l, r;\n\n\tl = 1, r = c1;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2;\n\t\tConnectivity res = segment->query(mid, c1);\n\t\tif (res(0, r1) || res(1, r1)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\tconst int lpos = l;\n\tConnectivity lconn = segment->query(lpos, c1);\n\n\tl = c2, r = n;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tConnectivity res = segment->query(c2, mid);\n\t\tif (res(r2, 0) || res(r2, 1)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\tconst int rpos = l;\n\tConnectivity rconn = segment->query(c2, rpos);\n\n\tConnectivity conn = segment->query(lpos, rpos);\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (lconn(i, r1) && rconn(r2, j) && conn(i, j)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tsegment = SegmentTree::build(1, n);\n\n\tchar cmd[5];\n\twhile (~scanf(\"%s\", cmd)) {\n\t\tif (cmd[0] == 'E') break;\n\t\telse if (cmd[0] == 'O') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tupdate(r1 - 1, c1, r2 - 1, c2, true);\n\t\t} else if (cmd[0] == 'C') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tupdate(r1 - 1, c1, r2 - 1, c2, false);\n\t\t} else if (cmd[0] == 'A') {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tscanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n\t\t\tif (c1 > c2) std::swap(c1, c2), std::swap(r1, r2);\n\t\t\tputs(query(r1 - 1, c1, r2 - 1, c2) ? \"Y\" : \"N\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"shoi2008-traffic","published":1,"updated":"2016-10-19T06:30:27.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6byw008sc2xlihfle7ic"},{"title":"SHOI2008 - ","date":"2016-10-19T07:53:00.000Z","_content":"\n $ n $ ****\n\n<!-- more -->\n\n### \n[BZOJ 1022](http://www.lydsy.com/JudgeOnline/problem.php?id=1022)\n\n### \n\n\n****\n\n\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 50;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tint s = 0;\n\t\tbool flag = false;\n\t\twhile (n--) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\ts ^= x;\n\t\t\tif (x > 1) flag = true;\n\t\t}\n\n\t\tputs(((!flag && s == 0) || (flag && s != 0)) ? \"John\" : \"Brother\");\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/shoi2008-john.md","raw":"title: SHOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - \n  - \npermalink: shoi2008-john\ndate: 2016-10-19 15:53:00\n---\n\n $ n $ ****\n\n<!-- more -->\n\n### \n[BZOJ 1022](http://www.lydsy.com/JudgeOnline/problem.php?id=1022)\n\n### \n\n\n****\n\n\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 50;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tint s = 0;\n\t\tbool flag = false;\n\t\twhile (n--) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\ts ^= x;\n\t\t\tif (x > 1) flag = true;\n\t\t}\n\n\t\tputs(((!flag && s == 0) || (flag && s != 0)) ? \"John\" : \"Brother\");\n\t}\n\n\treturn 0;\n}\n```","slug":"shoi2008-john","published":1,"updated":"2016-10-19T07:53:47.059Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bz0008yc2xl5ned3wmd"},{"title":"SHOI2008 - DP","date":"2016-10-19T07:24:00.000Z","_content":"\nABACBABCCA  CB A \n\n1. \n2. \n\n  \n\n\n<!-- more -->\n\n### \n[BZOJ 1019](http://www.lydsy.com/JudgeOnline/problem.php?id=1019)\n\n### \n $ f(j, i) $  $ i $  $ j $  $ g(j, i) $ \n\n $ j - 1 $  $ f(j - 1, i) $  $ g(j - 1, i) $  $ a = g(j - 1, i) $ $ b = 3 - a - i $ $ j $  $ b $ \n\n $ a $  $ j - 1 $  $ g(j - 1, a) $  $ g(j - 1, a) = b $ $ b $  $ j $  $ b $  $ f(j, i) = f(j - 1, i) + 1 + f(j - 1, a) $$ g(j, i) = b $\n\n $ g(j - 1, a) = i $  $ j - 1 $  $ i $  $ a $  $ j - 1 $  $ a $  $ g(j - 1, i) = a $ $ f(j, i) = f(j - 1, i) + 1 + f(j - 1, a) + 1 + f(j - 1, i) $$ g(j, i) = a $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 30;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int g[MAXN + 1][3];\n\tg[1][0] = g[1][1] = g[1][2] = -1;\n\tfor (int i = 0; i < 6; i++) {\n\t\tchar s[3];\n\t\tscanf(\"%s\", s);\n\t\tint a = s[0] - 'A', b = s[1] - 'A';\n\t\tif (g[1][a] == -1) g[1][a] = b;\n\t}\n\n\tstatic long long f[MAXN + 1][3];\n\tf[1][0] = f[1][1] = f[1][2] = 1;\n\n\tfor (int j = 2; j <= n; j++) {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tconst int a = g[j - 1][i], b = 3 - a - i;\n\t\t\tif (g[j - 1][a] == b) {\n\t\t\t\tf[j][i] = f[j - 1][i] + 1 + f[j - 1][a];\n\t\t\t\tg[j][i] = b;\n\t\t\t} else {\n\t\t\t\tf[j][i] = f[j - 1][i] + 1 + f[j - 1][a] + 1 + f[j - 1][i];\n\t\t\t\tg[j][i] = a;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", f[n][0]);\n\n\treturn 0;\n}\n```","source":"_posts/shoi2008-hannoi.md","raw":"title: SHOI2008 - DP\ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - DP\npermalink: shoi2008-hannoi\ndate: 2016-10-19 15:24:00\n---\n\nABACBABCCA  CB A \n\n1. \n2. \n\n  \n\n\n<!-- more -->\n\n### \n[BZOJ 1019](http://www.lydsy.com/JudgeOnline/problem.php?id=1019)\n\n### \n $ f(j, i) $  $ i $  $ j $  $ g(j, i) $ \n\n $ j - 1 $  $ f(j - 1, i) $  $ g(j - 1, i) $  $ a = g(j - 1, i) $ $ b = 3 - a - i $ $ j $  $ b $ \n\n $ a $  $ j - 1 $  $ g(j - 1, a) $  $ g(j - 1, a) = b $ $ b $  $ j $  $ b $  $ f(j, i) = f(j - 1, i) + 1 + f(j - 1, a) $$ g(j, i) = b $\n\n $ g(j - 1, a) = i $  $ j - 1 $  $ i $  $ a $  $ j - 1 $  $ a $  $ g(j - 1, i) = a $ $ f(j, i) = f(j - 1, i) + 1 + f(j - 1, a) + 1 + f(j - 1, i) $$ g(j, i) = a $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 30;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int g[MAXN + 1][3];\n\tg[1][0] = g[1][1] = g[1][2] = -1;\n\tfor (int i = 0; i < 6; i++) {\n\t\tchar s[3];\n\t\tscanf(\"%s\", s);\n\t\tint a = s[0] - 'A', b = s[1] - 'A';\n\t\tif (g[1][a] == -1) g[1][a] = b;\n\t}\n\n\tstatic long long f[MAXN + 1][3];\n\tf[1][0] = f[1][1] = f[1][2] = 1;\n\n\tfor (int j = 2; j <= n; j++) {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tconst int a = g[j - 1][i], b = 3 - a - i;\n\t\t\tif (g[j - 1][a] == b) {\n\t\t\t\tf[j][i] = f[j - 1][i] + 1 + f[j - 1][a];\n\t\t\t\tg[j][i] = b;\n\t\t\t} else {\n\t\t\t\tf[j][i] = f[j - 1][i] + 1 + f[j - 1][a] + 1 + f[j - 1][i];\n\t\t\t\tg[j][i] = a;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", f[n][0]);\n\n\treturn 0;\n}\n```","slug":"shoi2008-hannoi","published":1,"updated":"2016-10-19T07:24:21.733Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bz30095c2xlfqney5g0"},{"title":"SHOI2008 - DP","date":"2016-10-19T07:35:00.000Z","_content":"\nABC  $ 1, 5, 10, 20, 50, 100 $ \n\n<!-- more -->\n\n### \n[BZOJ 1021](http://www.lydsy.com/JudgeOnline/problem.php?id=1021)\n\n### \n $ f(i, a, b) $  $ i $  A  $ a $ B  $ b $ \n\n****\n\n* $ a \\rightarrow b, c $\n* $ b \\rightarrow a, c $\n* $ c \\rightarrow a, b $\n* $ a, b \\rightarrow c $\n* $ a, c \\rightarrow b $\n* $ b, c \\rightarrow a $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int VAL[] = { -1, 1, 5, 10, 20, 50, 100 };\n\nint main() {\n\tint a, b, c;\n\tscanf(\"%d %d %d\", &a, &b, &c);\n\n\tif (a > 0 && b > 0 && c > 0) {\n\t\tconst int min = std::min(std::min(a, b), c);\n\t\ta -= min, b -= min, c -= min;\n\t} else if (a < 0 && b < 0 && c < 0) {\n\t\tconst int max = std::max(std::max(a, b), c);\n\t\ta -= max, b -= max, c -= max;\n\t}\n\n\tint has[3][6 + 1];\n\tint sum = 0, sums[3] = { 0, 0, 0 };\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tscanf(\"%d\", &has[i][6 - j]);\n\t\t\tsums[i] += has[i][6 - j] * VAL[6 - j];\n#ifdef DBG\n\t\t\tfor (int k = 0; k < has[i][6 - j]; k++) printf(\"%d\\n\", VAL[6 - j]);\n#endif\n\t\t}\n\t\tsum += sums[i];\n#ifdef DBG\n\t\tputchar('\\n');\n#endif\n\t}\n#ifdef DBG\n\tprintf(\"%d %d %d\\n\", sums[0], sums[1], sums[2]);\n#endif\n\n\tstatic int f[6 + 1][MAXN + 1][MAXN + 1];\n\tfor (int i = 0; i <= 6; i++) for (int j = 0; j <= MAXN; j++) for (int k = 0; k <= MAXN; k++) f[i][j][k] = INT_MAX;\n\n\tf[0][sums[0]][sums[1]] = 0;\n\tfor (int i = 0; i < 6; i++) {\n\t\tfor (int a = 0; a <= sum; a++) {\n\t\t\tfor (int b = 0; b <= sum - a; b++) {\n\t\t\t\tconst int c = sum - a - b;\n\t\t\t\tif (f[i][a][b] == INT_MAX) continue;\n\n\t\t\t\t// a -> b, c\n\t\t\t\tfor (int tb = 0; tb <= has[0][i + 1]; tb++) {\n\t\t\t\t\tfor (int tc = 0; tc <= has[0][i + 1] - tb; tc++) {\n\t\t\t\t\t\tif (tb + tc == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * (tb + tc);\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * tb;\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * tc;\n\t\t\t\t\t\tif (_a > sum || _b < 0 || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + tb + tc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b -> a, c\n\t\t\t\tfor (int ta = 0; ta <= has[1][i + 1]; ta++) {\n\t\t\t\t\tfor (int tc = 0; tc <= has[1][i + 1] - ta; tc++) {\n\t\t\t\t\t\tif (ta + tc == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * ta;\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * (ta + tc);\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * tc;\n\t\t\t\t\t\tif (_a < 0 || _b > sum || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + ta + tc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// c -> a, b\n\t\t\t\tfor (int ta = 0; ta <= has[2][i + 1]; ta++) {\n\t\t\t\t\tfor (int tb = 0; tb <= has[2][i + 1] - ta; tb++) {\n\t\t\t\t\t\tif (ta + tb == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * ta;\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * tb;\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * (ta + tb);\n\t\t\t\t\t\tif (_a < 0 || _b < 0 || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + ta + tb);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// a, b -> c\n\t\t\t\tfor (int fa = 0; fa <= has[0][i + 1]; fa++) {\n\t\t\t\t\tfor (int fb = 0; fb <= has[1][i + 1]; fb++) {\n\t\t\t\t\t\tif (fa + fb == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * fa;\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * fb;\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * (fa + fb);\n\t\t\t\t\t\tif (_a > sum || _b > sum || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fa + fb);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// a, c -> b\n\t\t\t\tfor (int fa = 0; fa <= has[0][i + 1]; fa++) {\n\t\t\t\t\tfor (int fc = 0; fc <= has[2][i + 1]; fc++) {\n\t\t\t\t\t\tif (fa + fc == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * fa;\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * (fa + fc);\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * fc;\n\t\t\t\t\t\tif (_a > sum || _b < 0 || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fa + fc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b, c -> a\n\t\t\t\tfor (int fb = 0; fb <= has[1][i + 1]; fb++) {\n\t\t\t\t\tfor (int fc = 0; fc <= has[2][i + 1]; fc++) {\n\t\t\t\t\t\tif (fb + fc == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * (fb + fc);\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * fb;\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * fc;\n\t\t\t\t\t\tif (_a < 0 || _b > sum || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fb + fc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#ifdef DBG\n\t\t\t\tif (f[i + 1][a][b] != INT_MAX) printf(\"f(%d, %d, %d) = %d\\n\", i + 1, a, b, f[i + 1][a][b]);\n#endif\n\t\t\t\tf[i + 1][a][b] = std::min(f[i + 1][a][b], f[i][a][b]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint resA = sums[0] - a + c, resB = sums[1] - b + a, resC = sums[2] - c + b;\n#ifdef DBG\n\tprintf(\"%d %d %d\\n\", resA, resB, resC);\n#endif\n\tif (resA < 0 || resB < 0 || resC < 0 || f[6][resA][resB] == INT_MAX) puts(\"impossible\");\n\telse printf(\"%d\\n\", f[6][resA][resB]);\n\n\treturn 0;\n}\n```","source":"_posts/shoi2008-debt.md","raw":"title: SHOI2008 - DP\ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - DP\npermalink: shoi2008-debt\ndate: 2016-10-19 15:35:00\n---\n\nABC  $ 1, 5, 10, 20, 50, 100 $ \n\n<!-- more -->\n\n### \n[BZOJ 1021](http://www.lydsy.com/JudgeOnline/problem.php?id=1021)\n\n### \n $ f(i, a, b) $  $ i $  A  $ a $ B  $ b $ \n\n****\n\n* $ a \\rightarrow b, c $\n* $ b \\rightarrow a, c $\n* $ c \\rightarrow a, b $\n* $ a, b \\rightarrow c $\n* $ a, c \\rightarrow b $\n* $ b, c \\rightarrow a $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int VAL[] = { -1, 1, 5, 10, 20, 50, 100 };\n\nint main() {\n\tint a, b, c;\n\tscanf(\"%d %d %d\", &a, &b, &c);\n\n\tif (a > 0 && b > 0 && c > 0) {\n\t\tconst int min = std::min(std::min(a, b), c);\n\t\ta -= min, b -= min, c -= min;\n\t} else if (a < 0 && b < 0 && c < 0) {\n\t\tconst int max = std::max(std::max(a, b), c);\n\t\ta -= max, b -= max, c -= max;\n\t}\n\n\tint has[3][6 + 1];\n\tint sum = 0, sums[3] = { 0, 0, 0 };\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 6; j++) {\n\t\t\tscanf(\"%d\", &has[i][6 - j]);\n\t\t\tsums[i] += has[i][6 - j] * VAL[6 - j];\n#ifdef DBG\n\t\t\tfor (int k = 0; k < has[i][6 - j]; k++) printf(\"%d\\n\", VAL[6 - j]);\n#endif\n\t\t}\n\t\tsum += sums[i];\n#ifdef DBG\n\t\tputchar('\\n');\n#endif\n\t}\n#ifdef DBG\n\tprintf(\"%d %d %d\\n\", sums[0], sums[1], sums[2]);\n#endif\n\n\tstatic int f[6 + 1][MAXN + 1][MAXN + 1];\n\tfor (int i = 0; i <= 6; i++) for (int j = 0; j <= MAXN; j++) for (int k = 0; k <= MAXN; k++) f[i][j][k] = INT_MAX;\n\n\tf[0][sums[0]][sums[1]] = 0;\n\tfor (int i = 0; i < 6; i++) {\n\t\tfor (int a = 0; a <= sum; a++) {\n\t\t\tfor (int b = 0; b <= sum - a; b++) {\n\t\t\t\tconst int c = sum - a - b;\n\t\t\t\tif (f[i][a][b] == INT_MAX) continue;\n\n\t\t\t\t// a -> b, c\n\t\t\t\tfor (int tb = 0; tb <= has[0][i + 1]; tb++) {\n\t\t\t\t\tfor (int tc = 0; tc <= has[0][i + 1] - tb; tc++) {\n\t\t\t\t\t\tif (tb + tc == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * (tb + tc);\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * tb;\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * tc;\n\t\t\t\t\t\tif (_a > sum || _b < 0 || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + tb + tc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b -> a, c\n\t\t\t\tfor (int ta = 0; ta <= has[1][i + 1]; ta++) {\n\t\t\t\t\tfor (int tc = 0; tc <= has[1][i + 1] - ta; tc++) {\n\t\t\t\t\t\tif (ta + tc == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * ta;\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * (ta + tc);\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * tc;\n\t\t\t\t\t\tif (_a < 0 || _b > sum || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + ta + tc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// c -> a, b\n\t\t\t\tfor (int ta = 0; ta <= has[2][i + 1]; ta++) {\n\t\t\t\t\tfor (int tb = 0; tb <= has[2][i + 1] - ta; tb++) {\n\t\t\t\t\t\tif (ta + tb == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * ta;\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * tb;\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * (ta + tb);\n\t\t\t\t\t\tif (_a < 0 || _b < 0 || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + ta + tb);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// a, b -> c\n\t\t\t\tfor (int fa = 0; fa <= has[0][i + 1]; fa++) {\n\t\t\t\t\tfor (int fb = 0; fb <= has[1][i + 1]; fb++) {\n\t\t\t\t\t\tif (fa + fb == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * fa;\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * fb;\n\t\t\t\t\t\tconst int _c = c + VAL[i + 1] * (fa + fb);\n\t\t\t\t\t\tif (_a > sum || _b > sum || _c < 0) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fa + fb);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// a, c -> b\n\t\t\t\tfor (int fa = 0; fa <= has[0][i + 1]; fa++) {\n\t\t\t\t\tfor (int fc = 0; fc <= has[2][i + 1]; fc++) {\n\t\t\t\t\t\tif (fa + fc == 0) continue;\n\t\t\t\t\t\tconst int _a = a - VAL[i + 1] * fa;\n\t\t\t\t\t\tconst int _b = b + VAL[i + 1] * (fa + fc);\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * fc;\n\t\t\t\t\t\tif (_a > sum || _b < 0 || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fa + fc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b, c -> a\n\t\t\t\tfor (int fb = 0; fb <= has[1][i + 1]; fb++) {\n\t\t\t\t\tfor (int fc = 0; fc <= has[2][i + 1]; fc++) {\n\t\t\t\t\t\tif (fb + fc == 0) continue;\n\t\t\t\t\t\tconst int _a = a + VAL[i + 1] * (fb + fc);\n\t\t\t\t\t\tconst int _b = b - VAL[i + 1] * fb;\n\t\t\t\t\t\tconst int _c = c - VAL[i + 1] * fc;\n\t\t\t\t\t\tif (_a < 0 || _b > sum || _c > sum) continue;\n\t\t\t\t\t\tf[i + 1][_a][_b] = std::min(f[i + 1][_a][_b], f[i][a][b] + fb + fc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n#ifdef DBG\n\t\t\t\tif (f[i + 1][a][b] != INT_MAX) printf(\"f(%d, %d, %d) = %d\\n\", i + 1, a, b, f[i + 1][a][b]);\n#endif\n\t\t\t\tf[i + 1][a][b] = std::min(f[i + 1][a][b], f[i][a][b]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint resA = sums[0] - a + c, resB = sums[1] - b + a, resC = sums[2] - c + b;\n#ifdef DBG\n\tprintf(\"%d %d %d\\n\", resA, resB, resC);\n#endif\n\tif (resA < 0 || resB < 0 || resC < 0 || f[6][resA][resB] == INT_MAX) puts(\"impossible\");\n\telse printf(\"%d\\n\", f[6][resA][resB]);\n\n\treturn 0;\n}\n```","slug":"shoi2008-debt","published":1,"updated":"2016-10-19T07:35:55.225Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bz7009ac2xlytb1inkm"},{"title":"SHOI2008 -  DP","date":"2016-10-26T00:02:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1023](http://www.lydsy.com/JudgeOnline/problem.php?id=1023)\n\n### \nDFS  $ f(i) $  **DFS  $ i $ ** $ i $ \n\n DP DP **** $ f(i) $  $ i $ \n\n DFS  $ \\mathrm{dfn}(i) $  $ \\mathrm{low}(i) $ $ i $  $ j $$ j $  $ i $  $ \\mathrm{low}(j) > \\mathrm{dfn}(i) $ $ j $  $ i $  $ f(j) $  $ f(i) $ $ j $  $ i $  $ \\mathrm{dfn}(j) > \\mathrm{dfn}(i) $ $ i $  $ j $ \n\n**** $ i $ $ f(i) $  $ i $  $ f(i) $  $ j $$ f(i) $  $ f(j) + \\mathrm{dist}(j) $ \n\n $ f(i) + f(j) + \\mathrm{dist}(i, j) $  $ s(i) $  $ i $ $ f'(i) $  $ i $  $ f $  $ f'(i) + f'(j) + s(i) - s(j) $  $ f'(j) - s(j) $  $ s(i) - s(j) $  $ f $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 50000;\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tNode *parent;\n\tint dfn, low, len;\n\tbool visited, pushed;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nint n;\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\ninline void updateCircle(Node *top, Node *u, int &ans) {\n#ifdef DBG\n\tprintf(\"updateCircle(%lu, %lu)\\n\", top - N + 1, u - N + 1);\n#endif\n\tstatic Node *v[MAXN * 2];\n\tint cnt = 0;\n\twhile (1) {\n\t\tv[cnt++] = u;\n\t\tif (u == top) break;\n\t\tu = u->parent;\n\t}\n\tstd::reverse(v, v + cnt);\n\tstd::copy(v, v + cnt, v + cnt);\n\n\tint half = cnt / 2;\n\n\tstatic int q[MAXN * 2];\n\tint *l = q, *r = q;\n\t*r = 0;\n\n\t// ans = max{ f[i] + f[j] + i - j }\n\t// maintain the max of f[j] - j\n\tfor (int i = 1; i < cnt * 2; i++) {\n\t\twhile (i - *l > half) l++;\n#ifdef DBG\n\t\tprintf(\"updateCircle: ans <- %d\\n\", v[*l]->len + v[i]->len + i - *l);\n#endif\n\t\tans = std::max(ans, v[*l]->len + v[i]->len + i - *l);\n\t\twhile (l <= r && v[i]->len - i > v[*r]->len - *r) r--;\n\t\t*++r = i;\n\t}\n\n\tint res = 0;\n\tfor (int i = 1; i < cnt; i++) {\n\t\t// printf(\"updateCircle(%lu, %lu): (f[%lu] = %d) + min(%d, %d)\\n\", top - N + 1, u - N + 1, v[i] - N + 1, v[i]->len, i, cnt - i);\n\t\tres = std::max(res, v[i]->len + std::min(i, cnt - i));\n\t}\n\n#ifdef CHECK\n\tprintf(\"updateCircle(%lu, %lu) = %d\\n\", top - N + 1, u - N + 1, res);\n#endif\n\n\ttop->len = std::max(top->len, res);\n}\n\ninline int tarjan() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].pushed = true;\n\n\tint ts = 0, ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t\tv->dfn = v->low = ++ts;\n\t\t}\n\n\t\tif (v->c && v->c->t == v->parent) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tEdge *&e = v->c;\n\t\t\tif (e->t->dfn) {\n\t\t\t\tv->low = std::min(v->low, e->t->dfn);\n\t\t\t} else {\n\t\t\t\te->t->pushed = true;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t\te = e->next;\n\t\t} else {\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t == v->parent) continue;\n\n\t\t\t\tif (e->t->low > v->dfn) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: ans <- (f[%lu] = %d) + (f[%lu] = %d) + 1\\n\", v - N + 1, v->len, e->t - N + 1, e->t->len);\n#endif\n\t\t\t\t\tans = std::max(ans, v->len + e->t->len + 1);\n\t\t\t\t\tv->len = std::max(v->len, e->t->len + 1);\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: f[%lu] = %d\\n\", v - N + 1, v->len);\n#endif\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (e->t->parent != v && e->t->dfn > v->dfn) {\n\t\t\t\t\tupdateCircle(v, e->t, ans);\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: f[%lu] = %d (from circle)\\n\", v - N + 1, v->len);\n#endif\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (v->parent) v->parent->low = std::min(v->parent->low, v->low);\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint k, u;\n\t\tscanf(\"%d %d\", &k, &u), u--, k--;\n\t\twhile (k--) {\n\t\t\tint v;\n\t\t\tscanf(\"%d\", &v), v--;\n\t\t\taddEdge(u, v);\n\t\t\tu = v;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", tarjan());\n\n\treturn 0;\n}\n```","source":"_posts/shoi2008-cactus.md","raw":"title: SHOI2008 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - DP\n  - \n  - Tarjan\npermalink: shoi2008-cactus\ndate: 2016-10-26 08:02:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1023](http://www.lydsy.com/JudgeOnline/problem.php?id=1023)\n\n### \nDFS  $ f(i) $  **DFS  $ i $ ** $ i $ \n\n DP DP **** $ f(i) $  $ i $ \n\n DFS  $ \\mathrm{dfn}(i) $  $ \\mathrm{low}(i) $ $ i $  $ j $$ j $  $ i $  $ \\mathrm{low}(j) > \\mathrm{dfn}(i) $ $ j $  $ i $  $ f(j) $  $ f(i) $ $ j $  $ i $  $ \\mathrm{dfn}(j) > \\mathrm{dfn}(i) $ $ i $  $ j $ \n\n**** $ i $ $ f(i) $  $ i $  $ f(i) $  $ j $$ f(i) $  $ f(j) + \\mathrm{dist}(j) $ \n\n $ f(i) + f(j) + \\mathrm{dist}(i, j) $  $ s(i) $  $ i $ $ f'(i) $  $ i $  $ f $  $ f'(i) + f'(j) + s(i) - s(j) $  $ f'(j) - s(j) $  $ s(i) - s(j) $  $ f $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 50000;\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tNode *parent;\n\tint dfn, low, len;\n\tbool visited, pushed;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nint n;\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\ninline void updateCircle(Node *top, Node *u, int &ans) {\n#ifdef DBG\n\tprintf(\"updateCircle(%lu, %lu)\\n\", top - N + 1, u - N + 1);\n#endif\n\tstatic Node *v[MAXN * 2];\n\tint cnt = 0;\n\twhile (1) {\n\t\tv[cnt++] = u;\n\t\tif (u == top) break;\n\t\tu = u->parent;\n\t}\n\tstd::reverse(v, v + cnt);\n\tstd::copy(v, v + cnt, v + cnt);\n\n\tint half = cnt / 2;\n\n\tstatic int q[MAXN * 2];\n\tint *l = q, *r = q;\n\t*r = 0;\n\n\t// ans = max{ f[i] + f[j] + i - j }\n\t// maintain the max of f[j] - j\n\tfor (int i = 1; i < cnt * 2; i++) {\n\t\twhile (i - *l > half) l++;\n#ifdef DBG\n\t\tprintf(\"updateCircle: ans <- %d\\n\", v[*l]->len + v[i]->len + i - *l);\n#endif\n\t\tans = std::max(ans, v[*l]->len + v[i]->len + i - *l);\n\t\twhile (l <= r && v[i]->len - i > v[*r]->len - *r) r--;\n\t\t*++r = i;\n\t}\n\n\tint res = 0;\n\tfor (int i = 1; i < cnt; i++) {\n\t\t// printf(\"updateCircle(%lu, %lu): (f[%lu] = %d) + min(%d, %d)\\n\", top - N + 1, u - N + 1, v[i] - N + 1, v[i]->len, i, cnt - i);\n\t\tres = std::max(res, v[i]->len + std::min(i, cnt - i));\n\t}\n\n#ifdef CHECK\n\tprintf(\"updateCircle(%lu, %lu) = %d\\n\", top - N + 1, u - N + 1, res);\n#endif\n\n\ttop->len = std::max(top->len, res);\n}\n\ninline int tarjan() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].pushed = true;\n\n\tint ts = 0, ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t\tv->dfn = v->low = ++ts;\n\t\t}\n\n\t\tif (v->c && v->c->t == v->parent) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tEdge *&e = v->c;\n\t\t\tif (e->t->dfn) {\n\t\t\t\tv->low = std::min(v->low, e->t->dfn);\n\t\t\t} else {\n\t\t\t\te->t->pushed = true;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t\te = e->next;\n\t\t} else {\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t == v->parent) continue;\n\n\t\t\t\tif (e->t->low > v->dfn) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: ans <- (f[%lu] = %d) + (f[%lu] = %d) + 1\\n\", v - N + 1, v->len, e->t - N + 1, e->t->len);\n#endif\n\t\t\t\t\tans = std::max(ans, v->len + e->t->len + 1);\n\t\t\t\t\tv->len = std::max(v->len, e->t->len + 1);\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: f[%lu] = %d\\n\", v - N + 1, v->len);\n#endif\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (e->t->parent != v && e->t->dfn > v->dfn) {\n\t\t\t\t\tupdateCircle(v, e->t, ans);\n#ifdef DBG\n\t\t\t\t\tprintf(\"tarjan: f[%lu] = %d (from circle)\\n\", v - N + 1, v->len);\n#endif\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (v->parent) v->parent->low = std::min(v->parent->low, v->low);\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint k, u;\n\t\tscanf(\"%d %d\", &k, &u), u--, k--;\n\t\twhile (k--) {\n\t\t\tint v;\n\t\t\tscanf(\"%d\", &v), v--;\n\t\t\taddEdge(u, v);\n\t\t\tu = v;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", tarjan());\n\n\treturn 0;\n}\n```","slug":"shoi2008-cactus","published":1,"updated":"2016-10-26T00:02:45.110Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bza009fc2xlq7y3j4dd"},{"title":"SHOI2007 - ","date":"2016-06-21T07:04:00.000Z","_content":"\n $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 1934](http://www.lydsy.com/JudgeOnline/problem.php?id=1934)\n\n### \n $ 1 $\n\n $ S - u - v - T $$ u $ $ v $  $ u - v $  $ u $  $ v $  $ +1 $ $ S - u $  $ v - T $ $ u $  $ v $  $ +1 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = MAXN * (MAXN - 1) / 2;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->e; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\t// printf(\"[%d, %d, %d, %d]\\n\", s, t, c, rc);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], rc);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tif (x == 0) {\n\t\t\taddEdge(s, i, 1);\n\t\t} else {\n\t\t\taddEdge(i, t, 1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u, v, 1, 1);\n\t}\n\n\tint maxFlow = dinic(s, t, n + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/shoi2007-vote.md","raw":"title: SHOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - \n  - Dinic\n  - \npermalink: shoi2007-vote\ndate: 2016-06-21 15:04:00\n---\n\n $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 1934](http://www.lydsy.com/JudgeOnline/problem.php?id=1934)\n\n### \n $ 1 $\n\n $ S - u - v - T $$ u $ $ v $  $ u - v $  $ u $  $ v $  $ +1 $ $ S - u $  $ v - T $ $ u $  $ v $  $ +1 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = MAXN * (MAXN - 1) / 2;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->e; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\t// printf(\"[%d, %d, %d, %d]\\n\", s, t, c, rc);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], rc);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tif (x == 0) {\n\t\t\taddEdge(s, i, 1);\n\t\t} else {\n\t\t\taddEdge(i, t, 1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u, v, 1, 1);\n\t}\n\n\tint maxFlow = dinic(s, t, n + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"shoi2007-vote","published":1,"updated":"2016-06-21T07:04:25.384Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bzf009nc2xl1qv01htn"},{"title":"SHOI2007 - CDQ","date":"2016-06-25T02:54:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1935](http://www.lydsy.com/JudgeOnline/problem.php?id=1935)\n\n### \n [BZOJ 1176](bzoj-1176)\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\nconst int MAXX = 10000000;\n\nstruct Triple {\n\tint x, y, *ans, k;\n\n\tTriple() {}\n\tTriple(const int x, const int y, int *ans, const int k) : x(x), y(y), ans(ans), k(k) {}\n} a[MAXN + MAXM * 4];\n\nint max = 0;\n\nstruct BinaryIndexedTree {\n\tint a[MAXX + 2];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\t// printf(\"sum[1, %d] = %d\\n\", x, ans);\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\t// printf(\"a[%d] += %d\\n\", x, delta);\n\t\tfor (int i = x; i <= max; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\t// printf(\"a[%d] = 0\\n\", x);\n\t\tfor (int i = x; i <= max; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\nvoid cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN + MAXM * 4];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = mid + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= mid && p1->x <= p2->x) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tif (!q->ans) bit.update(q->y, 1);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\t// printf(\"ans += %d\\n\", bit.query(q->y) * q->k);\n\t\t\tif (q->ans) *q->ans += bit.query(q->y) * q->k;\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; q++, p++) {\n\t\t*p = *q;\n\t\tbit.clear(p->y);\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].x, &a[i].y), a[i].x += 2, a[i].y += 2;\n\t\tmax = std::max(max, a[i].y);\n\t}\n\n\tstatic int ans[MAXM];\n\tint cnt = n;\n\tfor (int i = 0; i < m; i++) {\n\t\tint x1, y1, x2, y2;\n\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2), x1 += 2, y1 += 2, x2 += 2, y2 += 2;\n\t\tint *p = &ans[i];\n\n\t\ta[cnt++] = Triple(x2, y2, p, 1);\n\t\ta[cnt++] = Triple(x1 - 1, y1 - 1, p, 1);\n\t\ta[cnt++] = Triple(x1 - 1, y2, p, -1);\n\t\ta[cnt++] = Triple(x2, y1 - 1, p, -1);\n\n\t\tmax = std::max(max, y1);\n\t\tmax = std::max(max, y2);\n\t}\n\n\t// for (int i = 0; i < cnt; i++) {\n\t// \tif (a[i].ans) printf(\"Query [%d, %d] for ans[%ld]\\n\", a[i].x, a[i].y, a[i].ans - ans);\n\t// \telse printf(\"Update [%d, %d] = 1\\n\", a[i].x, a[i].y);\n\t// }\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < m; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/shoi2007-tree.md","raw":"title: SHOI2007 - CDQ\ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - \n  - CDQ\n  - \n  - \npermalink: shoi2007-tree\ndate: 2016-06-25 10:54:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1935](http://www.lydsy.com/JudgeOnline/problem.php?id=1935)\n\n### \n [BZOJ 1176](bzoj-1176)\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\nconst int MAXX = 10000000;\n\nstruct Triple {\n\tint x, y, *ans, k;\n\n\tTriple() {}\n\tTriple(const int x, const int y, int *ans, const int k) : x(x), y(y), ans(ans), k(k) {}\n} a[MAXN + MAXM * 4];\n\nint max = 0;\n\nstruct BinaryIndexedTree {\n\tint a[MAXX + 2];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\t// printf(\"sum[1, %d] = %d\\n\", x, ans);\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\t// printf(\"a[%d] += %d\\n\", x, delta);\n\t\tfor (int i = x; i <= max; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\t// printf(\"a[%d] = 0\\n\", x);\n\t\tfor (int i = x; i <= max; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\nvoid cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN + MAXM * 4];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = mid + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= mid && p1->x <= p2->x) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tif (!q->ans) bit.update(q->y, 1);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\t// printf(\"ans += %d\\n\", bit.query(q->y) * q->k);\n\t\t\tif (q->ans) *q->ans += bit.query(q->y) * q->k;\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; q++, p++) {\n\t\t*p = *q;\n\t\tbit.clear(p->y);\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].x, &a[i].y), a[i].x += 2, a[i].y += 2;\n\t\tmax = std::max(max, a[i].y);\n\t}\n\n\tstatic int ans[MAXM];\n\tint cnt = n;\n\tfor (int i = 0; i < m; i++) {\n\t\tint x1, y1, x2, y2;\n\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2), x1 += 2, y1 += 2, x2 += 2, y2 += 2;\n\t\tint *p = &ans[i];\n\n\t\ta[cnt++] = Triple(x2, y2, p, 1);\n\t\ta[cnt++] = Triple(x1 - 1, y1 - 1, p, 1);\n\t\ta[cnt++] = Triple(x1 - 1, y2, p, -1);\n\t\ta[cnt++] = Triple(x2, y1 - 1, p, -1);\n\n\t\tmax = std::max(max, y1);\n\t\tmax = std::max(max, y2);\n\t}\n\n\t// for (int i = 0; i < cnt; i++) {\n\t// \tif (a[i].ans) printf(\"Query [%d, %d] for ans[%ld]\\n\", a[i].x, a[i].y, a[i].ans - ans);\n\t// \telse printf(\"Update [%d, %d] = 1\\n\", a[i].x, a[i].y);\n\t// }\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < m; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"shoi2007-tree","published":1,"updated":"2016-06-25T03:07:53.211Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bzj009uc2xlzsl9e2y3"},{"title":"SDOI2016 - ","date":"2016-04-18T09:06:53.000Z","_content":"\n $ n $  $ m $  $ 0 $  $ n - 1 $  $ 0 $  $ m - 1 $   \n $ i $  $ j $  $ (i \\ {\\rm xor} \\ j) $ \n\n$$ \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {m - 1} (i \\ {\\rm xor} \\ j) $$\n\n $ 1 $ $ 0 $   \n$ k $ \n\n$$ \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {m - 1} \\max((i \\ {\\rm xor} \\ j) - k, 0) $$\n\n $ k $   \n $ p $ \n\n<!-- more -->\n\n### \n[COGS 2220](http://cogs.top/cogs/problem/problem.php?pid=2220)  \n[BZOJ 4513](http://www.lydsy.com/JudgeOnline/problem.php?id=4513)\n\n### \n DP   \n\n\n\n $ x < 2 ^ N $$ y < 2 ^ N $ $ (x + 2 ^ N) \\ {\\rm xor} \\ (y + 2 ^ N) = x \\ {\\rm xor} \\ y $\n\n>  $ N $  $ 0 $ $ 1 $\n\n $ x \\neq y $ $ x \\ {\\rm xor} \\ z \\neq y \\ {\\rm xor} \\ z $\n\n>  $ x \\ {\\rm xor} \\ z = y \\ {\\rm xor} \\ z = a $ $ x \\ {\\rm xor} \\ a = z $$ y \\ {\\rm xor} \\ a = z $ $ x = y $\n\n $ x < 2 ^ N $$ [0, 2 ^ N - 1] $  $ x $  $ [0, 2 ^ N - 1] $ \n\n>  2  $ N $  $ 2 ^ N $ $ 2 ^ N - 1 $  $ [0, 2 ^ N - 1] $ \n\n $ n > m $$ n $ $ m $ \n\n $ k $ $ n = m = 2 ^ N $$ N = 3 $\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 \\\\\n4 & 5 & 6 & 7 & 0 & 1 & 2 & 3 \\\\\n5 & 4 & 7 & 6 & 1 & 0 & 3 & 2 \\\\\n6 & 7 & 4 & 5 & 2 & 3 & 0 & 1 \\\\\n7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\\\\n\\end{matrix}\n$$\n\n $ [0, 2 ^ N - 1] $ \n\n $ N = \\lfloor \\log_2 n \\rfloor $$ M = \\lfloor \\log_2 m \\rfloor $ $ N = M $ \n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & \\color{rgb(236, 62, 61)}{8} & \\color{rgb(236, 62, 61)}{9} \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 & \\color{rgb(236, 62, 61)}{9} & \\color{rgb(236, 62, 61)}{8} \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 & \\color{rgb(236, 62, 61)}{10} & \\color{rgb(236, 62, 61)}{11} \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 & \\color{rgb(236, 62, 61)}{11} & \\color{rgb(236, 62, 61)}{10} \\\\\n4 & 5 & 6 & 7 & 0 & 1 & 2 & 3 & \\color{rgb(236, 62, 61)}{12} & \\color{rgb(236, 62, 61)}{13} \\\\\n5 & 4 & 7 & 6 & 1 & 0 & 3 & 2 & \\color{rgb(236, 62, 61)}{13} & \\color{rgb(236, 62, 61)}{12} \\\\\n6 & 7 & 4 & 5 & 2 & 3 & 0 & 1 & \\color{rgb(236, 62, 61)}{14} & \\color{rgb(236, 62, 61)}{15} \\\\\n7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & \\color{rgb(236, 62, 61)}{15} & \\color{rgb(236, 62, 61)}{14} \\\\\n\\color{rgb(20, 122, 4)}{8} & \\color{rgb(20, 122, 4)}{9} & \\color{rgb(20, 122, 4)}{10} & \\color{rgb(20, 122, 4)}{11} & \\color{rgb(20, 122, 4)}{12} & \\color{rgb(20, 122, 4)}{13} & \\color{rgb(20, 122, 4)}{14} & \\color{rgb(20, 122, 4)}{15} & \\color{rgb(249, 181, 37)}{0} & \\color{rgb(249, 181, 37)}{1} \\\\\n\\color{rgb(20, 122, 4)}{9} & \\color{rgb(20, 122, 4)}{8} & \\color{rgb(20, 122, 4)}{11} & \\color{rgb(20, 122, 4)}{10} & \\color{rgb(20, 122, 4)}{13} & \\color{rgb(20, 122, 4)}{12} & \\color{rgb(20, 122, 4)}{15} & \\color{rgb(20, 122, 4)}{14} & \\color{rgb(249, 181, 37)}{1} & \\color{rgb(249, 181, 37)}{0} \\\\\n\\end{matrix}\n$$\n\n $ [2 ^ N, 2 ^ N + 2 ^ M - 1] $ \n\n $ n $  $ m $ \n\n $ N > M $ $ n > m $  $ N < M $\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & \\color{rgb(102, 204, 255)}{8} & \\color{rgb(102, 204, 255)}{9} \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 & \\color{rgb(102, 204, 255)}{9} & \\color{rgb(102, 204, 255)}{8} \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 & \\color{rgb(102, 204, 255)}{10} & \\color{rgb(102, 204, 255)}{11} \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 & \\color{rgb(102, 204, 255)}{11} & \\color{rgb(102, 204, 255)}{10} \\\\\n\\end{matrix}\n$$\n\n $ [0, 2 ^ N - 1] $ $ 2 ^ N $ $ 2 ^ N $  $ N = M $  $ 2 ^ N $ \n\n $ k $  $ 0, 1, 2, 3,  n $  $ \\leq k $  $ 0 $ $ k $ $ 1 $  $ n - k $ \n\n $ k $  $ n $  $ k $ \n\n $ n $  $ 1 $ $ O(T \\log (\\max(n, m))) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 5000;\nconst long long MAXN = 1e18;\nconst long long MAXM = 1e18;\nconst long long MAXK = 1e18;\nconst int MAXP = 1e9;\n\nlong long p = MAXP;\n\n/*\ntemplate <typename T>\ninline int bitsCount(const T &x) {\n    for (int i = sizeof(T) * 8 - 1; i >= 0; i--) if (x & ((T)1 << i)) return i + 1;\n    return 0;\n}\n*/\n\ntemplate <typename T>\ninline void bitsPrint(const T &x) {\n    for (int i = sizeof(T) * 8 - 1; i >= 0; i--)\n        if (x & ((T)1 << i)) putchar('1');\n        else putchar('0');\n    putchar('\\n');\n}\n\ntemplate <typename T>\ninline T lowbit(const T &x) { return x & -x; }\n\ntemplate <typename T>\ninline int log2(T x) {\n    int ans = 0;\n    while (x >>= 1) ans++;\n    return ans;\n}\n\ntemplate <typename T>\ninline T mul(T x, T y, const T &z = 1) {\n    // (x * y) / z, z is 1 or 2;\n    if (z == 2) {\n        if (x & 1) y >>= 1;\n        else if (y & 1) x >>= 1;\n        else throw;\n    }\n    return (x % p) * (y % p) % p;\n}\n\ninline long long sumTimes(long long first, long long n, const long long k, const long long t) {\n   //  printf(\"from %lld to %lld = (%lld + %lld) * %lld / 2, and %lld times\\n\", first, first + n - 1, first, (first + n - 1), n, t);\n    first -= k;\n    if (first < 1) n -= (1 - first), first = 1;\n    // printf(\"from %lld to %lld = (%lld + %lld) * %lld / 2, and %lld times\\n\", first, first + n - 1, first, (first + n - 1), n, t);\n    if (n <= 0) return 0;\n    return mul(mul(first + (first + n - 1), n, 2ll), t);\n}\n\nlong long solve(long long n, long long m, long long k) {\n    // printf(\"solve(%lld, %lld, %lld)\\n\", n, m, k);\n    if (n == 0 || m == 0) return 0;\n\n    if (k < 0) k = 0;\n    if (n < m) std::swap(n, m);\n\n    if (n == m && lowbit(n) == n) {\n        return sumTimes(1, n - 1, k, m);\n    }\n\n    int N = log2(n), M = log2(m);\n    long long centerWidth = (1ll << N), centerHeight = (1ll << M);\n    if (N == M) {\n        long long rightWidth = n - centerWidth, rightHeight = centerHeight;\n        long long bottomWidth = centerWidth, bottomHeight = m - centerHeight;\n\n        long long rightSum = sumTimes(centerWidth, rightHeight, k, rightWidth);\n        long long bottomSum = sumTimes(centerHeight, bottomWidth, k, bottomHeight);\n\n        long long sideSum = solve(rightWidth, bottomHeight, k);\n        long long centerSum = solve(bottomWidth, rightHeight, k);\n\n        return ((rightSum + bottomSum) % p + (sideSum + centerSum) % p) % p;\n    } else {\n        long long leftWidth = (1ll << N), leftHeight = m;\n        long long rightWidth = n - leftWidth, rightHeight = leftHeight;\n\n        long long leftSum = sumTimes(0, leftWidth, k, leftHeight);\n        long long rightSum = solve(rightWidth, rightHeight, k - leftWidth);\n\n        if (leftWidth > k) {\n            rightSum += mul(mul(leftWidth - k, m), n - leftWidth);\n            rightSum %= p;\n        }\n\n        return (leftSum + rightSum) % p;\n    }\n}\n\nint main() {\n    freopen(\"menci_table.in\", \"r\", stdin);\n    freopen(\"menci_table.out\", \"w\", stdout);\n\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        long long n, m, k;\n        scanf(\"%lld %lld %lld %lld\", &n, &m, &k, &p);\n        printf(\"%lld\\n\", solve(n, m, k));\n    }\n\n    // long long n, m, k;\n    // scanf(\"%lld %lld %lld\", &n, &m, &k);\n    // bitsPrint(n), bitsPrint(m);\n\n    // printf(\"lowbit(%lld) = %lld\\nbitsCount(%lld) = %d\\n2 ^ bitsCount(%lld) = %d\\n\", n, lowbit(n), n, bitsCount(n), n, 1 << (bitsCount(n)));\n    // bitsPrint((1 << bitsCount(n)) - 1);\n\n    /*long long ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int t = std::max((i ^ j) - k, 0ll);\n            printf(\"%3d\", t);\n            ans += t;\n        }\n        putchar('\\n');\n    }*/\n\n    // printf(\"ans = %lld\\n\", ans);\n\n    // printf(\"%lld\\n\", solve(n, m, k));\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/sdoi2016-table.md","raw":"title: SDOI2016 - \ndate: 2016-04-18 17:06:53\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - \n  - \n  - \npermalink: sdoi2016-table\n---\n\n $ n $  $ m $  $ 0 $  $ n - 1 $  $ 0 $  $ m - 1 $   \n $ i $  $ j $  $ (i \\ {\\rm xor} \\ j) $ \n\n$$ \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {m - 1} (i \\ {\\rm xor} \\ j) $$\n\n $ 1 $ $ 0 $   \n$ k $ \n\n$$ \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {m - 1} \\max((i \\ {\\rm xor} \\ j) - k, 0) $$\n\n $ k $   \n $ p $ \n\n<!-- more -->\n\n### \n[COGS 2220](http://cogs.top/cogs/problem/problem.php?pid=2220)  \n[BZOJ 4513](http://www.lydsy.com/JudgeOnline/problem.php?id=4513)\n\n### \n DP   \n\n\n\n $ x < 2 ^ N $$ y < 2 ^ N $ $ (x + 2 ^ N) \\ {\\rm xor} \\ (y + 2 ^ N) = x \\ {\\rm xor} \\ y $\n\n>  $ N $  $ 0 $ $ 1 $\n\n $ x \\neq y $ $ x \\ {\\rm xor} \\ z \\neq y \\ {\\rm xor} \\ z $\n\n>  $ x \\ {\\rm xor} \\ z = y \\ {\\rm xor} \\ z = a $ $ x \\ {\\rm xor} \\ a = z $$ y \\ {\\rm xor} \\ a = z $ $ x = y $\n\n $ x < 2 ^ N $$ [0, 2 ^ N - 1] $  $ x $  $ [0, 2 ^ N - 1] $ \n\n>  2  $ N $  $ 2 ^ N $ $ 2 ^ N - 1 $  $ [0, 2 ^ N - 1] $ \n\n $ n > m $$ n $ $ m $ \n\n $ k $ $ n = m = 2 ^ N $$ N = 3 $\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 \\\\\n4 & 5 & 6 & 7 & 0 & 1 & 2 & 3 \\\\\n5 & 4 & 7 & 6 & 1 & 0 & 3 & 2 \\\\\n6 & 7 & 4 & 5 & 2 & 3 & 0 & 1 \\\\\n7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 \\\\\n\\end{matrix}\n$$\n\n $ [0, 2 ^ N - 1] $ \n\n $ N = \\lfloor \\log_2 n \\rfloor $$ M = \\lfloor \\log_2 m \\rfloor $ $ N = M $ \n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & \\color{rgb(236, 62, 61)}{8} & \\color{rgb(236, 62, 61)}{9} \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 & \\color{rgb(236, 62, 61)}{9} & \\color{rgb(236, 62, 61)}{8} \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 & \\color{rgb(236, 62, 61)}{10} & \\color{rgb(236, 62, 61)}{11} \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 & \\color{rgb(236, 62, 61)}{11} & \\color{rgb(236, 62, 61)}{10} \\\\\n4 & 5 & 6 & 7 & 0 & 1 & 2 & 3 & \\color{rgb(236, 62, 61)}{12} & \\color{rgb(236, 62, 61)}{13} \\\\\n5 & 4 & 7 & 6 & 1 & 0 & 3 & 2 & \\color{rgb(236, 62, 61)}{13} & \\color{rgb(236, 62, 61)}{12} \\\\\n6 & 7 & 4 & 5 & 2 & 3 & 0 & 1 & \\color{rgb(236, 62, 61)}{14} & \\color{rgb(236, 62, 61)}{15} \\\\\n7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & \\color{rgb(236, 62, 61)}{15} & \\color{rgb(236, 62, 61)}{14} \\\\\n\\color{rgb(20, 122, 4)}{8} & \\color{rgb(20, 122, 4)}{9} & \\color{rgb(20, 122, 4)}{10} & \\color{rgb(20, 122, 4)}{11} & \\color{rgb(20, 122, 4)}{12} & \\color{rgb(20, 122, 4)}{13} & \\color{rgb(20, 122, 4)}{14} & \\color{rgb(20, 122, 4)}{15} & \\color{rgb(249, 181, 37)}{0} & \\color{rgb(249, 181, 37)}{1} \\\\\n\\color{rgb(20, 122, 4)}{9} & \\color{rgb(20, 122, 4)}{8} & \\color{rgb(20, 122, 4)}{11} & \\color{rgb(20, 122, 4)}{10} & \\color{rgb(20, 122, 4)}{13} & \\color{rgb(20, 122, 4)}{12} & \\color{rgb(20, 122, 4)}{15} & \\color{rgb(20, 122, 4)}{14} & \\color{rgb(249, 181, 37)}{1} & \\color{rgb(249, 181, 37)}{0} \\\\\n\\end{matrix}\n$$\n\n $ [2 ^ N, 2 ^ N + 2 ^ M - 1] $ \n\n $ n $  $ m $ \n\n $ N > M $ $ n > m $  $ N < M $\n\n$$\n\\begin{matrix}\n0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & \\color{rgb(102, 204, 255)}{8} & \\color{rgb(102, 204, 255)}{9} \\\\\n1 & 0 & 3 & 2 & 5 & 4 & 7 & 6 & \\color{rgb(102, 204, 255)}{9} & \\color{rgb(102, 204, 255)}{8} \\\\\n2 & 3 & 0 & 1 & 6 & 7 & 4 & 5 & \\color{rgb(102, 204, 255)}{10} & \\color{rgb(102, 204, 255)}{11} \\\\\n3 & 2 & 1 & 0 & 7 & 6 & 5 & 4 & \\color{rgb(102, 204, 255)}{11} & \\color{rgb(102, 204, 255)}{10} \\\\\n\\end{matrix}\n$$\n\n $ [0, 2 ^ N - 1] $ $ 2 ^ N $ $ 2 ^ N $  $ N = M $  $ 2 ^ N $ \n\n $ k $  $ 0, 1, 2, 3,  n $  $ \\leq k $  $ 0 $ $ k $ $ 1 $  $ n - k $ \n\n $ k $  $ n $  $ k $ \n\n $ n $  $ 1 $ $ O(T \\log (\\max(n, m))) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 5000;\nconst long long MAXN = 1e18;\nconst long long MAXM = 1e18;\nconst long long MAXK = 1e18;\nconst int MAXP = 1e9;\n\nlong long p = MAXP;\n\n/*\ntemplate <typename T>\ninline int bitsCount(const T &x) {\n    for (int i = sizeof(T) * 8 - 1; i >= 0; i--) if (x & ((T)1 << i)) return i + 1;\n    return 0;\n}\n*/\n\ntemplate <typename T>\ninline void bitsPrint(const T &x) {\n    for (int i = sizeof(T) * 8 - 1; i >= 0; i--)\n        if (x & ((T)1 << i)) putchar('1');\n        else putchar('0');\n    putchar('\\n');\n}\n\ntemplate <typename T>\ninline T lowbit(const T &x) { return x & -x; }\n\ntemplate <typename T>\ninline int log2(T x) {\n    int ans = 0;\n    while (x >>= 1) ans++;\n    return ans;\n}\n\ntemplate <typename T>\ninline T mul(T x, T y, const T &z = 1) {\n    // (x * y) / z, z is 1 or 2;\n    if (z == 2) {\n        if (x & 1) y >>= 1;\n        else if (y & 1) x >>= 1;\n        else throw;\n    }\n    return (x % p) * (y % p) % p;\n}\n\ninline long long sumTimes(long long first, long long n, const long long k, const long long t) {\n   //  printf(\"from %lld to %lld = (%lld + %lld) * %lld / 2, and %lld times\\n\", first, first + n - 1, first, (first + n - 1), n, t);\n    first -= k;\n    if (first < 1) n -= (1 - first), first = 1;\n    // printf(\"from %lld to %lld = (%lld + %lld) * %lld / 2, and %lld times\\n\", first, first + n - 1, first, (first + n - 1), n, t);\n    if (n <= 0) return 0;\n    return mul(mul(first + (first + n - 1), n, 2ll), t);\n}\n\nlong long solve(long long n, long long m, long long k) {\n    // printf(\"solve(%lld, %lld, %lld)\\n\", n, m, k);\n    if (n == 0 || m == 0) return 0;\n\n    if (k < 0) k = 0;\n    if (n < m) std::swap(n, m);\n\n    if (n == m && lowbit(n) == n) {\n        return sumTimes(1, n - 1, k, m);\n    }\n\n    int N = log2(n), M = log2(m);\n    long long centerWidth = (1ll << N), centerHeight = (1ll << M);\n    if (N == M) {\n        long long rightWidth = n - centerWidth, rightHeight = centerHeight;\n        long long bottomWidth = centerWidth, bottomHeight = m - centerHeight;\n\n        long long rightSum = sumTimes(centerWidth, rightHeight, k, rightWidth);\n        long long bottomSum = sumTimes(centerHeight, bottomWidth, k, bottomHeight);\n\n        long long sideSum = solve(rightWidth, bottomHeight, k);\n        long long centerSum = solve(bottomWidth, rightHeight, k);\n\n        return ((rightSum + bottomSum) % p + (sideSum + centerSum) % p) % p;\n    } else {\n        long long leftWidth = (1ll << N), leftHeight = m;\n        long long rightWidth = n - leftWidth, rightHeight = leftHeight;\n\n        long long leftSum = sumTimes(0, leftWidth, k, leftHeight);\n        long long rightSum = solve(rightWidth, rightHeight, k - leftWidth);\n\n        if (leftWidth > k) {\n            rightSum += mul(mul(leftWidth - k, m), n - leftWidth);\n            rightSum %= p;\n        }\n\n        return (leftSum + rightSum) % p;\n    }\n}\n\nint main() {\n    freopen(\"menci_table.in\", \"r\", stdin);\n    freopen(\"menci_table.out\", \"w\", stdout);\n\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        long long n, m, k;\n        scanf(\"%lld %lld %lld %lld\", &n, &m, &k, &p);\n        printf(\"%lld\\n\", solve(n, m, k));\n    }\n\n    // long long n, m, k;\n    // scanf(\"%lld %lld %lld\", &n, &m, &k);\n    // bitsPrint(n), bitsPrint(m);\n\n    // printf(\"lowbit(%lld) = %lld\\nbitsCount(%lld) = %d\\n2 ^ bitsCount(%lld) = %d\\n\", n, lowbit(n), n, bitsCount(n), n, 1 << (bitsCount(n)));\n    // bitsPrint((1 << bitsCount(n)) - 1);\n\n    /*long long ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            int t = std::max((i ^ j) - k, 0ll);\n            printf(\"%3d\", t);\n            ans += t;\n        }\n        putchar('\\n');\n    }*/\n\n    // printf(\"ans = %lld\\n\", ans);\n\n    // printf(\"%lld\\n\", solve(n, m, k));\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"sdoi2016-table","published":1,"updated":"2016-09-10T05:54:16.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bzn00a4c2xl7y3lfduh"},{"title":"SDOI2016 Round1 ","date":"2016-04-09T13:59:32.000Z","_content":"\n \n\n<!-- more -->\n\n### Day 0\n     \n\n   \n\n  **** \n\n \n\n EK  \n\n \n\n QwQ \n\n yts1999 %%%\n\n Blog  \n\n### Day 1\n   \n XP  Windows    \n7:59  WC  \n\n \n\n   DP   \n30min    \n  20  \n\n    Miller  Rabin    \n +    \n  \npapapa  $ 1000 \\times 1000 $    $ O((n + m) ^ 3) $   \n     EK    \n   \n   \n  \n $ b_i $    \n   \n`Wrong Answer on Test #7`md     \n`Wrong Answer on Test #13`md     \n `Accepted`    \n\n  \n     SegmentTree Beats    \n BFS    \n $ a = 0 $    \n  \n      \n`Wrong Answer on Test #18`     \n`Wrong Answer on Test #32`       \nmd      \nmd  `size`    \n`s.top()`  `s.pop()`   \n 12:40    \n\n T2  maya      \nT2  $ O( $  $ ) $    $ n = 200 $    \n 1.5s   \n   \nT  T    \n\n140rank9 \n\nheheda AK   \nstd rank2\n\n\n\n     KMP   \n\nDay1   \n Day2 \n\n### Day 2\n  7:50 \n\nwow  \n\n7:57  \n\n \n\nmaya 60  60   \n 30 `std::set< std::vector<int> >`    \n\nmaya        \n     \n 10   $ O(n!) $  \n\n DP10 $ O(n ^ 3) $  DP  30    \n\n   `std::sort`    \n `height`   `height`    \n\n $ O(n ^ 2 \\log n + n ^ 2) $  \n\n \n\n1.5h  `height`  \n\n \n\n$ O(n ^ 2) $  `height`    \n `height` `height + 1` 0   \n `\"heheda\"`    \n   \n   \n\n\n\n     \n   \n `std::sort` \n\n $ O(n \\log n \\log n + n) $ \n\n    \n   \n `height`   \n   \n   \nmaya  \n\n   \n\n\n $ O(n \\log n \\log n + n ^ 2) $   \n `height`      \n\n  \n       \n\n 30  DP  12:40    \nmaya   \n  maya   \n   \n `double`    \n     \n\n12:50       \nmaya   \n\n13:00    \n\n \n\nDay1 T1 DP  \nT2      \nT3  Orz\n\nDay2 T1   \n   \nT2 maya 60    \nT3      \n\n  90    60  \n\n Day1  Flag \n\n \n","source":"_posts/sdoi2016-round1.md","raw":"title: SDOI2016 Round1 \ncategories: \n  - Diary\npermalink: sdoi2016-round1\ndate: 2016-04-09 21:59:32\n---\n\n \n\n<!-- more -->\n\n### Day 0\n     \n\n   \n\n  **** \n\n \n\n EK  \n\n \n\n QwQ \n\n yts1999 %%%\n\n Blog  \n\n### Day 1\n   \n XP  Windows    \n7:59  WC  \n\n \n\n   DP   \n30min    \n  20  \n\n    Miller  Rabin    \n +    \n  \npapapa  $ 1000 \\times 1000 $    $ O((n + m) ^ 3) $   \n     EK    \n   \n   \n  \n $ b_i $    \n   \n`Wrong Answer on Test #7`md     \n`Wrong Answer on Test #13`md     \n `Accepted`    \n\n  \n     SegmentTree Beats    \n BFS    \n $ a = 0 $    \n  \n      \n`Wrong Answer on Test #18`     \n`Wrong Answer on Test #32`       \nmd      \nmd  `size`    \n`s.top()`  `s.pop()`   \n 12:40    \n\n T2  maya      \nT2  $ O( $  $ ) $    $ n = 200 $    \n 1.5s   \n   \nT  T    \n\n140rank9 \n\nheheda AK   \nstd rank2\n\n\n\n     KMP   \n\nDay1   \n Day2 \n\n### Day 2\n  7:50 \n\nwow  \n\n7:57  \n\n \n\nmaya 60  60   \n 30 `std::set< std::vector<int> >`    \n\nmaya        \n     \n 10   $ O(n!) $  \n\n DP10 $ O(n ^ 3) $  DP  30    \n\n   `std::sort`    \n `height`   `height`    \n\n $ O(n ^ 2 \\log n + n ^ 2) $  \n\n \n\n1.5h  `height`  \n\n \n\n$ O(n ^ 2) $  `height`    \n `height` `height + 1` 0   \n `\"heheda\"`    \n   \n   \n\n\n\n     \n   \n `std::sort` \n\n $ O(n \\log n \\log n + n) $ \n\n    \n   \n `height`   \n   \n   \nmaya  \n\n   \n\n\n $ O(n \\log n \\log n + n ^ 2) $   \n `height`      \n\n  \n       \n\n 30  DP  12:40    \nmaya   \n  maya   \n   \n `double`    \n     \n\n12:50       \nmaya   \n\n13:00    \n\n \n\nDay1 T1 DP  \nT2      \nT3  Orz\n\nDay2 T1   \n   \nT2 maya 60    \nT3      \n\n  90    60  \n\n Day1  Flag \n\n \n","slug":"sdoi2016-round1","published":1,"updated":"2016-11-20T15:49:24.533Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bzu00agc2xlqu7taing"},{"title":"SDOI2016 -  + ","date":"2016-04-13T03:45:13.000Z","_content":"\n $ n $  $ A $\n\n* $ 1 $ ~ $ n $  $ n $ \n*  $ i $  $ A[i] $  $ i $ $ i $  $ m $ \n\n $ 10 ^ 9 + 7 $ \n\n<!-- more -->\n\n### \n[COGS 2224](http://cogs.top/cogs/problem/problem.php?pid=2224)  \n[BZOJ 4517](http://www.lydsy.com/JudgeOnline/problem.php?id=4517)\n\n### \n\n\n $ n $  $ m $  $ n - m $ \n\n $ f(i) $  i \n\n$$ C(n, m) * f(n - m) $$\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXT = 500000;\nconst int MAXN = 1000000;\nconst int MAXM = 1000000;\nconst int MOD = 1e9 + 7;\n\nlong long fac[MAXN + 1], inv[MAXN + 1], facInv[MAXN + 1], f[MAXN + 1];\n\n/*\ninline int pow(const int n, const int k) {\n\tlong long ans = 1;\n\tfor (long long num = n, t = k; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\nvoid exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int num) {\n\tint g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn ((x % MOD) + MOD) % MOD;\n}\n*/\n\ninline int C(const int n, const int k) {\n\tif (k == 0) return 1;\n\treturn fac[n] * facInv[k] % MOD * facInv[n - k] % MOD;\n}\n\ninline void prepare() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) fac[i] = fac[i - 1] * i % MOD;\n\n\tinv[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;\n\n\tfacInv[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) facInv[i] = facInv[i - 1] * inv[i] % MOD;\n\n\tf[0] = 0, f[1] = 0, f[2] = 1;\n\tfor (int i = 3; i <= MAXN; i++) {\n\t\tf[i] = (i - 1) * (f[i - 1] + f[i - 2]) % MOD;\n\t}\n}\n\ninline int solve(const int n, const int m) {\n\tif (n < m || n == 0) return 0;\n\telse if (n == m) return 1;\n\telse {\n\t\treturn C(n, m) * f[n - m] % MOD;\n\t}\n}\n\nint main() {\n\tfreopen(\"menci_permutation.in\", \"r\", stdin);\n\tfreopen(\"menci_permutation.out\", \"w\", stdout);\n\n\tprepare();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tprintf(\"%d\\n\", solve(n, m));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2016-permutation.md","raw":"title: SDOI2016 -  + \ndate: 2016-04-13 11:45:13\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - \n  - \n  - \n  - \npermalink: sdoi2016-permutation\n---\n\n $ n $  $ A $\n\n* $ 1 $ ~ $ n $  $ n $ \n*  $ i $  $ A[i] $  $ i $ $ i $  $ m $ \n\n $ 10 ^ 9 + 7 $ \n\n<!-- more -->\n\n### \n[COGS 2224](http://cogs.top/cogs/problem/problem.php?pid=2224)  \n[BZOJ 4517](http://www.lydsy.com/JudgeOnline/problem.php?id=4517)\n\n### \n\n\n $ n $  $ m $  $ n - m $ \n\n $ f(i) $  i \n\n$$ C(n, m) * f(n - m) $$\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXT = 500000;\nconst int MAXN = 1000000;\nconst int MAXM = 1000000;\nconst int MOD = 1e9 + 7;\n\nlong long fac[MAXN + 1], inv[MAXN + 1], facInv[MAXN + 1], f[MAXN + 1];\n\n/*\ninline int pow(const int n, const int k) {\n\tlong long ans = 1;\n\tfor (long long num = n, t = k; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\nvoid exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int num) {\n\tint g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn ((x % MOD) + MOD) % MOD;\n}\n*/\n\ninline int C(const int n, const int k) {\n\tif (k == 0) return 1;\n\treturn fac[n] * facInv[k] % MOD * facInv[n - k] % MOD;\n}\n\ninline void prepare() {\n\tfac[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) fac[i] = fac[i - 1] * i % MOD;\n\n\tinv[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;\n\n\tfacInv[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) facInv[i] = facInv[i - 1] * inv[i] % MOD;\n\n\tf[0] = 0, f[1] = 0, f[2] = 1;\n\tfor (int i = 3; i <= MAXN; i++) {\n\t\tf[i] = (i - 1) * (f[i - 1] + f[i - 2]) % MOD;\n\t}\n}\n\ninline int solve(const int n, const int m) {\n\tif (n < m || n == 0) return 0;\n\telse if (n == m) return 1;\n\telse {\n\t\treturn C(n, m) * f[n - m] % MOD;\n\t}\n}\n\nint main() {\n\tfreopen(\"menci_permutation.in\", \"r\", stdin);\n\tfreopen(\"menci_permutation.out\", \"w\", stdout);\n\n\tprepare();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tprintf(\"%d\\n\", solve(n, m));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2016-permutation","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6bzx00ajc2xlml35kc7l"},{"title":"SDOI2016 - ","date":"2016-04-09T10:06:43.000Z","_content":"\n $ n $  $ i $  $ a_i $ $ b_i $  $ c_i $\n\n $ a_i $$ a_j $ $ a_i $  $ a_j $  $ \\frac{a_i}{a_j} $  $ c_i \\times c_j $ \n\n  \n $ 0 $ \n\n<!-- more -->\n\n### \n[BZOJ 4514](http://www.lydsy.com/JudgeOnline/problem.php?id=4514)  \n[COGS 2221](http://cogs.top/cogs/problem/problem.php?pid=2221)\n\n### \n $ 10 ^ 6 $ \n\n $ X $  $ b_i $  $ 0 $ $ Y $  $ b_i $  $ 0 $ $ X $  $ Y $  $ -(c_i \\times c_j) $\n\n $ \\leq 0 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXA = 1e9;\nconst int MAXP = 1e6;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint c, f;\n\tlong long d;\n\tbool q;\n} N[MAXN + 3];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tlong long w;\n\tEdge *next, *r;\n\t\n\tEdge(Node *s, Node *t, const int c, const long long w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n} *limE;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\t\n\tMemoryPool() {\n\t\treset();\n\t}\n\t\n\tvoid reset() { cur = buf; }\n\t\n\tT *alloc() {\n\t\tif (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn (T *)p;\n\t\t}\n\t}\n};\n\nMemoryPool<Edge, MAXN * MAXN * 10> pool;\ninline Edge *addEdge(int u, int v, const int c, const long long w) {\n\t// printf(\"E(%d, %d, %d, %d)\\n\", u, v, c, w);\n\tN[u].e = &(*(pool.alloc()) = Edge(&N[u], &N[v], c, w));\n\tN[v].e = &(*(pool.alloc()) = Edge(&N[v], &N[u], 0, -w));\n\tN[u].e->r = N[v].e, N[v].e->r = N[u].e;\n\t\n\treturn N[u].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, long long &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = LLONG_MAX;\n\t\t}\n\t\t\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->q = false;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\t\te->t->in = e;\n\t\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\t\tif (!e->t->q) {\n\t\t\t\t\t\te->t->q = true;\n\t\t\t\t\t\tq.push(e->t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (N[t].d == LLONG_MAX) return;\n\t\t\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\t\t\n\t\tflow += N[t].f;\n\t\tcost += N[t].f * N[t].d;\n\t\t// printf(\"cost = %d\\n\", -cost);\n\t}\t\n}\n\nint n, s, ss, t;\n\nstruct Number {\n\tint a, b, c, t;\n\t\n\tbool operator<(const Number &o) const { return a < o.a; }\n} a[MAXN + 1];\n\ninline void color() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].c != 0) continue;\n\t\t\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].c = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->c == 0) {\n\t\t\t\t\te->t->c = (v->c == 1) ? -1 : 1;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t} else {\n\t\t\t\t\t// if (e->t->c == v->c) throw;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n}\n\ninline bool check(const int limit) {\n\tfor (int i = 0; i < n + 3; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\te->f = 0;\n\t\t}\n\t}\n\t\n\tlimE->c = limit;\n\t\n\tint flow;\n\tlong long cost;\n\tedmondskarp(ss, t, n + 3, flow, cost);\n\t// printf(\"cost = %d\\n\", cost);\n\treturn cost <= 0;\n}\n\ninline int solve() {\n\tlimE->c = INT_MAX;\n\tint flow;\n\tlong long cost;\n\tedmondskarp(ss, t, n + 3, flow, cost);\n\n\tint l = 0, r = flow;\n\twhile (l < r) {\n\t\t// printf(\"(%d, %d)\\n\", l, r);\n\t\tint mid = l + ((r - l) >> 1) + 1;\n\t\tif (check(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\t\n\treturn l;\n}\n\nbool isNotPrime[MAXP + 1];\nint primes[MAXP], cnt;\ninline void euler() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXP; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t}\n\t\t\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tif (primes[j] * i > MAXP) break;\n\t\t\tisNotPrime[primes[j] * i] = true;\n\t\t\tif (i % primes[j] == 0) break; \n\t\t}\n\t}\n}\n\ninline bool isPrime(const int x) {\n\tif (x <= MAXP && isNotPrime[x]) return false;\n\tif (x == 1) return false;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tint &p = primes[i];\n\t\tif (p * p > x) return true;\n\t\tif (x % p == 0) return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tfreopen(\"pair.in\", \"r\", stdin);\n\tfreopen(\"pair.out\", \"w\", stdout);\n\t\n\teuler();\n\t\n\tscanf(\"%d\", &n);\n\tint sum = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].a);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].b), sum += a[i].b;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].c);\n\tstd::sort(a + 1, a + n + 1);\n\t\n\tbool valid[MAXN + 1][MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tNumber &xi = a[i];\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tNumber &xj = a[j];\n\t\t\tif (xi.a % xj.a == 0 && isPrime(xi.a / xj.a)) {\n\t\t\t\tvalid[i][j] = true;\n\t\t\t\taddEdge(i, j, 0, 0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcolor();\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].t = N[i].c;\n\t\tN[i].e = NULL;\n\t}\n\t\n\tpool.reset();\n\t\n\ts = 0, ss = n + 1, t = n + 2;\n\tfor (int i = 1; i <= n; i++) {\n\t\tNumber &xi = a[i];\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tNumber &xj = a[j];\n\t\t\tif (valid[i][j]) {\n\t\t\t\t// if (xi.t == xj.t) puts(\"failed!\");\n\t\t\t\tif (xi.t == 1) {\n\t\t\t\t\taddEdge(i, j, INT_MAX, -(long long)xi.c * xj.c);\n\t\t\t\t} else {\n\t\t\t\t\taddEdge(j, i, INT_MAX, -(long long)xi.c * xj.c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (N[i].c == 1) {\n\t\t\taddEdge(s, i, xi.b, 0);\n\t\t} else {\n\t\t\taddEdge(i, t, xi.b, 0);\n\t\t}\n\t}\n\t\n\tlimE = addEdge(ss, s, sum, 0);\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2016-pair.md","raw":"title: SDOI2016 - \ndate: 2016-04-09 18:06:43\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - Edmonds-Karp\n  - \n  - \n  - \n  - \n  - \n  - \npermalink: sdoi2016-pair\n---\n\n $ n $  $ i $  $ a_i $ $ b_i $  $ c_i $\n\n $ a_i $$ a_j $ $ a_i $  $ a_j $  $ \\frac{a_i}{a_j} $  $ c_i \\times c_j $ \n\n  \n $ 0 $ \n\n<!-- more -->\n\n### \n[BZOJ 4514](http://www.lydsy.com/JudgeOnline/problem.php?id=4514)  \n[COGS 2221](http://cogs.top/cogs/problem/problem.php?pid=2221)\n\n### \n $ 10 ^ 6 $ \n\n $ X $  $ b_i $  $ 0 $ $ Y $  $ b_i $  $ 0 $ $ X $  $ Y $  $ -(c_i \\times c_j) $\n\n $ \\leq 0 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXA = 1e9;\nconst int MAXP = 1e6;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint c, f;\n\tlong long d;\n\tbool q;\n} N[MAXN + 3];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tlong long w;\n\tEdge *next, *r;\n\t\n\tEdge(Node *s, Node *t, const int c, const long long w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n} *limE;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\t\n\tMemoryPool() {\n\t\treset();\n\t}\n\t\n\tvoid reset() { cur = buf; }\n\t\n\tT *alloc() {\n\t\tif (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn (T *)p;\n\t\t}\n\t}\n};\n\nMemoryPool<Edge, MAXN * MAXN * 10> pool;\ninline Edge *addEdge(int u, int v, const int c, const long long w) {\n\t// printf(\"E(%d, %d, %d, %d)\\n\", u, v, c, w);\n\tN[u].e = &(*(pool.alloc()) = Edge(&N[u], &N[v], c, w));\n\tN[v].e = &(*(pool.alloc()) = Edge(&N[v], &N[u], 0, -w));\n\tN[u].e->r = N[v].e, N[v].e->r = N[u].e;\n\t\n\treturn N[u].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, long long &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = LLONG_MAX;\n\t\t}\n\t\t\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->q = false;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\t\te->t->in = e;\n\t\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\t\tif (!e->t->q) {\n\t\t\t\t\t\te->t->q = true;\n\t\t\t\t\t\tq.push(e->t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (N[t].d == LLONG_MAX) return;\n\t\t\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\t\t\n\t\tflow += N[t].f;\n\t\tcost += N[t].f * N[t].d;\n\t\t// printf(\"cost = %d\\n\", -cost);\n\t}\t\n}\n\nint n, s, ss, t;\n\nstruct Number {\n\tint a, b, c, t;\n\t\n\tbool operator<(const Number &o) const { return a < o.a; }\n} a[MAXN + 1];\n\ninline void color() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].c != 0) continue;\n\t\t\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].c = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->c == 0) {\n\t\t\t\t\te->t->c = (v->c == 1) ? -1 : 1;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t} else {\n\t\t\t\t\t// if (e->t->c == v->c) throw;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n}\n\ninline bool check(const int limit) {\n\tfor (int i = 0; i < n + 3; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\te->f = 0;\n\t\t}\n\t}\n\t\n\tlimE->c = limit;\n\t\n\tint flow;\n\tlong long cost;\n\tedmondskarp(ss, t, n + 3, flow, cost);\n\t// printf(\"cost = %d\\n\", cost);\n\treturn cost <= 0;\n}\n\ninline int solve() {\n\tlimE->c = INT_MAX;\n\tint flow;\n\tlong long cost;\n\tedmondskarp(ss, t, n + 3, flow, cost);\n\n\tint l = 0, r = flow;\n\twhile (l < r) {\n\t\t// printf(\"(%d, %d)\\n\", l, r);\n\t\tint mid = l + ((r - l) >> 1) + 1;\n\t\tif (check(mid)) l = mid;\n\t\telse r = mid - 1;\n\t}\n\t\n\treturn l;\n}\n\nbool isNotPrime[MAXP + 1];\nint primes[MAXP], cnt;\ninline void euler() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXP; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t}\n\t\t\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tif (primes[j] * i > MAXP) break;\n\t\t\tisNotPrime[primes[j] * i] = true;\n\t\t\tif (i % primes[j] == 0) break; \n\t\t}\n\t}\n}\n\ninline bool isPrime(const int x) {\n\tif (x <= MAXP && isNotPrime[x]) return false;\n\tif (x == 1) return false;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tint &p = primes[i];\n\t\tif (p * p > x) return true;\n\t\tif (x % p == 0) return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tfreopen(\"pair.in\", \"r\", stdin);\n\tfreopen(\"pair.out\", \"w\", stdout);\n\t\n\teuler();\n\t\n\tscanf(\"%d\", &n);\n\tint sum = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].a);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].b), sum += a[i].b;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].c);\n\tstd::sort(a + 1, a + n + 1);\n\t\n\tbool valid[MAXN + 1][MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tNumber &xi = a[i];\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tNumber &xj = a[j];\n\t\t\tif (xi.a % xj.a == 0 && isPrime(xi.a / xj.a)) {\n\t\t\t\tvalid[i][j] = true;\n\t\t\t\taddEdge(i, j, 0, 0);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcolor();\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].t = N[i].c;\n\t\tN[i].e = NULL;\n\t}\n\t\n\tpool.reset();\n\t\n\ts = 0, ss = n + 1, t = n + 2;\n\tfor (int i = 1; i <= n; i++) {\n\t\tNumber &xi = a[i];\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tNumber &xj = a[j];\n\t\t\tif (valid[i][j]) {\n\t\t\t\t// if (xi.t == xj.t) puts(\"failed!\");\n\t\t\t\tif (xi.t == 1) {\n\t\t\t\t\taddEdge(i, j, INT_MAX, -(long long)xi.c * xj.c);\n\t\t\t\t} else {\n\t\t\t\t\taddEdge(j, i, INT_MAX, -(long long)xi.c * xj.c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (N[i].c == 1) {\n\t\t\taddEdge(s, i, xi.b, 0);\n\t\t} else {\n\t\t\taddEdge(i, t, xi.b, 0);\n\t\t}\n\t}\n\t\n\tlimE = addEdge(ss, s, sum, 0);\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2016-pair","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c0400atc2xlxateai4p"},{"title":"SDOI2016 -  DP","date":"2016-04-17T14:46:04.000Z","_content":"\nPine  $ S $  $ T $   \n $ S $  $ T $  $ n $   \nPine  $ m $  $ T $  $ m $  Pine   \nPine   \n Pine \n\n $ v $$ v \\times m ^ 2 $  $ v \\times m ^ 2 $\n\n<!-- more -->\n\n### \n[COGS 2225](http://cogs.top/cogs/problem/problem.php?pid=2225)  \n[BZOJ 4518](http://www.lydsy.com/JudgeOnline/problem.php?id=4518)\n\n### \n $ a_i $ $ S = \\sum\\limits_{i = 1} ^ n a_i $\n\n$$\nm ^ 2 \\times \\sum\\limits_{i = 1} ^ m \\frac{(a_i - \\frac{S}{m}) ^ 2}{m}\n$$\n\n\n\n$$\n\\begin{align*}\n  & m ^ 2 \\times \n          \\sum\\limits_{i = 1} ^ m\n                      \\frac{(a_i - \\frac{S}{m}) ^ 2}\n                           {m} \\\\\n= & m ^ 2 \\times\n          \\sum\\limits_{i = 1} ^ m\n                      \\frac{   a_i ^ 2\n                             + (\\frac{S}{m}) ^ 2\n                             - 2 a_i \\frac{S}{m}\n                           }\n                           {m} \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        + \\sum\\limits_{i = 1} ^ m\n                      \\frac{S ^ 2}{m ^ 3}\n      - 2 \\sum\\limits_{i = 1} ^ m\n                      a_i \\frac{S}{m ^ 2} ) \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        +             \\frac{S ^ 2}{m ^ 2}\n      - 2      \\times \\frac{S ^ 2}{m ^ 2} ) \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        -             \\frac{S ^ 2}{m ^ 2} ) \\\\\n= & m \\times \\sum\\limits_{i = 1} ^ m a_i ^ 2 - S ^ 2 \\\\\n\\end{align*}\n$$\n\n $ m $ $ S ^ 2 $ \n\n$$ \\sum\\limits_{i = 1} ^ m a_i ^ 2 $$\n\n\n\n $ f[j][i] $  $ i $  $ j $ \n\n$$ f[j][i] = \\min\\limits_{k = 1} ^ {j - 1}\\{ f[j - 1][k] + (s[i] - s[k]) ^ 2 \\} $$\n\nDP $ O(nm) $ $ O(nm ^ 2) $ 60 \n\n $ g(i) = f[j - 1][i] $ $ k $  $ k = a $  $ k = b $$ a > b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\ng(a) + (s_i - s_a) ^ 2 & < g(b) + (s_i - s_b) ^ 2 \\\\\ng(a) + s_i ^ 2 + s_a ^ 2 - 2 s_i s_a & < g(b) + s_i ^ 2 + s_b ^ 2 - 2 s_i s_b \\\\\ng(a) + s_a ^ 2 - 2 s_i s_a & < g(b) + s_b ^ 2 - 2 s_i s_b \\\\\ng(a) - g(b) + s_a ^ 2 - s_b ^ 2 & < 2 s_i s_a - 2 s_i s_b \\\\\ng(a) - g(b) + s_a ^ 2 - s_b ^ 2 & < 2 s_i (s_a - s_b) \\\\\n\\frac{(g(a) + s_a ^ 2) - (g(b) + s_b ^ 2)}{s_a - s_b} & < 2 s_i \\\\\n\\end{align*}\n$$\n\n\n\n1. \n2.  $ a $  $ b $ $ a > b $ $ 2 s_i $ $ a $ \n\n 2 \n\n $ i $ $ k $ 2 $ k $  1  $ O(1) $ $ O(nm) $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 3000;\nconst int MAXM = 3000;\n\nint n, m, a[MAXN + 1], s[MAXN + 1];\nlong long f[MAXN + 1], g[MAXN + 1];\n\ntemplate <typename T>\ninline T sqr(const T x) { return x * x; }\n\ninline double slope(const int a, const int b) {\n    // printf(\"K(%d, %d)\\n\", a, b);\n    return (double)(g[a] - g[b] + sqr(s[a]) - sqr(s[b])) / (double)(s[a] - s[b]);\n}\n\nint main() {\n    freopen(\"menci_journey.in\", \"r\", stdin);\n    freopen(\"menci_journey.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];\n\n    for (int i = 1; i <= n; i++) f[i] = INT_MAX;\n    for (int j = 1; j <= m; j++) {\n        memcpy(g, f, sizeof(f));\n        memset(f, 0, sizeof(f));\n\n        static int q[MAXN];\n        int l = 0, r = -1;\n        q[++r] = 0;\n\n        for (int i = 1; i <= n; i++) {\n            while (l < r && slope(q[l + 1], q[l]) < 2 * s[i]) l++;\n\n            int t = q[l];\n            f[i] = g[t] + sqr(s[i] - s[t]);\n\n            while (l < r && slope(q[r], q[r - 1]) > slope(q[r], i)) r--;\n\n            q[++r] = i;\n        }\n    }\n\n    // for (int i = 1; i <= n; i++) printf(\"s[%d] = %lld\\n\", i, s[i]);\n    printf(\"%d\\n\", (int)(f[n] * m - sqr(s[n])));\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/sdoi2016-journey.md","raw":"title: SDOI2016 -  DP\ndate: 2016-04-17 22:46:04\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - DP\n  - \n  - \npermalink: sdoi2016-journey\n---\n\nPine  $ S $  $ T $   \n $ S $  $ T $  $ n $   \nPine  $ m $  $ T $  $ m $  Pine   \nPine   \n Pine \n\n $ v $$ v \\times m ^ 2 $  $ v \\times m ^ 2 $\n\n<!-- more -->\n\n### \n[COGS 2225](http://cogs.top/cogs/problem/problem.php?pid=2225)  \n[BZOJ 4518](http://www.lydsy.com/JudgeOnline/problem.php?id=4518)\n\n### \n $ a_i $ $ S = \\sum\\limits_{i = 1} ^ n a_i $\n\n$$\nm ^ 2 \\times \\sum\\limits_{i = 1} ^ m \\frac{(a_i - \\frac{S}{m}) ^ 2}{m}\n$$\n\n\n\n$$\n\\begin{align*}\n  & m ^ 2 \\times \n          \\sum\\limits_{i = 1} ^ m\n                      \\frac{(a_i - \\frac{S}{m}) ^ 2}\n                           {m} \\\\\n= & m ^ 2 \\times\n          \\sum\\limits_{i = 1} ^ m\n                      \\frac{   a_i ^ 2\n                             + (\\frac{S}{m}) ^ 2\n                             - 2 a_i \\frac{S}{m}\n                           }\n                           {m} \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        + \\sum\\limits_{i = 1} ^ m\n                      \\frac{S ^ 2}{m ^ 3}\n      - 2 \\sum\\limits_{i = 1} ^ m\n                      a_i \\frac{S}{m ^ 2} ) \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        +             \\frac{S ^ 2}{m ^ 2}\n      - 2      \\times \\frac{S ^ 2}{m ^ 2} ) \\\\\n= & m ^ 2 \\times\n         (\\sum\\limits_{i = 1} ^ m\n                      \\frac{a_i ^ 2}{m}\n        -             \\frac{S ^ 2}{m ^ 2} ) \\\\\n= & m \\times \\sum\\limits_{i = 1} ^ m a_i ^ 2 - S ^ 2 \\\\\n\\end{align*}\n$$\n\n $ m $ $ S ^ 2 $ \n\n$$ \\sum\\limits_{i = 1} ^ m a_i ^ 2 $$\n\n\n\n $ f[j][i] $  $ i $  $ j $ \n\n$$ f[j][i] = \\min\\limits_{k = 1} ^ {j - 1}\\{ f[j - 1][k] + (s[i] - s[k]) ^ 2 \\} $$\n\nDP $ O(nm) $ $ O(nm ^ 2) $ 60 \n\n $ g(i) = f[j - 1][i] $ $ k $  $ k = a $  $ k = b $$ a > b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\ng(a) + (s_i - s_a) ^ 2 & < g(b) + (s_i - s_b) ^ 2 \\\\\ng(a) + s_i ^ 2 + s_a ^ 2 - 2 s_i s_a & < g(b) + s_i ^ 2 + s_b ^ 2 - 2 s_i s_b \\\\\ng(a) + s_a ^ 2 - 2 s_i s_a & < g(b) + s_b ^ 2 - 2 s_i s_b \\\\\ng(a) - g(b) + s_a ^ 2 - s_b ^ 2 & < 2 s_i s_a - 2 s_i s_b \\\\\ng(a) - g(b) + s_a ^ 2 - s_b ^ 2 & < 2 s_i (s_a - s_b) \\\\\n\\frac{(g(a) + s_a ^ 2) - (g(b) + s_b ^ 2)}{s_a - s_b} & < 2 s_i \\\\\n\\end{align*}\n$$\n\n\n\n1. \n2.  $ a $  $ b $ $ a > b $ $ 2 s_i $ $ a $ \n\n 2 \n\n $ i $ $ k $ 2 $ k $  1  $ O(1) $ $ O(nm) $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 3000;\nconst int MAXM = 3000;\n\nint n, m, a[MAXN + 1], s[MAXN + 1];\nlong long f[MAXN + 1], g[MAXN + 1];\n\ntemplate <typename T>\ninline T sqr(const T x) { return x * x; }\n\ninline double slope(const int a, const int b) {\n    // printf(\"K(%d, %d)\\n\", a, b);\n    return (double)(g[a] - g[b] + sqr(s[a]) - sqr(s[b])) / (double)(s[a] - s[b]);\n}\n\nint main() {\n    freopen(\"menci_journey.in\", \"r\", stdin);\n    freopen(\"menci_journey.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];\n\n    for (int i = 1; i <= n; i++) f[i] = INT_MAX;\n    for (int j = 1; j <= m; j++) {\n        memcpy(g, f, sizeof(f));\n        memset(f, 0, sizeof(f));\n\n        static int q[MAXN];\n        int l = 0, r = -1;\n        q[++r] = 0;\n\n        for (int i = 1; i <= n; i++) {\n            while (l < r && slope(q[l + 1], q[l]) < 2 * s[i]) l++;\n\n            int t = q[l];\n            f[i] = g[t] + sqr(s[i] - s[t]);\n\n            while (l < r && slope(q[r], q[r - 1]) > slope(q[r], i)) r--;\n\n            q[++r] = i;\n        }\n    }\n\n    // for (int i = 1; i <= n; i++) printf(\"s[%d] = %lld\\n\", i, s[i]);\n    printf(\"%d\\n\", (int)(f[n] * m - sqr(s[n])));\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"sdoi2016-journey","published":1,"updated":"2016-10-24T23:29:40.335Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c0b00b8c2xlr2vz42nv"},{"title":"SDOI2016 - ","date":"2016-04-12T13:57:57.000Z","_content":"\n $ 1 $$ 2 $  $ [1, 2] $  \n $ S $  $ S $   \n $ S = [1, 2, 1] $  $ [1] $$ [2] $$ [1, 2] $$ [2, 1] $$ [1, 2, 1] $ $ S = [1, 1, 1] $  $ [1] $$ [1, 1] $$ [1, 1, 1] $   \n $ S $  $ n $  $ S $  $ S $ \n\n<!-- more -->\n\n### \n[COGS 2223](http://cogs.top/cogs/problem/problem.php?pid=2223)  \n[BZOJ 4516](http://www.lydsy.com/JudgeOnline/problem.php?id=4516)\n\n### \n $ {\\rm height} $ \n\n\n\n `std::set` \n\n $ i $ $ pred $$ succ $\n\n$ pred $$ succ $ $ pred $$ succ $  $ i $ \n\n$$ {\\rm LCP}(pred, i) + {\\rm LCP}(i, succ) - {\\rm LCP}(pred, succ) $$\n\n $ i $ \n\n$$ \\sum\\limits_{j = 1} ^ {i} j = \\frac{i \\times (i + 1)}{2} $$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <set>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\n\nint n, a[MAXN], sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXLOGN + 1];\n\ninline void ary(const int *a, const int n) {\n\tfor (int i = 0; i < n - 1; i++) printf(\"%d \", a[i]);\n\tprintf(\"%d\\n\", a[n - 1]);\n}\n\ninline void suffixArray() {\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n}\n\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = ht[i + 1];\n\tfor (int t = 1; (1 << t) < n; t++) {\n\t\tfor (int i = 0, j = (1 << t); i < n; i++) {\n\t\t\tif (i + j >= n) break;\n\t\t\tst[i][t] = std::min(st[i][t - 1], st[i + (1 << (t - 1))][t - 1]);\n\t\t}\n\t}\n}\n\ninline int lcp(int a, int b) {\n\tif (a > b) std::swap(a, b);\n\t// printf(\"%d %d\\n\", a, b);\n\tint res;\n\tif (a == b) res = n - a;\n\telse {\n\t\tint t = (int)floor(log2(b - a));\n\t\tres = std::min(st[a][t], st[b - (1 << t)][t]);\n\t}\n\n\t// static char s[MAXN];\n\t// for (int i = 0; i < n; i++) s[i] = ::a[i] + 'a';\n\t// printf(\"LCP( '%s', '%s' ) = %d\\n\", &s[sa[a]], &s[sa[b + 1]], res);\n\n\treturn res;\n}\n\nstd::set<int> s;\n\ninline int queryPred(const int r) {\n\tstd::set<int>::const_iterator a = s.lower_bound(r);\n\tif (a == s.begin()) return -1;\n\telse return *--a;\n}\n\ninline int querySucc(const int r) {\n\tstd::set<int>::const_iterator a = s.lower_bound(r);\n\tif (a == s.end()) return -1;\n\telse return *a;\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T x) {\n\tstatic char s[64];\n\tint len = 0;\n\tdo s[len++] = x % 10; while (x /= 10);\n\twhile (len--) putchar(s[len] + '0');\n\tputchar('\\n');\n}\n\nint main() {\n\tfreopen(\"menci_incantation.in\", \"r\", stdin);\n\tfreopen(\"menci_incantation.out\", \"w\", stdout);\n\n\t// scanf(\"%d\", &n);\n\tread(n);\n\n\t// for (int i = n - 1; i >= 0; i--) scanf(\"%d\", &a[i]);\n\tfor (int i = n - 1; i >= 0; i--) read(a[i]);\n\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tsuffixArray();\n\tsparseTable();\n\n\tint cnt = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tint pred = queryPred(rk[i]);\n\t\tint succ = querySucc(rk[i]);\n\n\t\tif (pred != -1 && succ != -1) cnt -= lcp(pred, succ);\n\t\tif (pred != -1) cnt += lcp(pred, rk[i]);\n\t\tif (succ != -1) cnt += lcp(rk[i], succ);\n\n\t\ts.insert(rk[i]);\n\t\t// printf(\"%lld\\n\", (long long)(n - i) * (n - i + 1) / 2 - cnt);\n\t\twrite((long long)(n - i) * (n - i + 1) / 2 - cnt);\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%lld\\n\", ans[i]);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2016-incantation.md","raw":"title: SDOI2016 - \ndate: 2016-04-12 21:57:57\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - \n  - \n  - RMQ\npermalink: sdoi2016-incantation\n---\n\n $ 1 $$ 2 $  $ [1, 2] $  \n $ S $  $ S $   \n $ S = [1, 2, 1] $  $ [1] $$ [2] $$ [1, 2] $$ [2, 1] $$ [1, 2, 1] $ $ S = [1, 1, 1] $  $ [1] $$ [1, 1] $$ [1, 1, 1] $   \n $ S $  $ n $  $ S $  $ S $ \n\n<!-- more -->\n\n### \n[COGS 2223](http://cogs.top/cogs/problem/problem.php?pid=2223)  \n[BZOJ 4516](http://www.lydsy.com/JudgeOnline/problem.php?id=4516)\n\n### \n $ {\\rm height} $ \n\n\n\n `std::set` \n\n $ i $ $ pred $$ succ $\n\n$ pred $$ succ $ $ pred $$ succ $  $ i $ \n\n$$ {\\rm LCP}(pred, i) + {\\rm LCP}(i, succ) - {\\rm LCP}(pred, succ) $$\n\n $ i $ \n\n$$ \\sum\\limits_{j = 1} ^ {i} j = \\frac{i \\times (i + 1)}{2} $$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <set>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\n\nint n, a[MAXN], sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXLOGN + 1];\n\ninline void ary(const int *a, const int n) {\n\tfor (int i = 0; i < n - 1; i++) printf(\"%d \", a[i]);\n\tprintf(\"%d\\n\", a[n - 1]);\n}\n\ninline void suffixArray() {\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t <<= 1) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = (i + t >= n) ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n}\n\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = ht[i + 1];\n\tfor (int t = 1; (1 << t) < n; t++) {\n\t\tfor (int i = 0, j = (1 << t); i < n; i++) {\n\t\t\tif (i + j >= n) break;\n\t\t\tst[i][t] = std::min(st[i][t - 1], st[i + (1 << (t - 1))][t - 1]);\n\t\t}\n\t}\n}\n\ninline int lcp(int a, int b) {\n\tif (a > b) std::swap(a, b);\n\t// printf(\"%d %d\\n\", a, b);\n\tint res;\n\tif (a == b) res = n - a;\n\telse {\n\t\tint t = (int)floor(log2(b - a));\n\t\tres = std::min(st[a][t], st[b - (1 << t)][t]);\n\t}\n\n\t// static char s[MAXN];\n\t// for (int i = 0; i < n; i++) s[i] = ::a[i] + 'a';\n\t// printf(\"LCP( '%s', '%s' ) = %d\\n\", &s[sa[a]], &s[sa[b + 1]], res);\n\n\treturn res;\n}\n\nstd::set<int> s;\n\ninline int queryPred(const int r) {\n\tstd::set<int>::const_iterator a = s.lower_bound(r);\n\tif (a == s.begin()) return -1;\n\telse return *--a;\n}\n\ninline int querySucc(const int r) {\n\tstd::set<int>::const_iterator a = s.lower_bound(r);\n\tif (a == s.end()) return -1;\n\telse return *a;\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T x) {\n\tstatic char s[64];\n\tint len = 0;\n\tdo s[len++] = x % 10; while (x /= 10);\n\twhile (len--) putchar(s[len] + '0');\n\tputchar('\\n');\n}\n\nint main() {\n\tfreopen(\"menci_incantation.in\", \"r\", stdin);\n\tfreopen(\"menci_incantation.out\", \"w\", stdout);\n\n\t// scanf(\"%d\", &n);\n\tread(n);\n\n\t// for (int i = n - 1; i >= 0; i--) scanf(\"%d\", &a[i]);\n\tfor (int i = n - 1; i >= 0; i--) read(a[i]);\n\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tsuffixArray();\n\tsparseTable();\n\n\tint cnt = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tint pred = queryPred(rk[i]);\n\t\tint succ = querySucc(rk[i]);\n\n\t\tif (pred != -1 && succ != -1) cnt -= lcp(pred, succ);\n\t\tif (pred != -1) cnt += lcp(pred, rk[i]);\n\t\tif (succ != -1) cnt += lcp(rk[i], succ);\n\n\t\ts.insert(rk[i]);\n\t\t// printf(\"%lld\\n\", (long long)(n - i) * (n - i + 1) / 2 - cnt);\n\t\twrite((long long)(n - i) * (n - i + 1) / 2 - cnt);\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%lld\\n\", ans[i]);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2016-incantation","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c0f00bgc2xlirfamzo8"},{"title":"SDOI2016 - ","date":"2016-04-15T14:25:55.000Z","_content":"\nAlice  Bob   \n $ n $  $ 123456789123456789 $  \nAlice  $ s $  $ t $  $ r $ $ r $  $ s $  $ dis $ Alice  $ r $  $ a \\times dis + b $  \nBob  $ s $  $ t $   \nBob  Bob Bob \n\n<!-- more -->\n\n### \n[BZOJ 4515](http://www.lydsy.com/JudgeOnline/problem.php?id=4515)  \n[COGS 2222](http://cogs.top/cogs/problem/problem.php?pid=2222)\n\n### \n\n\n $ p = {\\rm LCA}(s, t) $  $ s \\rightarrow p $$ p \\rightarrow t $\n\n![Tree](sdoi2016-game/tree.png)\n\n $ {\\rm dist}(u, v) $  uv \n\n$$\n\\begin{align}\n& {\\rm dist}(u, s) \\times a + b \\\\\n= & ({\\rm dist}(s, root) - {\\rm dist}(u, root)) \\times a + b \\\\\n= & a \\times {\\rm dist}(s, root) - a \\times {\\rm dist}(u, root) + b \\\\\n= & -a \\times {\\rm dist}(u, root) + a \\times {\\rm dist}(s, root) + b\n\\end{align}\n$$\n\n $ a \\times {\\rm dist}(s, root) + b $ \n\n\n\n$$\n\\begin{align}\n& {\\rm dist}(u, s) \\times a + b \\\\\n= & ({\\rm dist}(s, root) + {\\rm dist}(u, root) - 2 \\times {\\rm dist}(p, root)) \\times a + b \\\\\n= & {\\rm dist}(s, root) \\times a + {\\rm dist}(u, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b \\\\\n= & {\\rm dist}(u, root) \\times a + {\\rm dist}(s, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b \\\\\n\\end{align}\n$$\n\n $ {\\rm dist}(s, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b $ \n\n $ x $  $ y $ \n\n\n\n1. \n2.  `mid` \n\n `mid` \n\n\n\n****\n\n\n\n\n\n\n\n![Line](sdoi2016-game/line.png)\n\n****\n\n\n\n $ O(\\log n) $  $ O(\\log n) $  $ O(\\log n) $  $ O(n \\log ^ 3 n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\n\nstruct Node;\nstruct Edge;\nstruct SegmentTree;\n\nstruct Node {\n\tEdge *e;\n\tint d, s, i, id;\n    long long dist;\n    bool v;\n    Node *p, *c, *t;\n} N[MAXN], *dfs[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    long long w;\n    Edge *next;\n\n    Edge(Node *s, Node *t, const long long w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nstruct Line {\n    long long k, b;\n\n    Line() : k(0), b(LLONG_MAX) {}\n    Line(const long long k, const long long b) : k(k), b(b) { /* printf(\"    Line(%lld, %lld)\\n\", k, b); */}\n\n    long long operator()(const int i) const { return k * dfs[i]->dist + b; }\n\n    long long operator()(const int i, const int j, const int k) {\n        long long ans = LLONG_MAX;\n        ans = std::min(ans, this->operator()(i));\n        ans = std::min(ans, this->operator()(j));\n        ans = std::min(ans, this->operator()(k));\n        return ans;\n    }\n\n    operator bool() const { return k != 0 || b != LLONG_MAX; }\n};\n\nstruct SegmentTree {\n    int l, r, m;\n    SegmentTree *lc, *rc;\n    Line f;\n    long long val;\n    bool covered;\n\n    SegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + ((r - l) >> 1)), lc(lc), rc(rc), val(123456789123456789LL) {}\n\n    ~SegmentTree() {\n        if (lc) delete lc;\n        if (rc) delete rc;\n    }\n\n    /*\n    bool test(const Line &f) {\n        return f(l) <= this->f(l) && f(m) <= this->f(m) && f(r) <= this->f(r);\n    }\n    */\n\n    void pushDown() {\n        if (lc && f) lc->update(lc->l, lc->r, this->f);\n        if (rc && f) rc->update(rc->l, rc->r, this->f);\n        /*\n        if (lc && f && (!lc->f || lc->test(f))) lc->f = f, lc->val = std::min(lc->val, lc->f(lc->l, lc->m, lc->r));\n        if (rc && f && (!rc->f || rc->test(f))) rc->f = f, rc->val = std::min(rc->val, rc->f(rc->l, rc->m, rc->r));\n        */\n    }\n\n    void cover(Line f) {\n        // pushDown();\n\n        bool L = (f(l) < this->f(l)), R = (f(r) < this->f(r)), M = (f(m) < this->f(m));\n        if (!L && !R) return;\n        if (L && R) {\n            this->f = f;\n            val = std::min(val, this->f(l, m, r));\n            return;\n        }\n\n        if (M) {\n            std::swap(f, this->f);\n            L ^= 1, R ^= 1;\n        }\n        \n        if (L) lc->cover(f);\n        if (R) rc->cover(f);\n\n        val = std::min(val, this->f(l, m, r));\n        val = std::min(val, lc->val);\n        val = std::min(val, rc->val);\n        // printf(\"val[%d, %d] = %lld\\n\", l, r, val);\n    }\n\n    void update(const int l, const int r, const Line &f) {\n        if (l > this->r || r < this->l) return;\n        else if (l <= this->l && r >= this->r) cover(f);\n        else {\n            // pushDown();\n            lc->update(l, r, f);\n            rc->update(l, r, f);\n            // val = std::min(val, this->f(this->l, this->m, this->r));\n            val = std::min(val, lc->val);\n            val = std::min(val, rc->val);\n        }\n    }\n\n    long long query(const int l, const int r) {\n        // printf(\"val[%d, %d] (with m = %d) = %lld\\n\", this->l, this->r, m, val);\n        if (l > this->r || r < this->l) return LLONG_MAX;\n        else if (l <= this->l && r >= this->r) {\n            long long ans = LLONG_MAX;\n            ans = std::min(ans, val);\n            // ans = std::min(ans, f(std::max(l, this->l)));\n            // ans = std::min(ans, f(std::min(r, this->r)));\n            // printf(\"query(%d, %d) in [%d, %d] = %lld\\n\", l, r, this->l, this->r, ans);\n            return ans;\n        }\n        else {\n            pushDown();\n            long long ans = LLONG_MAX;\n            // if (l <= this->m && r >= this->m) ans = std::min(ans, f(m));\n            /*if (covered) {\n                ans = std::min(ans, f(std::max(l, this->l)));\n                ans = std::min(ans, f(std::min(r, this->r)));\n            }*/\n            ans = std::min(ans, lc->query(l, r));\n            ans = std::min(ans, rc->query(l, r));\n            // printf(\"query(%d, %d) in [%d, %d] = %lld\\n\", l, r, this->l, this->r, ans);\n            return ans;\n        }\n    }\n} *segment;\n\nint n, m;\n\nSegmentTree *buildSegment(const int l, const int r) {\n    if (l > r) return NULL;\n    else if (l == r) return new SegmentTree(l, r, NULL, NULL);\n    else return new SegmentTree(l, r, buildSegment(l, l + ((r - l) >> 1)), buildSegment(l + ((r - l) >> 1) + 1, r));\n}\n\ninline void addEdge(const int u, const int v, const long long w) {\n    N[u].e = new Edge(&N[u], &N[v], w);\n    N[v].e = new Edge(&N[v], &N[u], w);\n}\n\ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n    N[0].d = 1;\n\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n                e->t->d = v->d + 1;\n                e->t->dist = v->dist + e->w;\n                e->t->p = v;\n                s.push(e->t);\n            }\n        } else {\n            v->s = 1;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n                v->s += e->t->s;\n                if (v->c == NULL || v->c->s < e->t->s) v->c = e->t;\n            }\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].v = false;\n\n    int time = -1;\n    s.push(&N[0]);\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            v->i = ++time;\n            dfs[v->i] = v;\n            if (!v->p || v != v->p->c) v->t = v;\n            else v->t = v->p->t;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else s.pop();\n    }\n\n    segment = buildSegment(0, n - 1);\n}\n\ninline int lca(const int u, const int v) {\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        a = a->t->p;\n    }\n\n    return a->d < b->d ? a->id : b->id;\n}\n\ninline void update(const int u, const int v, const Line &f) {\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        segment->update(a->t->i, a->i, f);\n        a = a->t->p;\n    }\n\n    if (a->i > b->i) std::swap(a, b);\n    segment->update(a->i, b->i, f);\n}\n\ninline long long query(const int u, const int v) {\n    long long ans = LLONG_MAX;\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        ans = std::min(ans, segment->query(a->t->i, a->i));\n        // printf(\"ans = %lld\\n\", ans);\n        a = a->t->p;\n    }\n\n    if (a->i > b->i) std::swap(a, b);\n    ans = std::min(ans, segment->query(a->i, b->i));\n    // printf(\"ans = %lld\\n\", ans);\n    return ans;\n}\n\nint main() {\n\tfreopen(\"menci_game.in\", \"r\", stdin);\n\tfreopen(\"menci_game.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < n; i++) N[i].id = i;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tlong long w;\n\t\tscanf(\"%d %d %lld\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n    cut();\n\n    // for (int i = 0; i < n; i++) printf(\"order(%d) = %d\\n\", i + 1, N[i].i);\n\n    for (int i = 0; i < m; i++) {\n        int x, s, t;\n        scanf(\"%d %d %d\", &x, &s, &t), s--, t--;\n        if (x == 1) {\n            long long a, b;\n            scanf(\"%lld %lld\", &a, &b);\n            int p = lca(s, t);\n            // printf(\"(%lld, %lld)\\n\", -a, a * N[s].dist + b);\n            // printf(\"(%lld, %lld)\\n\", a, (N[s].dist - 2 * N[p].dist) * a + b);\n            if (p != s) update(s, p, Line(-a, a * N[s].dist + b));\n            if (p != t || (p == s && p == t)) update(p, t, Line(a, (N[s].dist - 2 * N[p].dist) * a + b));\n        } else {\n            printf(\"%lld\\n\", query(s, t));\n        }\n    }\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2016-game.md","raw":"title: SDOI2016 - \ndate: 2016-04-15 22:25:55\ncategories: OI\ntags:\n  - SDOI\n  - COGS\n  - BZOJ\n  - \n  - \n  - \n  - \n  - \npermalink: sdoi2016-game\n---\n\nAlice  Bob   \n $ n $  $ 123456789123456789 $  \nAlice  $ s $  $ t $  $ r $ $ r $  $ s $  $ dis $ Alice  $ r $  $ a \\times dis + b $  \nBob  $ s $  $ t $   \nBob  Bob Bob \n\n<!-- more -->\n\n### \n[BZOJ 4515](http://www.lydsy.com/JudgeOnline/problem.php?id=4515)  \n[COGS 2222](http://cogs.top/cogs/problem/problem.php?pid=2222)\n\n### \n\n\n $ p = {\\rm LCA}(s, t) $  $ s \\rightarrow p $$ p \\rightarrow t $\n\n![Tree](sdoi2016-game/tree.png)\n\n $ {\\rm dist}(u, v) $  uv \n\n$$\n\\begin{align}\n& {\\rm dist}(u, s) \\times a + b \\\\\n= & ({\\rm dist}(s, root) - {\\rm dist}(u, root)) \\times a + b \\\\\n= & a \\times {\\rm dist}(s, root) - a \\times {\\rm dist}(u, root) + b \\\\\n= & -a \\times {\\rm dist}(u, root) + a \\times {\\rm dist}(s, root) + b\n\\end{align}\n$$\n\n $ a \\times {\\rm dist}(s, root) + b $ \n\n\n\n$$\n\\begin{align}\n& {\\rm dist}(u, s) \\times a + b \\\\\n= & ({\\rm dist}(s, root) + {\\rm dist}(u, root) - 2 \\times {\\rm dist}(p, root)) \\times a + b \\\\\n= & {\\rm dist}(s, root) \\times a + {\\rm dist}(u, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b \\\\\n= & {\\rm dist}(u, root) \\times a + {\\rm dist}(s, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b \\\\\n\\end{align}\n$$\n\n $ {\\rm dist}(s, root) \\times a - 2 \\times {\\rm dist}(p, root) \\times a + b $ \n\n $ x $  $ y $ \n\n\n\n1. \n2.  `mid` \n\n `mid` \n\n\n\n****\n\n\n\n\n\n\n\n![Line](sdoi2016-game/line.png)\n\n****\n\n\n\n $ O(\\log n) $  $ O(\\log n) $  $ O(\\log n) $  $ O(n \\log ^ 3 n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\n\nstruct Node;\nstruct Edge;\nstruct SegmentTree;\n\nstruct Node {\n\tEdge *e;\n\tint d, s, i, id;\n    long long dist;\n    bool v;\n    Node *p, *c, *t;\n} N[MAXN], *dfs[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    long long w;\n    Edge *next;\n\n    Edge(Node *s, Node *t, const long long w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nstruct Line {\n    long long k, b;\n\n    Line() : k(0), b(LLONG_MAX) {}\n    Line(const long long k, const long long b) : k(k), b(b) { /* printf(\"    Line(%lld, %lld)\\n\", k, b); */}\n\n    long long operator()(const int i) const { return k * dfs[i]->dist + b; }\n\n    long long operator()(const int i, const int j, const int k) {\n        long long ans = LLONG_MAX;\n        ans = std::min(ans, this->operator()(i));\n        ans = std::min(ans, this->operator()(j));\n        ans = std::min(ans, this->operator()(k));\n        return ans;\n    }\n\n    operator bool() const { return k != 0 || b != LLONG_MAX; }\n};\n\nstruct SegmentTree {\n    int l, r, m;\n    SegmentTree *lc, *rc;\n    Line f;\n    long long val;\n    bool covered;\n\n    SegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + ((r - l) >> 1)), lc(lc), rc(rc), val(123456789123456789LL) {}\n\n    ~SegmentTree() {\n        if (lc) delete lc;\n        if (rc) delete rc;\n    }\n\n    /*\n    bool test(const Line &f) {\n        return f(l) <= this->f(l) && f(m) <= this->f(m) && f(r) <= this->f(r);\n    }\n    */\n\n    void pushDown() {\n        if (lc && f) lc->update(lc->l, lc->r, this->f);\n        if (rc && f) rc->update(rc->l, rc->r, this->f);\n        /*\n        if (lc && f && (!lc->f || lc->test(f))) lc->f = f, lc->val = std::min(lc->val, lc->f(lc->l, lc->m, lc->r));\n        if (rc && f && (!rc->f || rc->test(f))) rc->f = f, rc->val = std::min(rc->val, rc->f(rc->l, rc->m, rc->r));\n        */\n    }\n\n    void cover(Line f) {\n        // pushDown();\n\n        bool L = (f(l) < this->f(l)), R = (f(r) < this->f(r)), M = (f(m) < this->f(m));\n        if (!L && !R) return;\n        if (L && R) {\n            this->f = f;\n            val = std::min(val, this->f(l, m, r));\n            return;\n        }\n\n        if (M) {\n            std::swap(f, this->f);\n            L ^= 1, R ^= 1;\n        }\n        \n        if (L) lc->cover(f);\n        if (R) rc->cover(f);\n\n        val = std::min(val, this->f(l, m, r));\n        val = std::min(val, lc->val);\n        val = std::min(val, rc->val);\n        // printf(\"val[%d, %d] = %lld\\n\", l, r, val);\n    }\n\n    void update(const int l, const int r, const Line &f) {\n        if (l > this->r || r < this->l) return;\n        else if (l <= this->l && r >= this->r) cover(f);\n        else {\n            // pushDown();\n            lc->update(l, r, f);\n            rc->update(l, r, f);\n            // val = std::min(val, this->f(this->l, this->m, this->r));\n            val = std::min(val, lc->val);\n            val = std::min(val, rc->val);\n        }\n    }\n\n    long long query(const int l, const int r) {\n        // printf(\"val[%d, %d] (with m = %d) = %lld\\n\", this->l, this->r, m, val);\n        if (l > this->r || r < this->l) return LLONG_MAX;\n        else if (l <= this->l && r >= this->r) {\n            long long ans = LLONG_MAX;\n            ans = std::min(ans, val);\n            // ans = std::min(ans, f(std::max(l, this->l)));\n            // ans = std::min(ans, f(std::min(r, this->r)));\n            // printf(\"query(%d, %d) in [%d, %d] = %lld\\n\", l, r, this->l, this->r, ans);\n            return ans;\n        }\n        else {\n            pushDown();\n            long long ans = LLONG_MAX;\n            // if (l <= this->m && r >= this->m) ans = std::min(ans, f(m));\n            /*if (covered) {\n                ans = std::min(ans, f(std::max(l, this->l)));\n                ans = std::min(ans, f(std::min(r, this->r)));\n            }*/\n            ans = std::min(ans, lc->query(l, r));\n            ans = std::min(ans, rc->query(l, r));\n            // printf(\"query(%d, %d) in [%d, %d] = %lld\\n\", l, r, this->l, this->r, ans);\n            return ans;\n        }\n    }\n} *segment;\n\nint n, m;\n\nSegmentTree *buildSegment(const int l, const int r) {\n    if (l > r) return NULL;\n    else if (l == r) return new SegmentTree(l, r, NULL, NULL);\n    else return new SegmentTree(l, r, buildSegment(l, l + ((r - l) >> 1)), buildSegment(l + ((r - l) >> 1) + 1, r));\n}\n\ninline void addEdge(const int u, const int v, const long long w) {\n    N[u].e = new Edge(&N[u], &N[v], w);\n    N[v].e = new Edge(&N[v], &N[u], w);\n}\n\ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n    N[0].d = 1;\n\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n                e->t->d = v->d + 1;\n                e->t->dist = v->dist + e->w;\n                e->t->p = v;\n                s.push(e->t);\n            }\n        } else {\n            v->s = 1;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n                v->s += e->t->s;\n                if (v->c == NULL || v->c->s < e->t->s) v->c = e->t;\n            }\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].v = false;\n\n    int time = -1;\n    s.push(&N[0]);\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            v->i = ++time;\n            dfs[v->i] = v;\n            if (!v->p || v != v->p->c) v->t = v;\n            else v->t = v->p->t;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else s.pop();\n    }\n\n    segment = buildSegment(0, n - 1);\n}\n\ninline int lca(const int u, const int v) {\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        a = a->t->p;\n    }\n\n    return a->d < b->d ? a->id : b->id;\n}\n\ninline void update(const int u, const int v, const Line &f) {\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        segment->update(a->t->i, a->i, f);\n        a = a->t->p;\n    }\n\n    if (a->i > b->i) std::swap(a, b);\n    segment->update(a->i, b->i, f);\n}\n\ninline long long query(const int u, const int v) {\n    long long ans = LLONG_MAX;\n    Node *a = &N[u], *b = &N[v];\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        ans = std::min(ans, segment->query(a->t->i, a->i));\n        // printf(\"ans = %lld\\n\", ans);\n        a = a->t->p;\n    }\n\n    if (a->i > b->i) std::swap(a, b);\n    ans = std::min(ans, segment->query(a->i, b->i));\n    // printf(\"ans = %lld\\n\", ans);\n    return ans;\n}\n\nint main() {\n\tfreopen(\"menci_game.in\", \"r\", stdin);\n\tfreopen(\"menci_game.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < n; i++) N[i].id = i;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tlong long w;\n\t\tscanf(\"%d %d %lld\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n    cut();\n\n    // for (int i = 0; i < n; i++) printf(\"order(%d) = %d\\n\", i + 1, N[i].i);\n\n    for (int i = 0; i < m; i++) {\n        int x, s, t;\n        scanf(\"%d %d %d\", &x, &s, &t), s--, t--;\n        if (x == 1) {\n            long long a, b;\n            scanf(\"%lld %lld\", &a, &b);\n            int p = lca(s, t);\n            // printf(\"(%lld, %lld)\\n\", -a, a * N[s].dist + b);\n            // printf(\"(%lld, %lld)\\n\", a, (N[s].dist - 2 * N[p].dist) * a + b);\n            if (p != s) update(s, p, Line(-a, a * N[s].dist + b));\n            if (p != t || (p == s && p == t)) update(p, t, Line(a, (N[s].dist - 2 * N[p].dist) * a + b));\n        } else {\n            printf(\"%lld\\n\", query(s, t));\n        }\n    }\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2016-game","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c0k00bpc2xl1fk96gdo"},{"title":"SDOI2015 - ","date":"2016-02-29T07:42:11.000Z","_content":"\nY  $ N $  X  $ i $  $ A_i $ 0 X  $ M $  $ i $  $ B_i $ Y  X  Y \n\n<!-- more -->\n\n### \n[BZOJ 3993](http://www.lydsy.com/JudgeOnline/problem.php?id=3993)\n\n### \n\n\n1.   \n2. \n3. \n\nw \n\n Dinic \n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <cfloat>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 50;\nconst int MAXM = 50;\nconst double EPS = 1e-4;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tdouble capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, double capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, robot[MAXN], sumRobot, gun[MAXM], minGun = INT_MAX, attack[MAXM][MAXN];\n\ninline bool equal(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (!equal(e->capacity - e->flow, 0) && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tdouble findPath(Node *s, Node *t, double limit = DBL_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && !equal(e->capacity - e->flow, 0)) {\n\t\t\t\tdouble flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tdouble operator()(int s, int t, int n) {\n\t\tdouble ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tdouble flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, double capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void cleanUp(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n\ninline bool check(double time) {\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= m; i++) addEdge(s, i, gun[i - 1] * time);\n\tfor (int i = 1; i <= n; i++) addEdge(i + m, t, robot[i - 1]);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (attack[i - 1][j - 1] == 1) {\n\t\t\t\taddEdge(i, j + m, DBL_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble flow = dinic(s, t, n + m + 2);\n\n\tcleanUp(n + m + 2);\n\n\t//printf(\"%.3lf %d\\n\", flow, sumRobot);\n\treturn equal(flow, sumRobot);\n}\n\ninline double dichotomy() {\n\tdouble l = 0, r = ((double)sumRobot) / ((double)minGun);\n\twhile (r - l > EPS) {\n\t\tdouble mid = l + (r - l) / 2;\n\t\t//printf(\"mid = %.6lf\\n\", mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\n\treturn l + (r - l) / 2;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &robot[i]), sumRobot += robot[i];\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &gun[i]), minGun = std::min(minGun, gun[i]);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &attack[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%.6lf\\n\", dichotomy());\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2015-war.md","raw":"title: SDOI2015 - \ndate: 2016-02-29 15:42:11\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - Dinic\n  - \n  - \n  - \n  - \npermalink: sdoi2015-war\n---\n\nY  $ N $  X  $ i $  $ A_i $ 0 X  $ M $  $ i $  $ B_i $ Y  X  Y \n\n<!-- more -->\n\n### \n[BZOJ 3993](http://www.lydsy.com/JudgeOnline/problem.php?id=3993)\n\n### \n\n\n1.   \n2. \n3. \n\nw \n\n Dinic \n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <cfloat>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 50;\nconst int MAXM = 50;\nconst double EPS = 1e-4;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tdouble capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, double capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, robot[MAXN], sumRobot, gun[MAXM], minGun = INT_MAX, attack[MAXM][MAXN];\n\ninline bool equal(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (!equal(e->capacity - e->flow, 0) && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tdouble findPath(Node *s, Node *t, double limit = DBL_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && !equal(e->capacity - e->flow, 0)) {\n\t\t\t\tdouble flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tdouble operator()(int s, int t, int n) {\n\t\tdouble ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tdouble flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, double capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void cleanUp(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n\ninline bool check(double time) {\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= m; i++) addEdge(s, i, gun[i - 1] * time);\n\tfor (int i = 1; i <= n; i++) addEdge(i + m, t, robot[i - 1]);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (attack[i - 1][j - 1] == 1) {\n\t\t\t\taddEdge(i, j + m, DBL_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble flow = dinic(s, t, n + m + 2);\n\n\tcleanUp(n + m + 2);\n\n\t//printf(\"%.3lf %d\\n\", flow, sumRobot);\n\treturn equal(flow, sumRobot);\n}\n\ninline double dichotomy() {\n\tdouble l = 0, r = ((double)sumRobot) / ((double)minGun);\n\twhile (r - l > EPS) {\n\t\tdouble mid = l + (r - l) / 2;\n\t\t//printf(\"mid = %.6lf\\n\", mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\n\treturn l + (r - l) / 2;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &robot[i]), sumRobot += robot[i];\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &gun[i]), minGun = std::min(minGun, gun[i]);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &attack[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%.6lf\\n\", dichotomy());\n\n\treturn 0;\n}\n```\n","slug":"sdoi2015-war","published":1,"updated":"2016-05-11T09:33:24.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c0t00c0c2xl4nsx8oc0"},{"title":"SDOI2015 -  + NTT","date":"2016-06-12T01:27:00.000Z","_content":"\n C  $ S $ $ M $  $ N $  $ S $\n\n C  C  $ x $ $ \\bmod M $  $ x $  C  $ \\{ A_i \\} $  $ \\{B_i\\} $  $ i $ $ A_i \\neq B_i $ C  $ \\bmod 1004535809 $ \n\n<!-- more -->\n\n### \n[BZOJ 3992](http://www.lydsy.com/JudgeOnline/problem.php?id=3992)\n\n### \n $ x $  $ S_i $  $ x $  $ M $  $ \\log S_i $  $ \\log x $ \n\n $ M $  $ 0 $ $ M - 2 $  $ [1,\\ M - 1] $  $ [0,\\ M - 2] $ $ g ^ {M - 1} \\equiv g ^ 0 \\equiv 1 \\pmod {M} $\n\n\n\n$$ A(x) = \\sum\\limits_{i = 0} ^ {\\infty} a_i x ^ i $$\n\n $ S_i $ $ a_{\\log S_i} = 1 $ $ a_{\\log S_i} = 0 $\n\n $ A ^ N(x) $  $ \\log x $  NTT\n\n $ \\bmod {M - 1} $  $ \\log x $ $ \\bmod {M - 1} $  $ i $  $ i $ \n\n $ O(M \\sqrt M + M \\log M \\log N) $\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXM = 8000;\nconst int MAXM_EXTENDED = 16384;\nconst long long MOD = 1004535809;\n\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\t// printf(\"root(%lld) = %d\\n\", p, i);\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n\ninline void exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long a, const long long p) {\n\tlong long g, x, y;\n\texgcd(a, p, g, x, y);\n\treturn (x + p) % p;\n}\n\nint m;\nlong long log[MAXM];\n\ninline void prepare() {\n\tlong long t = 1, r = root(m);\n\tfor (int i = 0; i < m - 1; i++) {\n\t\tlog[t] = i;\n\t\t// printf(\"log(%lld) = %d\\n\", t, i);\n\t\tt = t * r % m;\n\t}\n}\n\nstruct NumberTheoreticTransform {\n\tlong long omega[MAXM_EXTENDED], omegaInverse[MAXM_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tlong long g = root(MOD), x = pow(g, (MOD - 1) / n, MOD);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tomega[i] = (i == 0) ? 1 : omega[i - 1] * x % MOD;\n\t\t\tomegaInverse[i] = inv(omega[i], MOD);\n\t\t\t// printf(\"omega[%d] = %lld\\n\", i, omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(long long *a, const int n, const long long *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t\tassert(t < MAXM_EXTENDED);\n\t\t}\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tint m = l / 2;\n\t\t\tfor (long long *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tassert(n / l * i < MAXM_EXTENDED);\n\t\t\t\t\tassert(p - a + i < MAXM_EXTENDED);\n\t\t\t\t\tlong long t = omega[n / l * i] * p[i + m] % MOD;\n\t\t\t\t\t// printf(\"use omega = %lld\\n\", omega[n / l * i]);\n\t\t\t\t\tp[i + m] = (p[i] - t + MOD) % MOD;\n\t\t\t\t\t(p[i] += t) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(long long *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(long long *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tlong long x = inv(n, MOD);\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * x % MOD;\n\t}\n\n\tvoid operator()(long long *a, long long *b, const int n) {\n\t\tassert(n <= MAXM_EXTENDED);\n\t\t/*\n\t\tputchar('{');\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", a[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tprintf(\" * \");\n\t\tputchar('{');\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", b[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tdft(a, n);\n\t\t/*\n\t\tprintf(\"After NTT: {\");\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", a[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tif (a != b) dft(b, n);\n\t\t/*\n\t\tprintf(\"After NTT: {\");\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", b[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * b[i] % MOD;\n\n\t\tidft(a, n);\n\t\tif (a != b) idft(b, n);\n\t}\n} ntt;\n\ninline void pow(const long long *a, const int m, const int n, long long *res) {\n\tint size = 1;\n\twhile (size < m + m) size *= 2;\n\tntt.init(size);\n\t// printf(\"size = %d, m = %d\\n\", size, m);\n\n\tstatic long long buf[MAXM_EXTENDED], bufDft[MAXM_EXTENDED];\n\tstd::copy(a, a + m, buf);\n\tstd::copy(a, a + m, res);\n\tint tmp = n - 1;\n\n\t/*\n\tfor (int i = 0; i < tmp; i++) {\n\t\tntt(res, buf, size);\n\t\tfor (int i = m; i < size; i++) (res[i % m] += res[i]) %= MOD, res[i] = 0;\n\t}\n\treturn;\n\t*/\n\n\tassert(size <= MAXM_EXTENDED);\n\n\twhile (tmp) {\n\t\tif (tmp & 1) {\n\t\t\tntt.dft(res, size);\n\t\t\tstd::copy(buf, buf + size, bufDft);\n\t\t\tntt.dft(bufDft, size);\n\t\t\tfor (int i = 0; i < size; i++) (res[i] *= bufDft[i]) %= MOD;\n\t\t\tntt.idft(res, size);\n\t\t\tfor (int i = m; i < size; i++) (res[i % m] += res[i]) %= MOD, res[i] = 0;\n\t\t}\n\t\ttmp >>= 1;\n\n\t\tntt.dft(buf, size);\n\t\tfor (int i = 0; i < size; i++) (buf[i] *= buf[i]) %= MOD;\n\t\tntt.idft(buf, size);\n\t\tfor (int i = m; i < size; i++) (buf[i % m] += buf[i]) %= MOD, buf[i] = 0;\n\t}\n}\n\nint main() {\n\tlong long n;\n\tint x, s;\n\tstatic long long a[MAXM];\n\n\tscanf(\"%lld %d %d %d\", &n, &m, &x, &s);\n\tfor (int i = 0; i < s; i++) scanf(\"%lld\", &a[i]);\n\n\tprepare();\n\n\tstatic long long f[MAXM_EXTENDED];\n\tfor (int i = 0; i < s; i++) {\n\t\tif (a[i] == 0) continue;\n\t\tf[log[a[i] % m]]++;\n\t}\n\n\tstatic long long res[MAXM_EXTENDED];\n\tpow(f, m - 1, n, res);\n\n\tassert(log[x] < MAXM_EXTENDED);\n\n\tlong long ans = res[log[x]];\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2015-sequence.md","raw":"title: SDOI2015 -  + NTT\ndate: 2016-06-12 09:27:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - FFT\n  - NTT\n  - \n  - \n  - \n  - \npermalink: sdoi2015-sequence\n---\n\n C  $ S $ $ M $  $ N $  $ S $\n\n C  C  $ x $ $ \\bmod M $  $ x $  C  $ \\{ A_i \\} $  $ \\{B_i\\} $  $ i $ $ A_i \\neq B_i $ C  $ \\bmod 1004535809 $ \n\n<!-- more -->\n\n### \n[BZOJ 3992](http://www.lydsy.com/JudgeOnline/problem.php?id=3992)\n\n### \n $ x $  $ S_i $  $ x $  $ M $  $ \\log S_i $  $ \\log x $ \n\n $ M $  $ 0 $ $ M - 2 $  $ [1,\\ M - 1] $  $ [0,\\ M - 2] $ $ g ^ {M - 1} \\equiv g ^ 0 \\equiv 1 \\pmod {M} $\n\n\n\n$$ A(x) = \\sum\\limits_{i = 0} ^ {\\infty} a_i x ^ i $$\n\n $ S_i $ $ a_{\\log S_i} = 1 $ $ a_{\\log S_i} = 0 $\n\n $ A ^ N(x) $  $ \\log x $  NTT\n\n $ \\bmod {M - 1} $  $ \\log x $ $ \\bmod {M - 1} $  $ i $  $ i $ \n\n $ O(M \\sqrt M + M \\log M \\log N) $\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXM = 8000;\nconst int MAXM_EXTENDED = 16384;\nconst long long MOD = 1004535809;\n\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\t// printf(\"root(%lld) = %d\\n\", p, i);\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n\ninline void exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long a, const long long p) {\n\tlong long g, x, y;\n\texgcd(a, p, g, x, y);\n\treturn (x + p) % p;\n}\n\nint m;\nlong long log[MAXM];\n\ninline void prepare() {\n\tlong long t = 1, r = root(m);\n\tfor (int i = 0; i < m - 1; i++) {\n\t\tlog[t] = i;\n\t\t// printf(\"log(%lld) = %d\\n\", t, i);\n\t\tt = t * r % m;\n\t}\n}\n\nstruct NumberTheoreticTransform {\n\tlong long omega[MAXM_EXTENDED], omegaInverse[MAXM_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tlong long g = root(MOD), x = pow(g, (MOD - 1) / n, MOD);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tomega[i] = (i == 0) ? 1 : omega[i - 1] * x % MOD;\n\t\t\tomegaInverse[i] = inv(omega[i], MOD);\n\t\t\t// printf(\"omega[%d] = %lld\\n\", i, omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(long long *a, const int n, const long long *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t\tassert(t < MAXM_EXTENDED);\n\t\t}\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tint m = l / 2;\n\t\t\tfor (long long *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tassert(n / l * i < MAXM_EXTENDED);\n\t\t\t\t\tassert(p - a + i < MAXM_EXTENDED);\n\t\t\t\t\tlong long t = omega[n / l * i] * p[i + m] % MOD;\n\t\t\t\t\t// printf(\"use omega = %lld\\n\", omega[n / l * i]);\n\t\t\t\t\tp[i + m] = (p[i] - t + MOD) % MOD;\n\t\t\t\t\t(p[i] += t) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(long long *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(long long *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tlong long x = inv(n, MOD);\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * x % MOD;\n\t}\n\n\tvoid operator()(long long *a, long long *b, const int n) {\n\t\tassert(n <= MAXM_EXTENDED);\n\t\t/*\n\t\tputchar('{');\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", a[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tprintf(\" * \");\n\t\tputchar('{');\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", b[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tdft(a, n);\n\t\t/*\n\t\tprintf(\"After NTT: {\");\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", a[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tif (a != b) dft(b, n);\n\t\t/*\n\t\tprintf(\"After NTT: {\");\n\t\tfor (int i = 0; i < n; i++) printf(\" %lld%c\", b[i], (i == n - 1) ? ' ' : ',');\n\t\tputchar('}');\n\t\tputchar('\\n');\n\t\t*/\n\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * b[i] % MOD;\n\n\t\tidft(a, n);\n\t\tif (a != b) idft(b, n);\n\t}\n} ntt;\n\ninline void pow(const long long *a, const int m, const int n, long long *res) {\n\tint size = 1;\n\twhile (size < m + m) size *= 2;\n\tntt.init(size);\n\t// printf(\"size = %d, m = %d\\n\", size, m);\n\n\tstatic long long buf[MAXM_EXTENDED], bufDft[MAXM_EXTENDED];\n\tstd::copy(a, a + m, buf);\n\tstd::copy(a, a + m, res);\n\tint tmp = n - 1;\n\n\t/*\n\tfor (int i = 0; i < tmp; i++) {\n\t\tntt(res, buf, size);\n\t\tfor (int i = m; i < size; i++) (res[i % m] += res[i]) %= MOD, res[i] = 0;\n\t}\n\treturn;\n\t*/\n\n\tassert(size <= MAXM_EXTENDED);\n\n\twhile (tmp) {\n\t\tif (tmp & 1) {\n\t\t\tntt.dft(res, size);\n\t\t\tstd::copy(buf, buf + size, bufDft);\n\t\t\tntt.dft(bufDft, size);\n\t\t\tfor (int i = 0; i < size; i++) (res[i] *= bufDft[i]) %= MOD;\n\t\t\tntt.idft(res, size);\n\t\t\tfor (int i = m; i < size; i++) (res[i % m] += res[i]) %= MOD, res[i] = 0;\n\t\t}\n\t\ttmp >>= 1;\n\n\t\tntt.dft(buf, size);\n\t\tfor (int i = 0; i < size; i++) (buf[i] *= buf[i]) %= MOD;\n\t\tntt.idft(buf, size);\n\t\tfor (int i = m; i < size; i++) (buf[i % m] += buf[i]) %= MOD, buf[i] = 0;\n\t}\n}\n\nint main() {\n\tlong long n;\n\tint x, s;\n\tstatic long long a[MAXM];\n\n\tscanf(\"%lld %d %d %d\", &n, &m, &x, &s);\n\tfor (int i = 0; i < s; i++) scanf(\"%lld\", &a[i]);\n\n\tprepare();\n\n\tstatic long long f[MAXM_EXTENDED];\n\tfor (int i = 0; i < s; i++) {\n\t\tif (a[i] == 0) continue;\n\t\tf[log[a[i] % m]]++;\n\t}\n\n\tstatic long long res[MAXM_EXTENDED];\n\tpow(f, m - 1, n, res);\n\n\tassert(log[x] < MAXM_EXTENDED);\n\n\tlong long ans = res[log[x]];\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2015-sequence","published":1,"updated":"2016-06-17T13:39:09.686Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c0x00cac2xle8ywib7a"},{"title":"SDOI2014 - ","date":"2016-09-02T13:39:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 3531](http://www.lydsy.com/JudgeOnline/problem.php?id=3531)\n\n### \n $ O(n \\log n) $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 1e5;\nconst int MAXQ = 1e5;\nconst int MAXC = 1e5;\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tint max, sum;\n\n\tSegmentTree(const int l, const int r) : l(l), r(r), mid(l + (r - l) / 2), lc(NULL), rc(NULL), max(0), sum(0) {}\n\n\tvoid update(const int pos, const int val) {\n\t\tif (l != r) {\n\t\t\tSegmentTree *&c = pos <= mid ? lc : rc;\n\t\t\tif (!c) c = (pos <= mid) ? new SegmentTree(l, mid) : new SegmentTree(mid + 1, r);\n\t\t\tc->update(pos, val);\n\t\t\tif (val == 0 && !c->lc && !c->rc) delete c, c = NULL;\n\t\t\tmax = sum = 0;\n\t\t\tif (lc) max = std::max(max, lc->max), sum += lc->sum;\n\t\t\tif (rc) max = std::max(max, rc->max), sum += rc->sum;\n\t\t} else sum = max = val;\n\t}\n\n\tint querySum(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse return (lc ? lc->querySum(l, r) : 0) + (rc ? rc->querySum(l, r) : 0);\n\t}\n\n\tint queryMax(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return max;\n\t\telse return std::max(lc ? lc->queryMax(l, r) : 0, rc ? rc->queryMax(l, r) : 0);\n\t}\n} *seg[MAXC];\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint d, s, i;\n\tbool f;\n\tNode *p, *c, *t;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, q, f[MAXN], v[MAXN];\n\ninline void cut() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].d = 1;\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->f) {\n\t\t\tv->f = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n\t\t\t\te->t->d = v->d + 1;\n\t\t\t\te->t->p = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->s = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->s += e->t->s;\n\t\t\t\tif (!v->c || v->c->s < e->t->s) v->c = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\ts.push(&N[0]);\n\tint i = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (v->f) {\n\t\t\tv->f = false;\n\t\t\tv->i = i++;\n\t\t\tif (!v->p || v != v->p->c) v->t = v;\n\t\t\telse v->t = v->p->t;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else s.pop();\n\t}\n}\n\ninline int querySum(const int u, const int v, SegmentTree *seg) {\n\tNode *a = &N[u], *b = &N[v];\n\tint ans = 0;\n\twhile (a->t != b->t) {\n\t\tif (a->t->d < b->t->d) std::swap(a, b);\n\t\tans += seg->querySum(a->t->i, a->i);\n\t\ta = a->t->p;\n\t}\n\tif (a->d > b->d) std::swap(a, b);\n\treturn ans + seg->querySum(a->i, b->i);\n}\n\ninline int queryMax(const int u, const int v, SegmentTree *seg) {\n\tNode *a = &N[u], *b = &N[v];\n\tint ans = 0;\n\twhile (a->t != b->t) {\n\t\tif (a->t->d < b->t->d) std::swap(a, b);\n\t\tans = std::max(ans, seg->queryMax(a->t->i, a->i));\n\t\ta = a->t->p;\n\t}\n\tif (a->d > b->d) std::swap(a, b);\n\treturn std::max(ans, seg->queryMax(a->i, b->i));\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &q);\n\n\tfor (int i = 0; i < MAXC; i++) seg[i] = new SegmentTree(0, n - 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &v[i], &f[i]);\n\t\tf[i]--;\n\t\t// printf(\"seg[%d]->update(%d, %d)\\n\", f[i], i, v[i]);\n\t\t// seg[f[i]]->update(i, v[i]);\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tcut();\n\n\tfor (int i = 0; i < n; i++) seg[f[i]]->update(N[i].i, v[i]);\n\n\twhile (q-- ) {\n\t\tchar s[3];\n\t\tint a, b;\n\t\tscanf(\"%s %d %d\", s, &a, &b);\n\t\t\n\t\tif (s[1] == 'C') {\n\t\t\ta--, b--;\n\t\t\tseg[f[a]]->update(N[a].i, 0);\n\t\t\tseg[b]->update(N[a].i, v[a]);\n\t\t\tf[a] = b;\n\t\t} else if (s[1] == 'W') {\n\t\t\ta--;\n\t\t\tseg[f[a]]->update(N[a].i, b);\n\t\t\tv[a] = b;\n\t\t} else if (s[1] == 'S') {\n\t\t\ta--, b--;\n\t\t\tprintf(\"%d\\n\", querySum(a, b, seg[f[a]]));\n\t\t} else if (s[1] == 'M') {\n\t\t\ta--, b--;\n\t\t\tprintf(\"%d\\n\", queryMax(a, b, seg[f[a]]));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/sdoi2014-journey.md","raw":"title: SDOI2014 - \ndate: 2016-09-02 21:39:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - \n  - \npermalink: sdoi2014-journey\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 3531](http://www.lydsy.com/JudgeOnline/problem.php?id=3531)\n\n### \n $ O(n \\log n) $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 1e5;\nconst int MAXQ = 1e5;\nconst int MAXC = 1e5;\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tint max, sum;\n\n\tSegmentTree(const int l, const int r) : l(l), r(r), mid(l + (r - l) / 2), lc(NULL), rc(NULL), max(0), sum(0) {}\n\n\tvoid update(const int pos, const int val) {\n\t\tif (l != r) {\n\t\t\tSegmentTree *&c = pos <= mid ? lc : rc;\n\t\t\tif (!c) c = (pos <= mid) ? new SegmentTree(l, mid) : new SegmentTree(mid + 1, r);\n\t\t\tc->update(pos, val);\n\t\t\tif (val == 0 && !c->lc && !c->rc) delete c, c = NULL;\n\t\t\tmax = sum = 0;\n\t\t\tif (lc) max = std::max(max, lc->max), sum += lc->sum;\n\t\t\tif (rc) max = std::max(max, rc->max), sum += rc->sum;\n\t\t} else sum = max = val;\n\t}\n\n\tint querySum(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse return (lc ? lc->querySum(l, r) : 0) + (rc ? rc->querySum(l, r) : 0);\n\t}\n\n\tint queryMax(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return max;\n\t\telse return std::max(lc ? lc->queryMax(l, r) : 0, rc ? rc->queryMax(l, r) : 0);\n\t}\n} *seg[MAXC];\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint d, s, i;\n\tbool f;\n\tNode *p, *c, *t;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, q, f[MAXN], v[MAXN];\n\ninline void cut() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].d = 1;\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->f) {\n\t\t\tv->f = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n\t\t\t\te->t->d = v->d + 1;\n\t\t\t\te->t->p = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->s = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->s += e->t->s;\n\t\t\t\tif (!v->c || v->c->s < e->t->s) v->c = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\ts.push(&N[0]);\n\tint i = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (v->f) {\n\t\t\tv->f = false;\n\t\t\tv->i = i++;\n\t\t\tif (!v->p || v != v->p->c) v->t = v;\n\t\t\telse v->t = v->p->t;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else s.pop();\n\t}\n}\n\ninline int querySum(const int u, const int v, SegmentTree *seg) {\n\tNode *a = &N[u], *b = &N[v];\n\tint ans = 0;\n\twhile (a->t != b->t) {\n\t\tif (a->t->d < b->t->d) std::swap(a, b);\n\t\tans += seg->querySum(a->t->i, a->i);\n\t\ta = a->t->p;\n\t}\n\tif (a->d > b->d) std::swap(a, b);\n\treturn ans + seg->querySum(a->i, b->i);\n}\n\ninline int queryMax(const int u, const int v, SegmentTree *seg) {\n\tNode *a = &N[u], *b = &N[v];\n\tint ans = 0;\n\twhile (a->t != b->t) {\n\t\tif (a->t->d < b->t->d) std::swap(a, b);\n\t\tans = std::max(ans, seg->queryMax(a->t->i, a->i));\n\t\ta = a->t->p;\n\t}\n\tif (a->d > b->d) std::swap(a, b);\n\treturn std::max(ans, seg->queryMax(a->i, b->i));\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &q);\n\n\tfor (int i = 0; i < MAXC; i++) seg[i] = new SegmentTree(0, n - 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &v[i], &f[i]);\n\t\tf[i]--;\n\t\t// printf(\"seg[%d]->update(%d, %d)\\n\", f[i], i, v[i]);\n\t\t// seg[f[i]]->update(i, v[i]);\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tcut();\n\n\tfor (int i = 0; i < n; i++) seg[f[i]]->update(N[i].i, v[i]);\n\n\twhile (q-- ) {\n\t\tchar s[3];\n\t\tint a, b;\n\t\tscanf(\"%s %d %d\", s, &a, &b);\n\t\t\n\t\tif (s[1] == 'C') {\n\t\t\ta--, b--;\n\t\t\tseg[f[a]]->update(N[a].i, 0);\n\t\t\tseg[b]->update(N[a].i, v[a]);\n\t\t\tf[a] = b;\n\t\t} else if (s[1] == 'W') {\n\t\t\ta--;\n\t\t\tseg[f[a]]->update(N[a].i, b);\n\t\t\tv[a] = b;\n\t\t} else if (s[1] == 'S') {\n\t\t\ta--, b--;\n\t\t\tprintf(\"%d\\n\", querySum(a, b, seg[f[a]]));\n\t\t} else if (s[1] == 'M') {\n\t\t\ta--, b--;\n\t\t\tprintf(\"%d\\n\", queryMax(a, b, seg[f[a]]));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"sdoi2014-journey","published":1,"updated":"2016-09-02T13:42:35.641Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c1500coc2xlua0rrkkv"},{"title":"SDOI2013 - LCA +  + ","date":"2016-09-05T13:49:00.000Z","_content":"\n $ n $ $ m $  $ T $ \n\n1.  $ k $ \n2. \n\n<!-- more -->\n\n### \n[BZOJ 3123](http://www.lydsy.com/JudgeOnline/problem.php?id=3123)\n\n### \n $ k $ \n\n $ O(n \\log ^ 2 n) $\n\n### \n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\n#define inline inline __attribute__((always_inline))\n\nconst int MAXN = 80000;\nconst int MAXN_LOG = 17;\n\nstruct UnionFindSet {\n\tint a[MAXN], s[MAXN];\n\n\tinline void init(const int n) { for (register int i = 0; i < n; i++) a[i] = i, s[i] = 1; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tinline int getSize(const int x) { return s[find(x)]; }\n\n\tinline void merge(const int x, const int y) {\n\t\tconst register int p = find(x), q = find(y);\n\t\ta[p] = q;\n\t\ts[q] += s[p];\n\t}\n} ufs;\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tint cnt, refCnt;\n\n\tinline SegmentTree(const int l, const int r, SegmentTree *lc = NULL, SegmentTree *rc = NULL, const int cnt = 0) : l(l), r(r), lc(lc), rc(rc), cnt(cnt), refCnt(1) {}\n\n\tinline static SegmentTree *newNode();\n\tinline static void deleteNode(SegmentTree *v);\n\n\t~SegmentTree() {\n\t\tif (r - l < 600) return;\n\t\tif (lc && lc->unref()) deleteNode(lc);\n\t\tif (rc && rc->unref()) deleteNode(rc);\n\t}\n\n\tinline SegmentTree *buildChild(const int x) {\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x <= mid) return new (newNode()) SegmentTree(l, mid, NULL, NULL, 0);\n\t\telse return new (newNode()) SegmentTree(mid + 1, r, NULL, NULL, 0);\n\t}\n\n\tSegmentTree *insertSelf(const int x) {\n\t\tcnt++;\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x == l && x == r) return this;\n\t\telse if (x <= mid) return (lc = buildChild(x))->insertSelf(x), this;\n\t\telse return (rc = buildChild(x))->insertSelf(x), this;\n\t}\n\n\tSegmentTree *insert(const int x) {\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x == l && x == r) return new (newNode()) SegmentTree(l, r, NULL, NULL, cnt + 1);\n\t\telse if (x <= mid) return new (newNode()) SegmentTree(l, r, lc ? lc->insert(x) : buildChild(x)->insertSelf(x), rc ? rc->ref() : NULL, cnt + 1);\n\t\telse return new (newNode()) SegmentTree(l, r, lc ? lc->ref() : NULL, rc ? rc->insert(x) : buildChild(x)->insertSelf(x), cnt + 1);\n\t}\n\n\tinline SegmentTree *ref() {\n\t\trefCnt++;\n\t\treturn this;\n\t}\n\n\tinline bool unref() {\n\t\treturn !--refCnt;\n\t}\n\n\tint query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\telse return lc->query(l, r) + rc->query(l, r);\n\t}\n\n\tinline int rank() {\n\t\treturn lc ? lc->cnt : 0;\n\t}\n} *segRoot;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[sizeof(T) * SIZE], *p;\n\tT *recycle[SIZE], **pr;\n\t\n\tinline MemoryPool() : p(buf), pr(recycle) {}\n\n\tinline T *alloc() {\n\t\tif (p == buf + sizeof(T) * SIZE) {\n\t\t\tif (pr <= recycle) throw std::bad_alloc();\n\t\t\telse return *--pr;\n\t\t} else {\n\t\t\tregister char *res = p;\n\t\t\tp += sizeof(T);\n\t\t\treturn reinterpret_cast<T *>(res);\n\t\t}\n\t}\n\n\tinline void free(T *p) {\n\t\t*pr++ = p;\n\t}\n};\n\nMemoryPool<SegmentTree, MAXN * MAXN_LOG * 10> pool;\ninline SegmentTree *SegmentTree::newNode() {\n\treturn pool.alloc();\n}\n\ninline void SegmentTree::deleteNode(SegmentTree *p) {\n\tp->~SegmentTree();\n\tpool.free(p);\n}\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *p;\n\tint w, ts, d;\n\tbool v;\n\tSegmentTree *seg;\n\tNode *f[MAXN_LOG + 1];\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {};\n};\n\ninline void addEdge(const int u, const int v) {\n\tN[u].e = new Edge(&N[u], &N[v]);\n\tN[v].e = new Edge(&N[v], &N[u]);\n}\n\nint n, ts, logn = 0;\n\ninline void bfs(Node *start, const bool init = true) {\n\t++ts;\n\tstd::queue<Node *> q;\n\tstart->ts = ts;\n\tif (init) {\n\t\tstart->p = start->f[0] = start;\n\t\tstart->seg = segRoot->insert(start->w);\n\t\tstart->d = 0;\n\t}\n\tq.push(start);\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (register int j = 1; j <= logn; j++) {\n\t\t\tv->f[j] = v->f[j - 1]->f[j - 1];\n\t\t}\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->ts != ts && (init || e->t != start->p)) {\n\t\t\te->t->ts = ts;\n\t\t\te->t->p = e->t->f[0] = v;\n\t\t\tif (e->t->seg) SegmentTree::deleteNode(e->t->seg);\n\t\t\te->t->seg = v->seg->insert(e->t->w);\n\t\t\te->t->d = v->d + 1;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n}\n\ninline void bfs() {\n\tfor (register int i = 0; i < n; i++) if (N[i].ts == 0) bfs(&N[i]);\n}\n\ninline void link(int u, int v) {\n\tconst register int su = ufs.getSize(u), sv = ufs.getSize(v);\n\tif (su > sv) std::swap(u, v);\n\n\taddEdge(u, v);\n\tN[u].p = N[u].f[0] = &N[v];\n\tSegmentTree::deleteNode(N[u].seg);\n\tN[u].seg = N[v].seg->insert(N[u].w);\n\tN[u].d = N[v].d + 1;\n\tbfs(&N[u], false);\n\n\tufs.merge(u, v);\n}\n\ninline Node *lca(Node *u, Node *v) {\n\tif (u->d < v->d) std::swap(u, v);\n\tif (u->d != v->d) {\n\t\tfor (register int i = logn; i >= 0; i--) if (u->f[i]->d >= v->d) u = u->f[i];\n\t}\n\tif (u != v) {\n\t\tfor (register int i = logn; i >= 0; i--) if (u->f[i] != v->f[i]) u = u->f[i], v = v->f[i];\n\t\treturn u->p;\n\t}\n\treturn u;\n}\n\ninline int query(Node *u, Node *v, int k) {\n\tNode *p = lca(u, v);\n\tregister int min = 0, max = n - 1;\n\tSegmentTree *sa = u->seg, *sb = v->seg, *sc = p->seg, *sd = p->p != p ? p->p->seg : segRoot;\n\twhile (min != max) {\n\t\tconst register int mid = min + (max - min) / 2;\n\t\tregister int t = 0;\n\t\tif (sa) t += sa->rank();\n\t\tif (sb) t += sb->rank();\n\t\tif (sc) t -= sc->rank();\n\t\tif (sd) t -= sd->rank();\n\t\tif (k <= t) {\n\t\t\tif (sa) sa = sa->lc;\n\t\t\tif (sb) sb = sb->lc;\n\t\t\tif (sc) sc = sc->lc;\n\t\t\tif (sd) sd = sd->lc;\n\t\t\tmax = mid;\n\t\t} else {\n\t\t\tif (sa) sa = sa->rc;\n\t\t\tif (sb) sb = sb->rc;\n\t\t\tif (sc) sc = sc->rc;\n\t\t\tif (sd) sd = sd->rc;\n\t\t\tk -= t, min = mid + 1;\n\t\t}\n\t}\n\treturn min;\n}\n\nint main() {\n\tint tc;\n\tscanf(\"%d\", &tc);\n\tint m, t;\n\tscanf(\"%d %d %d\", &n, &m, &t);\n\tufs.init(n);\n\tfor (; (1 << (logn + 1)) <= n; logn++);\n\n\tfor (register int i = 0; i < n; i++) scanf(\"%d\", &N[i].w);\n\tstatic int set[MAXN];\n\tfor (register int i = 0; i < n; i++) set[i] = N[i].w;\n\tstd::sort(set, set + n);\n\tregister int *end = std::unique(set, set + n);\n\tfor (register int i = 0; i < n; i++) N[i].w = std::lower_bound(set, end, N[i].w) - set;\n\n\tsegRoot = new SegmentTree(0, n - 1);\n\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tbfs();\n\n\tregister int lastAns = 0;\n\twhile (t--) {\n\t\tchar cmd[2];\n\t\tint u, v;\n\t\tscanf(\"%s %d %d\", cmd, &u, &v), u ^= lastAns, v ^= lastAns, u--, v--;\n\t\tif (cmd[0] == 'Q') {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tk ^= lastAns;\n\t\t\tprintf(\"%d\\n\", lastAns = set[query(&N[u], &N[v], k)]);\n\t\t} else {\n\t\t\tlink(u, v);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2013-rforest.md","raw":"title: SDOI2013 - LCA +  + \ndate: 2016-09-05 21:49:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - \n  - \n  - \n  - \npermalink: sdoi2013-rforest\n---\n\n $ n $ $ m $  $ T $ \n\n1.  $ k $ \n2. \n\n<!-- more -->\n\n### \n[BZOJ 3123](http://www.lydsy.com/JudgeOnline/problem.php?id=3123)\n\n### \n $ k $ \n\n $ O(n \\log ^ 2 n) $\n\n### \n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\n#define inline inline __attribute__((always_inline))\n\nconst int MAXN = 80000;\nconst int MAXN_LOG = 17;\n\nstruct UnionFindSet {\n\tint a[MAXN], s[MAXN];\n\n\tinline void init(const int n) { for (register int i = 0; i < n; i++) a[i] = i, s[i] = 1; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tinline int getSize(const int x) { return s[find(x)]; }\n\n\tinline void merge(const int x, const int y) {\n\t\tconst register int p = find(x), q = find(y);\n\t\ta[p] = q;\n\t\ts[q] += s[p];\n\t}\n} ufs;\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tint cnt, refCnt;\n\n\tinline SegmentTree(const int l, const int r, SegmentTree *lc = NULL, SegmentTree *rc = NULL, const int cnt = 0) : l(l), r(r), lc(lc), rc(rc), cnt(cnt), refCnt(1) {}\n\n\tinline static SegmentTree *newNode();\n\tinline static void deleteNode(SegmentTree *v);\n\n\t~SegmentTree() {\n\t\tif (r - l < 600) return;\n\t\tif (lc && lc->unref()) deleteNode(lc);\n\t\tif (rc && rc->unref()) deleteNode(rc);\n\t}\n\n\tinline SegmentTree *buildChild(const int x) {\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x <= mid) return new (newNode()) SegmentTree(l, mid, NULL, NULL, 0);\n\t\telse return new (newNode()) SegmentTree(mid + 1, r, NULL, NULL, 0);\n\t}\n\n\tSegmentTree *insertSelf(const int x) {\n\t\tcnt++;\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x == l && x == r) return this;\n\t\telse if (x <= mid) return (lc = buildChild(x))->insertSelf(x), this;\n\t\telse return (rc = buildChild(x))->insertSelf(x), this;\n\t}\n\n\tSegmentTree *insert(const int x) {\n\t\tregister int mid = l + (r - l) / 2;\n\t\tif (x == l && x == r) return new (newNode()) SegmentTree(l, r, NULL, NULL, cnt + 1);\n\t\telse if (x <= mid) return new (newNode()) SegmentTree(l, r, lc ? lc->insert(x) : buildChild(x)->insertSelf(x), rc ? rc->ref() : NULL, cnt + 1);\n\t\telse return new (newNode()) SegmentTree(l, r, lc ? lc->ref() : NULL, rc ? rc->insert(x) : buildChild(x)->insertSelf(x), cnt + 1);\n\t}\n\n\tinline SegmentTree *ref() {\n\t\trefCnt++;\n\t\treturn this;\n\t}\n\n\tinline bool unref() {\n\t\treturn !--refCnt;\n\t}\n\n\tint query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\telse return lc->query(l, r) + rc->query(l, r);\n\t}\n\n\tinline int rank() {\n\t\treturn lc ? lc->cnt : 0;\n\t}\n} *segRoot;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[sizeof(T) * SIZE], *p;\n\tT *recycle[SIZE], **pr;\n\t\n\tinline MemoryPool() : p(buf), pr(recycle) {}\n\n\tinline T *alloc() {\n\t\tif (p == buf + sizeof(T) * SIZE) {\n\t\t\tif (pr <= recycle) throw std::bad_alloc();\n\t\t\telse return *--pr;\n\t\t} else {\n\t\t\tregister char *res = p;\n\t\t\tp += sizeof(T);\n\t\t\treturn reinterpret_cast<T *>(res);\n\t\t}\n\t}\n\n\tinline void free(T *p) {\n\t\t*pr++ = p;\n\t}\n};\n\nMemoryPool<SegmentTree, MAXN * MAXN_LOG * 10> pool;\ninline SegmentTree *SegmentTree::newNode() {\n\treturn pool.alloc();\n}\n\ninline void SegmentTree::deleteNode(SegmentTree *p) {\n\tp->~SegmentTree();\n\tpool.free(p);\n}\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *p;\n\tint w, ts, d;\n\tbool v;\n\tSegmentTree *seg;\n\tNode *f[MAXN_LOG + 1];\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {};\n};\n\ninline void addEdge(const int u, const int v) {\n\tN[u].e = new Edge(&N[u], &N[v]);\n\tN[v].e = new Edge(&N[v], &N[u]);\n}\n\nint n, ts, logn = 0;\n\ninline void bfs(Node *start, const bool init = true) {\n\t++ts;\n\tstd::queue<Node *> q;\n\tstart->ts = ts;\n\tif (init) {\n\t\tstart->p = start->f[0] = start;\n\t\tstart->seg = segRoot->insert(start->w);\n\t\tstart->d = 0;\n\t}\n\tq.push(start);\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (register int j = 1; j <= logn; j++) {\n\t\t\tv->f[j] = v->f[j - 1]->f[j - 1];\n\t\t}\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->ts != ts && (init || e->t != start->p)) {\n\t\t\te->t->ts = ts;\n\t\t\te->t->p = e->t->f[0] = v;\n\t\t\tif (e->t->seg) SegmentTree::deleteNode(e->t->seg);\n\t\t\te->t->seg = v->seg->insert(e->t->w);\n\t\t\te->t->d = v->d + 1;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n}\n\ninline void bfs() {\n\tfor (register int i = 0; i < n; i++) if (N[i].ts == 0) bfs(&N[i]);\n}\n\ninline void link(int u, int v) {\n\tconst register int su = ufs.getSize(u), sv = ufs.getSize(v);\n\tif (su > sv) std::swap(u, v);\n\n\taddEdge(u, v);\n\tN[u].p = N[u].f[0] = &N[v];\n\tSegmentTree::deleteNode(N[u].seg);\n\tN[u].seg = N[v].seg->insert(N[u].w);\n\tN[u].d = N[v].d + 1;\n\tbfs(&N[u], false);\n\n\tufs.merge(u, v);\n}\n\ninline Node *lca(Node *u, Node *v) {\n\tif (u->d < v->d) std::swap(u, v);\n\tif (u->d != v->d) {\n\t\tfor (register int i = logn; i >= 0; i--) if (u->f[i]->d >= v->d) u = u->f[i];\n\t}\n\tif (u != v) {\n\t\tfor (register int i = logn; i >= 0; i--) if (u->f[i] != v->f[i]) u = u->f[i], v = v->f[i];\n\t\treturn u->p;\n\t}\n\treturn u;\n}\n\ninline int query(Node *u, Node *v, int k) {\n\tNode *p = lca(u, v);\n\tregister int min = 0, max = n - 1;\n\tSegmentTree *sa = u->seg, *sb = v->seg, *sc = p->seg, *sd = p->p != p ? p->p->seg : segRoot;\n\twhile (min != max) {\n\t\tconst register int mid = min + (max - min) / 2;\n\t\tregister int t = 0;\n\t\tif (sa) t += sa->rank();\n\t\tif (sb) t += sb->rank();\n\t\tif (sc) t -= sc->rank();\n\t\tif (sd) t -= sd->rank();\n\t\tif (k <= t) {\n\t\t\tif (sa) sa = sa->lc;\n\t\t\tif (sb) sb = sb->lc;\n\t\t\tif (sc) sc = sc->lc;\n\t\t\tif (sd) sd = sd->lc;\n\t\t\tmax = mid;\n\t\t} else {\n\t\t\tif (sa) sa = sa->rc;\n\t\t\tif (sb) sb = sb->rc;\n\t\t\tif (sc) sc = sc->rc;\n\t\t\tif (sd) sd = sd->rc;\n\t\t\tk -= t, min = mid + 1;\n\t\t}\n\t}\n\treturn min;\n}\n\nint main() {\n\tint tc;\n\tscanf(\"%d\", &tc);\n\tint m, t;\n\tscanf(\"%d %d %d\", &n, &m, &t);\n\tufs.init(n);\n\tfor (; (1 << (logn + 1)) <= n; logn++);\n\n\tfor (register int i = 0; i < n; i++) scanf(\"%d\", &N[i].w);\n\tstatic int set[MAXN];\n\tfor (register int i = 0; i < n; i++) set[i] = N[i].w;\n\tstd::sort(set, set + n);\n\tregister int *end = std::unique(set, set + n);\n\tfor (register int i = 0; i < n; i++) N[i].w = std::lower_bound(set, end, N[i].w) - set;\n\n\tsegRoot = new SegmentTree(0, n - 1);\n\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tbfs();\n\n\tregister int lastAns = 0;\n\twhile (t--) {\n\t\tchar cmd[2];\n\t\tint u, v;\n\t\tscanf(\"%s %d %d\", cmd, &u, &v), u ^= lastAns, v ^= lastAns, u--, v--;\n\t\tif (cmd[0] == 'Q') {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k);\n\t\t\tk ^= lastAns;\n\t\t\tprintf(\"%d\\n\", lastAns = set[query(&N[u], &N[v], k)]);\n\t\t} else {\n\t\t\tlink(u, v);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"sdoi2013-rforest","published":1,"updated":"2016-10-19T09:24:21.064Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c1a00cuc2xlsd79jq5o"},{"title":"SDOI2011 -  + EXGCD + BSGS","date":"2016-06-13T04:07:00.000Z","_content":"\n\n\n1.  $ y $$ z $$ p $ $ y ^ z \\bmod p $ \n2.  $ y $$ z $$ p $ $ xy \\equiv z \\pmod p $  $ x $\n3.  $ y $$ z $$ p $ $ y ^ x \\equiv z \\pmod p $ $ x $\n\n<!-- more -->\n\n### \n[BZOJ 2242](http://www.lydsy.com/JudgeOnline/problem.php?id=2242)\n\n### \n\n\n $ y \\equiv 0 \\pmod p $  $ z \\not \\equiv 0 \\pmod p $   \n $ z \\equiv 0 \\pmod p $  $ 0 $\n\n $ y $  $ p $ \n\n$$ x \\equiv z \\times y ^ {-1} \\pmod p $$\n\nEXGCD \n\nBSGS \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <tr1/unordered_map>\n\ntemplate <typename T>\ninline T pow(const T a, const T n, const T p) {\n\tT ans = 1;\n\tfor (T x = a, tmp = n; tmp; tmp >>= 1, x = x * x % p) if (tmp & 1) ans = ans * x % p;\n\treturn ans;\n}\n\ntemplate <typename T>\ninline void exgcd(const T a, const T b, T &g, T &x, T &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ntemplate <typename T>\ninline T inv(const T x, const T p) {\n\tT g, r, y;\n\texgcd(x, p, g, r, y);\n\treturn (r % p + p) % p;\n}\n\ntemplate <typename T>\ninline T bsgs(const T a, const T b, const T p) {\n\tif (a == 0) {\n\t\treturn b == 0 ? 1 : -1;\n\t}\n\n\tstd::tr1::unordered_map<T, T> map;\n\tT m = ceil(sqrt(static_cast<double>(p))), t = 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!map.count(t)) map[t] = i;\n\t\tt = t * a % p;\n\t}\n\n\tT r = b, k = inv(t, p) % p;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (map.count(r)) return map[r] + i * m;\n\t\tr = r * k % p;\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tint t, k;\n\tscanf(\"%d %d\", &t, &k);\n\twhile (t--) {\n\t\tlong long a, b, p;\n\t\tscanf(\"%lld %lld %lld\", &a, &b, &p);\n\t\tif (k == 1) {\n\t\t\tprintf(\"%lld\\n\", pow(a, b, p));\n\t\t} else if (k == 2) {\n\t\t\tif (a > p && a % p == 0) puts(\"Orz, I cannot find x!\");\n\t\t\telse {\n\t\t\t\tlong long t = inv(a, p);\n\t\t\t\tprintf(\"%lld\\n\", b * t % p);\n\t\t\t}\n\t\t} else if (k == 3) {\n\t\t\tlong long ans = bsgs(a % p, b % p, p);\n\t\t\tif (ans == -1) puts(\"Orz, I cannot find x!\");\n\t\t\telse printf(\"%lld\\n\", ans);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2011-calc.md","raw":"title: SDOI2011 -  + EXGCD + BSGS\ndate: 2016-06-13 12:07:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - \n  - EXGCD\n  - \n  - BSGS\npermalink: sdoi2011-calc\n---\n\n\n\n1.  $ y $$ z $$ p $ $ y ^ z \\bmod p $ \n2.  $ y $$ z $$ p $ $ xy \\equiv z \\pmod p $  $ x $\n3.  $ y $$ z $$ p $ $ y ^ x \\equiv z \\pmod p $ $ x $\n\n<!-- more -->\n\n### \n[BZOJ 2242](http://www.lydsy.com/JudgeOnline/problem.php?id=2242)\n\n### \n\n\n $ y \\equiv 0 \\pmod p $  $ z \\not \\equiv 0 \\pmod p $   \n $ z \\equiv 0 \\pmod p $  $ 0 $\n\n $ y $  $ p $ \n\n$$ x \\equiv z \\times y ^ {-1} \\pmod p $$\n\nEXGCD \n\nBSGS \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <tr1/unordered_map>\n\ntemplate <typename T>\ninline T pow(const T a, const T n, const T p) {\n\tT ans = 1;\n\tfor (T x = a, tmp = n; tmp; tmp >>= 1, x = x * x % p) if (tmp & 1) ans = ans * x % p;\n\treturn ans;\n}\n\ntemplate <typename T>\ninline void exgcd(const T a, const T b, T &g, T &x, T &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ntemplate <typename T>\ninline T inv(const T x, const T p) {\n\tT g, r, y;\n\texgcd(x, p, g, r, y);\n\treturn (r % p + p) % p;\n}\n\ntemplate <typename T>\ninline T bsgs(const T a, const T b, const T p) {\n\tif (a == 0) {\n\t\treturn b == 0 ? 1 : -1;\n\t}\n\n\tstd::tr1::unordered_map<T, T> map;\n\tT m = ceil(sqrt(static_cast<double>(p))), t = 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!map.count(t)) map[t] = i;\n\t\tt = t * a % p;\n\t}\n\n\tT r = b, k = inv(t, p) % p;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (map.count(r)) return map[r] + i * m;\n\t\tr = r * k % p;\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tint t, k;\n\tscanf(\"%d %d\", &t, &k);\n\twhile (t--) {\n\t\tlong long a, b, p;\n\t\tscanf(\"%lld %lld %lld\", &a, &b, &p);\n\t\tif (k == 1) {\n\t\t\tprintf(\"%lld\\n\", pow(a, b, p));\n\t\t} else if (k == 2) {\n\t\t\tif (a > p && a % p == 0) puts(\"Orz, I cannot find x!\");\n\t\t\telse {\n\t\t\t\tlong long t = inv(a, p);\n\t\t\t\tprintf(\"%lld\\n\", b * t % p);\n\t\t\t}\n\t\t} else if (k == 3) {\n\t\t\tlong long ans = bsgs(a % p, b % p, p);\n\t\t\tif (ans == -1) puts(\"Orz, I cannot find x!\");\n\t\t\telse printf(\"%lld\\n\", ans);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"sdoi2011-calc","published":1,"updated":"2016-06-13T04:07:43.358Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c1o00d5c2xl0hilvwi2"},{"title":"SDOI2010 - ","date":"2016-02-29T13:30:11.000Z","_content":"\n $ N $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1927](http://www.lydsy.com/JudgeOnline/problem.php?id=1927)  \n[CodeVS 2313](http://codevs.cn/problem/2313/)\n\n### \n  \n\n****\n\n1.  1\n2.  1 \n3.  1 \n4.  1 \n5.  1  0  1 \n\n   \n\n  \n\n\n\n****\n\n1. \n2.  1 \n3.  1 \n4.  1 \n5. **** 1 \n\n  \n\n  \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 800;\nconst int MAXM = 15000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m;\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(s, i + n, 1, x);\n\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(i + n, t, 1, 0);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v + n, 1, w);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n * 2 + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2010-starrace.md","raw":"title: SDOI2010 -  \ndate: 2016-02-29 21:30:11\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - Edmonds-Karp\n  - \n  - \n  - \npermalink: sdoi2010-starrace\n---\n\n $ N $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1927](http://www.lydsy.com/JudgeOnline/problem.php?id=1927)  \n[CodeVS 2313](http://codevs.cn/problem/2313/)\n\n### \n  \n\n****\n\n1.  1\n2.  1 \n3.  1 \n4.  1 \n5.  1  0  1 \n\n   \n\n  \n\n\n\n****\n\n1. \n2.  1 \n3.  1 \n4.  1 \n5. **** 1 \n\n  \n\n  \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 800;\nconst int MAXM = 15000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m;\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(s, i + n, 1, x);\n\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(i + n, t, 1, 0);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v + n, 1, w);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n * 2 + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2010-starrace","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c1t00dfc2xlczjqoznc"},{"title":"SDOI2010 - DP","date":"2016-06-20T07:49:00.000Z","_content":"\n\n\n $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1925](http://www.lydsy.com/JudgeOnline/problem.php?id=1925)\n\n### \n $ 0 $ ~ $ n - 1 $ \n\n $ f(i,\\ j) $  $ 0 $ ~ $ i $  $ j $$ j \\leq i $****\n\n**** $ j - 1 $  $ j - 1 $  $ f(i,\\ j - 1) $  \n**** $ j - 1 $  $ 0 $ ~ $ i - 1 $ **** $ x $  $ (i - 1) - x $ $ f(i - 1,\\ (i - 1) - (j - 1)) $\n\n $ f(i,\\ j) = f(i,\\ j - 1) + f(i - 1, i - j) $\n\n $ 2 \\sum\\limits_{i = 0} ^ {n - 1} f(n - 1,\\ i) $**** $ 2 $\n\n### \n 30M+ \n\n```c++\n#include <cstdio>\n\nconst int MAXN = 4200;\n\nint n, p;\nint _f[MAXN * (MAXN + 1) / 2];\nint *f[MAXN + 1];\n\ninline void init() {\n\tint *curr = _f;\n\tfor (int i = 0; i < n; i++) {\n\t\tf[i] = curr;\n\t\tcurr += i + 1;\n\t}\n\t// printf(\"%ld %d\\n\", curr - _f, n * (n + 1) / 2);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &p);\n\tinit();\n\n\tf[1][1] = 1;\n\tfor (int i = 2; i < n; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tf[i][j] = (f[i][j - 1] + f[i - 1][i - j]) % p;\n\t\t\t// printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) ans = (ans + f[n - 1][i]) % p;\n\n\tprintf(\"%d\\n\", ans * 2 % p);\n\n\treturn 0;\n}\n```\n\n\n\n```c++\n#include <cstdio>\n\nconst int MAXN = 4200;\n\nint n, p;\n\nint main() {\n\tscanf(\"%d %d\", &n, &p);\n\n\tstatic int f[2][MAXN];\n\tf[1 % 2][1] = 1;\n\tfor (int i = 2; i < n; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tf[i % 2][j] = (f[i % 2][j - 1] + f[(i - 1) % 2][i - j]) % p;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) ans = (ans + f[(n - 1) % 2][i]) % p;\n\n\tprintf(\"%d\\n\", ans * 2 % p);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2010-goblin.md","raw":"title: SDOI2010 - DP\ndate: 2016-06-20 15:49:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - DP\npermalink: sdoi2010-goblin\n---\n\n\n\n $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1925](http://www.lydsy.com/JudgeOnline/problem.php?id=1925)\n\n### \n $ 0 $ ~ $ n - 1 $ \n\n $ f(i,\\ j) $  $ 0 $ ~ $ i $  $ j $$ j \\leq i $****\n\n**** $ j - 1 $  $ j - 1 $  $ f(i,\\ j - 1) $  \n**** $ j - 1 $  $ 0 $ ~ $ i - 1 $ **** $ x $  $ (i - 1) - x $ $ f(i - 1,\\ (i - 1) - (j - 1)) $\n\n $ f(i,\\ j) = f(i,\\ j - 1) + f(i - 1, i - j) $\n\n $ 2 \\sum\\limits_{i = 0} ^ {n - 1} f(n - 1,\\ i) $**** $ 2 $\n\n### \n 30M+ \n\n```c++\n#include <cstdio>\n\nconst int MAXN = 4200;\n\nint n, p;\nint _f[MAXN * (MAXN + 1) / 2];\nint *f[MAXN + 1];\n\ninline void init() {\n\tint *curr = _f;\n\tfor (int i = 0; i < n; i++) {\n\t\tf[i] = curr;\n\t\tcurr += i + 1;\n\t}\n\t// printf(\"%ld %d\\n\", curr - _f, n * (n + 1) / 2);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &p);\n\tinit();\n\n\tf[1][1] = 1;\n\tfor (int i = 2; i < n; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tf[i][j] = (f[i][j - 1] + f[i - 1][i - j]) % p;\n\t\t\t// printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) ans = (ans + f[n - 1][i]) % p;\n\n\tprintf(\"%d\\n\", ans * 2 % p);\n\n\treturn 0;\n}\n```\n\n\n\n```c++\n#include <cstdio>\n\nconst int MAXN = 4200;\n\nint n, p;\n\nint main() {\n\tscanf(\"%d %d\", &n, &p);\n\n\tstatic int f[2][MAXN];\n\tf[1 % 2][1] = 1;\n\tfor (int i = 2; i < n; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tf[i % 2][j] = (f[i % 2][j - 1] + f[(i - 1) % 2][i - j]) % p;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) ans = (ans + f[(n - 1) % 2][i]) % p;\n\n\tprintf(\"%d\\n\", ans * 2 % p);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2010-goblin","published":1,"updated":"2016-06-20T07:50:35.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c1y00dnc2xlepo0bnx5"},{"title":"SDOI2009 - ","date":"2016-06-21T12:24:00.000Z","_content":"\n $ N $  $ M $ Elaxia Elaxia  $ 1 $ $ N $ Elaxia   \n\n\n<!-- more -->\n\n### \n[BZOJ 1877](http://www.lydsy.com/JudgeOnline/problem.php?id=1877)\n\n### \n $ 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXM = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint f, d;\n\tbool q;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\t// printf(\"%d %d\\n\", f, c);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].q = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->d > v->d + e->w && e->f < e->c) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\t// printf(\"[%ld, %ld]\\n\", e->s - N, e->t - N);\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1, 0);\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\n\t\taddEdge(u + n, v, 1, w);\n\t}\n\n\taddEdge(s, 1 + n, INT_MAX, 0);\n\taddEdge(n, t, INT_MAX, 0);\n\n\tint f, c;\n\tedmondskarp(s, t, n * 2 + 2, f, c);\n\tprintf(\"%d %d\\n\", f, c);\n\n\treturn 0;\n}\n```\n","source":"_posts/sdoi2009-run.md","raw":"title: SDOI2009 - \ndate: 2016-06-21 20:24:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - \n  - \n  - Edmonds-Karp\npermalink: sdoi2009-run\n---\n\n $ N $  $ M $ Elaxia Elaxia  $ 1 $ $ N $ Elaxia   \n\n\n<!-- more -->\n\n### \n[BZOJ 1877](http://www.lydsy.com/JudgeOnline/problem.php?id=1877)\n\n### \n $ 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXM = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint f, d;\n\tbool q;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\t// printf(\"%d %d\\n\", f, c);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].q = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->d > v->d + e->w && e->f < e->c) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\t// printf(\"[%ld, %ld]\\n\", e->s - N, e->t - N);\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1, 0);\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\n\t\taddEdge(u + n, v, 1, w);\n\t}\n\n\taddEdge(s, 1 + n, INT_MAX, 0);\n\taddEdge(n, t, INT_MAX, 0);\n\n\tint f, c;\n\tedmondskarp(s, t, n * 2 + 2, f, c);\n\tprintf(\"%d %d\\n\", f, c);\n\n\treturn 0;\n}\n```\n","slug":"sdoi2009-run","published":1,"updated":"2016-06-21T12:24:51.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c2100dsc2xl2mo6co45"},{"title":"SDOI2008 - ","date":"2016-09-02T13:07:00.000Z","_content":"\nA  $ 5 $  $ S $$ S $ $ S $  \n\n$ 5 $ \n\n1. $ A = A \\cup B $\n2. $ A = A \\cap B $\n3. $ A = \\{ x \\mid x \\in A \\ \\mathrm{and} \\ x \\notin B \\} $\n4. $ A = \\{ x \\mid x \\notin A \\ \\mathrm{and} \\ x \\in B \\} $\n5. $ A = \\{ x \\mid x \\in A \\ \\mathrm{and} \\ x \\notin B \\} \\cup \\{ x \\mid x \\notin A \\ \\mathrm{and} \\ x \\in B \\} $\n\n<!-- more -->\n\n### \n[BZOJ 3226](http://www.lydsy.com/JudgeOnline/problem.php?id=3226)\n\n### \n $ (a, b) $ $ [a + 0.5, b - 0.5] $ $ \\times 2 $ $ [2a + 1, 2b - 1] $\n\n\n\n1.  $ B $  $ 1 $\n2.  $ B $  $ 0 $\n3.  $ B $  $ 0 $\n4.  $ B $  $ 0 $\n5.  $ B $ \n\n $ 0 $  $ 1 $  $ 0 $  $ 1 $ $ 1 $  $ 0 $\n\n $ 0 $  $ 1 $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 65535;\nconst int MAXM = 70000;\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tenum TagType {\n\t\tZero, One, Reverse, None\n\t} tag;\n\tbool val;\n\n\tSegmentTree(const int l, const int r, const int mid, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(mid), lc(lc), rc(rc), tag(None), val(false) {}\n\n\tvoid setTag(const TagType t) {\n\t\tif (t == Reverse) {\n\t\t\tif (l == r) val ^= 1;\n\t\t\telse {\n\t\t\t\tif (tag == Reverse) tag = None;\n\t\t\t\telse if (tag == Zero) tag = One;\n\t\t\t\telse if (tag == One) tag = Zero;\n\t\t\t\telse tag = Reverse;\n\t\t\t}\n\t\t} else {\n\t\t\tif (l == r) val = t == One;\n\t\t\telse tag = t;\n\t\t}\n\t}\n\n\tvoid pushDown() {\n\t\tif (tag != None) {\n\t\t\tlc->setTag(tag);\n\t\t\trc->setTag(tag);\n\t\t\ttag = None;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const TagType t) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) setTag(t);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlc->update(l, r, t);\n\t\t\trc->update(l, r, t);\n\t\t}\n\t}\n\n\tbool query(const int pos) {\n\t\tSegmentTree *v = this;\n\t\tbool rev = false;\n\t\twhile (!(v->l == v->r || v->tag == Zero || v->tag == One)) {\n\t\t\tif (v->tag == Reverse) rev ^= 1;\n\t\t\tv = (pos <= v->mid) ? v->lc : v->rc;\n\t\t}\n\t\tif (v->tag == Zero) v->val = false;\n\t\telse if (v->tag == One) v->val = true;\n\t\treturn rev ? v->val ^ 1 : v->val;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, l, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, mid, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n\n\t/*\n\tstatic bool a[MAXN * 2 + 1];\n\n\tstatic void update(const int l, const int r, const TagType t) {\n\t\tif (l > r) return;\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tif (t == Zero) a[i] = false;\n\t\t\telse if (t == One) a[i] = true;\n\t\t\telse if (t == Reverse) a[i] ^= 1;\n\t\t}\n\t}\n\n\tstatic bool query(const int pos) { return a[pos]; }\n\n\tstatic SegmentTree *build(const int l, const int r) { return NULL; }\n\t*/\n} *segment;\n\n// bool SegmentTree::a[MAXN * 2 + 1];\n\ninline void parse(char *s, int &l, int &r) {\n\tchar ch;\n\tbool fl = false;\n\tch = *s++;\n\tif (ch == '(') fl = true;\n\tl = 0;\n\twhile ((ch = *s++) != ',') l = l * 10 + ch - '0';\n\tl *= 2;\n\tif (fl) l++;\n\tr = 0;\n\twhile ((ch = *s++), (ch >= '0' && ch <= '9')) r = r * 10 + ch - '0';\n\tr *= 2;\n\tif (ch == ')') r--;\n}\n\ninline void print() {\n\tint l = -1;\n\tbool flag = false;\n\tfor (int i = 0; i <= MAXN * 2; i++) {\n\t\tbool val = segment->query(i);\n\t\tif (l == -1 && val) {\n\t\t\tl = i;\n\t\t} else if (l != -1 && !val) {\n\t\t\tprintf(\"%c%d,%d%c \", l % 2 == 0 ? '[' : '(', l / 2, (i - 1 + 1) / 2, (i - 1) % 2 == 0 ? ']' : ')');\n\t\t\tflag = true;\n\t\t\tl = -1;\n\t\t}\n\t}\n\tif (l != -1) printf(\"%c%d,%d%c \", l % 2 == 0 ? '[' : '(', l / 2, MAXN, ']'), flag = true;\n\tif (!flag) printf(\"empty set\");\n\tputchar('\\n');\n}\n\nint main() {\n\tsegment = SegmentTree::build(0, MAXN * 2);\n\tchar cmd[2], s[100];\n\twhile (~scanf(\"%s %s\", cmd, s)) {\n\t\tint l, r;\n\t\tparse(s, l, r);\n\t\t// printf(\"read: [%d, %d]\\n\", l, r);\n\n\t\tif (cmd[0] == 'U') {\n\t\t\tsegment->update(l, r, SegmentTree::One);\n\t\t} else if (cmd[0] == 'I') {\n\t\t\tsegment->update(0, l - 1, SegmentTree::Zero);\n\t\t\tsegment->update(r + 1, MAXN * 2, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'D') {\n\t\t\tsegment->update(l, r, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'C') {\n\t\t\tsegment->update(0, MAXN * 2, SegmentTree::Reverse);\n\t\t\tsegment->update(0, l - 1, SegmentTree::Zero);\n\t\t\tsegment->update(r + 1, MAXN * 2, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'S') {\n\t\t\tsegment->update(l, r, SegmentTree::Reverse);\n\t\t}\n\n\t\t// print();\n\t}\n\n\tprint();\n\n\treturn 0;\n}\n```","source":"_posts/sdoi2008-interval.md","raw":"title: SDOI2008 - \ndate: 2016-09-02 21:07:00\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - \n  - \npermalink: sdoi2008-interval\n---\n\nA  $ 5 $  $ S $$ S $ $ S $  \n\n$ 5 $ \n\n1. $ A = A \\cup B $\n2. $ A = A \\cap B $\n3. $ A = \\{ x \\mid x \\in A \\ \\mathrm{and} \\ x \\notin B \\} $\n4. $ A = \\{ x \\mid x \\notin A \\ \\mathrm{and} \\ x \\in B \\} $\n5. $ A = \\{ x \\mid x \\in A \\ \\mathrm{and} \\ x \\notin B \\} \\cup \\{ x \\mid x \\notin A \\ \\mathrm{and} \\ x \\in B \\} $\n\n<!-- more -->\n\n### \n[BZOJ 3226](http://www.lydsy.com/JudgeOnline/problem.php?id=3226)\n\n### \n $ (a, b) $ $ [a + 0.5, b - 0.5] $ $ \\times 2 $ $ [2a + 1, 2b - 1] $\n\n\n\n1.  $ B $  $ 1 $\n2.  $ B $  $ 0 $\n3.  $ B $  $ 0 $\n4.  $ B $  $ 0 $\n5.  $ B $ \n\n $ 0 $  $ 1 $  $ 0 $  $ 1 $ $ 1 $  $ 0 $\n\n $ 0 $  $ 1 $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 65535;\nconst int MAXM = 70000;\n\nstruct SegmentTree {\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tenum TagType {\n\t\tZero, One, Reverse, None\n\t} tag;\n\tbool val;\n\n\tSegmentTree(const int l, const int r, const int mid, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(mid), lc(lc), rc(rc), tag(None), val(false) {}\n\n\tvoid setTag(const TagType t) {\n\t\tif (t == Reverse) {\n\t\t\tif (l == r) val ^= 1;\n\t\t\telse {\n\t\t\t\tif (tag == Reverse) tag = None;\n\t\t\t\telse if (tag == Zero) tag = One;\n\t\t\t\telse if (tag == One) tag = Zero;\n\t\t\t\telse tag = Reverse;\n\t\t\t}\n\t\t} else {\n\t\t\tif (l == r) val = t == One;\n\t\t\telse tag = t;\n\t\t}\n\t}\n\n\tvoid pushDown() {\n\t\tif (tag != None) {\n\t\t\tlc->setTag(tag);\n\t\t\trc->setTag(tag);\n\t\t\ttag = None;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const TagType t) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) setTag(t);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlc->update(l, r, t);\n\t\t\trc->update(l, r, t);\n\t\t}\n\t}\n\n\tbool query(const int pos) {\n\t\tSegmentTree *v = this;\n\t\tbool rev = false;\n\t\twhile (!(v->l == v->r || v->tag == Zero || v->tag == One)) {\n\t\t\tif (v->tag == Reverse) rev ^= 1;\n\t\t\tv = (pos <= v->mid) ? v->lc : v->rc;\n\t\t}\n\t\tif (v->tag == Zero) v->val = false;\n\t\telse if (v->tag == One) v->val = true;\n\t\treturn rev ? v->val ^ 1 : v->val;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, l, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, mid, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n\n\t/*\n\tstatic bool a[MAXN * 2 + 1];\n\n\tstatic void update(const int l, const int r, const TagType t) {\n\t\tif (l > r) return;\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tif (t == Zero) a[i] = false;\n\t\t\telse if (t == One) a[i] = true;\n\t\t\telse if (t == Reverse) a[i] ^= 1;\n\t\t}\n\t}\n\n\tstatic bool query(const int pos) { return a[pos]; }\n\n\tstatic SegmentTree *build(const int l, const int r) { return NULL; }\n\t*/\n} *segment;\n\n// bool SegmentTree::a[MAXN * 2 + 1];\n\ninline void parse(char *s, int &l, int &r) {\n\tchar ch;\n\tbool fl = false;\n\tch = *s++;\n\tif (ch == '(') fl = true;\n\tl = 0;\n\twhile ((ch = *s++) != ',') l = l * 10 + ch - '0';\n\tl *= 2;\n\tif (fl) l++;\n\tr = 0;\n\twhile ((ch = *s++), (ch >= '0' && ch <= '9')) r = r * 10 + ch - '0';\n\tr *= 2;\n\tif (ch == ')') r--;\n}\n\ninline void print() {\n\tint l = -1;\n\tbool flag = false;\n\tfor (int i = 0; i <= MAXN * 2; i++) {\n\t\tbool val = segment->query(i);\n\t\tif (l == -1 && val) {\n\t\t\tl = i;\n\t\t} else if (l != -1 && !val) {\n\t\t\tprintf(\"%c%d,%d%c \", l % 2 == 0 ? '[' : '(', l / 2, (i - 1 + 1) / 2, (i - 1) % 2 == 0 ? ']' : ')');\n\t\t\tflag = true;\n\t\t\tl = -1;\n\t\t}\n\t}\n\tif (l != -1) printf(\"%c%d,%d%c \", l % 2 == 0 ? '[' : '(', l / 2, MAXN, ']'), flag = true;\n\tif (!flag) printf(\"empty set\");\n\tputchar('\\n');\n}\n\nint main() {\n\tsegment = SegmentTree::build(0, MAXN * 2);\n\tchar cmd[2], s[100];\n\twhile (~scanf(\"%s %s\", cmd, s)) {\n\t\tint l, r;\n\t\tparse(s, l, r);\n\t\t// printf(\"read: [%d, %d]\\n\", l, r);\n\n\t\tif (cmd[0] == 'U') {\n\t\t\tsegment->update(l, r, SegmentTree::One);\n\t\t} else if (cmd[0] == 'I') {\n\t\t\tsegment->update(0, l - 1, SegmentTree::Zero);\n\t\t\tsegment->update(r + 1, MAXN * 2, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'D') {\n\t\t\tsegment->update(l, r, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'C') {\n\t\t\tsegment->update(0, MAXN * 2, SegmentTree::Reverse);\n\t\t\tsegment->update(0, l - 1, SegmentTree::Zero);\n\t\t\tsegment->update(r + 1, MAXN * 2, SegmentTree::Zero);\n\t\t} else if (cmd[0] == 'S') {\n\t\t\tsegment->update(l, r, SegmentTree::Reverse);\n\t\t}\n\n\t\t// print();\n\t}\n\n\tprint();\n\n\treturn 0;\n}\n```","slug":"sdoi2008-interval","published":1,"updated":"2016-09-02T13:38:18.227Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c2500dzc2xlygy30xcd"},{"title":"SDOI2008 - Link-Cut Tree","date":"2016-03-15T12:06:34.000Z","_content":"\n $ u $  $ v $  `Connect u v` $ u $  $ v $  `Destroy u v` `Query u v` $ u $  $ v $ \n\n<!-- more -->\n\n### \n[BZOJ 2049](http://www.lydsy.com/JudgeOnline/problem.php?id=2049)  \n[CodeVS 1839](http://codevs.cn/problem/1839/)\n\n### \n Link-Cut Tree \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), reversed(false) {\n\t\t\tchild[0] = child[1] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\t\t\t\n\n\t\t\tNode *oldParent = parent;\n\t\t\tRelation r = relation();\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\t\t\toldParent->child[r] = child[r ^ 1];\n\n\t\t\toldParent->parent = this;\n\t\t\tchild[r ^ 1] = oldParent;\n\n\t\t\tstd::swap(pathParent, oldParent->pathParent);\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\t\tparent->pushDown(), pushDown();\n\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->pathParent, child[R]->parent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tNode *findRoot() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\tNode *v = this;\n\t\t\twhile (v->pushDown(), v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].child[R] = NULL;\n\t\tnodes[v - 1].parent = NULL;\n\t}\n\n\tNode *find(int u) {\n\t\treturn nodes[u - 1].findRoot();\n\t}\n} lct;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar command[sizeof(\"Connect\")];\n\t\tint u, v;\n\t\tscanf(\"%s %d %d\", command, &u, &v);\n\n\t\tif (command[0] == 'C') lct.link(u, v);\n\t\telse if (command[0] == 'D') lct.cut(u, v);\n\t\telse if (command[0] == 'Q') {\n\t\t\tif (lct.find(u) == lct.find(v)) puts(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n```\n","source":"_posts/sdoi2008-cave.md","raw":"title: SDOI2008 - Link-Cut Tree \ndate: 2016-03-15 20:06:34\ncategories: OI\ntags:\n  - BZOJ\n  - SDOI\n  - CodeVS\n  - \n  - \n  - \n  - Link-Cut Tree\npermalink: sdoi2008-cave\n---\n\n $ u $  $ v $  `Connect u v` $ u $  $ v $  `Destroy u v` `Query u v` $ u $  $ v $ \n\n<!-- more -->\n\n### \n[BZOJ 2049](http://www.lydsy.com/JudgeOnline/problem.php?id=2049)  \n[CodeVS 1839](http://codevs.cn/problem/1839/)\n\n### \n Link-Cut Tree \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), reversed(false) {\n\t\t\tchild[0] = child[1] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\t\t\t\n\n\t\t\tNode *oldParent = parent;\n\t\t\tRelation r = relation();\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\t\t\toldParent->child[r] = child[r ^ 1];\n\n\t\t\toldParent->parent = this;\n\t\t\tchild[r ^ 1] = oldParent;\n\n\t\t\tstd::swap(pathParent, oldParent->pathParent);\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\t\tparent->pushDown(), pushDown();\n\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->pathParent, child[R]->parent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tNode *findRoot() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\tNode *v = this;\n\t\t\twhile (v->pushDown(), v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].child[R] = NULL;\n\t\tnodes[v - 1].parent = NULL;\n\t}\n\n\tNode *find(int u) {\n\t\treturn nodes[u - 1].findRoot();\n\t}\n} lct;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar command[sizeof(\"Connect\")];\n\t\tint u, v;\n\t\tscanf(\"%s %d %d\", command, &u, &v);\n\n\t\tif (command[0] == 'C') lct.link(u, v);\n\t\telse if (command[0] == 'D') lct.cut(u, v);\n\t\telse if (command[0] == 'Q') {\n\t\t\tif (lct.find(u) == lct.find(v)) puts(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n```\n","slug":"sdoi2008-cave","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c2a00e5c2xlm66wx5rj"},{"title":"SCOI2015 - set","date":"2016-03-25T00:53:27.000Z","_content":"\n $ A $  $ C $ $ B $\n\n1. $ B_0 = A_0 $\n2.  $ C_x = + $ $ B_c = (A_x + A_{x - 1}) ~ {\\rm mod} ~ 10 $\n3.  $ C_x = * $ $ B_c = (A_x * A_{x - 1}) ~ {\\rm mod} ~ 10 $\n\n $ A $  $ C $  $ B $  $ B $  $ B_0 $  $ B_0 $ \n\n<!-- more -->\n\n### \n[BZOJ 4447](http://www.lydsy.com/JudgeOnline/problem.php?id=4447)\n\n### \n B $ B_0 = A_0 $ $ B_i $  $ B_{i + 1} $\n\n\n\n `set`  \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <set>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nconst int MOD = 10;\n\nstruct ZeroRange {\n\tint l, r;\n\n\tZeroRange(int pos) : l(pos) {}\n\tZeroRange(int l, int r) : l(l), r(r) {}\n};\n\nbool operator<(const ZeroRange &a, const ZeroRange &b) {\n\treturn a.l < b.l;\n}\n\nbool operator<(int x, const ZeroRange &range) {\n\treturn x < range.l;\n}\n\nint n, m, A[MAXN], a[MAXN * 2];\nchar C[MAXN];\nstd::set<ZeroRange> s;\n\ninline void update(int pos, int newValue) {\n\tif (newValue == 0 && a[pos] != 0) {\n\t\tfor (int x = pos; x < n * 2; x += n) {\n\t\t\tstd::set<ZeroRange>::iterator next = s.lower_bound(x);\n\t\t\tstd::set<ZeroRange>::iterator prev = --s.lower_bound(x);\n\t\t\tif (next->l == x + 1 && prev->r == x - 1) {\n\t\t\t\tZeroRange range(prev->l, next->r);\n\t\t\t\ts.erase(next), s.erase(prev), s.insert(range);\n\t\t\t} else if (next->l == x + 1) {\n\t\t\t\tZeroRange range(x, next->r);\n\t\t\t\ts.erase(next), s.insert(range);\n\t\t\t} else if (prev->r == x - 1) {\n\t\t\t\tZeroRange range(prev->l, x);\n\t\t\t\ts.erase(prev), s.insert(range);\n\t\t\t} else s.insert(ZeroRange(x, x));\n\t\t}\n\t} else if (newValue != 0 && a[pos] == 0) {\n\t\tfor (int x = pos; x < n * 2; x += n) {\n\t\t\tstd::set<ZeroRange>::iterator self = --s.upper_bound(x);\n\t\t\tif (x != self->l && x != self->r) {\n\t\t\t\tZeroRange range1(self->l, x - 1), range2(x + 1, self->r);\n\t\t\t\ts.erase(self), s.insert(range1), s.insert(range2);\n\t\t\t} else if (x != self->r) {\n\t\t\t\tZeroRange range(x + 1, self->r);\n\t\t\t\ts.erase(self), s.insert(range);\n\t\t\t} else if (x != self->l) {\n\t\t\t\tZeroRange range(self->l, x - 1);\n\t\t\t\ts.erase(self), s.insert(range);\n\t\t\t} else s.erase(self);\n\t\t}\n\t}\n\n\ta[pos] = a[pos + n] = newValue;\n}\n\ninline int calc(int a, int b, char opt) {\n\tif (opt == '+') return (a + b) % MOD;\n\telse return (a * b) % MOD;\n}\n\ninline void update(int pos, int num, char opt) {\n\tA[pos] = num, C[pos] = opt;\n\tupdate(pos, calc(A[pos], A[(pos - 1 + n) % n], C[pos]));\n\tupdate((pos + 1) % n, calc(A[(pos + 1) % n], A[pos], C[(pos + 1) % n]));\n}\n\ninline int dist(int x, int y) {\n\tif (x > y) std::swap(x, y);\n\treturn std::min(y - x, n + x - y);\n}\n\ninline int dist(int pos, const ZeroRange &range) {\n\tif (range.l == INT_MAX || range.l == INT_MIN) return -1;\n\telse if (range.l < n && range.r >= n) {\n\t\tif (pos % n >= range.l && pos % n <= range.r) return 0;\n\t\telse if (pos % n + n >= range.l && pos % n + n <= range.r) return 0;\n\t}\n\tif (pos % n >= range.l % n && pos % n <= range.r % n) return 0;\n\telse return std::min(dist(pos % n, range.l % n), dist(pos % n, range.r % n));\n}\n\ninline int query(int pos) {\n\tint bak = a[pos];\n\tupdate(pos, A[pos]);\n\n\tint ans;\n\t/* if (s.size() == 3 && a[pos] == 0) ans = 0;\n\telse */ if (s.size() == 2) ans = -1;\n\telse if (s.size() == 3) ans = dist(pos, *++s.begin());\n\telse {\n\t\tans = -1;\n\t\tbool flag = (++s.begin())->l == ((--(--s.end()))->r + 1) % n;\n\n\t\tint oppositePos = ((pos - n / 2) + n) % n;\n\t\tstd::set<ZeroRange>::iterator opposite = --s.upper_bound(oppositePos);\n\t\tif (opposite == s.begin()) opposite = --s.upper_bound(oppositePos + n);\n\t\n\t\tif (flag && (opposite == ++s.begin())) opposite = --s.upper_bound(oppositePos + n);\n\t\t// if (flag && (opposite == --(--s.end()))) opposite--;\n\t\t\n\t\tif (opposite != s.begin() && !(flag && (opposite == ++s.begin() || opposite == --(--s.end())))) ans = std::max(ans, dist(pos, *opposite));\n\t\n\t\tif (opposite != ++s.begin()) {\n\t\t\tstd::set<ZeroRange>::iterator prev = opposite;\n\t\t\tprev--;\n\t\t\tif (!(flag && prev == ++s.begin())) ans = std::max(ans, dist(pos, *prev));\n\t\t}\n\n\t\tif (opposite != --s.end()) {\n\t\t\tstd::set<ZeroRange>::iterator next = opposite;\n\t\t\tnext++;\n\t\t\t// while (next->r != INT_MAX && flag && next == --(--s.end())) next++;\n\t\t\tif (!(flag && next == --(--s.end()))) ans = std::max(ans, dist(pos, *next));\n\t\t}\n\t}\n\n\tupdate(pos, bak);\n\n\treturn ans;\n}\n\n\nint main() {\n\t// freopen(\"password.in\", \"r\", stdin);\n\t// freopen(\"password.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &A[i]);\n\t\twhile (C[i] = getchar(), C[i] != '+' && C[i] != '*');\n\t}\n\n\tfor (int i = 0; i < n; i++) a[i] = a[i + n] = calc(A[i], A[(i - 1 + n) % n], C[i]);\n\tfor (int l = 0; l < n * 2; ) {\n\t\tif (a[l] == 0) {\n\t\t\tint r = l;\n\t\t\twhile (r + 1 < n * 2 && a[r + 1] == 0) r++;\n\t\t\ts.insert(ZeroRange(l, r));\n\t\t\tl = r + 1;\n\t\t} else l++;\n\t}\n\ts.insert(ZeroRange(INT_MIN, INT_MIN)), s.insert(ZeroRange(INT_MAX, INT_MAX));\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint type, pos;\n\t\tscanf(\"%d %d\", &type, &pos);\n\t\tif (type == 1) {\n\t\t\tint num;\n\t\t\tchar opt;\n\t\t\tscanf(\"%d\", &num);\n\t\t\twhile (opt = getchar(), opt != '+' && opt != '*');\n\t\t\tupdate(pos, num, opt);\n\t\t} else printf(\"%d\\n\", query(pos));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-password.md","raw":"title: SCOI2015 - set\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - set\n  - \npermalink: scoi2015-password\ndate: 2016-03-25 08:53:27\n---\n\n $ A $  $ C $ $ B $\n\n1. $ B_0 = A_0 $\n2.  $ C_x = + $ $ B_c = (A_x + A_{x - 1}) ~ {\\rm mod} ~ 10 $\n3.  $ C_x = * $ $ B_c = (A_x * A_{x - 1}) ~ {\\rm mod} ~ 10 $\n\n $ A $  $ C $  $ B $  $ B $  $ B_0 $  $ B_0 $ \n\n<!-- more -->\n\n### \n[BZOJ 4447](http://www.lydsy.com/JudgeOnline/problem.php?id=4447)\n\n### \n B $ B_0 = A_0 $ $ B_i $  $ B_{i + 1} $\n\n\n\n `set`  \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <set>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nconst int MOD = 10;\n\nstruct ZeroRange {\n\tint l, r;\n\n\tZeroRange(int pos) : l(pos) {}\n\tZeroRange(int l, int r) : l(l), r(r) {}\n};\n\nbool operator<(const ZeroRange &a, const ZeroRange &b) {\n\treturn a.l < b.l;\n}\n\nbool operator<(int x, const ZeroRange &range) {\n\treturn x < range.l;\n}\n\nint n, m, A[MAXN], a[MAXN * 2];\nchar C[MAXN];\nstd::set<ZeroRange> s;\n\ninline void update(int pos, int newValue) {\n\tif (newValue == 0 && a[pos] != 0) {\n\t\tfor (int x = pos; x < n * 2; x += n) {\n\t\t\tstd::set<ZeroRange>::iterator next = s.lower_bound(x);\n\t\t\tstd::set<ZeroRange>::iterator prev = --s.lower_bound(x);\n\t\t\tif (next->l == x + 1 && prev->r == x - 1) {\n\t\t\t\tZeroRange range(prev->l, next->r);\n\t\t\t\ts.erase(next), s.erase(prev), s.insert(range);\n\t\t\t} else if (next->l == x + 1) {\n\t\t\t\tZeroRange range(x, next->r);\n\t\t\t\ts.erase(next), s.insert(range);\n\t\t\t} else if (prev->r == x - 1) {\n\t\t\t\tZeroRange range(prev->l, x);\n\t\t\t\ts.erase(prev), s.insert(range);\n\t\t\t} else s.insert(ZeroRange(x, x));\n\t\t}\n\t} else if (newValue != 0 && a[pos] == 0) {\n\t\tfor (int x = pos; x < n * 2; x += n) {\n\t\t\tstd::set<ZeroRange>::iterator self = --s.upper_bound(x);\n\t\t\tif (x != self->l && x != self->r) {\n\t\t\t\tZeroRange range1(self->l, x - 1), range2(x + 1, self->r);\n\t\t\t\ts.erase(self), s.insert(range1), s.insert(range2);\n\t\t\t} else if (x != self->r) {\n\t\t\t\tZeroRange range(x + 1, self->r);\n\t\t\t\ts.erase(self), s.insert(range);\n\t\t\t} else if (x != self->l) {\n\t\t\t\tZeroRange range(self->l, x - 1);\n\t\t\t\ts.erase(self), s.insert(range);\n\t\t\t} else s.erase(self);\n\t\t}\n\t}\n\n\ta[pos] = a[pos + n] = newValue;\n}\n\ninline int calc(int a, int b, char opt) {\n\tif (opt == '+') return (a + b) % MOD;\n\telse return (a * b) % MOD;\n}\n\ninline void update(int pos, int num, char opt) {\n\tA[pos] = num, C[pos] = opt;\n\tupdate(pos, calc(A[pos], A[(pos - 1 + n) % n], C[pos]));\n\tupdate((pos + 1) % n, calc(A[(pos + 1) % n], A[pos], C[(pos + 1) % n]));\n}\n\ninline int dist(int x, int y) {\n\tif (x > y) std::swap(x, y);\n\treturn std::min(y - x, n + x - y);\n}\n\ninline int dist(int pos, const ZeroRange &range) {\n\tif (range.l == INT_MAX || range.l == INT_MIN) return -1;\n\telse if (range.l < n && range.r >= n) {\n\t\tif (pos % n >= range.l && pos % n <= range.r) return 0;\n\t\telse if (pos % n + n >= range.l && pos % n + n <= range.r) return 0;\n\t}\n\tif (pos % n >= range.l % n && pos % n <= range.r % n) return 0;\n\telse return std::min(dist(pos % n, range.l % n), dist(pos % n, range.r % n));\n}\n\ninline int query(int pos) {\n\tint bak = a[pos];\n\tupdate(pos, A[pos]);\n\n\tint ans;\n\t/* if (s.size() == 3 && a[pos] == 0) ans = 0;\n\telse */ if (s.size() == 2) ans = -1;\n\telse if (s.size() == 3) ans = dist(pos, *++s.begin());\n\telse {\n\t\tans = -1;\n\t\tbool flag = (++s.begin())->l == ((--(--s.end()))->r + 1) % n;\n\n\t\tint oppositePos = ((pos - n / 2) + n) % n;\n\t\tstd::set<ZeroRange>::iterator opposite = --s.upper_bound(oppositePos);\n\t\tif (opposite == s.begin()) opposite = --s.upper_bound(oppositePos + n);\n\t\n\t\tif (flag && (opposite == ++s.begin())) opposite = --s.upper_bound(oppositePos + n);\n\t\t// if (flag && (opposite == --(--s.end()))) opposite--;\n\t\t\n\t\tif (opposite != s.begin() && !(flag && (opposite == ++s.begin() || opposite == --(--s.end())))) ans = std::max(ans, dist(pos, *opposite));\n\t\n\t\tif (opposite != ++s.begin()) {\n\t\t\tstd::set<ZeroRange>::iterator prev = opposite;\n\t\t\tprev--;\n\t\t\tif (!(flag && prev == ++s.begin())) ans = std::max(ans, dist(pos, *prev));\n\t\t}\n\n\t\tif (opposite != --s.end()) {\n\t\t\tstd::set<ZeroRange>::iterator next = opposite;\n\t\t\tnext++;\n\t\t\t// while (next->r != INT_MAX && flag && next == --(--s.end())) next++;\n\t\t\tif (!(flag && next == --(--s.end()))) ans = std::max(ans, dist(pos, *next));\n\t\t}\n\t}\n\n\tupdate(pos, bak);\n\n\treturn ans;\n}\n\n\nint main() {\n\t// freopen(\"password.in\", \"r\", stdin);\n\t// freopen(\"password.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &A[i]);\n\t\twhile (C[i] = getchar(), C[i] != '+' && C[i] != '*');\n\t}\n\n\tfor (int i = 0; i < n; i++) a[i] = a[i + n] = calc(A[i], A[(i - 1 + n) % n], C[i]);\n\tfor (int l = 0; l < n * 2; ) {\n\t\tif (a[l] == 0) {\n\t\t\tint r = l;\n\t\t\twhile (r + 1 < n * 2 && a[r + 1] == 0) r++;\n\t\t\ts.insert(ZeroRange(l, r));\n\t\t\tl = r + 1;\n\t\t} else l++;\n\t}\n\ts.insert(ZeroRange(INT_MIN, INT_MIN)), s.insert(ZeroRange(INT_MAX, INT_MAX));\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint type, pos;\n\t\tscanf(\"%d %d\", &type, &pos);\n\t\tif (type == 1) {\n\t\t\tint num;\n\t\t\tchar opt;\n\t\t\tscanf(\"%d\", &num);\n\t\t\twhile (opt = getchar(), opt != '+' && opt != '*');\n\t\t\tupdate(pos, num, opt);\n\t\t} else printf(\"%d\\n\", query(pos));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-password","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c2f00egc2xl0ksuclev"},{"title":"SCOI2015 -  + Link-Cut Tree","date":"2016-03-22T10:09:12.000Z","_content":"\n $ n $  1  $ n - 1 $  1 \n\n\n1.  $ T $ \n2.  $ X $  $ Y $ \n\n 0 1  0 2  1\n\n $ C $ $ C $ \n\n<!-- more -->\n\n### \n[BZOJ 4448](http://www.lydsy.com/JudgeOnline/problem.php?id=4448)\n\n### \n Link-Cut Tree \n\n 30 \n\n30 ~ 60  $ C = 0 $ 1 1 \n\n 40  $ C + 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tint value, sum, size;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), value(0), sum(0), size(1), reversed(false) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value, size = 1;\n\t\t\tif (child[L]) sum += child[L]->sum, size += child[L]->size;\n\t\t\tif (child[R]) sum += child[R]->sum, size += child[R]->size;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\t\t\toldParent->child[x] = child[x ^ 1];\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->parent, child[R]->pathParent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tpathParent->maintain();\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid query(int u, int v, int &size, int &sum) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[v - 1].splay();\n\t\tsize = nodes[v - 1].size;\n\t\tsum = nodes[v - 1].sum;\n\t}\n\n\tvoid update(int u, int value) {\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].value = value;\n\t\tnodes[u - 1].maintain();\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].splay();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n} lct;\n\nstruct Day {\n\tint id;\n\tint task;\n\tint u, v, c;\n\n\tbool operator<(const Day &other) const {\n\t\treturn c < other.c;\n\t}\n} days[MAXM];\n\nint n, m;\n\ninline void bfs() {\n\tstd::queue<Tree *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tTree *t = q.front();\n\t\tq.pop();\n\n\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\tc->depth = t->depth + 1;\n\t\t\tq.push(c);\n\t\t}\n\t}\n}\n\ninline void work() {\n\tfor (int i = 0; i < m; i++) {\n\t\tif (days[i].task == 2) lct.update(days[i].u, 1);\n\t\telse {\n\t\t\tint size, sum;\n\t\t\tlct.query(days[i].u, days[i].v, size, sum);\n\t\t\tprintf(\"%d %d\\n\", size, sum);\n\t\t}\n\t}\n}\n\nint main() {\n\t// freopen(\"message.in\", \"r\", stdin);\n\t// freopen(\"message.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint u;\n\t\tscanf(\"%d\", &u);\n\t\tif (u != 0) lct.link(u, i);\n\t}\n\n\tscanf(\"%d\", &m);\n\tbool flag1 = true, flag2 = true;\n\tfor (int i = 0; i < m; i++) {\n\t\tdays[i].id = i;\n\t\tscanf(\"%d\", &days[i].task);\n\t\tif (days[i].task == 2) scanf(\"%d\", &days[i].u), days[i].c = i;\n\t\telse {\n\t\t\tint tmp;\n\t\t\tscanf(\"%d %d %d\", &days[i].u, &days[i].v, &tmp);\n\t\t\tdays[i].c = i - tmp;\n\t\t}\n\t}\n\n\tstd::sort(days, days + m);\n\n\twork();\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-message.md","raw":"title: SCOI2015 -  + Link-Cut Tree\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - \n  - Link-Cut Tree\n  - \n  - \npermalink: scoi2015-message\ndate: 2016-03-22 18:09:12\n---\n\n $ n $  1  $ n - 1 $  1 \n\n\n1.  $ T $ \n2.  $ X $  $ Y $ \n\n 0 1  0 2  1\n\n $ C $ $ C $ \n\n<!-- more -->\n\n### \n[BZOJ 4448](http://www.lydsy.com/JudgeOnline/problem.php?id=4448)\n\n### \n Link-Cut Tree \n\n 30 \n\n30 ~ 60  $ C = 0 $ 1 1 \n\n 40  $ C + 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXM = 200000;\n\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tint value, sum, size;\n\t\tbool reversed;\n\n\t\tNode() : parent(NULL), pathParent(NULL), value(0), sum(0), size(1), reversed(false) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value, size = 1;\n\t\t\tif (child[L]) sum += child[L]->sum, size += child[L]->size;\n\t\t\tif (child[R]) sum += child[R]->sum, size += child[R]->size;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\t\t\toldParent->child[x] = child[x ^ 1];\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent != NULL) {\n\t\t\t\tif (parent->parent == NULL) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (child[R]) {\n\t\t\t\tstd::swap(child[R]->parent, child[R]->pathParent);\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tpathParent->maintain();\n\t\t\tstd::swap(parent, pathParent);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\t} nodes[MAXN];\n\n\tvoid query(int u, int v, int &size, int &sum) {\n\t\tnodes[u - 1].evert();\n\t\tnodes[v - 1].access();\n\t\tnodes[v - 1].splay();\n\t\tsize = nodes[v - 1].size;\n\t\tsum = nodes[v - 1].sum;\n\t}\n\n\tvoid update(int u, int value) {\n\t\tnodes[u - 1].splay();\n\t\tnodes[u - 1].value = value;\n\t\tnodes[u - 1].maintain();\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1].evert();\n\t\tnodes[v - 1].splay();\n\t\tnodes[v - 1].pathParent = &nodes[u - 1];\n\t}\n} lct;\n\nstruct Day {\n\tint id;\n\tint task;\n\tint u, v, c;\n\n\tbool operator<(const Day &other) const {\n\t\treturn c < other.c;\n\t}\n} days[MAXM];\n\nint n, m;\n\ninline void bfs() {\n\tstd::queue<Tree *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tTree *t = q.front();\n\t\tq.pop();\n\n\t\tfor (Tree *c = t->firstChild; c; c = c->next) {\n\t\t\tc->depth = t->depth + 1;\n\t\t\tq.push(c);\n\t\t}\n\t}\n}\n\ninline void work() {\n\tfor (int i = 0; i < m; i++) {\n\t\tif (days[i].task == 2) lct.update(days[i].u, 1);\n\t\telse {\n\t\t\tint size, sum;\n\t\t\tlct.query(days[i].u, days[i].v, size, sum);\n\t\t\tprintf(\"%d %d\\n\", size, sum);\n\t\t}\n\t}\n}\n\nint main() {\n\t// freopen(\"message.in\", \"r\", stdin);\n\t// freopen(\"message.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint u;\n\t\tscanf(\"%d\", &u);\n\t\tif (u != 0) lct.link(u, i);\n\t}\n\n\tscanf(\"%d\", &m);\n\tbool flag1 = true, flag2 = true;\n\tfor (int i = 0; i < m; i++) {\n\t\tdays[i].id = i;\n\t\tscanf(\"%d\", &days[i].task);\n\t\tif (days[i].task == 2) scanf(\"%d\", &days[i].u), days[i].c = i;\n\t\telse {\n\t\t\tint tmp;\n\t\t\tscanf(\"%d %d %d\", &days[i].u, &days[i].v, &tmp);\n\t\t\tdays[i].c = i - tmp;\n\t\t}\n\t}\n\n\tstd::sort(days, days + m);\n\n\twork();\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-message","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c2j00eqc2xln0f47hrk"},{"title":"SCOI2015 - ","date":"2016-03-22T09:56:34.000Z","_content":"\n $ N * M $$ N \\leq M $ $ A $ $ N $ $ N $  $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 4443](http://www.lydsy.com/JudgeOnline/problem.php?id=4443)\n\n### \n $ K $  $ N - K + 1 $\n\n $ K $  $ K $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 250;\nconst int MAXM = 250;\nconst int MAXK = 250;\nconst int CACHE_FIX = 3;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, k, a[MAXN + CACHE_FIX][MAXM], max;\n\nvoid cleanUp() {\n\tfor (int i = 0; i < n + m + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n\nbool check(int limit) {\n\tcleanUp();\n\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1);\n\tfor (int j = 1; j <= m; j++) addEdge(n + j, t, 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (a[i - 1][j - 1] <= limit) addEdge(i, n + j, 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\t// printf(\"%d\\n\", maxFlow);\n\treturn maxFlow >= n - k + 1;\n}\n\ninline int solve() {\n\tstatic int tmp[MAXN * MAXM];\n\tfor (int i = 0, c = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\ttmp[c++] = a[i][j];\n\t\t}\n\t}\n\tstd::sort(tmp, tmp + n * m);\n\n\tint *l = tmp, *r = std::unique(tmp, tmp + n * m) - 1;\n\twhile (l < r) {\n\t\tint *const mid = l + ((r - l) >> 1);\n\t\tif (check(*mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn *l;\n}\n\nint main() {\n\t// freopen(\"matrix.in\", \"r\", stdin);\n\t// freopen(\"matrix.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-matrix.md","raw":"title: SCOI2015 - \ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - \n  - \n  - \n  - Dinic\npermalink: scoi2015-matrix\ndate: 2016-03-22 17:56:34\n---\n\n $ N * M $$ N \\leq M $ $ A $ $ N $ $ N $  $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 4443](http://www.lydsy.com/JudgeOnline/problem.php?id=4443)\n\n### \n $ K $  $ N - K + 1 $\n\n $ K $  $ K $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 250;\nconst int MAXM = 250;\nconst int MAXK = 250;\nconst int CACHE_FIX = 3;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, k, a[MAXN + CACHE_FIX][MAXM], max;\n\nvoid cleanUp() {\n\tfor (int i = 0; i < n + m + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n}\n\nbool check(int limit) {\n\tcleanUp();\n\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1);\n\tfor (int j = 1; j <= m; j++) addEdge(n + j, t, 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (a[i - 1][j - 1] <= limit) addEdge(i, n + j, 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\t// printf(\"%d\\n\", maxFlow);\n\treturn maxFlow >= n - k + 1;\n}\n\ninline int solve() {\n\tstatic int tmp[MAXN * MAXM];\n\tfor (int i = 0, c = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\ttmp[c++] = a[i][j];\n\t\t}\n\t}\n\tstd::sort(tmp, tmp + n * m);\n\n\tint *l = tmp, *r = std::unique(tmp, tmp + n * m) - 1;\n\twhile (l < r) {\n\t\tint *const mid = l + ((r - l) >> 1);\n\t\tif (check(*mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn *l;\n}\n\nint main() {\n\t// freopen(\"matrix.in\", \"r\", stdin);\n\t// freopen(\"matrix.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-matrix","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c2o00ezc2xlkuv05dqx"},{"title":"SCOI2015 -  DP","date":"2016-03-23T15:16:05.000Z","_content":"\n $ n $  $ A_i $ $ B_i $ $ 1 $  $ 1 $  $ V $  $ U $  $ V $  $ D_{u, v} $ $ A_v $\n\n<!-- more -->\n\n### \n[BZOJ 4446](http://www.lydsy.com/JudgeOnline/problem.php?id=4446)\n\n### \n $ f_{x, i} $  $ x $  $ i $ \n\n\n $ x $ \n\n$$ f_{x, i} = {\\rm dist}(x, y) $$\n\n $ x $ \n\n$$ f_{x, i} = f_{ {\\rm lchild}[x], i} * {\\rm dist}(x, { {\\rm lchild}[x]}) $$\n\n $ x $ \n\n DP$ g_{x, i} $  $ x $  $ i $ \n\n $ x $ \n\n$$ g_{x, i} = {\\rm dist}(x, y) $$\n\n $ x $ \n\n$$ g_{x, i} = g_{ {\\rm lchild}[x], i} * {\\rm dist}(x, { {\\rm lchild}[x]}) $$\n\n $ x $ \n\n\n$ i = 0 $  $ {\\rm dist} $  $ 0 $  $ 0 $\n\n $ g_{1, 0} $\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXLOGN = 18;\n\nint n, l[MAXN + 1];\nlong long a[MAXN + 1], b[MAXN + 1], d[MAXN + 1], f[MAXN + 1][MAXLOGN + 1], g[MAXN + 1][MAXLOGN + 1];\n\ninline void dp() {\n\tfor (int x = n; x; x--) {\n\t\tfor (int i = l[x] - 1; i >= 0; i--) {\n\t\t\tint lchild = x << 1, rchild = lchild + 1, target = x >> (l[x] - i - 1) ^ 1;\n\t\t\tif (lchild > n) {\n\t\t\t\tf[x][i] = a[target] * (d[x] + d[target] - (d[target >> 1] << 1));\n\t\t\t} else if (rchild > n) {\n\t\t\t\tf[x][i] = f[lchild][i] + a[lchild] * b[lchild];\n\t\t\t} else {\n\t\t\t\tf[x][i] = std::min(\n\t\t\t\t\ta[lchild] * b[lchild] + f[lchild][l[x]] + f[rchild][i],\n\t\t\t\t\ta[rchild] * b[rchild] + f[rchild][l[x]] + f[lchild][i]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int x = n; x; x--) {\n\t\tfor (int i = l[x]; i >= 0; i--) {\n\t\t\tint lchild = x << 1, rchild = lchild + 1, target = x >> (l[x] - i);\n\t\t\tif (lchild > n) {\n\t\t\t\tg[x][i] = a[target] * (d[x] - d[target]);\n\t\t\t} else if (rchild > n) {\n\t\t\t\tg[x][i] = g[lchild][i] + a[lchild] * b[lchild];\n\t\t\t} else {\n\t\t\t\tg[x][i] = std::min(\n\t\t\t\t\ta[lchild] * b[lchild] + f[lchild][l[x]] + g[rchild][i],\n\t\t\t\t\ta[rchild] * b[rchild] + f[rchild][l[x]] + g[lchild][i]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long calc(int x) {\n\tlong long result = g[x][l[x] - 1];\n\tfor (; x != 1; x >>= 1) {\n\t\tint brother = x ^ 1, parent = x >> 1;\n\t\tif (brother > n) {\n\t\t\tresult += a[parent >> 1] * b[parent];\n\t\t} else {\n\t\t\tresult += a[brother] * b[brother] + g[brother][l[parent] - 1];\n\t\t}\n\t}\n\n\treturn result;\n}\n\ninline long long solve() {\n\tlong long ans = g[1][0];\n\tfor (int i = 2; i <= n; i++) ans = std::min(ans, calc(i));\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"light.in\", \"r\", stdin);\n\t// freopen(\"light.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &a[i]);\n\t}\n\n\tfor (int i = 2; i <= n; i++) {\n\t\tscanf(\"%lld\", &b[i]);\n\t}\n\n\tl[1] = 1, d[1] = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tl[i] = l[i >> 1] + 1;\n\t\td[i] = d[i >> 1] + b[i];\n\t}\n\n\tdp();\n\tprintf(\"%lld\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-light.md","raw":"title: SCOI2015 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - DP\n  -  DP\npermalink: scoi2015-light\ndate: 2016-03-23 23:16:05\n---\n\n $ n $  $ A_i $ $ B_i $ $ 1 $  $ 1 $  $ V $  $ U $  $ V $  $ D_{u, v} $ $ A_v $\n\n<!-- more -->\n\n### \n[BZOJ 4446](http://www.lydsy.com/JudgeOnline/problem.php?id=4446)\n\n### \n $ f_{x, i} $  $ x $  $ i $ \n\n\n $ x $ \n\n$$ f_{x, i} = {\\rm dist}(x, y) $$\n\n $ x $ \n\n$$ f_{x, i} = f_{ {\\rm lchild}[x], i} * {\\rm dist}(x, { {\\rm lchild}[x]}) $$\n\n $ x $ \n\n DP$ g_{x, i} $  $ x $  $ i $ \n\n $ x $ \n\n$$ g_{x, i} = {\\rm dist}(x, y) $$\n\n $ x $ \n\n$$ g_{x, i} = g_{ {\\rm lchild}[x], i} * {\\rm dist}(x, { {\\rm lchild}[x]}) $$\n\n $ x $ \n\n\n$ i = 0 $  $ {\\rm dist} $  $ 0 $  $ 0 $\n\n $ g_{1, 0} $\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXLOGN = 18;\n\nint n, l[MAXN + 1];\nlong long a[MAXN + 1], b[MAXN + 1], d[MAXN + 1], f[MAXN + 1][MAXLOGN + 1], g[MAXN + 1][MAXLOGN + 1];\n\ninline void dp() {\n\tfor (int x = n; x; x--) {\n\t\tfor (int i = l[x] - 1; i >= 0; i--) {\n\t\t\tint lchild = x << 1, rchild = lchild + 1, target = x >> (l[x] - i - 1) ^ 1;\n\t\t\tif (lchild > n) {\n\t\t\t\tf[x][i] = a[target] * (d[x] + d[target] - (d[target >> 1] << 1));\n\t\t\t} else if (rchild > n) {\n\t\t\t\tf[x][i] = f[lchild][i] + a[lchild] * b[lchild];\n\t\t\t} else {\n\t\t\t\tf[x][i] = std::min(\n\t\t\t\t\ta[lchild] * b[lchild] + f[lchild][l[x]] + f[rchild][i],\n\t\t\t\t\ta[rchild] * b[rchild] + f[rchild][l[x]] + f[lchild][i]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int x = n; x; x--) {\n\t\tfor (int i = l[x]; i >= 0; i--) {\n\t\t\tint lchild = x << 1, rchild = lchild + 1, target = x >> (l[x] - i);\n\t\t\tif (lchild > n) {\n\t\t\t\tg[x][i] = a[target] * (d[x] - d[target]);\n\t\t\t} else if (rchild > n) {\n\t\t\t\tg[x][i] = g[lchild][i] + a[lchild] * b[lchild];\n\t\t\t} else {\n\t\t\t\tg[x][i] = std::min(\n\t\t\t\t\ta[lchild] * b[lchild] + f[lchild][l[x]] + g[rchild][i],\n\t\t\t\t\ta[rchild] * b[rchild] + f[rchild][l[x]] + g[lchild][i]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long calc(int x) {\n\tlong long result = g[x][l[x] - 1];\n\tfor (; x != 1; x >>= 1) {\n\t\tint brother = x ^ 1, parent = x >> 1;\n\t\tif (brother > n) {\n\t\t\tresult += a[parent >> 1] * b[parent];\n\t\t} else {\n\t\t\tresult += a[brother] * b[brother] + g[brother][l[parent] - 1];\n\t\t}\n\t}\n\n\treturn result;\n}\n\ninline long long solve() {\n\tlong long ans = g[1][0];\n\tfor (int i = 2; i <= n; i++) ans = std::min(ans, calc(i));\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"light.in\", \"r\", stdin);\n\t// freopen(\"light.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &a[i]);\n\t}\n\n\tfor (int i = 2; i <= n; i++) {\n\t\tscanf(\"%lld\", &b[i]);\n\t}\n\n\tl[1] = 1, d[1] = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tl[i] = l[i >> 1] + 1;\n\t\td[i] = d[i >> 1] + b[i];\n\t}\n\n\tdp();\n\tprintf(\"%lld\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-light","published":1,"updated":"2016-10-24T23:31:27.454Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c2x00f9c2xl6rd90nt6"},{"title":"SCOI2015 -  + ","date":"2016-03-22T10:25:14.000Z","_content":"\nA  $ M $  $ 1 $  $ M $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 4444](http://www.lydsy.com/JudgeOnline/problem.php?id=4444)\n\n### \n\n\n\n\n40  $ O(n ^ 2) $\n\n70  $ O(n \\log n) $ `std::upper_bound` -1 \n\n100  $ O(n \\log n) $  $ next_{i, j} $  $ i $  $ 2 ^ j $  $ O(\\log n) $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXLOGN = 18;\n\nstruct Fighter {\n\tint id, l, r, ans;\n\tFighter *next[MAXLOGN + 1];\n} fighters[MAXN * 2];\n\nint n, m, ans[MAXN];\n\nbool operator<(const Fighter &a, const Fighter &b) {\n\treturn a.l < b.l;\n}\n\nbool operator<(int r, const Fighter &a) {\n\treturn r < a.l;\n}\n\nint main() {\n\tfreopen(\"flag.in\", \"r\", stdin);\n\t// freopen(\"flag.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.id = i;\n\t\tscanf(\"%d %d\", &a.l, &a.r);\n\t\tif (a.l > a.r) a.r += m;\n\t\tfighters[i + n].l = a.l + m, fighters[i + n].r = a.r + m;\n\t}\n\n\tstd::sort(fighters, fighters + n * 2);\n\n\tfor (int i = 0; i < n * 2; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.next[0] = std::upper_bound(fighters, fighters + n * 2, a.r) - 1;\n\t}\n\n\tfor (int j = 1; (1 << j) <= n * 2; j++) {\n\t\tfor (int i = 0; i < n * 2; i++) {\n\t\t\tFighter &a = fighters[i];\n\t\t\tif (a.next[j - 1]) {\n\t\t\t\ta.next[j] = a.next[j - 1]->next[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter *p = &fighters[i];\n\t\tfor (int j = MAXLOGN; j >= 0; j--) {\n\t\t\tif (p->next[j] && p->next[j]->r < fighters[i].l + m) {\n\t\t\t\tans[fighters[i].id] += (1 << j);\n\t\t\t\tp = p->next[j];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", ans[i] + 2);\n\t}\n\tputchar('\\n');\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2015-flag.md","raw":"title: SCOI2015 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - \n  - \npermalink: scoi2015-flag\ndate: 2016-03-22 18:25:14\n---\n\nA  $ M $  $ 1 $  $ M $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 4444](http://www.lydsy.com/JudgeOnline/problem.php?id=4444)\n\n### \n\n\n\n\n40  $ O(n ^ 2) $\n\n70  $ O(n \\log n) $ `std::upper_bound` -1 \n\n100  $ O(n \\log n) $  $ next_{i, j} $  $ i $  $ 2 ^ j $  $ O(\\log n) $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 200000;\nconst int MAXLOGN = 18;\n\nstruct Fighter {\n\tint id, l, r, ans;\n\tFighter *next[MAXLOGN + 1];\n} fighters[MAXN * 2];\n\nint n, m, ans[MAXN];\n\nbool operator<(const Fighter &a, const Fighter &b) {\n\treturn a.l < b.l;\n}\n\nbool operator<(int r, const Fighter &a) {\n\treturn r < a.l;\n}\n\nint main() {\n\tfreopen(\"flag.in\", \"r\", stdin);\n\t// freopen(\"flag.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.id = i;\n\t\tscanf(\"%d %d\", &a.l, &a.r);\n\t\tif (a.l > a.r) a.r += m;\n\t\tfighters[i + n].l = a.l + m, fighters[i + n].r = a.r + m;\n\t}\n\n\tstd::sort(fighters, fighters + n * 2);\n\n\tfor (int i = 0; i < n * 2; i++) {\n\t\tFighter &a = fighters[i];\n\t\ta.next[0] = std::upper_bound(fighters, fighters + n * 2, a.r) - 1;\n\t}\n\n\tfor (int j = 1; (1 << j) <= n * 2; j++) {\n\t\tfor (int i = 0; i < n * 2; i++) {\n\t\t\tFighter &a = fighters[i];\n\t\t\tif (a.next[j - 1]) {\n\t\t\t\ta.next[j] = a.next[j - 1]->next[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tFighter *p = &fighters[i];\n\t\tfor (int j = MAXLOGN; j >= 0; j--) {\n\t\t\tif (p->next[j] && p->next[j]->r < fighters[i].l + m) {\n\t\t\t\tans[fighters[i].id] += (1 << j);\n\t\t\t\tp = p->next[j];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", ans[i] + 2);\n\t}\n\tputchar('\\n');\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"scoi2015-flag","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c3200fhc2xlie3l1pnf"},{"title":"SCOI2012 - AC ","date":"2016-09-29T13:26:00.000Z","_content":"\n $ N $  $ M $ \n\n $ M $ \n\n<!-- more -->\n\n### \n[BZOJ 2754](http://www.lydsy.com/JudgeOnline/problem.php?id=2754)\n\n### \n AC \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 50000;\nconst int MAXLEN = 100000;\n\nstruct Trie {\n\tstruct Node {\n\t\tstd::map<int, Node *> c;\n\t\tNode *fail, *next;\n\t\tint wordCnt, ts, ans;\n\n\t\tNode(const int wordCnt = 0) : fail(NULL), next(NULL), wordCnt(wordCnt), ts(0), ans(0) {}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"insert: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tNode **v = &root;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(1);\n\t\telse /*assert((*v)->isWord == false), */(*v)->wordCnt++;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (std::map<int, Node *>::iterator it = v->c.begin(); it != v->c.end(); it++) {\n\t\t\t\tNode *&c = it->second, *u = v->fail;\n\t\t\t\twhile (u != root && u->c.find(it->first) == u->c.end()) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c.find(it->first) != u->c.end() ? u->c[it->first] : root;\n\t\t\t\tc->next = c->fail->wordCnt ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tint exec(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"exec: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tstatic int ts = 0;\n\t\t++ts;\n\t\tNode *v = root;\n\t\tint ans = 0;\n\t\tstatic int sumAns = 0;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\twhile (v != root && v->c.find(*p) == v->c.end()) v = v->fail;\n\t\t\tstd::map<int, Node *>::iterator it;\n\t\t\tif ((it = v->c.find(*p)) != v->c.end()) v = it->second;\n\t\t\t// if (it != v->c.end()) v = it->second;\n\t\t\tNode *u = v->wordCnt ? v : v->next;\n\t\t\twhile (u) {\n#ifdef DBG\n\t\t\t\tprintf(\"apply(%lu)\\n\", u);\n#endif\n\t\t\t\tif (u->ts != ts) {\n\t\t\t\t\tu->ts = ts;\n\t\t\t\t\tu->ans++;\n\t\t\t\t\tans += u->wordCnt;\n\t\t\t\t\tsumAns++;\n\t\t\t\t\t// printf(\"- %d %d\\n\", u->ans, ans);\n\t\t\t\t\tu = u->next;\n\t\t\t\t} else break;\n\t\t\t}\n\t\t}\n\t\t// printf(\"sumAns = %d\\n\", sumAns);\n\t\treturn ans;\n\t}\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int buf[MAXN * 2 + MAXLEN], set[MAXLEN];\n\tint cnt = 0;\n\tfor (int i = 0, tot = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n#ifdef DBG\n\t\t\tprintf(\"--- %d ---\\n\", l);\n#endif\n\t\t\tbuf[tot++] = l;\n\t\t\tfor (int k = 0; k < l; k++) {\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tbuf[tot++] = set[cnt++] = x;\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(set, set + cnt);\n\tint *end = std::unique(set, set + cnt);\n\n\tstatic Trie::Node *a[MAXM];\n\tfor (int i = 0; i < m; i++) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\t\tstatic int buf[MAXLEN];\n\t\tbool invalid = false;\n\t\tfor (int j = 0; j < l; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\t/*\n\t\t\tif (i == 1354 - 1) {\n\t\t\t\tprintf(\"(%d)\\n\", x);\n\t\t\t}\n\t\t\t*/\n\t\t\tint *p = std::lower_bound(set, end, x);\n\t\t\tif (p == end || *p != x) {\n\t\t\t\tinvalid = true;\n\t\t\t}\n\t\t\tbuf[j] = p - set;\n\t\t}\n\t\tif (!invalid) a[i] = t.insert(buf, buf + l);\n\t\telse a[i] = NULL;\n\t\t/*\n\t\tif (i == 1354 - 1) {\n\t\t\tprintf(\"1354: \");\n\t\t\tfor (int i = 0; i < l; i++) printf(\"%d%c\", buf[i], i == l - 1 ? '\\n' : ' ');\n\t\t}\n\t\t*/\n\t}\n\n\tt.build();\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0, pos = 0; i < n; i++) {\n\t\tstatic int buf2[MAXLEN + 1];\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (j == 1) buf2[cnt++] = -1;\n\t\t\tint l = buf[pos++];\n\t\t\t// printf(\"- \");\n\t\t\tfor (int k = 0; k < l; k++) buf2[cnt++] = std::lower_bound(set, end, buf[pos++]) - set; // , printf(\"%d \", buf2[cnt - 1]);\n\t\t\t// putchar('\\n');\n\t\t}\n\t\tans[i] = t.exec(buf2, buf2 + cnt);\n\t}\n\n\tint sum1 = 0, sum2 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tsum1 += a[i] ? a[i]->ans : 0;\n\t\t// if (i == 1354 - 1) putchar('*');\n\t\tprintf(\"%d\\n\", a[i] ? a[i]->ans : 0);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsum2 += ans[i];\n\t\tprintf(\"%d%c\", ans[i], i == n - 1 ? '\\n' : ' ');\n\t}\n\n\t// printf(\"%d %d\\n\", sum1, sum2);\n\n\treturn 0;\n}\n```","source":"_posts/scoi2012-name.md","raw":"title: SCOI2012 - AC \ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - AC \npermalink: scoi2012-name\ndate: 2016-09-29 21:26:00\n---\n\n $ N $  $ M $ \n\n $ M $ \n\n<!-- more -->\n\n### \n[BZOJ 2754](http://www.lydsy.com/JudgeOnline/problem.php?id=2754)\n\n### \n AC \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 50000;\nconst int MAXLEN = 100000;\n\nstruct Trie {\n\tstruct Node {\n\t\tstd::map<int, Node *> c;\n\t\tNode *fail, *next;\n\t\tint wordCnt, ts, ans;\n\n\t\tNode(const int wordCnt = 0) : fail(NULL), next(NULL), wordCnt(wordCnt), ts(0), ans(0) {}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"insert: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tNode **v = &root;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(1);\n\t\telse /*assert((*v)->isWord == false), */(*v)->wordCnt++;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (std::map<int, Node *>::iterator it = v->c.begin(); it != v->c.end(); it++) {\n\t\t\t\tNode *&c = it->second, *u = v->fail;\n\t\t\t\twhile (u != root && u->c.find(it->first) == u->c.end()) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c.find(it->first) != u->c.end() ? u->c[it->first] : root;\n\t\t\t\tc->next = c->fail->wordCnt ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tint exec(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"exec: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tstatic int ts = 0;\n\t\t++ts;\n\t\tNode *v = root;\n\t\tint ans = 0;\n\t\tstatic int sumAns = 0;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\twhile (v != root && v->c.find(*p) == v->c.end()) v = v->fail;\n\t\t\tstd::map<int, Node *>::iterator it;\n\t\t\tif ((it = v->c.find(*p)) != v->c.end()) v = it->second;\n\t\t\t// if (it != v->c.end()) v = it->second;\n\t\t\tNode *u = v->wordCnt ? v : v->next;\n\t\t\twhile (u) {\n#ifdef DBG\n\t\t\t\tprintf(\"apply(%lu)\\n\", u);\n#endif\n\t\t\t\tif (u->ts != ts) {\n\t\t\t\t\tu->ts = ts;\n\t\t\t\t\tu->ans++;\n\t\t\t\t\tans += u->wordCnt;\n\t\t\t\t\tsumAns++;\n\t\t\t\t\t// printf(\"- %d %d\\n\", u->ans, ans);\n\t\t\t\t\tu = u->next;\n\t\t\t\t} else break;\n\t\t\t}\n\t\t}\n\t\t// printf(\"sumAns = %d\\n\", sumAns);\n\t\treturn ans;\n\t}\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int buf[MAXN * 2 + MAXLEN], set[MAXLEN];\n\tint cnt = 0;\n\tfor (int i = 0, tot = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n#ifdef DBG\n\t\t\tprintf(\"--- %d ---\\n\", l);\n#endif\n\t\t\tbuf[tot++] = l;\n\t\t\tfor (int k = 0; k < l; k++) {\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tbuf[tot++] = set[cnt++] = x;\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(set, set + cnt);\n\tint *end = std::unique(set, set + cnt);\n\n\tstatic Trie::Node *a[MAXM];\n\tfor (int i = 0; i < m; i++) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\t\tstatic int buf[MAXLEN];\n\t\tbool invalid = false;\n\t\tfor (int j = 0; j < l; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\t/*\n\t\t\tif (i == 1354 - 1) {\n\t\t\t\tprintf(\"(%d)\\n\", x);\n\t\t\t}\n\t\t\t*/\n\t\t\tint *p = std::lower_bound(set, end, x);\n\t\t\tif (p == end || *p != x) {\n\t\t\t\tinvalid = true;\n\t\t\t}\n\t\t\tbuf[j] = p - set;\n\t\t}\n\t\tif (!invalid) a[i] = t.insert(buf, buf + l);\n\t\telse a[i] = NULL;\n\t\t/*\n\t\tif (i == 1354 - 1) {\n\t\t\tprintf(\"1354: \");\n\t\t\tfor (int i = 0; i < l; i++) printf(\"%d%c\", buf[i], i == l - 1 ? '\\n' : ' ');\n\t\t}\n\t\t*/\n\t}\n\n\tt.build();\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0, pos = 0; i < n; i++) {\n\t\tstatic int buf2[MAXLEN + 1];\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (j == 1) buf2[cnt++] = -1;\n\t\t\tint l = buf[pos++];\n\t\t\t// printf(\"- \");\n\t\t\tfor (int k = 0; k < l; k++) buf2[cnt++] = std::lower_bound(set, end, buf[pos++]) - set; // , printf(\"%d \", buf2[cnt - 1]);\n\t\t\t// putchar('\\n');\n\t\t}\n\t\tans[i] = t.exec(buf2, buf2 + cnt);\n\t}\n\n\tint sum1 = 0, sum2 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tsum1 += a[i] ? a[i]->ans : 0;\n\t\t// if (i == 1354 - 1) putchar('*');\n\t\tprintf(\"%d\\n\", a[i] ? a[i]->ans : 0);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsum2 += ans[i];\n\t\tprintf(\"%d%c\", ans[i], i == n - 1 ? '\\n' : ' ');\n\t}\n\n\t// printf(\"%d %d\\n\", sum1, sum2);\n\n\treturn 0;\n}\n```","slug":"scoi2012-name","published":1,"updated":"2016-09-29T13:28:38.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c3700fpc2xllyop1drz"},{"title":"SCOI2011 -  + ","date":"2016-03-04T13:32:23.000Z","_content":"\n $ N $  $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 2330](http://www.lydsy.com/JudgeOnline/problem.php?id=2330)\n\n### \n\n\n Tarjan  Tarjan\n\n 0 1 1\n\n `long long`\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, inDegree, dist;\n\tbool visited, pushed, inStack;\n\tConnected *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} sccs[MAXN];\n\nstruct Condition {\n\tint x, u, v;\n} conditions[MAXK];\n\nint n, k;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\te->from->scc->v.firstEdge = new Edge(&e->from->scc->v, &e->to->scc->v, e->w);\n\t\t\t\te->to->scc->v.inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long topoSort(int count) {\n\tstd::queue<Node *> q;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.inDegree == 0) {\n\t\t\tsccs[i].v.dist = 1;\n\t\t\tq.push(&sccs[i].v);\n\t\t}\n\t}\n\n\tint x = count;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tx--;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist == 0 || e->to->dist < v->dist + e->w) e->to->dist = v->dist + e->w;\n\t\t\tif (--e->to->inDegree == 0) {\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x > 0) return -1;\n\telse {\n\t\tlong long ans = 0;\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tans += (long long)sccs[i].size * (long long)sccs[i].v.dist;\n\t\t}\n\n\t\treturn ans;\n\t}\n}\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < k; i++) {\n\t\tscanf(\"%d %d %d\", &conditions[i].x, &conditions[i].u, &conditions[i].v);\n\t\tconditions[i].u--, conditions[i].v--;\n\n\t\tif (conditions[i].x == 4) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 2;\n\t\t} else if (conditions[i].x == 3) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 5;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 1) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t\taddEdge(conditions[i].v, conditions[i].u, 0);\n\t\t} else if (conditions[i].x == 5) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t}\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 2) {\n\t\t\tNode *u = &nodes[conditions[i].u].scc->v, *v = &nodes[conditions[i].v].scc->v;\n\t\t\tu->firstEdge = new Edge(u, v, 1);\n\t\t\tv->inDegree++;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", topoSort(count));\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2011-candy.md","raw":"title: SCOI2011 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - Tarjan\n  - \n  - \n  - \npermalink: scoi2011-candy\ndate: 2016-03-04 21:32:23\n---\n\n $ N $  $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 2330](http://www.lydsy.com/JudgeOnline/problem.php?id=2330)\n\n### \n\n\n Tarjan  Tarjan\n\n 0 1 1\n\n `long long`\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, inDegree, dist;\n\tbool visited, pushed, inStack;\n\tConnected *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} sccs[MAXN];\n\nstruct Condition {\n\tint x, u, v;\n} conditions[MAXK];\n\nint n, k;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\te->from->scc->v.firstEdge = new Edge(&e->from->scc->v, &e->to->scc->v, e->w);\n\t\t\t\te->to->scc->v.inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long topoSort(int count) {\n\tstd::queue<Node *> q;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.inDegree == 0) {\n\t\t\tsccs[i].v.dist = 1;\n\t\t\tq.push(&sccs[i].v);\n\t\t}\n\t}\n\n\tint x = count;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tx--;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist == 0 || e->to->dist < v->dist + e->w) e->to->dist = v->dist + e->w;\n\t\t\tif (--e->to->inDegree == 0) {\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x > 0) return -1;\n\telse {\n\t\tlong long ans = 0;\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tans += (long long)sccs[i].size * (long long)sccs[i].v.dist;\n\t\t}\n\n\t\treturn ans;\n\t}\n}\n\ninline void addEdge(int from, int to, int w) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < k; i++) {\n\t\tscanf(\"%d %d %d\", &conditions[i].x, &conditions[i].u, &conditions[i].v);\n\t\tconditions[i].u--, conditions[i].v--;\n\n\t\tif (conditions[i].x == 4) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 2;\n\t\t} else if (conditions[i].x == 3) {\n\t\t\tstd::swap(conditions[i].u, conditions[i].v);\n\t\t\tconditions[i].x = 5;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 1) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t\taddEdge(conditions[i].v, conditions[i].u, 0);\n\t\t} else if (conditions[i].x == 5) {\n\t\t\taddEdge(conditions[i].u, conditions[i].v, 0);\n\t\t}\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tfor (int i = 0; i < k; i++) {\n\t\tif (conditions[i].x == 2) {\n\t\t\tNode *u = &nodes[conditions[i].u].scc->v, *v = &nodes[conditions[i].v].scc->v;\n\t\t\tu->firstEdge = new Edge(u, v, 1);\n\t\t\tv->inDegree++;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", topoSort(count));\n\n\treturn 0;\n}\n```\n","slug":"scoi2011-candy","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c3c00fvc2xleuwccy1p"},{"title":"SCOI2010 - ","date":"2016-03-07T01:43:18.000Z","_content":"\n $ [1, 10000] $   BOSS  $ 1 $  BOSS  $ 1 $  BOSS $ 2 $  BOSS $ 3 $  BOSS   BOSS \n\n<!-- more -->\n\n### \n[BZOJ 1854](http://www.lydsy.com/JudgeOnline/problem.php?id=1854)\n\n### \n $ N  1000000 $ $ O(n) $  $ O(n) $  \n\n\n\n\n\n $ 1 $  $ 1 $  $ X $  $ \\{X, Y\\} $  $ X $ $ Y $ $ Y < X $\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 1000000;\nconst int MAXX = 10000;\n\nstruct Gun {\n\tint x[2];\n\tint selected;\n\n\tGun() : selected(-1) {}\n\n\tvoid select(int x) {\n\t\tif (this->x[0] == x) selected = 0;\n\t\telse selected = 1;\n\t}\n} guns[MAXN];\n\nint n;\nstd::vector<int> gunID[MAXX];\n\ninline bool check(int x, int ignore = -1) {\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tGun &g = guns[*p];\n\t\tif (g.selected == -1) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tif (*p == ignore) continue;\n\n\t\tGun &g = guns[*p];\n\t\tif (check(g.x[g.selected ^ 1], *p)) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tGun &g = guns[i];\n\n\t\tscanf(\"%d %d\", &g.x[0], &g.x[1]), g.x[0]--, g.x[1]--;\n\n\t\tgunID[g.x[0]].push_back(i);\n\t\tgunID[g.x[1]].push_back(i);\n\t}\n\n\tint i;\n\tfor (i = 0; i < MAXX; i++) {\n\t\tif (!check(i)) break;\n\t}\n\n\tprintf(\"%d\\n\", i);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2010-game.md","raw":"title: SCOI2010 - \ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - \n  - \n  - \npermalink: scoi2010-game\ndate: 2016-03-07 09:43:18\n---\n\n $ [1, 10000] $   BOSS  $ 1 $  BOSS  $ 1 $  BOSS $ 2 $  BOSS $ 3 $  BOSS   BOSS \n\n<!-- more -->\n\n### \n[BZOJ 1854](http://www.lydsy.com/JudgeOnline/problem.php?id=1854)\n\n### \n $ N  1000000 $ $ O(n) $  $ O(n) $  \n\n\n\n\n\n $ 1 $  $ 1 $  $ X $  $ \\{X, Y\\} $  $ X $ $ Y $ $ Y < X $\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <vector>\n\nconst int MAXN = 1000000;\nconst int MAXX = 10000;\n\nstruct Gun {\n\tint x[2];\n\tint selected;\n\n\tGun() : selected(-1) {}\n\n\tvoid select(int x) {\n\t\tif (this->x[0] == x) selected = 0;\n\t\telse selected = 1;\n\t}\n} guns[MAXN];\n\nint n;\nstd::vector<int> gunID[MAXX];\n\ninline bool check(int x, int ignore = -1) {\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tGun &g = guns[*p];\n\t\tif (g.selected == -1) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tfor (std::vector<int>::const_iterator p = gunID[x].begin(); p != gunID[x].end(); p++) {\n\t\tif (*p == ignore) continue;\n\n\t\tGun &g = guns[*p];\n\t\tif (check(g.x[g.selected ^ 1], *p)) {\n\t\t\tg.select(x);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tGun &g = guns[i];\n\n\t\tscanf(\"%d %d\", &g.x[0], &g.x[1]), g.x[0]--, g.x[1]--;\n\n\t\tgunID[g.x[0]].push_back(i);\n\t\tgunID[g.x[1]].push_back(i);\n\t}\n\n\tint i;\n\tfor (i = 0; i < MAXX; i++) {\n\t\tif (!check(i)) break;\n\t}\n\n\tprintf(\"%d\\n\", i);\n\n\treturn 0;\n}\n```\n","slug":"scoi2010-game","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c3i00g5c2xlx7ymxp67"},{"title":"SCOI2009windy  -  DP","date":"2016-05-12T09:25:00.000Z","_content":"\nwindy  windy  $ 2 $  windy \n\nwindy  $ A $  $ B $  $ A $  $ B $ windy \n\n<!-- more -->\n\n### \n[BZOJ 1026](http://www.lydsy.com/JudgeOnline/problem.php?id=1026)\n\n### \n DP\n\n$$ f[n][last][notZero][limited] $$\n\n $ n $  $ n $  $ last $\n\nPS\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXX = 2000000000;\nconst int MAXN = 10;\nconst int MINGAP = 2;\n\nconst int CHARSET_SIZE = 10;\nconst int FLAG = 2;\n\nint a[MAXN], n;\n\nint mem[MAXN][CHARSET_SIZE][FLAG][FLAG];\nbool calced[MAXN][CHARSET_SIZE][FLAG][FLAG];\n\ninline int dp(const int n, const int last, const bool notZero, const bool limited) {\n    int &ans = mem[n][last][notZero][limited];\n    if (calced[n][last][notZero][limited]) return ans;\n    calced[n][last][notZero][limited] = true;\n    \n    if (n == 0) {\n        ans = 1;\n    } else {\n        int limit;\n        if (limited) limit = a[::n - n];\n        else limit = CHARSET_SIZE - 1;\n        \n        for (int i = 0; i <= limit; i++) {\n            if (notZero && abs(i - last) < MINGAP) continue;\n            ans += dp(n - 1, i, notZero || i != 0, limited && i == limit);\n        }\n    }\n    \n    return ans;\n}\n\ninline int solve(const char *s) {\n    std::fill(a, a + n, 0);\n    int len = strlen(s);\n    for (int i = 0; i < len; i++) a[i] = s[len - i - 1] - '0';\n    std::reverse(a, a + n);\n    \n    // for (int i = 0; i < n; i++) putchar('0' + a[i]);\n    // putchar('\\n');\n    \n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    int ans = 0;\n    for (int i = 0; i <= a[0]; i++) {\n        ans += dp(n - 1, i, i != 0, i == a[0]);\n    }\n    \n    return ans;\n}\n\nint main() {\n    int l, r;\n    scanf(\"%d %d\", &l, &r);\n    \n    char s1[MAXN + 1], s2[MAXN + 1];\n    sprintf(s1, \"%d\", l - 1);\n    sprintf(s2, \"%d\", r);\n    \n    n = strlen(s2);\n    \n    printf(\"%d\\n\", solve(s2) - solve(s1));\n    \n    return 0;\n}\n```\n","source":"_posts/scoi2009-windy.md","raw":"title: SCOI2009windy  -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  -  DP\n  - DP\npermalink: scoi2009-windy\ndate: 2016-05-12 17:25:00\n---\n\nwindy  windy  $ 2 $  windy \n\nwindy  $ A $  $ B $  $ A $  $ B $ windy \n\n<!-- more -->\n\n### \n[BZOJ 1026](http://www.lydsy.com/JudgeOnline/problem.php?id=1026)\n\n### \n DP\n\n$$ f[n][last][notZero][limited] $$\n\n $ n $  $ n $  $ last $\n\nPS\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXX = 2000000000;\nconst int MAXN = 10;\nconst int MINGAP = 2;\n\nconst int CHARSET_SIZE = 10;\nconst int FLAG = 2;\n\nint a[MAXN], n;\n\nint mem[MAXN][CHARSET_SIZE][FLAG][FLAG];\nbool calced[MAXN][CHARSET_SIZE][FLAG][FLAG];\n\ninline int dp(const int n, const int last, const bool notZero, const bool limited) {\n    int &ans = mem[n][last][notZero][limited];\n    if (calced[n][last][notZero][limited]) return ans;\n    calced[n][last][notZero][limited] = true;\n    \n    if (n == 0) {\n        ans = 1;\n    } else {\n        int limit;\n        if (limited) limit = a[::n - n];\n        else limit = CHARSET_SIZE - 1;\n        \n        for (int i = 0; i <= limit; i++) {\n            if (notZero && abs(i - last) < MINGAP) continue;\n            ans += dp(n - 1, i, notZero || i != 0, limited && i == limit);\n        }\n    }\n    \n    return ans;\n}\n\ninline int solve(const char *s) {\n    std::fill(a, a + n, 0);\n    int len = strlen(s);\n    for (int i = 0; i < len; i++) a[i] = s[len - i - 1] - '0';\n    std::reverse(a, a + n);\n    \n    // for (int i = 0; i < n; i++) putchar('0' + a[i]);\n    // putchar('\\n');\n    \n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    int ans = 0;\n    for (int i = 0; i <= a[0]; i++) {\n        ans += dp(n - 1, i, i != 0, i == a[0]);\n    }\n    \n    return ans;\n}\n\nint main() {\n    int l, r;\n    scanf(\"%d %d\", &l, &r);\n    \n    char s1[MAXN + 1], s2[MAXN + 1];\n    sprintf(s1, \"%d\", l - 1);\n    sprintf(s2, \"%d\", r);\n    \n    n = strlen(s2);\n    \n    printf(\"%d\\n\", solve(s2) - solve(s1));\n    \n    return 0;\n}\n```\n","slug":"scoi2009-windy","published":1,"updated":"2016-10-24T23:30:33.902Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c3n00gfc2xlur06igll"},{"title":"SCOI2009 -  DP","date":"2016-07-11T14:59:00.000Z","_content":"\nwindy  $ N $  $ M $   windy  windy  $ T $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1296](http://www.lydsy.com/JudgeOnline/problem.php?id=1296)\n\n### \n $ f(j, k) $  $ j $  $ k $ \n\n $ w(i, j) $  $ i $  $ j $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 50;\nconst int MAXM = 50;\nconst int MAXT = 2500;\n\nint main() {\n\tint n, m, t;\n\tscanf(\"%d %d %d\", &n, &m, &t);\n\n\tstatic int w[MAXN][MAXM + 1], f[MAXM + 1][MAXM + 1];\n\tfor (int i = 0; i < n; i++) {\n\t\tmemset(f, 0, sizeof(f));\n\t\tstatic char s[MAXM + 1];\n\t\tscanf(\"%s\", s);\n\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int k = 1; k <= j; k++) {\n\t\t\t\tint cnt[2] = { 0, 0 };\n\t\t\t\tfor (int l = j - 1; l >= k - 1; l--) {\n\t\t\t\t\tcnt[s[l] - '0']++;\n\t\t\t\t\tf[j][k] = std::max(f[j][k], f[l][k - 1] + std::max(cnt[0], cnt[1]));\n\t\t\t\t\tw[i][k] = std::max(w[i][k], f[j][k]);\n\t\t\t\t}\n\t\t\t\t// printf(\"f[%d][%d][%d] = %d\\n\", i, j, k, f[j][k]);\n\t\t\t}\n\t\t}\n\n\t\t// for (int j = 1; j <= m; j++) printf(\"w[%d][%d] = %d\\n\", i, j, w[i][j]);\n\t}\n\n\tstatic int g[MAXT + 1];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = t; j >= 0; j--) {\n\t\t\tfor (int k = 1; k <= m; k++) {\n\t\t\t\tif (k <= j) g[j] = std::max(g[j], g[j - k] + w[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", g[t]);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2009-paint.md","raw":"title: SCOI2009 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - DP\n  -  DP\npermalink: scoi2009-paint\ndate: 2016-07-11 22:59:00\n---\n\nwindy  $ N $  $ M $   windy  windy  $ T $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1296](http://www.lydsy.com/JudgeOnline/problem.php?id=1296)\n\n### \n $ f(j, k) $  $ j $  $ k $ \n\n $ w(i, j) $  $ i $  $ j $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 50;\nconst int MAXM = 50;\nconst int MAXT = 2500;\n\nint main() {\n\tint n, m, t;\n\tscanf(\"%d %d %d\", &n, &m, &t);\n\n\tstatic int w[MAXN][MAXM + 1], f[MAXM + 1][MAXM + 1];\n\tfor (int i = 0; i < n; i++) {\n\t\tmemset(f, 0, sizeof(f));\n\t\tstatic char s[MAXM + 1];\n\t\tscanf(\"%s\", s);\n\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int k = 1; k <= j; k++) {\n\t\t\t\tint cnt[2] = { 0, 0 };\n\t\t\t\tfor (int l = j - 1; l >= k - 1; l--) {\n\t\t\t\t\tcnt[s[l] - '0']++;\n\t\t\t\t\tf[j][k] = std::max(f[j][k], f[l][k - 1] + std::max(cnt[0], cnt[1]));\n\t\t\t\t\tw[i][k] = std::max(w[i][k], f[j][k]);\n\t\t\t\t}\n\t\t\t\t// printf(\"f[%d][%d][%d] = %d\\n\", i, j, k, f[j][k]);\n\t\t\t}\n\t\t}\n\n\t\t// for (int j = 1; j <= m; j++) printf(\"w[%d][%d] = %d\\n\", i, j, w[i][j]);\n\t}\n\n\tstatic int g[MAXT + 1];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = t; j >= 0; j--) {\n\t\t\tfor (int k = 1; k <= m; k++) {\n\t\t\t\tif (k <= j) g[j] = std::max(g[j], g[j - k] + w[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", g[t]);\n\n\treturn 0;\n}\n```\n","slug":"scoi2009-paint","published":1,"updated":"2016-10-24T23:30:41.406Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c3q00glc2xlxho77mpr"},{"title":"SCOI2009 -  +  DP","date":"2016-11-13T00:24:00.000Z","_content":"\nwindy  $ 1 $  $ N $  $ N $  $ 1 $  $ N $  windy  $ 1, 2, 3, \\ldots, N $  $ 1, 2, 3, \\ldots, N $\n\n$ 1, 2, 3, 4, 5, 6 $ \n\n$$\n\\begin{cases}\n1 \\rightarrow 2 \\\\\n2 \\rightarrow 3 \\\\\n3 \\rightarrow 1 \\\\\n4 \\rightarrow 5 \\\\\n5 \\rightarrow 4 \\\\\n6 \\rightarrow 6\n\\end{cases}\n$$\n\nwindy \n\n$$\n\\begin{gather}\n1, 2, 3, 4, 5, 6 \\\\\n\\downarrow \\\\\n2, 3, 1, 5, 4, 6 \\\\\n\\downarrow \\\\\n3, 1, 2, 4, 5, 6 \\\\\n\\downarrow \\\\\n1, 2, 3, 5, 4, 6 \\\\\n\\downarrow \\\\\n2, 3, 1, 4, 5, 6 \\\\\n\\downarrow \\\\\n3, 1, 2, 5, 4, 6 \\\\\n\\downarrow \\\\\n1, 2, 3, 4, 5, 6\n\\end{gather}\n$$\n\n $ 1 $  $ N $  $ 7 $  windy \n\n<!-- more -->\n\n### \n[BZOJ 1025](http://www.lydsy.com/JudgeOnline/problem.php?id=1025)\n\n### \n\n\n$$ \\{ x_1, x_2, \\ldots, x_m \\} $$\n\n $ x_k $  $ p $ $ \\mathrm{lcm}(x_1, x_2, \\ldots, x_m) $  $ p $  $ x_k $  $ x_i $ \n\n $ x_i $  $ x_i = 1 $ \n\n$$\n\\begin{cases}\nx_1 = p_1 ^ {k_1} \\\\\nx_2 = p_2 ^ {k_2} \\\\\n\\cdots \\\\\nx_m = p_m ^ {k_m}\n\\end{cases}\n$$\n\n$ \\mathrm{lcm}(x_1, x_2, \\ldots, x_m) = x_1 \\times x_2 \\times \\ldots \\times x_m $ $ \\{ x_1. x_2, \\ldots, x_m \\} $  $ x_1 + x_2 + \\ldots + x_m = n $ $ 1 $  $ x_1 + x_2 + \\ldots + x_m \\leq n $ \n\n $ p_i $ $ p_i ^ {k_i} $ $ \\leq n $   $ i $  $ p_i ^ 1, p_i ^ 2, \\ldots p_i ^ {k_i} $$ p_i ^ {k_i} \\leq n $ $ n $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\n\nint primes[MAXN], isNotPrime[MAXN + 1], cnt;\n\ninline void getPrimes() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[++cnt] = i;\n\t\t}\n\t\tfor (int j = 1; j <= cnt && i * primes[j] <= MAXN; j++) {\n\t\t\tisNotPrime[i * primes[j]] = true;\n\t\t\tif (i % primes[j] == 0) break;\n\t\t}\n\t}\n\t// for (int i = 0; i < cnt; i++) printf(\"%d\\n\", primes[i]);\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tgetPrimes();\n\n\tstatic long long f[MAXN + 1][MAXN + 1];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= cnt; i++) {\n\t\tfor (int k = 0; k <= n; k++) f[i][k] = f[i - 1][k];\n\t\tfor (int p = primes[i]; p <= n; p *= primes[i]) {\n\t\t\tfor (int k = p; k <= n; k++) {\n\t\t\t\tf[i][k] += f[i - 1][k - p];\n\t\t\t}\n\t\t}\n\t\t// for (int k = 0; k <= n; k++) printf(\"f[%d][%d] = %d\\n\", i, k, f[i][k]);\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = 0; i <= n; i++) ans += f[cnt][i];\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/scoi2009-game.md","raw":"title: SCOI2009 -  +  DP\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - \n  -  DP\n  - DP\npermalink: scoi2009-game\ndate: 2016-11-13 08:24:00\n---\n\nwindy  $ 1 $  $ N $  $ N $  $ 1 $  $ N $  windy  $ 1, 2, 3, \\ldots, N $  $ 1, 2, 3, \\ldots, N $\n\n$ 1, 2, 3, 4, 5, 6 $ \n\n$$\n\\begin{cases}\n1 \\rightarrow 2 \\\\\n2 \\rightarrow 3 \\\\\n3 \\rightarrow 1 \\\\\n4 \\rightarrow 5 \\\\\n5 \\rightarrow 4 \\\\\n6 \\rightarrow 6\n\\end{cases}\n$$\n\nwindy \n\n$$\n\\begin{gather}\n1, 2, 3, 4, 5, 6 \\\\\n\\downarrow \\\\\n2, 3, 1, 5, 4, 6 \\\\\n\\downarrow \\\\\n3, 1, 2, 4, 5, 6 \\\\\n\\downarrow \\\\\n1, 2, 3, 5, 4, 6 \\\\\n\\downarrow \\\\\n2, 3, 1, 4, 5, 6 \\\\\n\\downarrow \\\\\n3, 1, 2, 5, 4, 6 \\\\\n\\downarrow \\\\\n1, 2, 3, 4, 5, 6\n\\end{gather}\n$$\n\n $ 1 $  $ N $  $ 7 $  windy \n\n<!-- more -->\n\n### \n[BZOJ 1025](http://www.lydsy.com/JudgeOnline/problem.php?id=1025)\n\n### \n\n\n$$ \\{ x_1, x_2, \\ldots, x_m \\} $$\n\n $ x_k $  $ p $ $ \\mathrm{lcm}(x_1, x_2, \\ldots, x_m) $  $ p $  $ x_k $  $ x_i $ \n\n $ x_i $  $ x_i = 1 $ \n\n$$\n\\begin{cases}\nx_1 = p_1 ^ {k_1} \\\\\nx_2 = p_2 ^ {k_2} \\\\\n\\cdots \\\\\nx_m = p_m ^ {k_m}\n\\end{cases}\n$$\n\n$ \\mathrm{lcm}(x_1, x_2, \\ldots, x_m) = x_1 \\times x_2 \\times \\ldots \\times x_m $ $ \\{ x_1. x_2, \\ldots, x_m \\} $  $ x_1 + x_2 + \\ldots + x_m = n $ $ 1 $  $ x_1 + x_2 + \\ldots + x_m \\leq n $ \n\n $ p_i $ $ p_i ^ {k_i} $ $ \\leq n $   $ i $  $ p_i ^ 1, p_i ^ 2, \\ldots p_i ^ {k_i} $$ p_i ^ {k_i} \\leq n $ $ n $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\n\nint primes[MAXN], isNotPrime[MAXN + 1], cnt;\n\ninline void getPrimes() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[++cnt] = i;\n\t\t}\n\t\tfor (int j = 1; j <= cnt && i * primes[j] <= MAXN; j++) {\n\t\t\tisNotPrime[i * primes[j]] = true;\n\t\t\tif (i % primes[j] == 0) break;\n\t\t}\n\t}\n\t// for (int i = 0; i < cnt; i++) printf(\"%d\\n\", primes[i]);\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tgetPrimes();\n\n\tstatic long long f[MAXN + 1][MAXN + 1];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= cnt; i++) {\n\t\tfor (int k = 0; k <= n; k++) f[i][k] = f[i - 1][k];\n\t\tfor (int p = primes[i]; p <= n; p *= primes[i]) {\n\t\t\tfor (int k = p; k <= n; k++) {\n\t\t\t\tf[i][k] += f[i - 1][k - p];\n\t\t\t}\n\t\t}\n\t\t// for (int k = 0; k <= n; k++) printf(\"f[%d][%d] = %d\\n\", i, k, f[i][k]);\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = 0; i <= n; i++) ans += f[cnt][i];\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"scoi2009-game","published":1,"updated":"2016-11-13T00:47:58.148Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c3t00grc2xljphzz9oq"},{"title":"SCOI2009 - ","date":"2016-11-12T13:17:00.000Z","_content":"\nwindy  $ X $  $ Y $  windy $ N $ windy  $ N $ windy  $ N - 1 $  $ N $  windy \n\n<!-- more -->\n\n### \n[BZOJ 1024](http://www.lydsy.com/JudgeOnline/problem.php?id=1024)\n\n### \n**** $ k \\over n $ $ k $ \n\nDFS \n\n### \n```c++\n#include <cstdio>\n#include <cfloat>\n#include <algorithm>\n\nconst int MAXN = 10;\n\ndouble dfs(const int n, const double x, const double y) {\n\tif (n == 1) {\n\t\treturn std::max(x, y) / std::min(x, y);\n\t}\n\n\tdouble res1 = DBL_MAX;\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\tres1 = std::min(res1, std::max(dfs(i, i * x / n, y), dfs(n - i, (n - i) * x / n, y)));\n\t}\n\n\tdouble res2 = DBL_MAX;\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\tres2 = std::min(res2, std::max(dfs(i, x, i * y / n), dfs(n - i, x, (n - i) * y / n)));\n\t}\n\n\treturn std::min(res1, res2);\n}\n\nint main() {\n\tint x, y, n;\n\tscanf(\"%d %d %d\", &x, &y, &n);\n\tprintf(\"%.6lf\\n\", dfs(n, x, y));\n\treturn 0;\n}\n```","source":"_posts/scoi2009-cake.md","raw":"title: SCOI2009 - \ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - DFS\npermalink: scoi2009-cake\ndate: 2016-11-12 21:17:00\n---\n\nwindy  $ X $  $ Y $  windy $ N $ windy  $ N $ windy  $ N - 1 $  $ N $  windy \n\n<!-- more -->\n\n### \n[BZOJ 1024](http://www.lydsy.com/JudgeOnline/problem.php?id=1024)\n\n### \n**** $ k \\over n $ $ k $ \n\nDFS \n\n### \n```c++\n#include <cstdio>\n#include <cfloat>\n#include <algorithm>\n\nconst int MAXN = 10;\n\ndouble dfs(const int n, const double x, const double y) {\n\tif (n == 1) {\n\t\treturn std::max(x, y) / std::min(x, y);\n\t}\n\n\tdouble res1 = DBL_MAX;\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\tres1 = std::min(res1, std::max(dfs(i, i * x / n, y), dfs(n - i, (n - i) * x / n, y)));\n\t}\n\n\tdouble res2 = DBL_MAX;\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\tres2 = std::min(res2, std::max(dfs(i, x, i * y / n), dfs(n - i, x, (n - i) * y / n)));\n\t}\n\n\treturn std::min(res1, res2);\n}\n\nint main() {\n\tint x, y, n;\n\tscanf(\"%d %d %d\", &x, &y, &n);\n\tprintf(\"%.6lf\\n\", dfs(n, x, y));\n\treturn 0;\n}\n```","slug":"scoi2009-cake","published":1,"updated":"2016-11-12T13:17:41.779Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c3y00h0c2xl2sz697zb"},{"title":"SCOI2007 - ","date":"2016-03-09T01:52:35.000Z","_content":"\n $ N $  $ M $  $ M $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1070](http://www.lydsy.com/JudgeOnline/problem.php?id=1070)  \n[CodeVS 2436](http://codevs.cn/problem/2436/)\n\n### \n****\n\n $ i $  $ j $  $ t_{i, j} $ $ i $  $ v_i $ $ i $  $ k $  $ k $  $ v_{j, k} $$ k {\\in} [1, n] $\n\n 1 0 $ v_i $  $ v_{j, k} $  1 $ t_{i, j} * k $ $ v_{j, k} $  1 0\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 60;\nconst int MAXM = 9;\nconst int MAXT = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + MAXM * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), flow(0), capacity(capacity), cost(cost), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, time[MAXM][MAXN];\n\ninline int hash(int j, int k) {\n\treturn n + (j - 1) * n + k;\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &time[j][i]);\n\t\t}\n\t}\n\n\tconst int s = 0, t = n + n * m + 1;\n\t//printf(\"s = %d, t = %d\\n\", s, t);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t}\n\n\tfor (int j = 1; j <= m; j++) {\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\taddEdge(hash(j, k), t, 1, 0);\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t//printf(\"%d -> %d\\n\", i, hash(j, k));\n\t\t\t\taddEdge(i, hash(j, k), 1, time[j - 1][i - 1] * k);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n * m + 2, flow, cost);\n\n\tprintf(\"%.2lf\\n\", (double)cost / (double)n);\n\n\treturn 0;\n}\n```\n\n### \n $ n $$ m $  \n\n EK  \n\nhehe\n","source":"_posts/scoi2007-repair.md","raw":"title: SCOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - SCOI\n  - \n  - \n  - \n  - Edmonds-Karp\npermalink: scoi2007-repair\ndate: 2016-03-09 09:52:35\n---\n\n $ N $  $ M $  $ M $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1070](http://www.lydsy.com/JudgeOnline/problem.php?id=1070)  \n[CodeVS 2436](http://codevs.cn/problem/2436/)\n\n### \n****\n\n $ i $  $ j $  $ t_{i, j} $ $ i $  $ v_i $ $ i $  $ k $  $ k $  $ v_{j, k} $$ k {\\in} [1, n] $\n\n 1 0 $ v_i $  $ v_{j, k} $  1 $ t_{i, j} * k $ $ v_{j, k} $  1 0\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 60;\nconst int MAXM = 9;\nconst int MAXT = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + MAXM * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), flow(0), capacity(capacity), cost(cost), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, time[MAXM][MAXN];\n\ninline int hash(int j, int k) {\n\treturn n + (j - 1) * n + k;\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &time[j][i]);\n\t\t}\n\t}\n\n\tconst int s = 0, t = n + n * m + 1;\n\t//printf(\"s = %d, t = %d\\n\", s, t);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t}\n\n\tfor (int j = 1; j <= m; j++) {\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\taddEdge(hash(j, k), t, 1, 0);\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t//printf(\"%d -> %d\\n\", i, hash(j, k));\n\t\t\t\taddEdge(i, hash(j, k), 1, time[j - 1][i - 1] * k);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n * m + 2, flow, cost);\n\n\tprintf(\"%.2lf\\n\", (double)cost / (double)n);\n\n\treturn 0;\n}\n```\n\n### \n $ n $$ m $  \n\n EK  \n\nhehe\n","slug":"scoi2007-repair","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c4400h8c2xlvdbx87ds"},{"title":"SCOI2007 - ","date":"2016-09-03T13:47:00.000Z","_content":"\n $ r $  $ c $ \n\n $ 1 $ $ d $**** $ d $ \n\n $ 1 $ $ 1 $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1066](http://www.lydsy.com/JudgeOnline/problem.php?id=1066)\n\n### \n $ d $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 20;\nconst int MAXD = 4;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\t// printf(\"addEdge(%d, %d, %d)\\n\", s, t, c);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j, const int l) {\n\treturn l * n * m + i * m + j + 1;\n}\n\nint main() {\n\tint d;\n\tscanf(\"%d %d %d\", &n, &m, &d);\n\n\t/*\n\tprintf(\"%d -> %d\\n\", id(2, 2, 1), id(2, 2, 0));\n\tprintf(\"%d -> %d\\n\", id(2, 2, 0), id(2, 2, 2));\n\tprintf(\"%d -> %d\\n\", id(2, 2, 2), id(2, 1, 1));\n\tprintf(\"%d -> %d\\n\", id(2, 1, 1), id(3, 1, 0));\n\tprintf(\"%d -> %d\\n\", id(3, 1, 0), id(3, 1, 2));\n\tprintf(\"%d -> %d\\n\", id(3, 1, 2), id(3, 0, 1));\n\t*/\n\t/*\n\tfor (int h = 0; h <= d; h++) for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) printf(\"%d\\n\", id(i, j, h));\n\tprintf(\"t = %d\\n\", n * m * (d + 1) + 1);\n\treturn 0;\n\t*/\n\n\tconst int s = 0, t = n * m * 2 + 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char buf[MAXN + 1];\n\t\tscanf(\"%s\", buf);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\taddEdge(id(i, j, 0), id(i, j, 1), buf[j] - '0');\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char buf[MAXN + 1];\n\t\tscanf(\"%s\", buf);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (buf[j] == 'L') addEdge(s, id(i, j, 0), 1), cnt++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int l = 0; l < m; l++) {\n\t\t\t\t\tif (abs(i - k) + abs(j - l) <= d) {\n\t\t\t\t\t\taddEdge(id(i, j, 1), id(k, l, 0), INT_MAX);\n\t\t\t\t\t\taddEdge(id(k, l, 1), id(i, j, 0), INT_MAX);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i < d || i > n - d - 1 || j < d || j > m - d - 1) addEdge(id(i, j, 1), t, INT_MAX);\n\t\t}\n\t}\n\n\tint ans = dinic(s, t, n * m * 2 + 2);\n\tprintf(\"%d\\n\", cnt - ans);\n\n\treturn 0;\n}\n```","source":"_posts/scoi2007-lizard.md","raw":"title: SCOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - \n  - Dinic\npermalink: scoi2007-lizard\ndate: 2016-09-03 21:47:00\n---\n\n $ r $  $ c $ \n\n $ 1 $ $ d $**** $ d $ \n\n $ 1 $ $ 1 $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1066](http://www.lydsy.com/JudgeOnline/problem.php?id=1066)\n\n### \n $ d $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 20;\nconst int MAXD = 4;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\t// printf(\"addEdge(%d, %d, %d)\\n\", s, t, c);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j, const int l) {\n\treturn l * n * m + i * m + j + 1;\n}\n\nint main() {\n\tint d;\n\tscanf(\"%d %d %d\", &n, &m, &d);\n\n\t/*\n\tprintf(\"%d -> %d\\n\", id(2, 2, 1), id(2, 2, 0));\n\tprintf(\"%d -> %d\\n\", id(2, 2, 0), id(2, 2, 2));\n\tprintf(\"%d -> %d\\n\", id(2, 2, 2), id(2, 1, 1));\n\tprintf(\"%d -> %d\\n\", id(2, 1, 1), id(3, 1, 0));\n\tprintf(\"%d -> %d\\n\", id(3, 1, 0), id(3, 1, 2));\n\tprintf(\"%d -> %d\\n\", id(3, 1, 2), id(3, 0, 1));\n\t*/\n\t/*\n\tfor (int h = 0; h <= d; h++) for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) printf(\"%d\\n\", id(i, j, h));\n\tprintf(\"t = %d\\n\", n * m * (d + 1) + 1);\n\treturn 0;\n\t*/\n\n\tconst int s = 0, t = n * m * 2 + 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char buf[MAXN + 1];\n\t\tscanf(\"%s\", buf);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\taddEdge(id(i, j, 0), id(i, j, 1), buf[j] - '0');\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char buf[MAXN + 1];\n\t\tscanf(\"%s\", buf);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (buf[j] == 'L') addEdge(s, id(i, j, 0), 1), cnt++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int l = 0; l < m; l++) {\n\t\t\t\t\tif (abs(i - k) + abs(j - l) <= d) {\n\t\t\t\t\t\taddEdge(id(i, j, 1), id(k, l, 0), INT_MAX);\n\t\t\t\t\t\taddEdge(id(k, l, 1), id(i, j, 0), INT_MAX);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i < d || i > n - d - 1 || j < d || j > m - d - 1) addEdge(id(i, j, 1), t, INT_MAX);\n\t\t}\n\t}\n\n\tint ans = dinic(s, t, n * m * 2 + 2);\n\tprintf(\"%d\\n\", cnt - ans);\n\n\treturn 0;\n}\n```","slug":"scoi2007-lizard","published":1,"updated":"2016-09-03T13:51:23.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c4900hhc2xlz1u499la"},{"title":"SCOI2003 -  DP","date":"2016-07-06T03:54:00.000Z","_content":"\n\n\n1. \n2. $ X(S) $  $ X(X > 1) $  $ S $ \n3.  $ A $  $ A $ $ B $  $ B $  $ AB $  $ AB $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1090](http://www.lydsy.com/JudgeOnline/problem.php?id=1090)\n\n### \n $ f(l, r) $  $ [l, r] $ \n\n\n\n1.  $ r - l + 1 $\n2. \n3. \n4. \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nint n;\nchar s[MAXN + 1];\n\ninline int numberLength(int x) {\n\tint res = 0;\n\tdo res++; while (x /= 10);\n\treturn res;\n}\n\ninline int dp(const int l, const int r) {\n\tstatic int mem[MAXN][MAXN];\n\tstatic bool calced[MAXN][MAXN];\n\tint &ans = mem[l][r];\n\tif (calced[l][r]) return ans;\n\tcalced[l][r] = true;\n\n\tif (l == r) return ans = 1;\n\telse if (l > r) return ans = 0;\n\n\tans = r - l + 1;\n\n\tfor (int i = 1; i <= r - l + 1; i++) {\n\t\tint base = dp(l, l + i - 1);\n\t\tint pos = l + i, cnt = 1;\n\t\twhile (pos + i - 1 <= r && strncmp(s + l, s + pos, i) == 0) pos += i, cnt++;\n\t\tans = std::min(ans, dp(pos, r) + numberLength(cnt) + 2 + base);\n\t}\n\n\tfor (int i = 1; i <= r - l + 1; i++) {\n\t\tint base = dp(r - i + 1, r);\n\t\tint pos = r - i - i + 1, cnt = 1;\n\t\twhile (pos >= l && strncmp(s + r - i + 1, s + pos, i) == 0) pos -= i, cnt++;\n\t\tans = std::min(ans, dp(l, pos + i - 1) + numberLength(cnt) + 2 + base);\n\t}\n\n\tfor (int i = 1; i <= r - l + 1 - 1; i++) {\n\t\tans = std::min(ans, dp(l, i) + dp(i + 1, r));\n\t}\n\n\t// printf(\"dp(%d, %d) = %d\\n\", l, r, ans);\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\n\tprintf(\"%d\\n\", dp(0, n - 1));\n\n\treturn 0;\n}\n```\n\n\n\n","source":"_posts/scoi2003-fold.md","raw":"title: SCOI2003 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - SCOI\n  - DP\n  -  DP\npermalink: scoi2003-fold\ndate: 2016-07-06 11:54:00\n---\n\n\n\n1. \n2. $ X(S) $  $ X(X > 1) $  $ S $ \n3.  $ A $  $ A $ $ B $  $ B $  $ AB $  $ AB $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1090](http://www.lydsy.com/JudgeOnline/problem.php?id=1090)\n\n### \n $ f(l, r) $  $ [l, r] $ \n\n\n\n1.  $ r - l + 1 $\n2. \n3. \n4. \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nint n;\nchar s[MAXN + 1];\n\ninline int numberLength(int x) {\n\tint res = 0;\n\tdo res++; while (x /= 10);\n\treturn res;\n}\n\ninline int dp(const int l, const int r) {\n\tstatic int mem[MAXN][MAXN];\n\tstatic bool calced[MAXN][MAXN];\n\tint &ans = mem[l][r];\n\tif (calced[l][r]) return ans;\n\tcalced[l][r] = true;\n\n\tif (l == r) return ans = 1;\n\telse if (l > r) return ans = 0;\n\n\tans = r - l + 1;\n\n\tfor (int i = 1; i <= r - l + 1; i++) {\n\t\tint base = dp(l, l + i - 1);\n\t\tint pos = l + i, cnt = 1;\n\t\twhile (pos + i - 1 <= r && strncmp(s + l, s + pos, i) == 0) pos += i, cnt++;\n\t\tans = std::min(ans, dp(pos, r) + numberLength(cnt) + 2 + base);\n\t}\n\n\tfor (int i = 1; i <= r - l + 1; i++) {\n\t\tint base = dp(r - i + 1, r);\n\t\tint pos = r - i - i + 1, cnt = 1;\n\t\twhile (pos >= l && strncmp(s + r - i + 1, s + pos, i) == 0) pos -= i, cnt++;\n\t\tans = std::min(ans, dp(l, pos + i - 1) + numberLength(cnt) + 2 + base);\n\t}\n\n\tfor (int i = 1; i <= r - l + 1 - 1; i++) {\n\t\tans = std::min(ans, dp(l, i) + dp(i + 1, r));\n\t}\n\n\t// printf(\"dp(%d, %d) = %d\\n\", l, r, ans);\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\n\tprintf(\"%d\\n\", dp(0, n - 1));\n\n\treturn 0;\n}\n```\n\n\n\n","slug":"scoi2003-fold","published":1,"updated":"2016-10-24T23:31:18.502Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c4d00hnc2xlu1hlazam"},{"title":"POJ 3461Oulipo - KMP","date":"2016-04-09T13:36:23.000Z","_content":"\n\n\n<!-- more -->\n\n### \nKMP  \n\n `next`  `char`  \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000000;\n\nint m, n, next[MAXN + 1];\nchar s[MAXM + 1], p[MAXN + 1];\n\ninline void getNext() {\n\tnext[0] = -1;\n\tfor (int i = 0, j = -1; i < n; ) {\n\t\tif (j == -1 || p[i] == p[j]) next[++i] = ++j;\n\t\telse j = next[j];\n\t}\n}\n\ninline int kmp() {\n\tgetNext();\n\tint ans = 0;\n\tfor (int i = 0, j = 0; i < m; ) {\n\t\tif (j == -1 || s[i] == p[j]) i++, j++;\n\t\telse j = next[j];\n\t\tif (j == n) ans++, j = next[j];\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t), getchar();\n\twhile (t--) {\n\t\tgets(p);\n\t\tgets(s);\n\t\tn = strlen(p);\n\t\tm = strlen(s);\n\t\t// n = readLine(p);\n\t\t// m = readLine(s);\n\t\tprintf(\"%d\\n\", kmp());\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/poj-3461.md","raw":"title: POJ 3461Oulipo - KMP\ncategories: OI\ntags: \n  - POJ\n  - KMP\n  - \n  - \npermalink: poj-3461\ndate: 2016-04-09 21:36:23\n---\n\n\n\n<!-- more -->\n\n### \nKMP  \n\n `next`  `char`  \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000000;\n\nint m, n, next[MAXN + 1];\nchar s[MAXM + 1], p[MAXN + 1];\n\ninline void getNext() {\n\tnext[0] = -1;\n\tfor (int i = 0, j = -1; i < n; ) {\n\t\tif (j == -1 || p[i] == p[j]) next[++i] = ++j;\n\t\telse j = next[j];\n\t}\n}\n\ninline int kmp() {\n\tgetNext();\n\tint ans = 0;\n\tfor (int i = 0, j = 0; i < m; ) {\n\t\tif (j == -1 || s[i] == p[j]) i++, j++;\n\t\telse j = next[j];\n\t\tif (j == n) ans++, j = next[j];\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t), getchar();\n\twhile (t--) {\n\t\tgets(p);\n\t\tgets(s);\n\t\tn = strlen(p);\n\t\tm = strlen(s);\n\t\t// n = readLine(p);\n\t\t// m = readLine(s);\n\t\tprintf(\"%d\\n\", kmp());\n\t}\n\treturn 0;\n}\n```\n","slug":"poj-3461","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c4h00htc2xlqm9a4iz0"},{"title":"POJ 2728Desert King - 01 ","date":"2016-03-11T01:33:14.000Z","_content":"\n $ N $  $ (x, y) $  $ z $ $ N $ \n\n<!-- more -->\n\n### \n[POJ 2728](http://poj.org/problem?id=2728)\n\n### \n01   Orz\n\nPS WA  TLE G++  VC++  AC  \n\n### \n```cpp\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int CACHE_FIX = 3;\nconst float EPS = 1e-4;\n\nstruct Node;\nstruct UndirectedEdge;\n\nstruct Node {\n\tint id;\n\tint x, y, z;\n\tbool inTree;\n\tUndirectedEdge *e;\n} nodes[MAXN];\n\nstruct UndirectedEdge {\n\tfloat benifit, cost;\n\tfloat w;\n\n\tUndirectedEdge(float benifit, float cost) : benifit(benifit), cost(cost) {}\n\tUndirectedEdge() {}\n} edges[MAXN + CACHE_FIX][MAXN];\n\nint n;\n\ninline float prim() {\n\tnodes[0].inTree = true;\n\tfor (int i = 1; i < n; i++) nodes[i].e = &edges[0][i], nodes[i].inTree = false;\n\n\tfloat ans = 0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tNode *v = NULL;\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && (v == NULL || nodes[i].e->w < v->e->w)) v = &nodes[i];\n\n\t\tans += v->e->w;\n\t\tv->e = NULL;\n\t\tv->inTree = true;\n\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && nodes[i].e->w > edges[i][v->id].w) nodes[i].e = &edges[i][v->id];\n\t}\n\n\treturn ans;\n}\n\ninline float test(float p) {\n\tfor (register int i = 0; i < n; i++) {\n\t\tfor (register int j = i + 1; j < n; j++) {\n\t\t\tedges[j][i].w = edges[i][j].w = edges[i][j].cost - edges[i][j].benifit * p;\n\t\t}\n\t}\n\n\tfloat result = prim();\n\t//printf(\"test(%lf) = %lf\\n\", p, result);\n\treturn result;\n}\n\ninline float solve(float sum) {\n\tregister float l = 0, r = sum;\n\t//while (r - l > EPS) {\n\tfor (int i = 0; i < 22; i++) {\n\t\tfloat mid = l + (r - l) / 2;\n\t\tif (test(mid) > 0) l = mid;\n\t\telse r = mid;\n\t}\n\n\treturn l + (r - l) / 2;\n}\n\ninline float sqr(float x) {\n\treturn x * x;\n}\n\ninline float distance(float x1, float x2, float y1, float y2) {\n\treturn sqrt(sqr(x1 - x2) + sqr(y1 - y2));\n}\n\nint main() {\n\twhile (scanf(\"%d\", &n) != EOF && n != 0) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].id = i;\n\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &nodes[i].x, &nodes[i].y, &nodes[i].z);\n\n\t\tfloat sum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tedges[j][i] = edges[i][j] = UndirectedEdge(distance(nodes[i].x, nodes[j].x, nodes[i].y, nodes[j].y), abs(nodes[i].z - nodes[j].z));\n\t\t\t\tsum += edges[i][j].benifit;\n\t\t\t}\n\t\t}\n\n\t\tfloat ans = solve(100);\n\t\tprintf(\"%.3f\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n\nconst int MAXN = 1000;\n\ninline int luckyRand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tconst int x = rand();\n\tsrand(x ^ ((time(NULL) << 16) | (clock() << 16 >> 16)) ^ MAGIC_NUMBER);\n\treturn (rand() ^ x ^ MAGIC_NUMBER) % (r - l + 1) + l;\n}\n\nint main() {\n\tconst int t = 3;\n\tconst int n = MAXN;\n\n\tfor (int i = 0; i < t; i++) {\n\t\tprintf(\"%d\\n\", n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), y = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), z = luckyRand(luckyRand(0, 10000), luckyRand(90000, 100000));\n\t\t\tprintf(\"%d %d %d\\n\", x, y, z);\n\t\t}\n\t}\n\n\tputs(\"0\");\n\n\treturn 0;\n}\n```\n","source":"_posts/poj-2728.md","raw":"title: POJ 2728Desert King - 01 \ncategories: OI\ntags: \n  - POJ\n  - Prim\n  - \n  - \n  - \n  - \npermalink: poj-2728\ndate: 2016-03-11 09:33:14\n---\n\n $ N $  $ (x, y) $  $ z $ $ N $ \n\n<!-- more -->\n\n### \n[POJ 2728](http://poj.org/problem?id=2728)\n\n### \n01   Orz\n\nPS WA  TLE G++  VC++  AC  \n\n### \n```cpp\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int CACHE_FIX = 3;\nconst float EPS = 1e-4;\n\nstruct Node;\nstruct UndirectedEdge;\n\nstruct Node {\n\tint id;\n\tint x, y, z;\n\tbool inTree;\n\tUndirectedEdge *e;\n} nodes[MAXN];\n\nstruct UndirectedEdge {\n\tfloat benifit, cost;\n\tfloat w;\n\n\tUndirectedEdge(float benifit, float cost) : benifit(benifit), cost(cost) {}\n\tUndirectedEdge() {}\n} edges[MAXN + CACHE_FIX][MAXN];\n\nint n;\n\ninline float prim() {\n\tnodes[0].inTree = true;\n\tfor (int i = 1; i < n; i++) nodes[i].e = &edges[0][i], nodes[i].inTree = false;\n\n\tfloat ans = 0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tNode *v = NULL;\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && (v == NULL || nodes[i].e->w < v->e->w)) v = &nodes[i];\n\n\t\tans += v->e->w;\n\t\tv->e = NULL;\n\t\tv->inTree = true;\n\n\t\tfor (int i = 0; i < n; i++) if (!nodes[i].inTree && nodes[i].e->w > edges[i][v->id].w) nodes[i].e = &edges[i][v->id];\n\t}\n\n\treturn ans;\n}\n\ninline float test(float p) {\n\tfor (register int i = 0; i < n; i++) {\n\t\tfor (register int j = i + 1; j < n; j++) {\n\t\t\tedges[j][i].w = edges[i][j].w = edges[i][j].cost - edges[i][j].benifit * p;\n\t\t}\n\t}\n\n\tfloat result = prim();\n\t//printf(\"test(%lf) = %lf\\n\", p, result);\n\treturn result;\n}\n\ninline float solve(float sum) {\n\tregister float l = 0, r = sum;\n\t//while (r - l > EPS) {\n\tfor (int i = 0; i < 22; i++) {\n\t\tfloat mid = l + (r - l) / 2;\n\t\tif (test(mid) > 0) l = mid;\n\t\telse r = mid;\n\t}\n\n\treturn l + (r - l) / 2;\n}\n\ninline float sqr(float x) {\n\treturn x * x;\n}\n\ninline float distance(float x1, float x2, float y1, float y2) {\n\treturn sqrt(sqr(x1 - x2) + sqr(y1 - y2));\n}\n\nint main() {\n\twhile (scanf(\"%d\", &n) != EOF && n != 0) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].id = i;\n\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &nodes[i].x, &nodes[i].y, &nodes[i].z);\n\n\t\tfloat sum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tedges[j][i] = edges[i][j] = UndirectedEdge(distance(nodes[i].x, nodes[j].x, nodes[i].y, nodes[j].y), abs(nodes[i].z - nodes[j].z));\n\t\t\t\tsum += edges[i][j].benifit;\n\t\t\t}\n\t\t}\n\n\t\tfloat ans = solve(100);\n\t\tprintf(\"%.3f\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n\nconst int MAXN = 1000;\n\ninline int luckyRand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tconst int x = rand();\n\tsrand(x ^ ((time(NULL) << 16) | (clock() << 16 >> 16)) ^ MAGIC_NUMBER);\n\treturn (rand() ^ x ^ MAGIC_NUMBER) % (r - l + 1) + l;\n}\n\nint main() {\n\tconst int t = 3;\n\tconst int n = MAXN;\n\n\tfor (int i = 0; i < t; i++) {\n\t\tprintf(\"%d\\n\", n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), y = luckyRand(luckyRand(0, 30), luckyRand(30, 60)), z = luckyRand(luckyRand(0, 10000), luckyRand(90000, 100000));\n\t\t\tprintf(\"%d %d %d\\n\", x, y, z);\n\t\t}\n\t}\n\n\tputs(\"0\");\n\n\treturn 0;\n}\n```\n","slug":"poj-2728","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c4m00i1c2xlblomrgol"},{"title":"POJ 1737Connected Graph -  +  + ","date":"2016-03-14T04:12:45.000Z","_content":"\n $ N $$ N \\leq 50 $\n\n<!-- more -->\n\n### \n[POJ 1737](http://poj.org/problem?id=1737)\n\n### \n N  N **** $ \\frac{N(N - 1)}{2} $  $ 2 ^ {\\frac{N(N - 1)}{2}} $ \n\n $ N $  $ v $ $ K $$ 1 \\leq K \\leq N - 1 $**** $ v $  $ K - 1 $  $ \\binom{N - 1}{K - 1} $**** $ N - K $ \n\n $ n $  $ f(n) $ $ g(n) $ $ h(n) $ $ f(n) $ \n\n$$\n\\begin{align}\n& f(n) = h(n) - g(n) \\\\\n& g(n) = \\sum\\limits_{k = 1}^{n - 1}\\binom{n - 1}{k - 1} * f(k) * h(n - k) \\\\\n& h(n) = 2 ^ {\\frac{n(n - 1)}{2}} \\\\\n\\end{align}\n$$\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 50;\n\nstruct BigInt;\nBigInt &countConnectedGraphs(int n);\nBigInt &countNonConnectedGraphs(int n);\ninline BigInt &countAllGraphs(int n);\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), x.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++){\n\t\t\tcombo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n\t\t}\n\t}\n}\n\ninline BigInt &C(int n, int k) {\n\treturn combo[n][k];\n}\n\nBigInt &countConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tans = countAllGraphs(n) - countNonConnectedGraphs(n);\n\n\treturn ans;\n}\n\nBigInt &countNonConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tfor (int k = 1; k <= n - 1; k++) {\n\t\tans += C(n - 1, k - 1) * countConnectedGraphs(k) * countAllGraphs(n - k);\n\t}\n\n\treturn ans;\n}\n\ninline BigInt &countAllGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tBigInt x = 2;\n\tint t = n * (n - 1) / 2;\n\tfor (ans = 1; t; t >>= 1, x = x * x) {\n\t\tif (t & 1) ans = ans * x;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tfor (int n; ~scanf(\"%d\", &n) && n > 0; ) {\n\t\tstd::cout << countConnectedGraphs(n) << std::endl;\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/poj-1737.md","raw":"title: POJ 1737Connected Graph -  +  + \ncategories: OI\ntags: \n  - POJ\n  - \n  - \n  - \n  - \n  - \npermalink: poj-1737\ndate: 2016-03-14 12:12:45\n---\n\n $ N $$ N \\leq 50 $\n\n<!-- more -->\n\n### \n[POJ 1737](http://poj.org/problem?id=1737)\n\n### \n N  N **** $ \\frac{N(N - 1)}{2} $  $ 2 ^ {\\frac{N(N - 1)}{2}} $ \n\n $ N $  $ v $ $ K $$ 1 \\leq K \\leq N - 1 $**** $ v $  $ K - 1 $  $ \\binom{N - 1}{K - 1} $**** $ N - K $ \n\n $ n $  $ f(n) $ $ g(n) $ $ h(n) $ $ f(n) $ \n\n$$\n\\begin{align}\n& f(n) = h(n) - g(n) \\\\\n& g(n) = \\sum\\limits_{k = 1}^{n - 1}\\binom{n - 1}{k - 1} * f(k) * h(n - k) \\\\\n& h(n) = 2 ^ {\\frac{n(n - 1)}{2}} \\\\\n\\end{align}\n$$\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 50;\n\nstruct BigInt;\nBigInt &countConnectedGraphs(int n);\nBigInt &countNonConnectedGraphs(int n);\ninline BigInt &countAllGraphs(int n);\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), x.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] + '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); i++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tcombo[i][0] = combo[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++){\n\t\t\tcombo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n\t\t}\n\t}\n}\n\ninline BigInt &C(int n, int k) {\n\treturn combo[n][k];\n}\n\nBigInt &countConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tans = countAllGraphs(n) - countNonConnectedGraphs(n);\n\n\treturn ans;\n}\n\nBigInt &countNonConnectedGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tfor (int k = 1; k <= n - 1; k++) {\n\t\tans += C(n - 1, k - 1) * countConnectedGraphs(k) * countAllGraphs(n - k);\n\t}\n\n\treturn ans;\n}\n\ninline BigInt &countAllGraphs(int n) {\n\tstatic bool calced[MAXN + 1];\n\tstatic BigInt mem[MAXN + 1];\n\tBigInt &ans = mem[n];\n\n\tif (calced[n]) return ans;\n\tcalced[n] = true;\n\n\tBigInt x = 2;\n\tint t = n * (n - 1) / 2;\n\tfor (ans = 1; t; t >>= 1, x = x * x) {\n\t\tif (t & 1) ans = ans * x;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tmakeComboTable();\n\n\tfor (int n; ~scanf(\"%d\", &n) && n > 0; ) {\n\t\tstd::cout << countConnectedGraphs(n) << std::endl;\n\t}\n\n\treturn 0;\n}\n```\n","slug":"poj-1737","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c4u00icc2xl4cdjx76c"},{"title":"POI2008BLO - ","date":"2016-09-08T10:37:00.000Z","_content":"\nByteotia  $ n $  towns$ m $  roads road  towns road towns \n\n******** $ (u, v) $ \n\n<!-- more -->\n\n### \n[BZOJ 1123](http://www.lydsy.com/JudgeOnline/problem.php?id=1123)\n\n### \n $ 2 \\times (n - 1) $\n\n\n\nDFS  DFS  $ u $ $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $  $ v $  $ u $ \n\n $ x_1, x_2, \\ldots, x_k $$ s = \\sum\\limits_{i = 1} ^ k x_i $\n\n$$\n\\begin{aligned}\n& x_1x_2 + x_1x_3 + \\ldots + x_1x_k + \\ldots + x_kx_{k - 1} \\\\\n= & x_1(x_2 + x_3 + \\ldots + x_k) + x_2(x_1 + x_3 + \\ldots + x_k) + \\ldots + x_k(x_1 + x_2 + \\ldots + x_{k - 1}) \\\\\n= & \\sum\\limits_{i = 1} ^ k x_i \\times (s - x_i)\n\\end{aligned}\n$$\n\n### \n```c++\n#include <cstdio>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low, size;\n\tlong long ans;\n\tbool flag, pushed, v;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline long long calc(const std::vector<long long> &vec) {\n\tlong long s = 0, ans = 0;\n\tfor (size_t i = 0; i < vec.size(); i++) s += vec[i];\n\tfor (size_t i = 0; i < vec.size(); i++) ans += (s - vec[i]) * vec[i];\n\treturn ans;\n}\n\ninline void tarjan() {\n\tint ts = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\n\t\tstd::stack<Node *> s;\n\t\tN[i].pushed = true;\n\t\ts.push(&N[i]);\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\t\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->size = 1;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, e->t->p = v, s.push(e->t);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tstd::vector<long long> vec;\n\t\t\t\tif (v != &N[i]) {\n\t\t\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\t\t\tif (e->t->p != v) continue;\n\t\t\t\t\t\tif (e->t->low >= v->dfn) {\n\t\t\t\t\t\t\tv->flag = true;\n\t\t\t\t\t\t\tvec.push_back(e->t->size);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tv->size += e->t->size;\n\t\t\t\t\t}\n\t\t\t\t\tint t = n - 1;\n\t\t\t\t\tfor (size_t i = 0; i < vec.size(); i++) t -= vec[i];\n\t\t\t\t\tvec.push_back(t);\n\t\t\t\t\tif (v->flag) v->ans = calc(vec);\n\t\t\t\t\t// if (v->flag) printf(\"tarjan(): found %lu\\n\", v - N + 1);\n\t\t\t\t}\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tstd::vector<long long> vec;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) vec.push_back(e->t->size);\n\t\tif (vec.size() >= 2) N[i].ans = calc(vec), N[i].flag = true;\n\t\t// if (N[i].flag) printf(\"tarjan(): found %d\\n\", i + 1);\n\t}\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\ttarjan();\n\n\tfor (int i = 0; i < n; i++) printf(\"%lld\\n\", N[i].ans + (n - 1) * 2);\n\n\treturn 0;\n}\n```","source":"_posts/poi2008-blo.md","raw":"title: POI2008BLO - \ncategories: OI\ntags: \n  - BZOJ\n  - POI\n  - Tarjan\n  - \n  - \npermalink: poi2008-blo\ndate: 2016-09-08 18:37:00\n---\n\nByteotia  $ n $  towns$ m $  roads road  towns road towns \n\n******** $ (u, v) $ \n\n<!-- more -->\n\n### \n[BZOJ 1123](http://www.lydsy.com/JudgeOnline/problem.php?id=1123)\n\n### \n $ 2 \\times (n - 1) $\n\n\n\nDFS  DFS  $ u $ $ \\mathrm{low}(v) \\geq \\mathrm{dfn}(u) $  $ v $  $ u $ \n\n $ x_1, x_2, \\ldots, x_k $$ s = \\sum\\limits_{i = 1} ^ k x_i $\n\n$$\n\\begin{aligned}\n& x_1x_2 + x_1x_3 + \\ldots + x_1x_k + \\ldots + x_kx_{k - 1} \\\\\n= & x_1(x_2 + x_3 + \\ldots + x_k) + x_2(x_1 + x_3 + \\ldots + x_k) + \\ldots + x_k(x_1 + x_2 + \\ldots + x_{k - 1}) \\\\\n= & \\sum\\limits_{i = 1} ^ k x_i \\times (s - x_i)\n\\end{aligned}\n$$\n\n### \n```c++\n#include <cstdio>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low, size;\n\tlong long ans;\n\tbool flag, pushed, v;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline long long calc(const std::vector<long long> &vec) {\n\tlong long s = 0, ans = 0;\n\tfor (size_t i = 0; i < vec.size(); i++) s += vec[i];\n\tfor (size_t i = 0; i < vec.size(); i++) ans += (s - vec[i]) * vec[i];\n\treturn ans;\n}\n\ninline void tarjan() {\n\tint ts = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\n\t\tstd::stack<Node *> s;\n\t\tN[i].pushed = true;\n\t\ts.push(&N[i]);\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\t\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->size = 1;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, e->t->p = v, s.push(e->t);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tstd::vector<long long> vec;\n\t\t\t\tif (v != &N[i]) {\n\t\t\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\t\t\tif (e->t->p != v) continue;\n\t\t\t\t\t\tif (e->t->low >= v->dfn) {\n\t\t\t\t\t\t\tv->flag = true;\n\t\t\t\t\t\t\tvec.push_back(e->t->size);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tv->size += e->t->size;\n\t\t\t\t\t}\n\t\t\t\t\tint t = n - 1;\n\t\t\t\t\tfor (size_t i = 0; i < vec.size(); i++) t -= vec[i];\n\t\t\t\t\tvec.push_back(t);\n\t\t\t\t\tif (v->flag) v->ans = calc(vec);\n\t\t\t\t\t// if (v->flag) printf(\"tarjan(): found %lu\\n\", v - N + 1);\n\t\t\t\t}\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tstd::vector<long long> vec;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) vec.push_back(e->t->size);\n\t\tif (vec.size() >= 2) N[i].ans = calc(vec), N[i].flag = true;\n\t\t// if (N[i].flag) printf(\"tarjan(): found %d\\n\", i + 1);\n\t}\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\ttarjan();\n\n\tfor (int i = 0; i < n; i++) printf(\"%lld\\n\", N[i].ans + (n - 1) * 2);\n\n\treturn 0;\n}\n```","slug":"poi2008-blo","published":1,"updated":"2016-09-08T10:58:08.939Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c4z00ikc2xlg02derhw"},{"title":"POI2006Szk-Schools - ","date":"2016-06-22T10:20:00.000Z","_content":"\n $ n $  $ a_i $ $ [1,\\ n] $  $ n $ \n\n1. $ a_i $  $ [l_i,\\ r_i] $ \n2. $ a_i $  $ x $  $ k \\times | a_i - x | $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1520](http://www.lydsy.com/JudgeOnline/problem.php?id=1520)\n\n### \n $ i $  $ [l_i,\\ r_i] $  $ 1 $\n\n $ 1 $ $ 1 $\n\n $ n $ \n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 200;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint d, f;\n\tbool q;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].in = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint m, l, r, k;\n\t\tscanf(\"%d %d %d %d\", &m, &l, &r, &k);\n\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(i + n, t, 1, 0);\n\n\t\tfor (int j = l; j <= r; j++) {\n\t\t\taddEdge(i, n + j, 1, k * abs(j - m));\n\t\t}\n\t}\n\n\tint f, c;\n\tedmondskarp(s, t, n * 2 + 2, f, c);\n\tif (f != n) puts(\"NIE\");\n\telse printf(\"%d\\n\", c);\n\n\treturn 0;\n}\n```\n","source":"_posts/poi2006-szk.md","raw":"title: POI2006Szk-Schools - \ndate: 2016-06-22 18:20:00\ncategories: OI\ntags:\n  - BZOJ\n  - POI\n  - \n  - \n  - Edmonds-Karp\npermalink: poi2006-szk\n---\n\n $ n $  $ a_i $ $ [1,\\ n] $  $ n $ \n\n1. $ a_i $  $ [l_i,\\ r_i] $ \n2. $ a_i $  $ x $  $ k \\times | a_i - x | $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1520](http://www.lydsy.com/JudgeOnline/problem.php?id=1520)\n\n### \n $ i $  $ [l_i,\\ r_i] $  $ 1 $\n\n $ 1 $ $ 1 $\n\n $ n $ \n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 200;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint d, f;\n\tbool q;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void edmondskarp(const int s, const int t, const int n, int &f, int &c) {\n\tf = c = 0;\n\twhile (true) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].in = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tf += N[t].f;\n\t\tc += N[t].f * N[t].d;\n\t}\n}\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint m, l, r, k;\n\t\tscanf(\"%d %d %d %d\", &m, &l, &r, &k);\n\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(i + n, t, 1, 0);\n\n\t\tfor (int j = l; j <= r; j++) {\n\t\t\taddEdge(i, n + j, 1, k * abs(j - m));\n\t\t}\n\t}\n\n\tint f, c;\n\tedmondskarp(s, t, n * 2 + 2, f, c);\n\tif (f != n) puts(\"NIE\");\n\telse printf(\"%d\\n\", c);\n\n\treturn 0;\n}\n```\n","slug":"poi2006-szk","published":1,"updated":"2016-06-22T10:20:59.112Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c5300isc2xlbxq2fkht"},{"title":"POI2005Kos-Dicing -  + ","date":"2016-06-22T10:25:00.000Z","_content":"\nDicing \n\n<!-- more -->\n\n### \n[BZOJ 1532](http://www.lydsy.com/JudgeOnline/problem.php?id=1532)\n\n### \n $ x $ $ x $ $ 1 $ $ 1 $ $ m $ \n\n $ 1 $ \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 10000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c > e->f) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c > e->f) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\t// printf(\"dinic() = %d\\n\", res);\n\t\treturn res;\n\t}\n} dinic;\n\ninline Edge *addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\treturn (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\nEdge *E[MAXN];\n\ninline void reset(const int c) {\n\tfor (int i = 0; i < n + m + 2; i++) {\n\t\tif (i < n) E[i]->c = c;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) e->f = 0;\n\t}\n}\n\ninline int solve(const int s, const int t, const int n) {\n\tint l = 0, r = m;\n\twhile (l < r) {\n\t\t// printf(\"[%d, %d]\\n\", l, r);\n\t\tint mid = l + (r - l) / 2;\n\n\t\treset(mid);\n\n\t\tif (dinic(s, t, n) < m) l = mid + 1;\n\t\telse r = mid;\n\t}\n\n\treturn l;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= n; i++) E[i - 1] = addEdge(s, i, 0);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\n\t\taddEdge(a, n + i, 1);\n\t\taddEdge(b, n + i, 1);\n\n\t\taddEdge(n + i, t, 1);\n\t}\n\n\tprintf(\"%d\\n\", solve(s, t, n + m + 2));\n\n\treturn 0;\n}\n```\n","source":"_posts/poi2005-kos.md","raw":"title: POI2005Kos-Dicing -  + \ndate: 2016-06-22 18:25:00\ncategories: OI\ntags:\n  - BZOJ\n  - POI\n  - \n  - Dinic\n  - \npermalink: poi2005-kos\n---\n\nDicing \n\n<!-- more -->\n\n### \n[BZOJ 1532](http://www.lydsy.com/JudgeOnline/problem.php?id=1532)\n\n### \n $ x $ $ x $ $ 1 $ $ 1 $ $ m $ \n\n $ 1 $ \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 10000;\nconst int MAXM = 10000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c > e->f) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c > e->f) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\t// printf(\"dinic() = %d\\n\", res);\n\t\treturn res;\n\t}\n} dinic;\n\ninline Edge *addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\treturn (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\nEdge *E[MAXN];\n\ninline void reset(const int c) {\n\tfor (int i = 0; i < n + m + 2; i++) {\n\t\tif (i < n) E[i]->c = c;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) e->f = 0;\n\t}\n}\n\ninline int solve(const int s, const int t, const int n) {\n\tint l = 0, r = m;\n\twhile (l < r) {\n\t\t// printf(\"[%d, %d]\\n\", l, r);\n\t\tint mid = l + (r - l) / 2;\n\n\t\treset(mid);\n\n\t\tif (dinic(s, t, n) < m) l = mid + 1;\n\t\telse r = mid;\n\t}\n\n\treturn l;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\n\tfor (int i = 1; i <= n; i++) E[i - 1] = addEdge(s, i, 0);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\n\t\taddEdge(a, n + i, 1);\n\t\taddEdge(b, n + i, 1);\n\n\t\taddEdge(n + i, t, 1);\n\t}\n\n\tprintf(\"%d\\n\", solve(s, t, n + m + 2));\n\n\treturn 0;\n}\n```\n","slug":"poi2005-kos","published":1,"updated":"2016-06-22T10:25:54.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c5900izc2xlfffxuvd0"},{"title":"POI2000 - AC  + ","date":"2016-09-12T23:46:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 2938](http://www.lydsy.com/JudgeOnline/problem.php?id=2938)\n\n### \n AC \n\n AC  $ 0 $  $ 1 $  AC \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int CHARSET_SIZE = '1' - '0' + 1;\nconst int BASE_CHAR = '0';\nconst int MAXN = 30000;\n\nint n;\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord, visited;\n\t\tint id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord), visited(false) {\n\t\t\tthis->id = n++;\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tstruct Edge *e;\n\tint inDegree;\n\tbool invalid, flag, visited;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\t// printf(\"Edge(%d, %d)\\n\", s, t);\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].inDegree++;\n}\n\ninline void build() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->isWord || v->next) N[v->id].invalid = true;\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tTrie::Node *u = v;\n\t\t\twhile (u != t.root && !u->c[i]) u = u->fail;\n\t\t\tif (u->c[i]) {\n\t\t\t\tif (!v->isWord && !v->next && !u->c[i]->isWord) addEdge(v->id, u->c[i]->id);\n\t\t\t} else {\n\t\t\t\tif (!v->isWord && !v->next) addEdge(v->id, t.root->id);\n\t\t\t}\n\n\t\t\tif (!v->c[i]) continue;\n\t\t\tv->c[i]->visited = true;\n\t\t\tq.push(v->c[i]);\n\t\t}\n\t}\n}\n\ninline bool solve() {\n\tstd::queue<Node *> q;\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) if (!N[i].inDegree && !N[i].invalid) {\n\t\tq.push(&N[i]);\n\t\tcnt++;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tcnt--;\n\t\tv->flag = true;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->invalid) continue;\n\t\t\tif (!--e->t->inDegree) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!cnt) return false;\n\n\tq.push(&N[0]);\n\tN[0].visited = true;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\tif (!v->flag) return true;\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->visited && !e->t->invalid) e->t->visited = true, q.push(e->t);\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic char s[MAXN + 1];\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\tbuild();\n\n\tputs(solve() ? \"TAK\" : \"NIE\");\n\n\treturn 0;\n}\n```","source":"_posts/poi2000-wir.md","raw":"title: POI2000 - AC  + \ndate: 2016-09-13 07:46:00\ncategories: OI\ntags:\n  - BZOJ\n  - POI\n  - \n  - AC \n  - \npermalink: poi2000-wir\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 2938](http://www.lydsy.com/JudgeOnline/problem.php?id=2938)\n\n### \n AC \n\n AC  $ 0 $  $ 1 $  AC \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int CHARSET_SIZE = '1' - '0' + 1;\nconst int BASE_CHAR = '0';\nconst int MAXN = 30000;\n\nint n;\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord, visited;\n\t\tint id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord), visited(false) {\n\t\t\tthis->id = n++;\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tstruct Edge *e;\n\tint inDegree;\n\tbool invalid, flag, visited;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\t// printf(\"Edge(%d, %d)\\n\", s, t);\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].inDegree++;\n}\n\ninline void build() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->isWord || v->next) N[v->id].invalid = true;\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tTrie::Node *u = v;\n\t\t\twhile (u != t.root && !u->c[i]) u = u->fail;\n\t\t\tif (u->c[i]) {\n\t\t\t\tif (!v->isWord && !v->next && !u->c[i]->isWord) addEdge(v->id, u->c[i]->id);\n\t\t\t} else {\n\t\t\t\tif (!v->isWord && !v->next) addEdge(v->id, t.root->id);\n\t\t\t}\n\n\t\t\tif (!v->c[i]) continue;\n\t\t\tv->c[i]->visited = true;\n\t\t\tq.push(v->c[i]);\n\t\t}\n\t}\n}\n\ninline bool solve() {\n\tstd::queue<Node *> q;\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) if (!N[i].inDegree && !N[i].invalid) {\n\t\tq.push(&N[i]);\n\t\tcnt++;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tcnt--;\n\t\tv->flag = true;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->invalid) continue;\n\t\t\tif (!--e->t->inDegree) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!cnt) return false;\n\n\tq.push(&N[0]);\n\tN[0].visited = true;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\tif (!v->flag) return true;\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->visited && !e->t->invalid) e->t->visited = true, q.push(e->t);\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic char s[MAXN + 1];\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\tbuild();\n\n\tputs(solve() ? \"TAK\" : \"NIE\");\n\n\treturn 0;\n}\n```","slug":"poi2000-wir","published":1,"updated":"2016-09-12T23:51:54.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c5e00j6c2xlx83fmb1t"},{"title":"","date":"2016-01-19T13:48:24.000Z","_content":"\n OI \n\n<!-- more -->\n\n### \n OI \n\n$$ \\gcd(a,b)=\\cases{ a & b = 0 \\\\ \\gcd(b,a \\ {\\rm mod} \\ b) & b  0 } $$\n\n```cpp\nint gcd(int a, int b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n```\n\n\n\n$$ {\\rm lcm}(a,b)=\\frac{a*b}{\\gcd(a,b)} $$\n\n\n\n```cpp\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\n```\n\n### \n `exgcd`  $\\gcd(a,b)$  $ax+by=\\gcd(a,b)$\n\n $\\gcd(47,30)$ \n\n$$\n\\begin{align*}\n& 47=30*1+17 \\\\\n& 30=17*1+13 \\\\\n& 17=13*1+4  \\\\\n& 13=4*3+1   \\\\\n\\end{align*}\n$$\n\n\n\n$$\n\\begin{align*}\n& 17=47+30*(-1) \\\\\n& 13=30+17*(-1) \\\\\n& 4=17+13*(-1)  \\\\\n& 1=13+4*(-3)   \\\\\n\\end{align*}\n$$\n\n $\\gcd(47,30)=1$ \n\n$$\n\\begin{align*}\n& \\gcd(47,30)             \\\\\n& =1                      \\\\\n& =13*1+4*(-3)            \\\\\n& =13*1+[17+13*(-1)]*(-3) \\\\\n& =13*4+17*(-3)           \\\\\n& =17*3+13*4              \\\\\n& =17*3+[30+17*(-1)]*4    \\\\\n& =17*(-7)+30*4           \\\\\n& =30*4+17*(-7)           \\\\\n& =30*4+[47+30*(-1)]*(-7) \\\\\n& =30*11+47*(-7)          \\\\\n& =47*(-7)+30*11          \\\\\n\\end{align*}\n$$\n\n $x=-7,y=11$\n\n `x`  `y` `y`  `x` \n\n```cpp\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n```\n\n### Eratosthenes \n\n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * 2; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n\n1.  $i^2$  $i$  $i'$$i*i'$  $i'$ \n2.  $[2,\\sqrt{n}]$  $p>\\sqrt{n}$ $k$  $p=k*k'$  $k< \\sqrt{n}$ $p$  $k$ \n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tint m = floor(sqrt(n + 0.5));\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * i; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n### \n $n$  $k$  $i$  $a_i$\n\n$$ n={\\prod_{i=1}^{k}} \\ {p_i}^{a_i} $$\n\n $n$  $p_i$   \n\n$$ \\phi(n)={\\sum_{S{\\subseteq}\\{p_1,p_2,\\ldots,p_k\\}}{(-1)^{|S|}} *  {\\frac{n}{ {\\prod_{ {p_i}{\\in}S} } \\ p_i }}} $$\n\n\n\n$$ \\phi(n)=n*\\prod_{i=1}^{k} (1 - \\frac{1}{p_i}) $$\n\n $n$ $p$  $p-1$ \n\n $n$\n\n```cpp\nint phi() {\n\tint m = floor(sqrt(n + 0.5)), ans = n;\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (n % i == 0) {\n\t\t\tans = ans / i * (i - 1);\n\t\t\twhile (n % i == 0) n /= i;\n\t\t}\n\t}\n\n\tif (n != 1) ans = ans / n * (n - 1); // \n\treturn ans;\n}\n```\n\n \n","source":"_posts/number-theory-notes-1.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  -   \npermalink: number-theory-notes-1\ndate: 2016-01-19 21:48:24\n---\n\n OI \n\n<!-- more -->\n\n### \n OI \n\n$$ \\gcd(a,b)=\\cases{ a & b = 0 \\\\ \\gcd(b,a \\ {\\rm mod} \\ b) & b  0 } $$\n\n```cpp\nint gcd(int a, int b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n```\n\n\n\n$$ {\\rm lcm}(a,b)=\\frac{a*b}{\\gcd(a,b)} $$\n\n\n\n```cpp\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\n```\n\n### \n `exgcd`  $\\gcd(a,b)$  $ax+by=\\gcd(a,b)$\n\n $\\gcd(47,30)$ \n\n$$\n\\begin{align*}\n& 47=30*1+17 \\\\\n& 30=17*1+13 \\\\\n& 17=13*1+4  \\\\\n& 13=4*3+1   \\\\\n\\end{align*}\n$$\n\n\n\n$$\n\\begin{align*}\n& 17=47+30*(-1) \\\\\n& 13=30+17*(-1) \\\\\n& 4=17+13*(-1)  \\\\\n& 1=13+4*(-3)   \\\\\n\\end{align*}\n$$\n\n $\\gcd(47,30)=1$ \n\n$$\n\\begin{align*}\n& \\gcd(47,30)             \\\\\n& =1                      \\\\\n& =13*1+4*(-3)            \\\\\n& =13*1+[17+13*(-1)]*(-3) \\\\\n& =13*4+17*(-3)           \\\\\n& =17*3+13*4              \\\\\n& =17*3+[30+17*(-1)]*4    \\\\\n& =17*(-7)+30*4           \\\\\n& =30*4+17*(-7)           \\\\\n& =30*4+[47+30*(-1)]*(-7) \\\\\n& =30*11+47*(-7)          \\\\\n& =47*(-7)+30*11          \\\\\n\\end{align*}\n$$\n\n $x=-7,y=11$\n\n `x`  `y` `y`  `x` \n\n```cpp\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n```\n\n### Eratosthenes \n\n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * 2; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n\n1.  $i^2$  $i$  $i'$$i*i'$  $i'$ \n2.  $[2,\\sqrt{n}]$  $p>\\sqrt{n}$ $k$  $p=k*k'$  $k< \\sqrt{n}$ $p$  $k$ \n\n```cpp\nbool isNotPrime[MAXN + 1];\nstd::vector<int> primes;\n\ninline void getPrimes(int n) {\n\tint m = floor(sqrt(n + 0.5));\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (isNotPrime[i]) continue;\n\t\tfor (int j = i * i; j <= n; j += i) isNotPrime[j] = true;\n\t}\n\n\tprimes.reserve(n);\n\tfor (int i = 2; i <= n; i++) if (!isNotPrime[i]) primes.push_back(i);\n}\n```\n\n### \n $n$  $k$  $i$  $a_i$\n\n$$ n={\\prod_{i=1}^{k}} \\ {p_i}^{a_i} $$\n\n $n$  $p_i$   \n\n$$ \\phi(n)={\\sum_{S{\\subseteq}\\{p_1,p_2,\\ldots,p_k\\}}{(-1)^{|S|}} *  {\\frac{n}{ {\\prod_{ {p_i}{\\in}S} } \\ p_i }}} $$\n\n\n\n$$ \\phi(n)=n*\\prod_{i=1}^{k} (1 - \\frac{1}{p_i}) $$\n\n $n$ $p$  $p-1$ \n\n $n$\n\n```cpp\nint phi() {\n\tint m = floor(sqrt(n + 0.5)), ans = n;\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (n % i == 0) {\n\t\t\tans = ans / i * (i - 1);\n\t\t\twhile (n % i == 0) n /= i;\n\t\t}\n\t}\n\n\tif (n != 1) ans = ans / n * (n - 1); // \n\treturn ans;\n}\n```\n\n \n","slug":"number-theory-notes-1","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c5j00jdc2xlk4a4ott5"},{"title":" std::stack  DFS","date":"2016-04-08T06:30:21.000Z","_content":"\n Windows  Windows  1M DFS  DFS\n\n<!-- more -->\n\n### \n DFS\n\n```c++\nvoid dfs(Iterator x) {\n\tx->visited = true;\n\tx->initialization();\n\tfor (Iterator i = x->subIterators.begin(); i != x->subIterators.end(); i++) {\n\t\tif (!i->visited) {\n\t\t\tx->pushDown(i);\n\t\t\tdfs(i);\n\t\t\tx->pushUpBack();\n\t\t} else x->pushUp(i);\n\t}\n\tx->exit();\n}\n```\n\n\n\n DFS \n\n```c++\nvoid dfs(Iterator start) {\n\tstd::stack<Iterator> s;\n\ts.push(start);\n\tstart->pushed = true;\n\n\twhile (!s.empty()) {\n\t\tIterator x = s.top();\n\n\t\tif (!x->visited) {\n\t\t\tx->visited = true;\n\t\t\tx->initialization();\n\t\t\tx->currentSubIterator = x->subIterators.begin();\n\t\t}\n\n\t\tif (x->currentSubIterator != x->subIterators.end()) {\n\t\t\tIterator &i = x->currentSubIterator;\n\t\t\tif (!i->pushed) {\n\t\t\t\tx->pushDown(i);\n\t\t\t\ti->predecessor = x;\n\t\t\t\ti->pushed = true;\n\t\t\t\ts.push(i);\n\t\t\t} else {\n\t\t\t\tx->pushUp(i);\n\t\t\t}\n\t\t\ti++;\n\t\t} else {\n\t\t\tx->exit();\n\t\t\tx->predecessor->pushUpBack(i);\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n```\n\n### Tarjan \n```c++\nstruct Node {\n    Edge *firstEdge, *currentEdge, *inEdge;\n    Connected *connected;\n    int dfn, low;\n    bool inStack, visited, pushed;\n} nodes[MAXN];\n\nstruct Edge {\n    Node *from, *to;\n    Edge *next;\n\n    Edge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n    int size;\n} connecteds[MAXN];\n\nint n;\n\ninline int tarjan() {\n    int timeStamp = 0, count = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (nodes[i].visited) continue;\n\n        std::stack<Node *> s, t;\n        s.push(&nodes[i]);\n        nodes[i].pushed = true;\n\n        while (!s.empty()) {\n            Node *v = s.top();\n\n            if (!v->visited) {\n                v->visited = true;\n                v->currentEdge = v->firstEdge;\n                v->dfn = v->low = timeStamp++;\n                v->inStack = true;\n                t.push(v);\n            }\n\n            if (v->currentEdge) {\n                Edge *&e = v->currentEdge;\n                if (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n                else if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n                e = e->next;\n            } else {\n                if (v->dfn == v->low) {\n                    v->connected = &connecteds[count++];\n                    Node *u;\n                    do {\n                        u = t.top();\n                        t.pop();\n                        u->inStack = false;\n                        u->connected = v->connected;\n                        u->connected->size++;\n                    } while (u != v);\n                }\n\n                if (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n                s.pop();\n            }\n        }\n    }\n\n    return count;\n}\n```\n\n### \n DFS \n\n```c++\nstruct Node {\n    Edge *e;\n    Node *c, *p;\n    int size, pos, posEnd;\n    bool visited;\n    Path *path;\n} N[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n\n    Edge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct Path {\n    Node *top;\n\n    Path(Node *top) : top(top) {}\n};\n\ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == NULL && e->t != v->p) e->t->p = v, s.push(e->t);\n        } else {\n            v->size = 1;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n                v->size += e->t->size;\n                if (v->c == NULL || v->c->size < e->t->size) v->c = e->t;\n            }\n\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].visited = false;\n\n    s.push(&N[0]);\n    int time = -1;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            v->pos = ++time;\n\n            if (!v->p || v != v->p->c) v->path = new Path(v);\n            else v->path = v->p->path;\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else v->posEnd = time, s.pop();\n    }\n}\n```\n","source":"_posts/non-recursion-dfs-with-stack.md","raw":"title:  std::stack  DFS\ncategories: OI\ntags: \n  - STL\n  - DFS\n  - \n  - Tarjan\n  - \n  - \npermalink: non-recursion-dfs-with-stack\ndate: 2016-04-08 14:30:21\n---\n\n Windows  Windows  1M DFS  DFS\n\n<!-- more -->\n\n### \n DFS\n\n```c++\nvoid dfs(Iterator x) {\n\tx->visited = true;\n\tx->initialization();\n\tfor (Iterator i = x->subIterators.begin(); i != x->subIterators.end(); i++) {\n\t\tif (!i->visited) {\n\t\t\tx->pushDown(i);\n\t\t\tdfs(i);\n\t\t\tx->pushUpBack();\n\t\t} else x->pushUp(i);\n\t}\n\tx->exit();\n}\n```\n\n\n\n DFS \n\n```c++\nvoid dfs(Iterator start) {\n\tstd::stack<Iterator> s;\n\ts.push(start);\n\tstart->pushed = true;\n\n\twhile (!s.empty()) {\n\t\tIterator x = s.top();\n\n\t\tif (!x->visited) {\n\t\t\tx->visited = true;\n\t\t\tx->initialization();\n\t\t\tx->currentSubIterator = x->subIterators.begin();\n\t\t}\n\n\t\tif (x->currentSubIterator != x->subIterators.end()) {\n\t\t\tIterator &i = x->currentSubIterator;\n\t\t\tif (!i->pushed) {\n\t\t\t\tx->pushDown(i);\n\t\t\t\ti->predecessor = x;\n\t\t\t\ti->pushed = true;\n\t\t\t\ts.push(i);\n\t\t\t} else {\n\t\t\t\tx->pushUp(i);\n\t\t\t}\n\t\t\ti++;\n\t\t} else {\n\t\t\tx->exit();\n\t\t\tx->predecessor->pushUpBack(i);\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n```\n\n### Tarjan \n```c++\nstruct Node {\n    Edge *firstEdge, *currentEdge, *inEdge;\n    Connected *connected;\n    int dfn, low;\n    bool inStack, visited, pushed;\n} nodes[MAXN];\n\nstruct Edge {\n    Node *from, *to;\n    Edge *next;\n\n    Edge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n    int size;\n} connecteds[MAXN];\n\nint n;\n\ninline int tarjan() {\n    int timeStamp = 0, count = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (nodes[i].visited) continue;\n\n        std::stack<Node *> s, t;\n        s.push(&nodes[i]);\n        nodes[i].pushed = true;\n\n        while (!s.empty()) {\n            Node *v = s.top();\n\n            if (!v->visited) {\n                v->visited = true;\n                v->currentEdge = v->firstEdge;\n                v->dfn = v->low = timeStamp++;\n                v->inStack = true;\n                t.push(v);\n            }\n\n            if (v->currentEdge) {\n                Edge *&e = v->currentEdge;\n                if (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n                else if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n                e = e->next;\n            } else {\n                if (v->dfn == v->low) {\n                    v->connected = &connecteds[count++];\n                    Node *u;\n                    do {\n                        u = t.top();\n                        t.pop();\n                        u->inStack = false;\n                        u->connected = v->connected;\n                        u->connected->size++;\n                    } while (u != v);\n                }\n\n                if (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n                s.pop();\n            }\n        }\n    }\n\n    return count;\n}\n```\n\n### \n DFS \n\n```c++\nstruct Node {\n    Edge *e;\n    Node *c, *p;\n    int size, pos, posEnd;\n    bool visited;\n    Path *path;\n} N[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n\n    Edge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct Path {\n    Node *top;\n\n    Path(Node *top) : top(top) {}\n};\n\ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == NULL && e->t != v->p) e->t->p = v, s.push(e->t);\n        } else {\n            v->size = 1;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n                v->size += e->t->size;\n                if (v->c == NULL || v->c->size < e->t->size) v->c = e->t;\n            }\n\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].visited = false;\n\n    s.push(&N[0]);\n    int time = -1;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            v->pos = ++time;\n\n            if (!v->p || v != v->p->c) v->path = new Path(v);\n            else v->path = v->p->path;\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else v->posEnd = time, s.pop();\n    }\n}\n```\n","slug":"non-recursion-dfs-with-stack","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c6500jjc2xl9q7yy1u2"},{"title":"NOIP2016 ","date":"2016-11-20T15:47:00.000Z","_content":"\n NOIP  \n NOIP\n\n<!-- more -->\n\n### Day0\n\n\n lwyz  %  10  \n\n zyzwjh  xzy  Erii\n\nDev-C++  VC6 Linux root  sda3  Windows  \n\n### Day1\nlyx  \n\n\n\n   DFS      + $ S_i = 1 $ \n\n Floyd $ m = 0 $  $ m = 1 $ $ m = 2 $  $ k = 1 $    DP \n\n zyz T2   T3  DP    \n\n     \n\n zyz \n\n### Day2\n\n\n Pascal  +  $ O(2000 ^ 2 + Tn) $ lyx  lyh    QAQ\n\n +  CCF   \n\n GDB  Windows  BugDFS  $ T = 5, n = 18 $  T BFS  $ O(T \\times (2 ^ n n ^ 2)) $ \n\n---\n\n\n\nDay1 Day2 \n\n   \n\n---\n\n>  \n  \n> \n\n> ","source":"_posts/noip2016.md","raw":"title: NOIP2016 \ncategories: Diary\npermalink: noip2016\ndate: 2016-11-20 23:47:00\n---\n\n NOIP  \n NOIP\n\n<!-- more -->\n\n### Day0\n\n\n lwyz  %  10  \n\n zyzwjh  xzy  Erii\n\nDev-C++  VC6 Linux root  sda3  Windows  \n\n### Day1\nlyx  \n\n\n\n   DFS      + $ S_i = 1 $ \n\n Floyd $ m = 0 $  $ m = 1 $ $ m = 2 $  $ k = 1 $    DP \n\n zyz T2   T3  DP    \n\n     \n\n zyz \n\n### Day2\n\n\n Pascal  +  $ O(2000 ^ 2 + Tn) $ lyx  lyh    QAQ\n\n +  CCF   \n\n GDB  Windows  BugDFS  $ T = 5, n = 18 $  T BFS  $ O(T \\times (2 ^ n n ^ 2)) $ \n\n---\n\n\n\nDay1 Day2 \n\n   \n\n---\n\n>  \n  \n> \n\n> ","slug":"noip2016","published":1,"updated":"2016-11-20T15:48:34.658Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c6f00jrc2xl7rm6u4go"},{"title":"NOIP2016 - ","date":"2016-11-29T03:25:00.000Z","_content":"\n\n\n\n\n `singer`  $ 3 $  $ 1 $  $ 2 $ \n\n \n\n\n\n`singer`  $ 3 $  `archer`  \n`archer`  $ 1 $  `thinker`  \n`thinker`  $ 2 $  `writer`\n\n `writer` \n\n\n\n $ n $  $ 1 $  $ m $  $ i $ / $ s_i $ \n\n<!-- more -->\n\n### \n[Luogu 1563](https://www.luogu.org/problem/show?pid=1563)  \n[LYOI #99](https://ly.men.ci/problem/99)\n\n### \n $ n $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1e5 + 10;\nconst int MAXM = 1e5 + 10;\n\nint main() {\n\tfreopen(\"toy.in\", \"r\", stdin);\n\tfreopen(\"toy.out\", \"w\", stdout);\n\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic struct Node {\n\t\tchar name[10 + 1];\n\t\tint opposite;\n\t} a[MAXN];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %s\", &a[i].opposite, a[i].name);\n\t}\n\n\tint curr = 0;\n\twhile (m--) {\n\t\t// printf(\"%d: %s\\n\", curr, a[curr].name);\n\n\t\tint k, s;\n\t\tscanf(\"%d %d\", &k, &s);\n\n\t\tint d = (k ^ a[curr].opposite) ? 1 : -1;\n\n\t\t(((curr += d * s) %= n) += n) %= n;\n\t}\n\n\tprintf(\"%s\\n\", a[curr].name);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2016-toy.md","raw":"title: NOIP2016 - \ncategories: OI\ntags: \n  - NOIP\n  - \npermalink: noip2016-toy\ndate: 2016-11-29 11:25:00\n---\n\n\n\n\n\n `singer`  $ 3 $  $ 1 $  $ 2 $ \n\n \n\n\n\n`singer`  $ 3 $  `archer`  \n`archer`  $ 1 $  `thinker`  \n`thinker`  $ 2 $  `writer`\n\n `writer` \n\n\n\n $ n $  $ 1 $  $ m $  $ i $ / $ s_i $ \n\n<!-- more -->\n\n### \n[Luogu 1563](https://www.luogu.org/problem/show?pid=1563)  \n[LYOI #99](https://ly.men.ci/problem/99)\n\n### \n $ n $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1e5 + 10;\nconst int MAXM = 1e5 + 10;\n\nint main() {\n\tfreopen(\"toy.in\", \"r\", stdin);\n\tfreopen(\"toy.out\", \"w\", stdout);\n\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic struct Node {\n\t\tchar name[10 + 1];\n\t\tint opposite;\n\t} a[MAXN];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %s\", &a[i].opposite, a[i].name);\n\t}\n\n\tint curr = 0;\n\twhile (m--) {\n\t\t// printf(\"%d: %s\\n\", curr, a[curr].name);\n\n\t\tint k, s;\n\t\tscanf(\"%d %d\", &k, &s);\n\n\t\tint d = (k ^ a[curr].opposite) ? 1 : -1;\n\n\t\t(((curr += d * s) %= n) += n) %= n;\n\t}\n\n\tprintf(\"%s\\n\", a[curr].name);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"noip2016-toy","published":1,"updated":"2016-11-29T07:36:08.883Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c6h00jtc2xlylaght2n"},{"title":"NOIP2016 -  + ","date":"2016-11-29T07:10:00.000Z","_content":"\n C \n\n $ n $  $ n - 1 $  $ 1 $  $ n $ \n\n $ m $  $ i $  $ S_i $ $ T_i $ $ 0 $  \n\n C  $ j $  $ W_j $  $ W_j $  $ j $ C \n\n $ j $  $ W_j $  $ j $  $ W_j $  $ j $ \n\n<!-- more -->\n\n### \n[Luogu 1600](https://www.luogu.org/problem/show?pid=1600)  \n[LYOI #100](https://ly.men.ci/problem/100)\n\n### \n $ L $  $ [0, L) $  $ S_j $  $ T_j $$ S_j < T_j $ $ i $  $ W_i = i - S_j $\n\n![](noip2016-running/linear-forward1.svg)\n\n $ S_j < 0 $ \n\n![](noip2016-running/linear-forward2.svg)\n\n $ S_j > T_j $  $ W_i = S_j - i $\n\n![](noip2016-running/linear-backward1.svg)\n\n$ S_j > L $ \n\n $ S_j < T_j $ $ S_j = i - W_i $ $ i $  $ X_i = i - W_i $\n\n1.  $ [S_j, T_j] $ \n2.  $ i $ $ X_i $\n\n $ S_j > T_j $ $ S_j = W_i + i $ $ X_i = i + W_i $ \n\n $ S_j $  $ T_j $  $ j $ $ j $\n\n $ O(n) $  $ O(\\log n) $  $ 0 $ $ S_j < T_j $  $ S_j > T_j $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <stack>\n\nconst int MAXN = 299998;\n\nstruct Tag {\n#ifdef FORCE\n\tint s, t, x;\n\n\tTag(int s, int t, int x) : s(s), t(t), x(x) {\n#ifdef DBG\n\t\tprintf(\"Tag(%d, %d, %d)\\n\", s, t, x);\n#endif\n\t}\n#else\n\tint x;\n\tbool remove;\n\n\tTag(int x, bool remove) : x(x), remove(remove) {}\n#endif\n};\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent, *child;\n\tint depth, size, w, index, x, ans;\n\tbool visited;\n\tstruct Chain *chain;\n#ifndef FORCE\n\tstd::vector<Tag> tagsForward, tagsBackward;\n#endif\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct Chain {\n\tNode *top, *bottom;\n\tstd::vector<Node *> nodes;\n#ifdef FORCE\n\tstd::vector<Tag> tagsForward, tagsBackward;\n#endif\n\tint len;\n} chains[MAXN + 1];\n\ninline void addEdge(int s, int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, chainCnt;\n\ninline void split() {\n\tstd::stack<Node *> s;\n\tN[1].depth = 1;\n\ts.push(&N[1]);\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->depth) {\n\t\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\t\te->t->parent = v;\n\t\t\t\t\ts.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (!v->child || v->child->size < e->t->size) v->child = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) N[i].visited = false;\n\n\tN[1].depth = 1;\n\ts.push(&N[1]);\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\n\t\t\tif (!v->parent || v != v->parent->child) {\n\t\t\t\tv->chain = &chains[++chainCnt];\n\t\t\t\tv->chain->top = v;\n\t\t\t\tv->index = 0;\n\t\t\t} else {\n\t\t\t\tv->chain = v->parent->chain;\n\t\t\t\tv->index = v->parent->index + 1;\n\t\t\t}\n\t\t\tv->chain->nodes.push_back(v);\n\t\t\tv->chain->bottom = v;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->parent == v) {\n\t\t\t\t\ts.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= chainCnt; i++) chains[i].len = chains[i].nodes.size();\n\n#ifdef DBG\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tprintf(\"chains[%d]: top = %lu, bottom = %lu, nodes = [\", i, chains[i].top - N, chains[i].bottom - N);\n\t\tfor (int j = 0; j < chains[i].len; j++) {\n\t\t\tprintf(\"%lu%s\", chains[i].nodes[j] - N, j == chains[i].len - 1 ? \"]\\n\" : \", \");\n\t\t}\n\t}\n#endif\n}\n\ninline Node *lca(Node *u, Node *v) {\n\twhile (u->chain != v->chain) {\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tu = u->chain->top->parent;\n\t}\n\tif (u->depth > v->depth) return v;\n\telse return u;\n}\n\ninline int dist(Node *u, Node *v, Node *p) {\n\treturn u->depth + v->depth - p->depth * 2;\n}\n\ninline void addTag(bool forward, Chain *chain, int s, int t, int x) {\n#ifdef FORCE\n\tif (forward) {\n\t\tchain->tagsForward.push_back(Tag(s, t, x));\n\t} else {\n\t\tchain->tagsBackward.push_back(Tag(s, t, x));\n\t}\n#else\n\tif (forward) {\n\t\tif (s > t) return;\n\t\tchain->nodes[s]->tagsForward.push_back(Tag(x, false));\n\t\tchain->nodes[t]->tagsForward.push_back(Tag(x, true));\n\t} else {\n\t\tif (t > s) return;\n\t\tchain->nodes[s]->tagsBackward.push_back(Tag(x, false));\n\t\tchain->nodes[t]->tagsBackward.push_back(Tag(x, true));\n\t}\n#ifdef DBG\n\tprintf(\"addTag(forward = %d, chain = %lu, s = %d, t = %d, x = %d)\\n\", forward, chain - chains, s, t, x);\n#endif\n#endif\n}\n\ninline void play(Node *s, Node *t) {\n\tif (s == t) {\n\t\tif (s->w == 0) s->ans++;\n\t\treturn;\n\t}\n\n\tNode *p = lca(s, t), *u = s, *v = t;\n\tif (dist(s, p, p) == p->w) p->ans++;\n#ifdef DBG\n\tprintf(\"play(s = %lu, t = %lu, p = %lu)\\n\", s - N, t - N, p - N);\n#endif\n\n\tif (p != s) {\n#ifdef DBG\n\t\tputs(\"[backward]\");\n#endif\n\t\t// S -> P, backward on chain\n\t\twhile (u->chain != p->chain) {\n#ifdef DBG\n\t\t\tprintf(\"chains[%lu]: \", u->chain - chains);\n#endif\n\t\t\taddTag(false, u->chain, u->index, 0, s->depth - u->chain->bottom->depth);\n\t\t\tu = u->chain->top->parent;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"chains[%lu]: \", u->chain - chains);\n#endif\n\t\taddTag(false, u->chain, u->index, p->index + 1, s->depth - u->chain->bottom->depth);\n\t}\n\n\tif (p != t) {\n#ifdef DBG\n\t\tputs(\"[forward]\");\n#endif\n\t\t// P -> T, forward on chain\n\t\twhile (v->chain != p->chain) {\n#ifdef DBG\n\t\t\tprintf(\"chains[%lu]: \", v->chain - chains);\n#endif\n\t\t\taddTag(true, v->chain, 0, v->index, (s->depth - p->depth) + (v->chain->top->depth - p->depth));\n\t\t\tv = v->chain->top->parent;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"chains[%lu]: \", v->chain - chains);\n#endif\n\t\taddTag(true, v->chain, p->index + 1, v->index, (s->depth - p->depth) + (v->chain->top->depth - p->depth));\n\t}\n}\n\ninline void solve() {\n#ifdef FORCE\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tChain &chain = chains[i];\n#ifdef DBG\n\t\tprintf(\"solve(): chains[%d]\\n\", i);\n#endif\n\n#ifdef DBG\n\t\tputs(\"[forward]\");\n#endif\n\t\tfor (std::vector<Tag>::const_iterator it = chain.tagsForward.begin(); it != chain.tagsForward.end(); it++) {\n\t\t\tfor (int j = it->s; j <= it->t; j++) {\n\t\t\t\tif (chain.nodes[j]->w - j == it->x) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"ans(%lu)++\\n\", chain.nodes[j] - N);\n#endif\n\t\t\t\t\tchain.nodes[j]->ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"[backward]\");\n#endif\n\t\tfor (std::vector<Tag>::const_iterator it = chain.tagsBackward.begin(); it != chain.tagsBackward.end(); it++) {\n\t\t\tfor (int j = it->s; j >= it->t; j--) {\n\t\t\t\tif (chain.nodes[j]->w - chain.len + j + 1 == it->x) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"ans(%lu)++\\n\", chain.nodes[j] - N);\n#endif\n\t\t\t\t\tchain.nodes[j]->ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#else\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tChain &chain = chains[i];\n#ifdef DBG\n\t\tprintf(\"solve(): chains[%d]\\n\", i);\n#endif\n\n\t\tstatic int _cnt[MAXN * 2 + 1], *cnt = _cnt + MAXN;\n\t\t\n\t\t// forward\n\t\tfor (int j = 0; j < chain.len; j++) {\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsForward.begin(); it != chain.nodes[j]->tagsForward.end(); it++) {\n\t\t\t\tif (!it->remove) cnt[it->x]++;\n\t\t\t}\n\n\t\t\tchain.nodes[j]->ans += cnt[chain.nodes[j]->w - j];\n#ifdef DBG\n\t\t\tprintf(\"ans(%lu, i = %d, j = %d) += %d, x = %d\\n\", chain.nodes[j] - N, i, j, cnt[chain.nodes[j]->w - j], chain.nodes[j]->w - j);\n#endif\n\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsForward.begin(); it != chain.nodes[j]->tagsForward.end(); it++) {\n\t\t\t\tif (it->remove) cnt[it->x]--;\n\t\t\t}\n\t\t}\n\n\t\t// backward\n\t\tfor (int j = chain.len - 1; j >= 0; j--) {\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsBackward.begin(); it != chain.nodes[j]->tagsBackward.end(); it++) {\n\t\t\t\tif (!it->remove) cnt[it->x]++;\n\t\t\t}\n\n\t\t\tchain.nodes[j]->ans += cnt[chain.nodes[j]->w - chain.len + j + 1];\n#ifdef DBG\n\t\t\tprintf(\"ans(%lu, i = %d, j = %d) += %d, x = %d\\n\", chain.nodes[j] - N, i, j, cnt[chain.nodes[j]->w - chain.len + j + 1], chain.nodes[j]->w - chain.len + j + 1);\n#endif\n\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsBackward.begin(); it != chain.nodes[j]->tagsBackward.end(); it++) {\n\t\t\t\tif (it->remove) cnt[it->x]--;\n\t\t\t}\n\t\t}\n\t}\n#endif\n}\n\nint main() {\n\tfreopen(\"running.in\", \"r\", stdin);\n\tfreopen(\"running.out\", \"w\", stdout);\n\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &N[i].w);\n\t}\n\n\tsplit();\n\n\twhile (m--) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tplay(&N[s], &N[t]);\n\t}\n\n\tsolve();\n\n\tfor (int i = 1; i <= n; i++) printf(\"%d%c\", N[i].ans, i == n ? '\\n' : ' ');\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2016-running.md","raw":"title: NOIP2016 -  + \ncategories: OI\ntags: \n  - NOIP\n  - \n  - \npermalink: noip2016-running\ndate: 2016-11-29 15:10:00\n---\n\n C \n\n $ n $  $ n - 1 $  $ 1 $  $ n $ \n\n $ m $  $ i $  $ S_i $ $ T_i $ $ 0 $  \n\n C  $ j $  $ W_j $  $ W_j $  $ j $ C \n\n $ j $  $ W_j $  $ j $  $ W_j $  $ j $ \n\n<!-- more -->\n\n### \n[Luogu 1600](https://www.luogu.org/problem/show?pid=1600)  \n[LYOI #100](https://ly.men.ci/problem/100)\n\n### \n $ L $  $ [0, L) $  $ S_j $  $ T_j $$ S_j < T_j $ $ i $  $ W_i = i - S_j $\n\n![](noip2016-running/linear-forward1.svg)\n\n $ S_j < 0 $ \n\n![](noip2016-running/linear-forward2.svg)\n\n $ S_j > T_j $  $ W_i = S_j - i $\n\n![](noip2016-running/linear-backward1.svg)\n\n$ S_j > L $ \n\n $ S_j < T_j $ $ S_j = i - W_i $ $ i $  $ X_i = i - W_i $\n\n1.  $ [S_j, T_j] $ \n2.  $ i $ $ X_i $\n\n $ S_j > T_j $ $ S_j = W_i + i $ $ X_i = i + W_i $ \n\n $ S_j $  $ T_j $  $ j $ $ j $\n\n $ O(n) $  $ O(\\log n) $  $ 0 $ $ S_j < T_j $  $ S_j > T_j $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <stack>\n\nconst int MAXN = 299998;\n\nstruct Tag {\n#ifdef FORCE\n\tint s, t, x;\n\n\tTag(int s, int t, int x) : s(s), t(t), x(x) {\n#ifdef DBG\n\t\tprintf(\"Tag(%d, %d, %d)\\n\", s, t, x);\n#endif\n\t}\n#else\n\tint x;\n\tbool remove;\n\n\tTag(int x, bool remove) : x(x), remove(remove) {}\n#endif\n};\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent, *child;\n\tint depth, size, w, index, x, ans;\n\tbool visited;\n\tstruct Chain *chain;\n#ifndef FORCE\n\tstd::vector<Tag> tagsForward, tagsBackward;\n#endif\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct Chain {\n\tNode *top, *bottom;\n\tstd::vector<Node *> nodes;\n#ifdef FORCE\n\tstd::vector<Tag> tagsForward, tagsBackward;\n#endif\n\tint len;\n} chains[MAXN + 1];\n\ninline void addEdge(int s, int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, chainCnt;\n\ninline void split() {\n\tstd::stack<Node *> s;\n\tN[1].depth = 1;\n\ts.push(&N[1]);\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->depth) {\n\t\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\t\te->t->parent = v;\n\t\t\t\t\ts.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (!v->child || v->child->size < e->t->size) v->child = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) N[i].visited = false;\n\n\tN[1].depth = 1;\n\ts.push(&N[1]);\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\n\t\t\tif (!v->parent || v != v->parent->child) {\n\t\t\t\tv->chain = &chains[++chainCnt];\n\t\t\t\tv->chain->top = v;\n\t\t\t\tv->index = 0;\n\t\t\t} else {\n\t\t\t\tv->chain = v->parent->chain;\n\t\t\t\tv->index = v->parent->index + 1;\n\t\t\t}\n\t\t\tv->chain->nodes.push_back(v);\n\t\t\tv->chain->bottom = v;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->parent == v) {\n\t\t\t\t\ts.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= chainCnt; i++) chains[i].len = chains[i].nodes.size();\n\n#ifdef DBG\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tprintf(\"chains[%d]: top = %lu, bottom = %lu, nodes = [\", i, chains[i].top - N, chains[i].bottom - N);\n\t\tfor (int j = 0; j < chains[i].len; j++) {\n\t\t\tprintf(\"%lu%s\", chains[i].nodes[j] - N, j == chains[i].len - 1 ? \"]\\n\" : \", \");\n\t\t}\n\t}\n#endif\n}\n\ninline Node *lca(Node *u, Node *v) {\n\twhile (u->chain != v->chain) {\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tu = u->chain->top->parent;\n\t}\n\tif (u->depth > v->depth) return v;\n\telse return u;\n}\n\ninline int dist(Node *u, Node *v, Node *p) {\n\treturn u->depth + v->depth - p->depth * 2;\n}\n\ninline void addTag(bool forward, Chain *chain, int s, int t, int x) {\n#ifdef FORCE\n\tif (forward) {\n\t\tchain->tagsForward.push_back(Tag(s, t, x));\n\t} else {\n\t\tchain->tagsBackward.push_back(Tag(s, t, x));\n\t}\n#else\n\tif (forward) {\n\t\tif (s > t) return;\n\t\tchain->nodes[s]->tagsForward.push_back(Tag(x, false));\n\t\tchain->nodes[t]->tagsForward.push_back(Tag(x, true));\n\t} else {\n\t\tif (t > s) return;\n\t\tchain->nodes[s]->tagsBackward.push_back(Tag(x, false));\n\t\tchain->nodes[t]->tagsBackward.push_back(Tag(x, true));\n\t}\n#ifdef DBG\n\tprintf(\"addTag(forward = %d, chain = %lu, s = %d, t = %d, x = %d)\\n\", forward, chain - chains, s, t, x);\n#endif\n#endif\n}\n\ninline void play(Node *s, Node *t) {\n\tif (s == t) {\n\t\tif (s->w == 0) s->ans++;\n\t\treturn;\n\t}\n\n\tNode *p = lca(s, t), *u = s, *v = t;\n\tif (dist(s, p, p) == p->w) p->ans++;\n#ifdef DBG\n\tprintf(\"play(s = %lu, t = %lu, p = %lu)\\n\", s - N, t - N, p - N);\n#endif\n\n\tif (p != s) {\n#ifdef DBG\n\t\tputs(\"[backward]\");\n#endif\n\t\t// S -> P, backward on chain\n\t\twhile (u->chain != p->chain) {\n#ifdef DBG\n\t\t\tprintf(\"chains[%lu]: \", u->chain - chains);\n#endif\n\t\t\taddTag(false, u->chain, u->index, 0, s->depth - u->chain->bottom->depth);\n\t\t\tu = u->chain->top->parent;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"chains[%lu]: \", u->chain - chains);\n#endif\n\t\taddTag(false, u->chain, u->index, p->index + 1, s->depth - u->chain->bottom->depth);\n\t}\n\n\tif (p != t) {\n#ifdef DBG\n\t\tputs(\"[forward]\");\n#endif\n\t\t// P -> T, forward on chain\n\t\twhile (v->chain != p->chain) {\n#ifdef DBG\n\t\t\tprintf(\"chains[%lu]: \", v->chain - chains);\n#endif\n\t\t\taddTag(true, v->chain, 0, v->index, (s->depth - p->depth) + (v->chain->top->depth - p->depth));\n\t\t\tv = v->chain->top->parent;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"chains[%lu]: \", v->chain - chains);\n#endif\n\t\taddTag(true, v->chain, p->index + 1, v->index, (s->depth - p->depth) + (v->chain->top->depth - p->depth));\n\t}\n}\n\ninline void solve() {\n#ifdef FORCE\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tChain &chain = chains[i];\n#ifdef DBG\n\t\tprintf(\"solve(): chains[%d]\\n\", i);\n#endif\n\n#ifdef DBG\n\t\tputs(\"[forward]\");\n#endif\n\t\tfor (std::vector<Tag>::const_iterator it = chain.tagsForward.begin(); it != chain.tagsForward.end(); it++) {\n\t\t\tfor (int j = it->s; j <= it->t; j++) {\n\t\t\t\tif (chain.nodes[j]->w - j == it->x) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"ans(%lu)++\\n\", chain.nodes[j] - N);\n#endif\n\t\t\t\t\tchain.nodes[j]->ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"[backward]\");\n#endif\n\t\tfor (std::vector<Tag>::const_iterator it = chain.tagsBackward.begin(); it != chain.tagsBackward.end(); it++) {\n\t\t\tfor (int j = it->s; j >= it->t; j--) {\n\t\t\t\tif (chain.nodes[j]->w - chain.len + j + 1 == it->x) {\n#ifdef DBG\n\t\t\t\t\tprintf(\"ans(%lu)++\\n\", chain.nodes[j] - N);\n#endif\n\t\t\t\t\tchain.nodes[j]->ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n#else\n\tfor (int i = 1; i <= chainCnt; i++) {\n\t\tChain &chain = chains[i];\n#ifdef DBG\n\t\tprintf(\"solve(): chains[%d]\\n\", i);\n#endif\n\n\t\tstatic int _cnt[MAXN * 2 + 1], *cnt = _cnt + MAXN;\n\t\t\n\t\t// forward\n\t\tfor (int j = 0; j < chain.len; j++) {\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsForward.begin(); it != chain.nodes[j]->tagsForward.end(); it++) {\n\t\t\t\tif (!it->remove) cnt[it->x]++;\n\t\t\t}\n\n\t\t\tchain.nodes[j]->ans += cnt[chain.nodes[j]->w - j];\n#ifdef DBG\n\t\t\tprintf(\"ans(%lu, i = %d, j = %d) += %d, x = %d\\n\", chain.nodes[j] - N, i, j, cnt[chain.nodes[j]->w - j], chain.nodes[j]->w - j);\n#endif\n\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsForward.begin(); it != chain.nodes[j]->tagsForward.end(); it++) {\n\t\t\t\tif (it->remove) cnt[it->x]--;\n\t\t\t}\n\t\t}\n\n\t\t// backward\n\t\tfor (int j = chain.len - 1; j >= 0; j--) {\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsBackward.begin(); it != chain.nodes[j]->tagsBackward.end(); it++) {\n\t\t\t\tif (!it->remove) cnt[it->x]++;\n\t\t\t}\n\n\t\t\tchain.nodes[j]->ans += cnt[chain.nodes[j]->w - chain.len + j + 1];\n#ifdef DBG\n\t\t\tprintf(\"ans(%lu, i = %d, j = %d) += %d, x = %d\\n\", chain.nodes[j] - N, i, j, cnt[chain.nodes[j]->w - chain.len + j + 1], chain.nodes[j]->w - chain.len + j + 1);\n#endif\n\n\t\t\tfor (std::vector<Tag>::const_iterator it = chain.nodes[j]->tagsBackward.begin(); it != chain.nodes[j]->tagsBackward.end(); it++) {\n\t\t\t\tif (it->remove) cnt[it->x]--;\n\t\t\t}\n\t\t}\n\t}\n#endif\n}\n\nint main() {\n\tfreopen(\"running.in\", \"r\", stdin);\n\tfreopen(\"running.out\", \"w\", stdout);\n\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &N[i].w);\n\t}\n\n\tsplit();\n\n\twhile (m--) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t);\n\t\tplay(&N[s], &N[t]);\n\t}\n\n\tsolve();\n\n\tfor (int i = 1; i <= n; i++) printf(\"%d%c\", N[i].ans, i == n ? '\\n' : ' ');\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"noip2016-running","published":1,"updated":"2016-11-29T07:36:19.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c6l00jyc2xlw2fnj5q9"},{"title":"NOIP2016 -  + ","date":"2016-11-29T12:54:00.000Z","_content":"\n $ n $  $ m $  $ (1, 2, 3) $  $ (1, 2) $$ (1, 3) $$ (2, 3) $ \n\n\n\n$$ C_n ^ m = \\frac{n!}{m!(n - m)!} $$\n\n $ n! = 1 \\times 2 \\times \\cdots \\times n $\n\n $ n $$ m $  $ k $ $ 0 \\leq i \\leq n $$ 0 \\leq j \\leq \\min(i, m) $  $ (i, j) $  $ k $ \n\n<!-- more -->\n\n### \n[Luogu 2822](https://www.luogu.org/problem/show?pid=2822)  \n[LYOI #102](https://ly.men.ci/problem/102)\n\n### \n Pascal \n\n$$ C_n ^ m = C_{n - 1} ^ {m - 1} + C_{n - 1} ^ {m} $$\n\n $ C_i ^ j \\bmod k $ $ s(u, i) $  $ 1 \\leq j \\leq i $ $ C_u ^ j \\bmod k = 0 $ $ O(n) $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 2000 + 10;\n\nint C[MAXN + 1][MAXN + 1], cnt[MAXN + 1][MAXN + 1];\n\nint main() {\n\tfreopen(\"problem.in\", \"r\", stdin);\n\tfreopen(\"problem.out\", \"w\", stdout);\n\t\n\tint t, k;\n\tscanf(\"%d %d\", &t, &k);\n\t\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tC[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % k;\n\t\t}\n\t\t\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tcnt[i][j] = cnt[i][j - 1];\n\t\t\tif (C[i][j] == 0) cnt[i][j]++;\n\t\t}\n\t}\n\t\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\t\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tans += cnt[i][std::min(i, m)];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n","source":"_posts/noip2016-problem.md","raw":"title: NOIP2016 -  + \ncategories: OI\ntags: \n  - NOIP\n  - \n  - \n  - \npermalink: noip2016-problem\ndate: 2016-11-29 20:54:00\n---\n\n $ n $  $ m $  $ (1, 2, 3) $  $ (1, 2) $$ (1, 3) $$ (2, 3) $ \n\n\n\n$$ C_n ^ m = \\frac{n!}{m!(n - m)!} $$\n\n $ n! = 1 \\times 2 \\times \\cdots \\times n $\n\n $ n $$ m $  $ k $ $ 0 \\leq i \\leq n $$ 0 \\leq j \\leq \\min(i, m) $  $ (i, j) $  $ k $ \n\n<!-- more -->\n\n### \n[Luogu 2822](https://www.luogu.org/problem/show?pid=2822)  \n[LYOI #102](https://ly.men.ci/problem/102)\n\n### \n Pascal \n\n$$ C_n ^ m = C_{n - 1} ^ {m - 1} + C_{n - 1} ^ {m} $$\n\n $ C_i ^ j \\bmod k $ $ s(u, i) $  $ 1 \\leq j \\leq i $ $ C_u ^ j \\bmod k = 0 $ $ O(n) $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 2000 + 10;\n\nint C[MAXN + 1][MAXN + 1], cnt[MAXN + 1][MAXN + 1];\n\nint main() {\n\tfreopen(\"problem.in\", \"r\", stdin);\n\tfreopen(\"problem.out\", \"w\", stdout);\n\t\n\tint t, k;\n\tscanf(\"%d %d\", &t, &k);\n\t\n\tfor (int i = 1; i <= MAXN; i++) {\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tC[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % k;\n\t\t}\n\t\t\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tcnt[i][j] = cnt[i][j - 1];\n\t\t\tif (C[i][j] == 0) cnt[i][j]++;\n\t\t}\n\t}\n\t\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\t\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tans += cnt[i][std::min(i, m)];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n","slug":"noip2016-problem","published":1,"updated":"2016-11-29T13:12:22.493Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c6u00k4c2xlc9y0x3gz"},{"title":"NOIP2016 - ","date":"2016-11-29T13:10:00.000Z","_content":"\n $ \\lfloor c \\rfloor $  $ c $ $ \\lfloor 3.0 \\rfloor = \\lfloor 3.1 \\rfloor = \\lfloor 3.9 \\rfloor = 3 $\n\n\n\n $ n $ $ n $  $ i $  $ a_i $$ i = 1, 2, \\ldots , n $ $ 0 $ \n\n $ p $ $ 0 < p < 1 $  $ x $ $ \\lfloor px \\rfloor $  $ x - \\lfloor px \\rfloor $  $ 0 $ $ 0 $  $ q $\n\n $ m $  $ m $ \n\n $ m $ \n\n* $ m $  $ m $ \n* $ m $  $ n + m $ \n\n \n\n<!-- more -->\n\n### \n[Luogu 2827](https://www.luogu.org/problem/show?pid=2827)  \n[LYOI #103](https://ly.men.ci/problem/103)\n\n### \n $ q = 0 $ \n\n $ q \\neq 0 $ \n\n $ O(n \\log n + m) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXM = 7000000;\n\ntemplate <typename T>\nstruct Queue {\n    T a[MAXN + MAXM], *l, *r;\n\n    Queue() : l(a), r(a - 1) {}\n\n    void push(const T &x) { *++r = x; }\n    void pop() { ++l; }\n    T &front() { return *l; }\n    bool empty() const { return l > r; }\n};\n\n#ifdef DBG\nstd::queue<int> q[3];\n#else\nQueue<int> q[3];\n#endif\n\ninline int getMax() {\n    int res = -1;\n    for (int i = 0; i < 3; i++) if (!q[i].empty() && (res == -1 || q[i].front() > q[res].front())) res = i;\n    return res;\n}\n\n#ifdef DBG\ninline void printAll(int d) {\n    std::vector<int> v;\n    for (int i = 0; i < 3; i++) {\n        std::queue<int> a = ::q[i];\n        while (!a.empty()) v.push_back(a.front()), a.pop();\n    }\n    std::sort(v.begin(), v.end());\n    printf(\"%lu: \", v.size());\n    for (std::vector<int>::iterator it = v.begin(); it != v.end(); it++) printf(\"%d%c\", *it, it == --v.end() ? '\\n' : ' ');\n}\n#endif\n\nint main() {\n    freopen(\"earthworm.in\", \"r\", stdin);\n    freopen(\"earthworm.out\", \"w\", stdout);\n\n    int n, m, k, u, v, t;\n    scanf(\"%d %d %d %d %d %d\", &n, &m, &k, &u, &v, &t);\n\n    static int a[MAXN + 1];\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n    std::sort(a + 1, a + n + 1);\n\n    for (int i = n; i >= 1; i--) q[0].push(a[i]);\n\n    int d = 0;\n    for (int i = 1; i <= m; i++) {\n        int j = getMax();\n\n        int x = q[j].front();\n        q[j].pop();\n\n        x += d;\n\n        if (i % t == 0) printf(\"%d \", x);\n\n        int a = static_cast<long long>(x) * u / v, b = x - a;\n\n        d += k;\n        a -= d, b -= d;\n\n        q[1].push(a), q[2].push(b);\n    }\n\n    putchar('\\n');\n\n    for (int i = 1; i <= n + m; i++) {\n        int j = getMax();\n        int x = q[j].front();\n        q[j].pop();\n\n        x += d;\n\n        if (i % t == 0) printf(\"%d \", x);\n    }\n\n    putchar('\\n');\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```","source":"_posts/noip2016-earthworm.md","raw":"title: NOIP2016 - \ncategories: OI\ntags: \n  - NOIP\n  - \npermalink: noip2016-earthworm\ndate: 2016-11-29 21:10:00\n---\n\n $ \\lfloor c \\rfloor $  $ c $ $ \\lfloor 3.0 \\rfloor = \\lfloor 3.1 \\rfloor = \\lfloor 3.9 \\rfloor = 3 $\n\n\n\n $ n $ $ n $  $ i $  $ a_i $$ i = 1, 2, \\ldots , n $ $ 0 $ \n\n $ p $ $ 0 < p < 1 $  $ x $ $ \\lfloor px \\rfloor $  $ x - \\lfloor px \\rfloor $  $ 0 $ $ 0 $  $ q $\n\n $ m $  $ m $ \n\n $ m $ \n\n* $ m $  $ m $ \n* $ m $  $ n + m $ \n\n \n\n<!-- more -->\n\n### \n[Luogu 2827](https://www.luogu.org/problem/show?pid=2827)  \n[LYOI #103](https://ly.men.ci/problem/103)\n\n### \n $ q = 0 $ \n\n $ q \\neq 0 $ \n\n $ O(n \\log n + m) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXM = 7000000;\n\ntemplate <typename T>\nstruct Queue {\n    T a[MAXN + MAXM], *l, *r;\n\n    Queue() : l(a), r(a - 1) {}\n\n    void push(const T &x) { *++r = x; }\n    void pop() { ++l; }\n    T &front() { return *l; }\n    bool empty() const { return l > r; }\n};\n\n#ifdef DBG\nstd::queue<int> q[3];\n#else\nQueue<int> q[3];\n#endif\n\ninline int getMax() {\n    int res = -1;\n    for (int i = 0; i < 3; i++) if (!q[i].empty() && (res == -1 || q[i].front() > q[res].front())) res = i;\n    return res;\n}\n\n#ifdef DBG\ninline void printAll(int d) {\n    std::vector<int> v;\n    for (int i = 0; i < 3; i++) {\n        std::queue<int> a = ::q[i];\n        while (!a.empty()) v.push_back(a.front()), a.pop();\n    }\n    std::sort(v.begin(), v.end());\n    printf(\"%lu: \", v.size());\n    for (std::vector<int>::iterator it = v.begin(); it != v.end(); it++) printf(\"%d%c\", *it, it == --v.end() ? '\\n' : ' ');\n}\n#endif\n\nint main() {\n    freopen(\"earthworm.in\", \"r\", stdin);\n    freopen(\"earthworm.out\", \"w\", stdout);\n\n    int n, m, k, u, v, t;\n    scanf(\"%d %d %d %d %d %d\", &n, &m, &k, &u, &v, &t);\n\n    static int a[MAXN + 1];\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n    std::sort(a + 1, a + n + 1);\n\n    for (int i = n; i >= 1; i--) q[0].push(a[i]);\n\n    int d = 0;\n    for (int i = 1; i <= m; i++) {\n        int j = getMax();\n\n        int x = q[j].front();\n        q[j].pop();\n\n        x += d;\n\n        if (i % t == 0) printf(\"%d \", x);\n\n        int a = static_cast<long long>(x) * u / v, b = x - a;\n\n        d += k;\n        a -= d, b -= d;\n\n        q[1].push(a), q[2].push(b);\n    }\n\n    putchar('\\n');\n\n    for (int i = 1; i <= n + m; i++) {\n        int j = getMax();\n        int x = q[j].front();\n        q[j].pop();\n\n        x += d;\n\n        if (i % t == 0) printf(\"%d \", x);\n    }\n\n    putchar('\\n');\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```","slug":"noip2016-earthworm","published":1,"updated":"2016-11-29T13:11:22.980Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c6y00kac2xlsvcveua9"},{"title":"NOIP2016 - Floyd + DP + ","date":"2016-11-29T07:35:00.000Z","_content":"\n\n\n $ 2n $  $ n $  $ i $ $ 1 \\leq  i \\leq n $ $ c_i $  $ d_i $ \n\n $ n $ i $ i $  $ d_i $  $ c_i $ \n\n $ i $  $ k_i $\n\n $ m $  $ m $  $ m $ \n\n\n\n $ v $  $ e $  $ i $$ 1 \\leq i \\leq n - 1 $\n\n\n\n<!-- more -->\n\n### \n[Luogu 1850](https://www.luogu.org/problem/show?pid=1850)  \n[LYOI #101](https://ly.men.ci/problem/101)\n\n### \n Floyd  $ f(i, j, k) $  $ i $  $ j $ $ k \\in \\{ 0, 1 \\} $  $ i $ \n\n $ f(i, j, 0) $ \n\n$$\nf(i, j, 0) = \\min\n\\begin{cases}\nf(i - 1, j, 0) + \\mathrm{dist}(c(i - 1), c(i)) \\\\ \\\\\n\\begin{aligned}\nf(i - 1, j, 1) & + \\mathrm{dist}(d(i - 1), c(i)) \\times k(i - 1) \\\\\n& + \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i - 1))\n\\end{aligned}\n\\end{cases}\n$$\n\n$ f(i, j, 1) $ \n\n$$\nf(i, j, 1) = \\min\n\\begin{cases}\n\\begin{aligned}\nf(i - 1, j - 1, 0) &+ \\mathrm{dist}(c(i - 1), d(i)) \\times k(i) \\\\\n&+ \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i))\n\\end{aligned}\n\\\\ \\\\\n\\begin{aligned}\nf(i - 1, j - 1, 1) &+ \\mathrm{dist}(d(i - 1), d(i)) \\times k(i - 1) \\times k(i) \\\\\n&+ \\mathrm{dist}(c(i - 1), d(i)) \\times (1 - k(i - 1)) \\times k(i) \\\\\n&+ \\mathrm{dist}(d(i - 1), c(i)) \\times k(i - 1) \\times (1 - k(i)) \\\\\n&+ \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i - 1)) \\times (1 - k(i))\n\\end{aligned}\n\\end{cases}\n$$\n\n\n\n$$\n\\begin{aligned}\nf(i, 0, 1) &= +\\infty \\\\\nf(1, 0, 0) &= 0\n\\end{aligned}\n$$\n\n $ O(v ^ 3 + nm) $\n\n### \n```c++\n#include <cstdio>\n#include <cfloat>\n#include <climits>\n#include <algorithm>\n\nconst int MAXCNT = 2000;\nconst int MAXN = 300;\n\nint cnt, max, n, c[MAXCNT + 1], d[MAXCNT + 1], g[MAXN + 1][MAXN + 1];\ndouble k[MAXCNT + 1];\n\nint main() {\n\tfreopen(\"classroom.in\", \"r\", stdin);\n\tfreopen(\"classroom.out\", \"w\", stdout);\n\n\tint m;\n\tscanf(\"%d %d %d %d\", &cnt, &max, &n, &m);\n\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%d\", &c[i]);\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%d\", &d[i]);\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%lf\", &k[i]);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tg[i][j] = INT_MAX;\n\t\t}\n\t}\n\n\twhile (m--) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tg[u][v] = g[v][u] = std::min(g[u][v], w);\n\t}\n\n\tfor (int k = 1; k <= n; k++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (g[i][k] != INT_MAX && g[k][j] != INT_MAX && g[i][j] > g[i][k] + g[k][j]) {\n\t\t\t\t\tg[i][j] = g[i][k] + g[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) g[i][i] = 0;\n\n\tstatic double f[MAXCNT + 1][MAXCNT + 1][2];\n\tf[1][0][0] = 0;\n\tf[1][0][1] = DBL_MAX;\n\n\tfor (int i = 2; i <= cnt; i++) {\n\t\tf[i][0][0] = f[i - 1][0][0] + g[c[i - 1]][c[i]];\n\t\tf[i][0][1] = DBL_MAX;\n\n\t\tfor (int j = 1; j <= max; j++) {\n\t\t\tf[i][j][0] = f[i][j][1] = DBL_MAX;\n\n\t\t\tif (f[i - 1][j][0] != DBL_MAX) {\n\t\t\t\tf[i][j][0] = std::min(f[i][j][0], f[i - 1][j][0] + g[c[i - 1]][c[i]]);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j][1] != DBL_MAX) {\n\t\t\t\tf[i][j][0] = std::min(f[i][j][0], f[i - 1][j][1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][c[i]] * k[i - 1])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i - 1]))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j - 1][0] != DBL_MAX) {\n\t\t\t\tf[i][j][1] = std::min(f[i][j][1], f[i - 1][j - 1][0]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][d[i]] * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i]))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j - 1][1] != DBL_MAX) {\n\t\t\t\tf[i][j][1] = std::min(f[i][j][1], f[i - 1][j - 1][1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][d[i]] * k[i - 1] * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][d[i]] * (1 - k[i - 1]) * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][c[i]] * k[i - 1] * (1 - k[i]))\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i - 1]) * (1 - k[i]))\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tfor (int j = 0; j <= max; j++) {\n\t\t\tprintf(\"f[%d][%d][0] = %.4lf\\n\", i, j, f[i][j][0]);\n\t\t\tprintf(\"f[%d][%d][1] = %.4lf\\n\", i, j, f[i][j][1]);\n\t\t}\n#endif\n\t}\n\n\tdouble ans = DBL_MAX;\n\tfor (int i = 0; i <= max; i++) {\n\t\tans = std::min(ans, f[cnt][i][0]);\n\t\tans = std::min(ans, f[cnt][i][1]);\n\t}\n\n\tprintf(\"%.2lf\\n\", ans);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2016-classroom.md","raw":"title: NOIP2016 - Floyd + DP + \ncategories: OI\ntags: \n  - NOIP\n  - DP\n  - Floyd\n  - \npermalink: noip2016-classroom\ndate: 2016-11-29 15:35:00\n---\n\n\n\n $ 2n $  $ n $  $ i $ $ 1 \\leq  i \\leq n $ $ c_i $  $ d_i $ \n\n $ n $ i $ i $  $ d_i $  $ c_i $ \n\n $ i $  $ k_i $\n\n $ m $  $ m $  $ m $ \n\n\n\n $ v $  $ e $  $ i $$ 1 \\leq i \\leq n - 1 $\n\n\n\n<!-- more -->\n\n### \n[Luogu 1850](https://www.luogu.org/problem/show?pid=1850)  \n[LYOI #101](https://ly.men.ci/problem/101)\n\n### \n Floyd  $ f(i, j, k) $  $ i $  $ j $ $ k \\in \\{ 0, 1 \\} $  $ i $ \n\n $ f(i, j, 0) $ \n\n$$\nf(i, j, 0) = \\min\n\\begin{cases}\nf(i - 1, j, 0) + \\mathrm{dist}(c(i - 1), c(i)) \\\\ \\\\\n\\begin{aligned}\nf(i - 1, j, 1) & + \\mathrm{dist}(d(i - 1), c(i)) \\times k(i - 1) \\\\\n& + \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i - 1))\n\\end{aligned}\n\\end{cases}\n$$\n\n$ f(i, j, 1) $ \n\n$$\nf(i, j, 1) = \\min\n\\begin{cases}\n\\begin{aligned}\nf(i - 1, j - 1, 0) &+ \\mathrm{dist}(c(i - 1), d(i)) \\times k(i) \\\\\n&+ \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i))\n\\end{aligned}\n\\\\ \\\\\n\\begin{aligned}\nf(i - 1, j - 1, 1) &+ \\mathrm{dist}(d(i - 1), d(i)) \\times k(i - 1) \\times k(i) \\\\\n&+ \\mathrm{dist}(c(i - 1), d(i)) \\times (1 - k(i - 1)) \\times k(i) \\\\\n&+ \\mathrm{dist}(d(i - 1), c(i)) \\times k(i - 1) \\times (1 - k(i)) \\\\\n&+ \\mathrm{dist}(c(i - 1), c(i)) \\times (1 - k(i - 1)) \\times (1 - k(i))\n\\end{aligned}\n\\end{cases}\n$$\n\n\n\n$$\n\\begin{aligned}\nf(i, 0, 1) &= +\\infty \\\\\nf(1, 0, 0) &= 0\n\\end{aligned}\n$$\n\n $ O(v ^ 3 + nm) $\n\n### \n```c++\n#include <cstdio>\n#include <cfloat>\n#include <climits>\n#include <algorithm>\n\nconst int MAXCNT = 2000;\nconst int MAXN = 300;\n\nint cnt, max, n, c[MAXCNT + 1], d[MAXCNT + 1], g[MAXN + 1][MAXN + 1];\ndouble k[MAXCNT + 1];\n\nint main() {\n\tfreopen(\"classroom.in\", \"r\", stdin);\n\tfreopen(\"classroom.out\", \"w\", stdout);\n\n\tint m;\n\tscanf(\"%d %d %d %d\", &cnt, &max, &n, &m);\n\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%d\", &c[i]);\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%d\", &d[i]);\n\tfor (int i = 1; i <= cnt; i++) scanf(\"%lf\", &k[i]);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tg[i][j] = INT_MAX;\n\t\t}\n\t}\n\n\twhile (m--) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tg[u][v] = g[v][u] = std::min(g[u][v], w);\n\t}\n\n\tfor (int k = 1; k <= n; k++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (g[i][k] != INT_MAX && g[k][j] != INT_MAX && g[i][j] > g[i][k] + g[k][j]) {\n\t\t\t\t\tg[i][j] = g[i][k] + g[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) g[i][i] = 0;\n\n\tstatic double f[MAXCNT + 1][MAXCNT + 1][2];\n\tf[1][0][0] = 0;\n\tf[1][0][1] = DBL_MAX;\n\n\tfor (int i = 2; i <= cnt; i++) {\n\t\tf[i][0][0] = f[i - 1][0][0] + g[c[i - 1]][c[i]];\n\t\tf[i][0][1] = DBL_MAX;\n\n\t\tfor (int j = 1; j <= max; j++) {\n\t\t\tf[i][j][0] = f[i][j][1] = DBL_MAX;\n\n\t\t\tif (f[i - 1][j][0] != DBL_MAX) {\n\t\t\t\tf[i][j][0] = std::min(f[i][j][0], f[i - 1][j][0] + g[c[i - 1]][c[i]]);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j][1] != DBL_MAX) {\n\t\t\t\tf[i][j][0] = std::min(f[i][j][0], f[i - 1][j][1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][c[i]] * k[i - 1])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i - 1]))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j - 1][0] != DBL_MAX) {\n\t\t\t\tf[i][j][1] = std::min(f[i][j][1], f[i - 1][j - 1][0]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][d[i]] * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i]))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (f[i - 1][j - 1][1] != DBL_MAX) {\n\t\t\t\tf[i][j][1] = std::min(f[i][j][1], f[i - 1][j - 1][1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][d[i]] * k[i - 1] * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][d[i]] * (1 - k[i - 1]) * k[i])\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[d[i - 1]][c[i]] * k[i - 1] * (1 - k[i]))\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ (g[c[i - 1]][c[i]] * (1 - k[i - 1]) * (1 - k[i]))\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tfor (int j = 0; j <= max; j++) {\n\t\t\tprintf(\"f[%d][%d][0] = %.4lf\\n\", i, j, f[i][j][0]);\n\t\t\tprintf(\"f[%d][%d][1] = %.4lf\\n\", i, j, f[i][j][1]);\n\t\t}\n#endif\n\t}\n\n\tdouble ans = DBL_MAX;\n\tfor (int i = 0; i <= max; i++) {\n\t\tans = std::min(ans, f[cnt][i][0]);\n\t\tans = std::min(ans, f[cnt][i][1]);\n\t}\n\n\tprintf(\"%.2lf\\n\", ans);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"noip2016-classroom","published":1,"updated":"2016-11-29T07:36:33.407Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c7100kfc2xlshvblmw1"},{"title":"NOIP2016 -  + BFS","date":"2016-11-29T13:21:00.000Z","_content":"\nKiana \n\n\n\n $ (0, 0) $  Kiana  $ y = ax ^ 2 + bx $  $ a $$ b $  Kiana  $ a < 0 $\n\n $ x $ \n\n $ n $  $ i $  $ (x_i, y_i) $\n\n$ (x_i, y_i) $ $ i $ \n\n$ (x_i, y_i) $ $ i $ \n\n $ (1, 3) $  $ (3, 3) $Kiana  $ y = -x ^ 2 + 4x $ \n\n\n\n Kiana  Kiana \n\n $ T $  Kiana \n\n<!-- more -->\n\n### \n[Luogu 2831](https://www.luogu.org/problem/show?pid=2831)  \n[LYOI #104](https://ly.men.ci/problem/104)\n\n### \n $ y = ax ^ 2 + bx + c $  $ c $  $ a \\leq 0 $  $ O(n ^ 2) $ \n\nBFS \n\n $ O(2 ^ n n ^ 2) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 18 + 3;\nconst int MAXSTATUS = (1 << (MAXN + 1));\nconst double EPS = 1e-6;\n\nstruct Point {\n    double x, y;\n    \n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n} a[MAXN];\n\ninline bool dcmp(double x) {\n    return fabs(x) <= EPS;\n}\n\ninline bool dcmp(double x, double y) {\n    return dcmp(x - y);\n}\n\nstruct Line {\n    double a, b;\n    bool valid;\n    unsigned int kill;\n    \n    Line(unsigned int kill = 0) : a(0), b(0), valid(true), kill(kill) {}\n    \n    bool operator<(const Line &other) const {\n        return kill > other.kill;\n    }\n    \n    bool operator==(const Line &other) const {\n        return kill == other.kill;\n    }\n} lines[MAXN * MAXN];\n\nstruct Node {\n    bool visited;\n    int dist;\n} N[MAXSTATUS];\n\nint n, cmd, limit, lineCnt;\n\n/*\n#ifdef DBG\ninline void print(int s) {\n    for (int i = 0; i < n; i++) putchar((s & (1u << i)) ? '1' : '0');\n}\n#endif\n*/\n\ninline int bfs(int status) {\n    if (!status) return 0;\n    \n    std::queue<int> q;\n    q.push(status);\n    N[status].visited = true;\n    N[status].dist = 0;\n    \n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        \n        if (N[v].dist == limit) continue;\n        \n        for (int i = 1; i <= lineCnt; i++) {\n            Line &l = lines[i];\n            if (l.valid && (l.kill & status)) {\n                int u = v;\n                u &= ~l.kill;\n                \n                if (!N[u].visited) {\n                    N[u].visited = true;\n                    N[u].dist = N[v].dist + 1;\n                    if (!u) return N[u].dist;\n                    q.push(u);\n                }\n            }\n        }\n    }\n    \n    return n;\n}\n\n/*\ninline void massert(bool x) {\n    if (!x) {\n        int b = 0;\n        b = 1;\n        b = 2;\n    }\n}\n*/\n\ninline Line getLine(const Point &a, const Point &b) {\n    Line l;\n//    printf(\"%lf %lf %u\\n\", l.a, l.b, l.kill);\n    // a = (x1 * y2 - x2 * y1) / (x1 * x2 ^ 2 - x2 * x1 ^ 2)\n    l.a = (a.x * b.y - b.x * a.y) / (a.x * b.x * b.x - b.x * a.x * a.x);\n    // b = (y1 - a * x1 ^ 2) / x1\n    l.b = (a.y - l.a * a.x * a.x) / a.x;\n//    printf(\"%lf %lf %u\\n\", l.a, l.b, l.kill);\n//    if (!dcmp(l.b, (b.y - l.a * b.x * b.x) / b.x)) {\n//        printf(\"ERROR: %lf %lf\\n\", l.b, (b.y - l.a * b.x * b.x) / b.x);\n//    }\n    return l;\n}\n\ninline bool onLine(const Line &l, const Point &a) {\n    return dcmp(l.a * a.x * a.x + l.b * a.x, a.y);\n}\n\ninline int solve() {\n    bool flags[MAXN];\n    for (int i = 1; i <= n; i++) flags[i] = false;\n    for (int i = 1; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            if (dcmp(a[i].x, a[j].x)) continue;\n            Line l = getLine(a[i], a[j]);\n            if (l.a >= 0) continue;\n            \n            flags[i] = flags[j] = true;\n            lines[++lineCnt] = l;\n        }\n    }\n    \n    for (int i = 1; i <= lineCnt; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (onLine(lines[i], a[j])) {\n                lines[i].kill |= (1u << (j - 1));\n            }\n        }\n        /*\n#ifdef DBG\n        printf(\"[a = %lf, b = %lf]: \", lines[i].a, lines[i].b);\n        print(lines[i].kill);\n        putchar('\\n');\n#endif\n        */\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        if (!flags[i]) {\n            lines[++lineCnt] = Line(1u << (i - 1));\n        }\n    }\n        \n    std::sort(lines + 1, lines + lineCnt + 1);\n    \n    for (int i = 1; i <= lineCnt; i++) {\n        for (int j = i + 1; j <= lineCnt; j++) {\n            if ((lines[i].kill | lines[j].kill) == lines[i].kill) {\n                lines[j].valid = false;\n            }\n        }\n    }\n    \n    for (unsigned int i = 0; i < (1u << n); i++) {\n        N[i].visited = false;\n    }\n    \n    return bfs((1u << n) - 1);\n}\n\nint main() {\n    freopen(\"angrybirds.in\", \"r\", stdin);\n    freopen(\"angrybirds.out\", \"w\", stdout);\n    \n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        scanf(\"%d %d\", &n, &cmd);\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%lf %lf\", &a[i].x, &a[i].y);\n        }\n        lineCnt = 0;\n        \n        if (cmd == 1) {\n            limit = ceil(double(n) / 3 + 1);\n        } else {\n            limit = n;\n        }\n        \n        printf(\"%d\\n\", solve());\n    }\n    \n    fclose(stdin);\n    fclose(stdout);\n}\n```","source":"_posts/noip2016-angrybirds.md","raw":"title: NOIP2016 -  + BFS\ncategories: OI\ntags: \n  - NOIP\n  - \n  - \n  - BFS\npermalink: noip2016-angrybirds\ndate: 2016-11-29 21:21:00\n---\n\nKiana \n\n\n\n $ (0, 0) $  Kiana  $ y = ax ^ 2 + bx $  $ a $$ b $  Kiana  $ a < 0 $\n\n $ x $ \n\n $ n $  $ i $  $ (x_i, y_i) $\n\n$ (x_i, y_i) $ $ i $ \n\n$ (x_i, y_i) $ $ i $ \n\n $ (1, 3) $  $ (3, 3) $Kiana  $ y = -x ^ 2 + 4x $ \n\n\n\n Kiana  Kiana \n\n $ T $  Kiana \n\n<!-- more -->\n\n### \n[Luogu 2831](https://www.luogu.org/problem/show?pid=2831)  \n[LYOI #104](https://ly.men.ci/problem/104)\n\n### \n $ y = ax ^ 2 + bx + c $  $ c $  $ a \\leq 0 $  $ O(n ^ 2) $ \n\nBFS \n\n $ O(2 ^ n n ^ 2) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 18 + 3;\nconst int MAXSTATUS = (1 << (MAXN + 1));\nconst double EPS = 1e-6;\n\nstruct Point {\n    double x, y;\n    \n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n} a[MAXN];\n\ninline bool dcmp(double x) {\n    return fabs(x) <= EPS;\n}\n\ninline bool dcmp(double x, double y) {\n    return dcmp(x - y);\n}\n\nstruct Line {\n    double a, b;\n    bool valid;\n    unsigned int kill;\n    \n    Line(unsigned int kill = 0) : a(0), b(0), valid(true), kill(kill) {}\n    \n    bool operator<(const Line &other) const {\n        return kill > other.kill;\n    }\n    \n    bool operator==(const Line &other) const {\n        return kill == other.kill;\n    }\n} lines[MAXN * MAXN];\n\nstruct Node {\n    bool visited;\n    int dist;\n} N[MAXSTATUS];\n\nint n, cmd, limit, lineCnt;\n\n/*\n#ifdef DBG\ninline void print(int s) {\n    for (int i = 0; i < n; i++) putchar((s & (1u << i)) ? '1' : '0');\n}\n#endif\n*/\n\ninline int bfs(int status) {\n    if (!status) return 0;\n    \n    std::queue<int> q;\n    q.push(status);\n    N[status].visited = true;\n    N[status].dist = 0;\n    \n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        \n        if (N[v].dist == limit) continue;\n        \n        for (int i = 1; i <= lineCnt; i++) {\n            Line &l = lines[i];\n            if (l.valid && (l.kill & status)) {\n                int u = v;\n                u &= ~l.kill;\n                \n                if (!N[u].visited) {\n                    N[u].visited = true;\n                    N[u].dist = N[v].dist + 1;\n                    if (!u) return N[u].dist;\n                    q.push(u);\n                }\n            }\n        }\n    }\n    \n    return n;\n}\n\n/*\ninline void massert(bool x) {\n    if (!x) {\n        int b = 0;\n        b = 1;\n        b = 2;\n    }\n}\n*/\n\ninline Line getLine(const Point &a, const Point &b) {\n    Line l;\n//    printf(\"%lf %lf %u\\n\", l.a, l.b, l.kill);\n    // a = (x1 * y2 - x2 * y1) / (x1 * x2 ^ 2 - x2 * x1 ^ 2)\n    l.a = (a.x * b.y - b.x * a.y) / (a.x * b.x * b.x - b.x * a.x * a.x);\n    // b = (y1 - a * x1 ^ 2) / x1\n    l.b = (a.y - l.a * a.x * a.x) / a.x;\n//    printf(\"%lf %lf %u\\n\", l.a, l.b, l.kill);\n//    if (!dcmp(l.b, (b.y - l.a * b.x * b.x) / b.x)) {\n//        printf(\"ERROR: %lf %lf\\n\", l.b, (b.y - l.a * b.x * b.x) / b.x);\n//    }\n    return l;\n}\n\ninline bool onLine(const Line &l, const Point &a) {\n    return dcmp(l.a * a.x * a.x + l.b * a.x, a.y);\n}\n\ninline int solve() {\n    bool flags[MAXN];\n    for (int i = 1; i <= n; i++) flags[i] = false;\n    for (int i = 1; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            if (dcmp(a[i].x, a[j].x)) continue;\n            Line l = getLine(a[i], a[j]);\n            if (l.a >= 0) continue;\n            \n            flags[i] = flags[j] = true;\n            lines[++lineCnt] = l;\n        }\n    }\n    \n    for (int i = 1; i <= lineCnt; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (onLine(lines[i], a[j])) {\n                lines[i].kill |= (1u << (j - 1));\n            }\n        }\n        /*\n#ifdef DBG\n        printf(\"[a = %lf, b = %lf]: \", lines[i].a, lines[i].b);\n        print(lines[i].kill);\n        putchar('\\n');\n#endif\n        */\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        if (!flags[i]) {\n            lines[++lineCnt] = Line(1u << (i - 1));\n        }\n    }\n        \n    std::sort(lines + 1, lines + lineCnt + 1);\n    \n    for (int i = 1; i <= lineCnt; i++) {\n        for (int j = i + 1; j <= lineCnt; j++) {\n            if ((lines[i].kill | lines[j].kill) == lines[i].kill) {\n                lines[j].valid = false;\n            }\n        }\n    }\n    \n    for (unsigned int i = 0; i < (1u << n); i++) {\n        N[i].visited = false;\n    }\n    \n    return bfs((1u << n) - 1);\n}\n\nint main() {\n    freopen(\"angrybirds.in\", \"r\", stdin);\n    freopen(\"angrybirds.out\", \"w\", stdout);\n    \n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        scanf(\"%d %d\", &n, &cmd);\n        for (int i = 1; i <= n; i++) {\n            scanf(\"%lf %lf\", &a[i].x, &a[i].y);\n        }\n        lineCnt = 0;\n        \n        if (cmd == 1) {\n            limit = ceil(double(n) / 3 + 1);\n        } else {\n            limit = n;\n        }\n        \n        printf(\"%d\\n\", solve());\n    }\n    \n    fclose(stdin);\n    fclose(stdout);\n}\n```","slug":"noip2016-angrybirds","published":1,"updated":"2016-11-29T13:22:13.905Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c7900kmc2xlata0f22v"},{"title":"NOIP2015 -  +  + ","date":"2016-10-19T09:19:00.000Z","_content":"\n $ m $  $ u_i \\leftrightarrow v_i $ $ 0 $ $ m $ \n\n<!-- more -->\n\n### \n[CodeVS 4632](http://codevs.cn/problem/4632/)  \n[CodeVS 5440](http://codevs.cn/problem/5440/)  \n[BZOJ 4326](http://www.lydsy.com/JudgeOnline/problem.php?id=4326)  \n\n### \n $ x $ $ > x $  $ \\leq x $ $ x $ \n\n**** $ u_i \\leftrightarrow v_i $ $ p_i = \\mathrm{lca}(u_i, v_i) $ $ u_i $  $ v_i $  $ +1 $  $ p_i $  $ -2 $ \n\n### \n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <algorithm>\n#include <new>\n\n#define inline inline __attribute__((always_inline))\n\nconst int MAXN = 300000;\nconst int MAXM = 300000;\nconst int MAXN_LOG = 20; // Math.log2(600000) = 19.194602975157967\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tbool visited;\n\tint pos, depth, cover, dist;\n} N[MAXN], *eulerTour[MAXN * 2], *dfsSequence[MAXN], *st[MAXN * 2][MAXN_LOG + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w, cover;\n\tEdge *next;\n\n\tEdge() {}\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n} mEdges[MAXN * 2 - 2], *pEdge = mEdges, *E[MAXN - 1];\n\nstruct Path {\n\tNode *u, *v, *p;\n\tint dist;\n} a[MAXM];\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new (pEdge++) Edge(&N[s], &N[t], w);\n\tN[t].e = new (pEdge++) Edge(&N[t], &N[s], w);\n}\n\nint n, m, log[MAXN * 2 + 1], max, eulerTourLen;\n\ninline void dfs() {\n\tstatic Node *s[MAXN];\n\tNode **top = s;\n\t*s = &N[0];\n\tN[0].depth = 1;\n\n\tint ts = 0;\n\twhile (top >= s) {\n\t\tNode *v = *top;\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t\tv->pos = eulerTourLen;\n\t\t\tdfsSequence[ts++] = v;\n\t\t}\n\n\t\teulerTour[eulerTourLen++] = v;\n\n\t\twhile (v->c && v->c->t->depth) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tif (!v->c->t->depth) {\n\t\t\t\tv->c->t->depth = v->depth + 1;\n\t\t\t\tv->c->t->dist = v->dist + v->c->w;\n\t\t\t\tv->c->t->in = v->c;\n\t\t\t\t*++top = v->c->t;\n\t\t\t}\n\t\t\tv->c = v->c->next;\n\t\t} else {\n\t\t\ttop--;\n\t\t}\n\t}\n\n\tfor (int i = 1; i < n; i++) E[i - 1] = N[i].in;\n}\n\ninline Node *min(Node *a, Node *b) {\n\treturn a->depth < b->depth ? a : b;\n}\n\ninline void sparseTable() {\n\tfor (int i = 0; i < eulerTourLen; i++) st[i][0] = eulerTour[i];\n\tfor (int j = 1; (1 << j) <= eulerTourLen; j++) {\n\t\tfor (int i = 0; i < eulerTourLen; i++) {\n\t\t\tif (i + (1 << (j - 1)) < eulerTourLen) st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\telse st[i][j] = st[i][j - 1];\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= eulerTourLen; i++) {\n\t\tint x = 0;\n\t\twhile ((1 << x) <= i) x++;\n\t\tlog[i] = x - 1;\n\t}\n}\n\ninline Node *rmq(const int l, const int r) {\n\tif (l == r) return st[l][0];\n\telse {\n\t\tconst int t = log[r - l];\n\t\treturn min(st[l][t], st[r - (1 << t) + 1][t]);\n\t}\n}\n\ninline Node *lca(Node *u, Node *v) {\n\treturn rmq(std::min(u->pos, v->pos), std::max(u->pos, v->pos));\n}\n\ninline int distance(Node *u, Node *v, Node *p) {\n\treturn u->dist + v->dist - p->dist * 2;\n}\n\ninline bool check(const int limit) {\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (a[i].dist > limit) {\n\t\t\ta[i].p->cover -= 2;\n\t\t\ta[i].u->cover++;\n\t\t\ta[i].v->cover++;\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (dfsSequence[i]->in) {\n\t\t\tdfsSequence[i]->in->cover = dfsSequence[i]->cover;\n\t\t\tdfsSequence[i]->in->s->cover += dfsSequence[i]->cover;\n\t\t}\n\t\tdfsSequence[i]->cover = 0;\n\t}\n\n\tEdge *maxEdge = NULL;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (E[i]->cover == cnt && (!maxEdge || E[i]->w > maxEdge->w)) maxEdge = E[i];\n\t}\n\n\treturn maxEdge && max - maxEdge->w <= limit;\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\nint main() {\n\tread(n), read(m);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tread(u), read(v), read(w), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tdfs();\n\tsparseTable();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tread(u), read(v), u--, v--;\n\t\ta[i].u = &N[u], a[i].v = &N[v];\n\t\ta[i].p = lca(a[i].u, a[i].v);\n\t\ta[i].dist = distance(a[i].u, a[i].v, a[i].p);\n\t\tmax = std::max(max, a[i].dist);\n\t\t// printf(\"lca(%lu, %lu) = %lu\\n\", a[i].u - N + 1, a[i].v - N + 1, a[i].p - N + 1);\n\t}\n\n\tint l = 0, r = max;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2;\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\t// check(11);\n\n\tprintf(\"%d\\n\", l);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2015-transport.md","raw":"title: NOIP2015 -  +  + \ncategories: OI\ntags: \n  - NOIP\n  - BZOJ\n  - CodeVS\n  - \npermalink: noip2015-transport\ndate: 2016-10-19 17:19:00\n---\n\n $ m $  $ u_i \\leftrightarrow v_i $ $ 0 $ $ m $ \n\n<!-- more -->\n\n### \n[CodeVS 4632](http://codevs.cn/problem/4632/)  \n[CodeVS 5440](http://codevs.cn/problem/5440/)  \n[BZOJ 4326](http://www.lydsy.com/JudgeOnline/problem.php?id=4326)  \n\n### \n $ x $ $ > x $  $ \\leq x $ $ x $ \n\n**** $ u_i \\leftrightarrow v_i $ $ p_i = \\mathrm{lca}(u_i, v_i) $ $ u_i $  $ v_i $  $ +1 $  $ p_i $  $ -2 $ \n\n### \n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <algorithm>\n#include <new>\n\n#define inline inline __attribute__((always_inline))\n\nconst int MAXN = 300000;\nconst int MAXM = 300000;\nconst int MAXN_LOG = 20; // Math.log2(600000) = 19.194602975157967\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tbool visited;\n\tint pos, depth, cover, dist;\n} N[MAXN], *eulerTour[MAXN * 2], *dfsSequence[MAXN], *st[MAXN * 2][MAXN_LOG + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w, cover;\n\tEdge *next;\n\n\tEdge() {}\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n} mEdges[MAXN * 2 - 2], *pEdge = mEdges, *E[MAXN - 1];\n\nstruct Path {\n\tNode *u, *v, *p;\n\tint dist;\n} a[MAXM];\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new (pEdge++) Edge(&N[s], &N[t], w);\n\tN[t].e = new (pEdge++) Edge(&N[t], &N[s], w);\n}\n\nint n, m, log[MAXN * 2 + 1], max, eulerTourLen;\n\ninline void dfs() {\n\tstatic Node *s[MAXN];\n\tNode **top = s;\n\t*s = &N[0];\n\tN[0].depth = 1;\n\n\tint ts = 0;\n\twhile (top >= s) {\n\t\tNode *v = *top;\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t\tv->pos = eulerTourLen;\n\t\t\tdfsSequence[ts++] = v;\n\t\t}\n\n\t\teulerTour[eulerTourLen++] = v;\n\n\t\twhile (v->c && v->c->t->depth) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tif (!v->c->t->depth) {\n\t\t\t\tv->c->t->depth = v->depth + 1;\n\t\t\t\tv->c->t->dist = v->dist + v->c->w;\n\t\t\t\tv->c->t->in = v->c;\n\t\t\t\t*++top = v->c->t;\n\t\t\t}\n\t\t\tv->c = v->c->next;\n\t\t} else {\n\t\t\ttop--;\n\t\t}\n\t}\n\n\tfor (int i = 1; i < n; i++) E[i - 1] = N[i].in;\n}\n\ninline Node *min(Node *a, Node *b) {\n\treturn a->depth < b->depth ? a : b;\n}\n\ninline void sparseTable() {\n\tfor (int i = 0; i < eulerTourLen; i++) st[i][0] = eulerTour[i];\n\tfor (int j = 1; (1 << j) <= eulerTourLen; j++) {\n\t\tfor (int i = 0; i < eulerTourLen; i++) {\n\t\t\tif (i + (1 << (j - 1)) < eulerTourLen) st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\telse st[i][j] = st[i][j - 1];\n\t\t}\n\t}\n\n\tfor (int i = 0; i <= eulerTourLen; i++) {\n\t\tint x = 0;\n\t\twhile ((1 << x) <= i) x++;\n\t\tlog[i] = x - 1;\n\t}\n}\n\ninline Node *rmq(const int l, const int r) {\n\tif (l == r) return st[l][0];\n\telse {\n\t\tconst int t = log[r - l];\n\t\treturn min(st[l][t], st[r - (1 << t) + 1][t]);\n\t}\n}\n\ninline Node *lca(Node *u, Node *v) {\n\treturn rmq(std::min(u->pos, v->pos), std::max(u->pos, v->pos));\n}\n\ninline int distance(Node *u, Node *v, Node *p) {\n\treturn u->dist + v->dist - p->dist * 2;\n}\n\ninline bool check(const int limit) {\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (a[i].dist > limit) {\n\t\t\ta[i].p->cover -= 2;\n\t\t\ta[i].u->cover++;\n\t\t\ta[i].v->cover++;\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (dfsSequence[i]->in) {\n\t\t\tdfsSequence[i]->in->cover = dfsSequence[i]->cover;\n\t\t\tdfsSequence[i]->in->s->cover += dfsSequence[i]->cover;\n\t\t}\n\t\tdfsSequence[i]->cover = 0;\n\t}\n\n\tEdge *maxEdge = NULL;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (E[i]->cover == cnt && (!maxEdge || E[i]->w > maxEdge->w)) maxEdge = E[i];\n\t}\n\n\treturn maxEdge && max - maxEdge->w <= limit;\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\nint main() {\n\tread(n), read(m);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tread(u), read(v), read(w), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tdfs();\n\tsparseTable();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tread(u), read(v), u--, v--;\n\t\ta[i].u = &N[u], a[i].v = &N[v];\n\t\ta[i].p = lca(a[i].u, a[i].v);\n\t\ta[i].dist = distance(a[i].u, a[i].v, a[i].p);\n\t\tmax = std::max(max, a[i].dist);\n\t\t// printf(\"lca(%lu, %lu) = %lu\\n\", a[i].u - N + 1, a[i].v - N + 1, a[i].p - N + 1);\n\t}\n\n\tint l = 0, r = max;\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2;\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\t// check(11);\n\n\tprintf(\"%d\\n\", l);\n\n\treturn 0;\n}\n```\n","slug":"noip2015-transport","published":1,"updated":"2016-10-19T13:07:29.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c7e00kuc2xl2i7m7a1c"},{"title":"NOIP2015 - DP","date":"2016-10-19T08:48:00.000Z","_content":"\n $ A $  $ B $ $ A $  $ k $  $ k $  $ A $  $ B $   \n\n\n<!-- more -->\n\n### \n[CodeVS 4560](http://codevs.cn/problem/4560/)\n\n### \n $ f(i, j, t) $  $ A $  $ i $  $ B $  $ j $  $ A_i $ $ t $ $ g(i, j, t) $  $ A $  $ i $  $ B $  $ j $  $ A_i $ $ t $ \n\n $ f(i, j, t) $ \n\n$$\nf(i, j, t) =\n\\begin{cases}\nf(i - 1, j - 1, t) + g(i - 1, j - 1, t - 1) & A_i = B_j \\\\\n0 & A_i \\neq B_j\n\\end{cases}\n$$\n\n$ g(i, j, t) $ \n\n$$\ng(i, j, t) =\n\\begin{cases}\ng(i - 1, j, t) + f(i, j, t) & A_i = B_j \\\\\ng(i - 1, j, t) & A_i \\neq B_j\n\\end{cases}\n$$\n\n $ f(i, 0, 0) = g(i, 0, 0) = 1 $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 200;\nconst int MAXK = 200;\nconst int MOD = 1e9 + 7;\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tstatic char a[MAXN + 1], b[MAXM + 1];\n\tscanf(\"%s\\n%s\", a, b);\n\n\tstatic int f[2][MAXM + 1][MAXK + 1], g[2][MAXM + 1][MAXK + 1];\n\tg[0][0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tconst int curr = i % 2, prev = !curr;\n\t\tmemset(f[curr], 0, sizeof(f[curr]));\n\t\tmemset(g[curr], 0, sizeof(g[curr]));\n\n\t\tg[curr][0][0] = f[curr][0][0] = 1;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int t = 1; t <= std::min(j, k); t++) {\n\t\t\t\tif (a[i - 1] == b[j - 1]) {\n\t\t\t\t\tf[curr][j][t] = (f[prev][j - 1][t] + g[prev][j - 1][t - 1]) % MOD;\n\t\t\t\t\tg[curr][j][t] = (g[prev][j][t] + f[curr][j][t]) % MOD;\n#ifdef DBG\n\t\t\t\t\tprintf(\"g[%d][%d][%d] = %d\\n\", i, j, t, g[curr][j][t]);\n\t\t\t\t\tprintf(\"f[%d][%d][%d] = %d\\n\", i, j, t, f[curr][j][t]);\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tf[curr][j][t] = 0;\n\t\t\t\t\tg[curr][j][t] = g[prev][j][t];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", g[n % 2][m][k]);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2015-substring.md","raw":"title: NOIP2015 - DP\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - DP\npermalink: noip2015-substring\ndate: 2016-10-19 16:48:00\n---\n\n $ A $  $ B $ $ A $  $ k $  $ k $  $ A $  $ B $   \n\n\n<!-- more -->\n\n### \n[CodeVS 4560](http://codevs.cn/problem/4560/)\n\n### \n $ f(i, j, t) $  $ A $  $ i $  $ B $  $ j $  $ A_i $ $ t $ $ g(i, j, t) $  $ A $  $ i $  $ B $  $ j $  $ A_i $ $ t $ \n\n $ f(i, j, t) $ \n\n$$\nf(i, j, t) =\n\\begin{cases}\nf(i - 1, j - 1, t) + g(i - 1, j - 1, t - 1) & A_i = B_j \\\\\n0 & A_i \\neq B_j\n\\end{cases}\n$$\n\n$ g(i, j, t) $ \n\n$$\ng(i, j, t) =\n\\begin{cases}\ng(i - 1, j, t) + f(i, j, t) & A_i = B_j \\\\\ng(i - 1, j, t) & A_i \\neq B_j\n\\end{cases}\n$$\n\n $ f(i, 0, 0) = g(i, 0, 0) = 1 $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 200;\nconst int MAXK = 200;\nconst int MOD = 1e9 + 7;\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tstatic char a[MAXN + 1], b[MAXM + 1];\n\tscanf(\"%s\\n%s\", a, b);\n\n\tstatic int f[2][MAXM + 1][MAXK + 1], g[2][MAXM + 1][MAXK + 1];\n\tg[0][0][0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tconst int curr = i % 2, prev = !curr;\n\t\tmemset(f[curr], 0, sizeof(f[curr]));\n\t\tmemset(g[curr], 0, sizeof(g[curr]));\n\n\t\tg[curr][0][0] = f[curr][0][0] = 1;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int t = 1; t <= std::min(j, k); t++) {\n\t\t\t\tif (a[i - 1] == b[j - 1]) {\n\t\t\t\t\tf[curr][j][t] = (f[prev][j - 1][t] + g[prev][j - 1][t - 1]) % MOD;\n\t\t\t\t\tg[curr][j][t] = (g[prev][j][t] + f[curr][j][t]) % MOD;\n#ifdef DBG\n\t\t\t\t\tprintf(\"g[%d][%d][%d] = %d\\n\", i, j, t, g[curr][j][t]);\n\t\t\t\t\tprintf(\"f[%d][%d][%d] = %d\\n\", i, j, t, f[curr][j][t]);\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tf[curr][j][t] = 0;\n\t\t\t\t\tg[curr][j][t] = g[prev][j][t];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", g[n % 2][m][k]);\n\n\treturn 0;\n}\n```\n","slug":"noip2015-substring","published":1,"updated":"2016-11-02T06:50:28.453Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c7h00l0c2xl01ii0mf9"},{"title":"NOIP2015 - ","date":"2016-10-19T08:30:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 4325](http://www.lydsy.com/JudgeOnline/problem.php?id=4325)  \n[CodeVS 4610](http://codevs.cn/problem/4610/)\n\n### \n 64 \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 13;\n\nconst int CARD_JOKER = 0;\nconst int CARD_2 = 1;\nconst int CARD_3 = 2;\nconst int CARD_4 = 3;\nconst int CARD_5 = 4;\nconst int CARD_6 = 5;\nconst int CARD_7 = 6;\nconst int CARD_8 = 7;\nconst int CARD_9 = 8;\nconst int CARD_10 = 9;\nconst int CARD_J = 10;\nconst int CARD_Q = 11;\nconst int CARD_K = 12;\nconst int CARD_A = 13;\n\ntypedef unsigned long long Status;\n\ninline int id(const int x) {\n\tif (x == 1) return 13;\n\treturn (x >= 2 && x <= 13) ? (x - 1) : x;\n}\n\ninline int get(const Status &s, const int index) {\n\treturn (s >> (index << 2)) & 15ll;\n}\n\n#ifdef DBG\ninline void print(const Status &s, const bool newLine = true) {\n\t// for (int i = 0; i < 64; i++) putchar((s & (1ll << i)) ? '1' : '0');\n\tfor (int i = 0; i < 14; i++) printf(\"%d \", get(s, i));\n\tif (newLine) putchar('\\n');\n}\n#endif\n\ninline void set(Status &s, const int index, const int val) {\n\t/*\n\tif (val < 0) {\n\t\tputs(\"???\");\n\t}\n\t*/\n#ifdef DBG\n\tprint(s, false);\n\tprintf(\"=> \");\n#endif\n\ts &= ~(15ll << (index << 2));\n\ts |= (val & 15ll) << (index << 2);\n#ifdef DBG\n\tprint(s);\n#endif\n}\n\ninline void change(Status &s, const int index, const int delta) {\n\tset(s, index, get(s, index) + delta);\n}\n\nint n, ans;\n// std::tr1::unordered_map<Status, int> map;\n\nstruct HashMap {\n\tconst static int HASH_SIZE = 7979717;\n\tstruct Node {\n\t\tStatus key;\n\t\tint val, time;\n\t} N[HASH_SIZE];\n\n\tint time;\n\n\tHashMap() : time(1) {}\n\n\tint locate(const Status &key) {\n\t\tint i;\n\t\tfor (i = key % HASH_SIZE; N[i].time == time && N[i].key != key; (i < HASH_SIZE - 1) ? (i++) : (i = 0));\n\t\tif (N[i].time != time) {\n\t\t\tN[i].time = time;\n\t\t\tN[i].key = key;\n\t\t\tN[i].val = INT_MAX;\n\t\t}\n\t\treturn i;\n\t}\n\n\tint &operator[](const Status &key) {\n\t\treturn N[locate(key)].val;\n\t}\n\n\tvoid clear() {\n\t\ttime++;\n\t}\n} map;\n\ninline void search(const Status &s, const int step = 0) {\n#ifdef DBG\n\tprint(s, false);\n\tprintf(\"[%d, %d]\\n\", step, ans);\n#endif\n\tif (step >= ans) return;\n\n\tint &x = map[s];\n\tif (step >= x) return;\n\tx = step;\n\n\t/*\n\tstd::tr1::unordered_map<Status, int>::iterator it = map.find(s);\n\tif (it != map.end() && step >= it->second) return;\n\tmap[s] = step;\n\t*/\n\n\tif (!s) {\n\t\tans = step;\n\t\treturn;\n\t}\n\n\t// 333 444\n\tfor (int i = CARD_3; i <= CARD_K; i++) {\n\t\tStatus next = s;\n\t\tint x = get(next, i);\n\t\tif (x < 3) {\n\t\t\tcontinue;\n\t\t} else set(next, i, x - 3);\n\n\t\tfor (int j = i + 1; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 3) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 3);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 33 44 55\n\tfor (int i = CARD_3; i <= CARD_Q; i++) {\n\t\tbool valid = true;\n\t\tStatus next = s;\n\t\tfor (int j = i; j < i + 2; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 2) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t} else set(next, j, x - 2);\n\t\t}\n\t\tif (!valid) continue;\n\n\t\tfor (int j = i + 2; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 2) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 2);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 3 4 5 6 7\n\tfor (int i = CARD_3; i <= CARD_10; i++) {\n\t\tbool valid = true;\n\t\tStatus next = s;\n\t\tfor (int j = i; j < i + 4; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 1) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t} else set(next, j, x - 1);\n\t\t}\n\t\tif (!valid) continue;\n\n\t\tfor (int j = i + 4; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 1) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::vector<int> four, three, two, one;\n\tfor (int i = CARD_JOKER; i <= CARD_A; i++) {\n\t\tint x = get(s, i);\n\t\tif (x == 4) four.push_back(i);\n\t\telse if (x == 3) three.push_back(i);\n\t\telse if (x == 2) two.push_back(i);\n\t\telse if (x == 1) one.push_back(i);\n\t}\n\n\t// 2222 [3 4] / 2222 [33 44]\n\tfor (std::vector<int>::const_iterator it = four.begin(); it != four.end(); it++) {\n\t\tStatus tmp = s;\n\t\tset(tmp, *it, 0);\n\n\t\tfor (std::vector<int>::const_iterator a = two.begin(); a != two.end(); a++) {\n\t\t\tif (*a == 0) continue;\n\t\t\tfor (std::vector<int>::const_iterator b = a + 1; b != two.end(); b++) {\n\t\t\t\tif (*b == 0) continue;\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 0);\n\t\t\t\tset(next, *b, 0);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tfor (std::vector<int>::const_iterator b = three.begin(); b != three.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tchange(next, *a, -2);\n\t\t\t\tchange(next, *b, -2);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = four.begin(); a != four.end(); a++) {\n\t\t\tif (*a == *it) continue;\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = one.begin(); a != one.end(); a++) {\n\t\t\tfor (std::vector<int>::const_iterator b = a + 1; b != one.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 0);\n\t\t\t\tset(next, *b, 0);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tfor (std::vector<int>::const_iterator b = three.begin(); b != three.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tchange(next, *a, -1);\n\t\t\t\tchange(next, *b, -1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\n\t\tsearch(tmp, step + 1);\n\t}\n\n\t// 222 [3] / 222 [33]\n\tfor (std::vector<int>::const_iterator it = three.begin(); it != three.end(); it++) {\n\t\tStatus tmp = s;\n\t\tset(tmp, *it, 0);\n\n\t\tfor (std::vector<int>::const_iterator a = three.begin(); a != three.end(); a++) {\n\t\t\tif (*a == *it) continue;\n\t\t\tStatus next = tmp;\n\t\t\tchange(next, *a, -1);\n\t\t\tsearch(next, step + 1);\n\t\t\tchange(next, *a, -1);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = two.begin(); a != two.end(); a++) {\n\t\t\tif (*a == 0) {\n\t\t\t\t// Take only one joker\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = one.begin(); a != one.end(); a++) {\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tsearch(tmp, step + 1);\n\t}\n\n\t// 22\n\tfor (std::vector<int>::const_iterator it = two.begin(); it != two.end(); it++) {\n\t\tStatus next = s;\n\t\tset(next, *it, 0);\n\t\tsearch(next, step + 1);\n\t}\n\n\t// 2\n\tfor (std::vector<int>::const_iterator it = one.begin(); it != one.end(); it++) {\n\t\tStatus next = s;\n\t\tset(next, *it, 0);\n\t\tsearch(next, step + 1);\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d %d\", &t, &n);\n\twhile (t--) {\n\t\tStatus init = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tchange(init, id(a), 1);\n\t\t}\n\n\t\tmap.clear();\n\t\tans = INT_MAX;\n\t\tsearch(init);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noip2015-landlords.md","raw":"title: NOIP2015 - \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - BZOJ\n  - \npermalink: noip2015-landlords\ndate: 2016-10-19 16:30:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 4325](http://www.lydsy.com/JudgeOnline/problem.php?id=4325)  \n[CodeVS 4610](http://codevs.cn/problem/4610/)\n\n### \n 64 \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 13;\n\nconst int CARD_JOKER = 0;\nconst int CARD_2 = 1;\nconst int CARD_3 = 2;\nconst int CARD_4 = 3;\nconst int CARD_5 = 4;\nconst int CARD_6 = 5;\nconst int CARD_7 = 6;\nconst int CARD_8 = 7;\nconst int CARD_9 = 8;\nconst int CARD_10 = 9;\nconst int CARD_J = 10;\nconst int CARD_Q = 11;\nconst int CARD_K = 12;\nconst int CARD_A = 13;\n\ntypedef unsigned long long Status;\n\ninline int id(const int x) {\n\tif (x == 1) return 13;\n\treturn (x >= 2 && x <= 13) ? (x - 1) : x;\n}\n\ninline int get(const Status &s, const int index) {\n\treturn (s >> (index << 2)) & 15ll;\n}\n\n#ifdef DBG\ninline void print(const Status &s, const bool newLine = true) {\n\t// for (int i = 0; i < 64; i++) putchar((s & (1ll << i)) ? '1' : '0');\n\tfor (int i = 0; i < 14; i++) printf(\"%d \", get(s, i));\n\tif (newLine) putchar('\\n');\n}\n#endif\n\ninline void set(Status &s, const int index, const int val) {\n\t/*\n\tif (val < 0) {\n\t\tputs(\"???\");\n\t}\n\t*/\n#ifdef DBG\n\tprint(s, false);\n\tprintf(\"=> \");\n#endif\n\ts &= ~(15ll << (index << 2));\n\ts |= (val & 15ll) << (index << 2);\n#ifdef DBG\n\tprint(s);\n#endif\n}\n\ninline void change(Status &s, const int index, const int delta) {\n\tset(s, index, get(s, index) + delta);\n}\n\nint n, ans;\n// std::tr1::unordered_map<Status, int> map;\n\nstruct HashMap {\n\tconst static int HASH_SIZE = 7979717;\n\tstruct Node {\n\t\tStatus key;\n\t\tint val, time;\n\t} N[HASH_SIZE];\n\n\tint time;\n\n\tHashMap() : time(1) {}\n\n\tint locate(const Status &key) {\n\t\tint i;\n\t\tfor (i = key % HASH_SIZE; N[i].time == time && N[i].key != key; (i < HASH_SIZE - 1) ? (i++) : (i = 0));\n\t\tif (N[i].time != time) {\n\t\t\tN[i].time = time;\n\t\t\tN[i].key = key;\n\t\t\tN[i].val = INT_MAX;\n\t\t}\n\t\treturn i;\n\t}\n\n\tint &operator[](const Status &key) {\n\t\treturn N[locate(key)].val;\n\t}\n\n\tvoid clear() {\n\t\ttime++;\n\t}\n} map;\n\ninline void search(const Status &s, const int step = 0) {\n#ifdef DBG\n\tprint(s, false);\n\tprintf(\"[%d, %d]\\n\", step, ans);\n#endif\n\tif (step >= ans) return;\n\n\tint &x = map[s];\n\tif (step >= x) return;\n\tx = step;\n\n\t/*\n\tstd::tr1::unordered_map<Status, int>::iterator it = map.find(s);\n\tif (it != map.end() && step >= it->second) return;\n\tmap[s] = step;\n\t*/\n\n\tif (!s) {\n\t\tans = step;\n\t\treturn;\n\t}\n\n\t// 333 444\n\tfor (int i = CARD_3; i <= CARD_K; i++) {\n\t\tStatus next = s;\n\t\tint x = get(next, i);\n\t\tif (x < 3) {\n\t\t\tcontinue;\n\t\t} else set(next, i, x - 3);\n\n\t\tfor (int j = i + 1; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 3) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 3);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 33 44 55\n\tfor (int i = CARD_3; i <= CARD_Q; i++) {\n\t\tbool valid = true;\n\t\tStatus next = s;\n\t\tfor (int j = i; j < i + 2; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 2) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t} else set(next, j, x - 2);\n\t\t}\n\t\tif (!valid) continue;\n\n\t\tfor (int j = i + 2; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 2) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 2);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// 3 4 5 6 7\n\tfor (int i = CARD_3; i <= CARD_10; i++) {\n\t\tbool valid = true;\n\t\tStatus next = s;\n\t\tfor (int j = i; j < i + 4; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 1) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t} else set(next, j, x - 1);\n\t\t}\n\t\tif (!valid) continue;\n\n\t\tfor (int j = i + 4; j <= CARD_A; j++) {\n\t\t\tint x = get(next, j);\n\t\t\tif (x < 1) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tset(next, j, x - 1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::vector<int> four, three, two, one;\n\tfor (int i = CARD_JOKER; i <= CARD_A; i++) {\n\t\tint x = get(s, i);\n\t\tif (x == 4) four.push_back(i);\n\t\telse if (x == 3) three.push_back(i);\n\t\telse if (x == 2) two.push_back(i);\n\t\telse if (x == 1) one.push_back(i);\n\t}\n\n\t// 2222 [3 4] / 2222 [33 44]\n\tfor (std::vector<int>::const_iterator it = four.begin(); it != four.end(); it++) {\n\t\tStatus tmp = s;\n\t\tset(tmp, *it, 0);\n\n\t\tfor (std::vector<int>::const_iterator a = two.begin(); a != two.end(); a++) {\n\t\t\tif (*a == 0) continue;\n\t\t\tfor (std::vector<int>::const_iterator b = a + 1; b != two.end(); b++) {\n\t\t\t\tif (*b == 0) continue;\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 0);\n\t\t\t\tset(next, *b, 0);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tfor (std::vector<int>::const_iterator b = three.begin(); b != three.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tchange(next, *a, -2);\n\t\t\t\tchange(next, *b, -2);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = four.begin(); a != four.end(); a++) {\n\t\t\tif (*a == *it) continue;\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = one.begin(); a != one.end(); a++) {\n\t\t\tfor (std::vector<int>::const_iterator b = a + 1; b != one.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 0);\n\t\t\t\tset(next, *b, 0);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\n\t\t\tfor (std::vector<int>::const_iterator b = three.begin(); b != three.end(); b++) {\n\t\t\t\tStatus next = tmp;\n\t\t\t\tchange(next, *a, -1);\n\t\t\t\tchange(next, *b, -1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t}\n\t\t}\n\n\t\tsearch(tmp, step + 1);\n\t}\n\n\t// 222 [3] / 222 [33]\n\tfor (std::vector<int>::const_iterator it = three.begin(); it != three.end(); it++) {\n\t\tStatus tmp = s;\n\t\tset(tmp, *it, 0);\n\n\t\tfor (std::vector<int>::const_iterator a = three.begin(); a != three.end(); a++) {\n\t\t\tif (*a == *it) continue;\n\t\t\tStatus next = tmp;\n\t\t\tchange(next, *a, -1);\n\t\t\tsearch(next, step + 1);\n\t\t\tchange(next, *a, -1);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = two.begin(); a != two.end(); a++) {\n\t\t\tif (*a == 0) {\n\t\t\t\t// Take only one joker\n\t\t\t\tStatus next = tmp;\n\t\t\t\tset(next, *a, 1);\n\t\t\t\tsearch(next, step + 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tfor (std::vector<int>::const_iterator a = one.begin(); a != one.end(); a++) {\n\t\t\tStatus next = tmp;\n\t\t\tset(next, *a, 0);\n\t\t\tsearch(next, step + 1);\n\t\t}\n\n\t\tsearch(tmp, step + 1);\n\t}\n\n\t// 22\n\tfor (std::vector<int>::const_iterator it = two.begin(); it != two.end(); it++) {\n\t\tStatus next = s;\n\t\tset(next, *it, 0);\n\t\tsearch(next, step + 1);\n\t}\n\n\t// 2\n\tfor (std::vector<int>::const_iterator it = one.begin(); it != one.end(); it++) {\n\t\tStatus next = s;\n\t\tset(next, *it, 0);\n\t\tsearch(next, step + 1);\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d %d\", &t, &n);\n\twhile (t--) {\n\t\tStatus init = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tchange(init, id(a), 1);\n\t\t}\n\n\t\tmap.clear();\n\t\tans = INT_MAX;\n\t\tsearch(init);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"noip2015-landlords","published":1,"updated":"2016-10-19T08:32:59.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c7l00l5c2xlia9o9uzg"},{"title":"NOIP2014 - Hash","date":"2016-10-19T08:25:00.000Z","_content":"\n\n\n$$ a_0 + a_1 x + a_2 x ^ 2 + \\cdots + a_n x ^ n = 0 $$\n\n $ [1, m] $ \n\n<!-- more -->\n\n### \n[BZOJ 3751](http://www.lydsy.com/JudgeOnline/problem.php?id=3751)  \n[CodeVS 4610](http://codevs.cn/problem/4610/)\n\n### \n $ f(x) = a_0 + a_1 x + a_2 x ^ 2 + \\cdots + a_n x ^ n = 0 $ $ p $  $ f(x) = 0 $ $ f(x) \\bmod p = 0 $\n\n $ f(x) \\bmod p = 0 $  $ x $ $ n $  $ x' = x + kp \\leq m $  $ p' $  $ f(x') \\bmod p' = 0 $ $ x' $ \n\n $ O(np + n \\frac{nm}{p}) $ $ p \\approx \\sqrt {nm} $  $ O(n \\sqrt{nm}) $\n\n### \n```c++\n#include <cstdio>\n#include <list>\n\nconst int MAXN = 100;\nconst int MAXLEN = 10000 + 1;\nconst int MAXM = 1000000;\nconst int MOD = 21893;\nconst int MOD2 = 18341629;\n\nint parse(const char *s, const int mod) {\n\tint res = 0, sgn = 1;\n\tif (*s == '-') s++, sgn = -1;\n\tfor (const char *p = s; *p; p++) res = (res * 10 + *p - '0') % mod;\n\treturn res * sgn;\n}\n\nint main() {\n\tstatic char s[MAXN + 1][MAXLEN + 1];\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i <= n; i++) {\n\t\tscanf(\"%s\", s[i]);\n\t}\n\n\tstatic int a[MAXN + 1];\n\tfor (int i = 0; i <= n; i++) a[i] = parse(s[i], MOD);\n\n\tstd::list<int> roots;\n\tfor (int i = 1; i < MOD; i++) {\n\t\tlong long pow = 1, val = 0;\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t(val += a[j] * pow) %= MOD;\n\t\t\tpow = pow * i % MOD;\n\t\t}\n\t\t\n\t\tif (val == 0) {\n\t\t\tfor (int j = i; j <= m; j += MOD) roots.push_back(j);\n\t\t}\n\t}\n\n\tfor (int j = 0; j <= n; j++) a[j] = parse(s[j], MOD2);\n\n\tfor (std::list<int>::iterator it = roots.begin(); it != roots.end(); ) {\n\t\tlong long pow = 1, val = 0;\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t(val += a[j] * pow) %= MOD2;\n\t\t\tpow = pow * *it % MOD2;\n\t\t}\n\n\t\tif (val != 0) it = roots.erase(it);\n\t\telse it++;\n\t}\n\n\tprintf(\"%lu\\n\", roots.size());\n\troots.sort();\n\tfor (std::list<int>::iterator it = roots.begin(); it != roots.end(); it++) printf(\"%d\\n\", *it);\n\n\treturn 0;\n}\n```","source":"_posts/noip2014-equation.md","raw":"title: NOIP2014 - Hash\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - BZOJ\n  - Hash\n  - \npermalink: noip2014-equation\ndate: 2016-10-19 16:25:00\n---\n\n\n\n$$ a_0 + a_1 x + a_2 x ^ 2 + \\cdots + a_n x ^ n = 0 $$\n\n $ [1, m] $ \n\n<!-- more -->\n\n### \n[BZOJ 3751](http://www.lydsy.com/JudgeOnline/problem.php?id=3751)  \n[CodeVS 4610](http://codevs.cn/problem/4610/)\n\n### \n $ f(x) = a_0 + a_1 x + a_2 x ^ 2 + \\cdots + a_n x ^ n = 0 $ $ p $  $ f(x) = 0 $ $ f(x) \\bmod p = 0 $\n\n $ f(x) \\bmod p = 0 $  $ x $ $ n $  $ x' = x + kp \\leq m $  $ p' $  $ f(x') \\bmod p' = 0 $ $ x' $ \n\n $ O(np + n \\frac{nm}{p}) $ $ p \\approx \\sqrt {nm} $  $ O(n \\sqrt{nm}) $\n\n### \n```c++\n#include <cstdio>\n#include <list>\n\nconst int MAXN = 100;\nconst int MAXLEN = 10000 + 1;\nconst int MAXM = 1000000;\nconst int MOD = 21893;\nconst int MOD2 = 18341629;\n\nint parse(const char *s, const int mod) {\n\tint res = 0, sgn = 1;\n\tif (*s == '-') s++, sgn = -1;\n\tfor (const char *p = s; *p; p++) res = (res * 10 + *p - '0') % mod;\n\treturn res * sgn;\n}\n\nint main() {\n\tstatic char s[MAXN + 1][MAXLEN + 1];\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i <= n; i++) {\n\t\tscanf(\"%s\", s[i]);\n\t}\n\n\tstatic int a[MAXN + 1];\n\tfor (int i = 0; i <= n; i++) a[i] = parse(s[i], MOD);\n\n\tstd::list<int> roots;\n\tfor (int i = 1; i < MOD; i++) {\n\t\tlong long pow = 1, val = 0;\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t(val += a[j] * pow) %= MOD;\n\t\t\tpow = pow * i % MOD;\n\t\t}\n\t\t\n\t\tif (val == 0) {\n\t\t\tfor (int j = i; j <= m; j += MOD) roots.push_back(j);\n\t\t}\n\t}\n\n\tfor (int j = 0; j <= n; j++) a[j] = parse(s[j], MOD2);\n\n\tfor (std::list<int>::iterator it = roots.begin(); it != roots.end(); ) {\n\t\tlong long pow = 1, val = 0;\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t(val += a[j] * pow) %= MOD2;\n\t\t\tpow = pow * *it % MOD2;\n\t\t}\n\n\t\tif (val != 0) it = roots.erase(it);\n\t\telse it++;\n\t}\n\n\tprintf(\"%lu\\n\", roots.size());\n\troots.sort();\n\tfor (std::list<int>::iterator it = roots.begin(); it != roots.end(); it++) printf(\"%d\\n\", *it);\n\n\treturn 0;\n}\n```","slug":"noip2014-equation","published":1,"updated":"2016-10-19T08:26:26.067Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c7p00lbc2xl2fmd6frl"},{"title":"NOIP2014 -  DP","date":"2016-10-08T09:06:00.000Z","_content":"\n*  $ n $ $ m $  $ k $ \n* \n*  $ 1 $ $ X $ $ Y $ $ X $  $ Y $ \n*  $ 0 $  $ m $ \n\n,\n\n<!-- more -->\n\n### \n[COGS 1805](http://cogs.pro/cogs/problem/problem.php?pid=1805)  \n[CodeVS 3729](http://codevs.cn/problem/3729/)\n\n### \n $ f(i, j) $  $ i $ $ j $ \n\n   $ i - 1 $  $ k $  $ k \\times X $  $ Y $  $ k $\n\n$$\nf(i, j) = \\min(\\min\\limits_k \\{ f(i - 1, j - kX) \\} + k, f(i - 1, j + Y))\n$$\n\n $ O(m) $ $ O(nm ^ 2) $\n\n $ k $  $ k - 1 $  $ k $  $ j $ $ k - 1 $  $ j - X $\n\n$$ f(i, j) = \\min(f(i - 1, j - X) + 1, f(i, j - X) + 1) $$\n\n\n\n   $ k - 1 $  $ k $  $ k $  $ k - 1 $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000;\n\nstruct Pipe {\n\tbool exist;\n\tint top, bottom;\n} a[MAXN + 1];\n\nint n, m, k, up[MAXN + 1], down[MAXN + 1];\n\ntemplate <typename T> bool cmin(T &a, const T &b) {\n\treturn (a > b) ? (a = b, true) : false;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &up[i], &down[i]);\n\t}\n\n\twhile (k--) {\n\t\tint i;\n\t\tscanf(\"%d\", &i);\n\t\tscanf(\"%d %d\", &a[i].bottom, &a[i].top);\n\t\ta[i].exist = true;\n\t}\n\n\tstatic int f[MAXN + 1][MAXM + 1];\n\t// for (int i = 1; i <= m; i++) f[0][i] = 0;\n\tf[0][0] = INT_MAX;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i][0] = INT_MAX;\n\t\tfor (int j = 1; j < m; j++) {\n\t\t\tf[i][j] = INT_MAX;\n\t\t\t// if (a[i].exist && (j <= a[i].bottom || j >= a[i].top)) continue;\n\n\t\t\tif (j >= up[i - 1]) {\n\t\t\t\tif (f[i - 1][j - up[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j - up[i - 1]] + 1);\n\t\t\t\tif (f[i][j - up[i - 1]] != INT_MAX) cmin(f[i][j], f[i][j - up[i - 1]] + 1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tif (j <= m - down[i - 1]) {\n\t\t\t\tif (f[i - 1][j + down[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j + down[i - 1]]);\n\t\t\t}\n\t\t\t*/\n\n#ifdef DBG\n\t\t\tprintf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n#endif\n\t\t}\n\n\t\tfor (int j = 1; j <= m - down[i - 1]; j++) {\n\t\t\t// if (a[i].exist && (j <= a[i].bottom || j >= a[i].top)) continue;\n\t\t\tif (f[i - 1][j + down[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j + down[i - 1]]);\n\t\t}\n\n\t\tf[i][m] = INT_MAX;\n\t\t// if (a[i].exist) continue;\n\t\tfor (int k = m - up[i - 1]; k <= m; k++) {\n\t\t\tif (f[i - 1][k] != INT_MAX) cmin(f[i][m], f[i - 1][k] + 1);\n\t\t\tif (f[i][k] != INT_MAX) cmin(f[i][m], f[i][k] + 1);\n\t\t}\n\n\t\tif (a[i].exist) for (int j = 1; j <= m; j++) if (j <= a[i].bottom || j >= a[i].top) f[i][j] = INT_MAX;\n\t}\n\n\tint clicks = INT_MAX;\n\tfor (int i = 1; i <= m; i++) cmin(clicks, f[n][i]);\n\n\tif (clicks != INT_MAX) {\n\t\tprintf(\"1\\n%d\\n\", clicks);\n\t} else {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tif (f[i][j] != INT_MAX) {\n\t\t\t\t\tpos = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pos != -1) break;\n\t\t}\n\n\t\tint pipeCnt = 0;\n\t\tfor (int i = 1; i <= pos; i++) if (a[i].exist) pipeCnt++;\n\n\t\tprintf(\"0\\n%d\\n\", pipeCnt);\n\t}\n\n\treturn 0;\n}\n```\t\n","source":"_posts/noip2014-bird.md","raw":"title: NOIP2014 -  DP\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - COGS\n  - DP\n  -  DP\npermalink: noip2014-bird\ndate: 2016-10-08 17:06:00\n---\n\n*  $ n $ $ m $  $ k $ \n* \n*  $ 1 $ $ X $ $ Y $ $ X $  $ Y $ \n*  $ 0 $  $ m $ \n\n,\n\n<!-- more -->\n\n### \n[COGS 1805](http://cogs.pro/cogs/problem/problem.php?pid=1805)  \n[CodeVS 3729](http://codevs.cn/problem/3729/)\n\n### \n $ f(i, j) $  $ i $ $ j $ \n\n   $ i - 1 $  $ k $  $ k \\times X $  $ Y $  $ k $\n\n$$\nf(i, j) = \\min(\\min\\limits_k \\{ f(i - 1, j - kX) \\} + k, f(i - 1, j + Y))\n$$\n\n $ O(m) $ $ O(nm ^ 2) $\n\n $ k $  $ k - 1 $  $ k $  $ j $ $ k - 1 $  $ j - X $\n\n$$ f(i, j) = \\min(f(i - 1, j - X) + 1, f(i, j - X) + 1) $$\n\n\n\n   $ k - 1 $  $ k $  $ k $  $ k - 1 $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000;\n\nstruct Pipe {\n\tbool exist;\n\tint top, bottom;\n} a[MAXN + 1];\n\nint n, m, k, up[MAXN + 1], down[MAXN + 1];\n\ntemplate <typename T> bool cmin(T &a, const T &b) {\n\treturn (a > b) ? (a = b, true) : false;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &up[i], &down[i]);\n\t}\n\n\twhile (k--) {\n\t\tint i;\n\t\tscanf(\"%d\", &i);\n\t\tscanf(\"%d %d\", &a[i].bottom, &a[i].top);\n\t\ta[i].exist = true;\n\t}\n\n\tstatic int f[MAXN + 1][MAXM + 1];\n\t// for (int i = 1; i <= m; i++) f[0][i] = 0;\n\tf[0][0] = INT_MAX;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[i][0] = INT_MAX;\n\t\tfor (int j = 1; j < m; j++) {\n\t\t\tf[i][j] = INT_MAX;\n\t\t\t// if (a[i].exist && (j <= a[i].bottom || j >= a[i].top)) continue;\n\n\t\t\tif (j >= up[i - 1]) {\n\t\t\t\tif (f[i - 1][j - up[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j - up[i - 1]] + 1);\n\t\t\t\tif (f[i][j - up[i - 1]] != INT_MAX) cmin(f[i][j], f[i][j - up[i - 1]] + 1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tif (j <= m - down[i - 1]) {\n\t\t\t\tif (f[i - 1][j + down[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j + down[i - 1]]);\n\t\t\t}\n\t\t\t*/\n\n#ifdef DBG\n\t\t\tprintf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n#endif\n\t\t}\n\n\t\tfor (int j = 1; j <= m - down[i - 1]; j++) {\n\t\t\t// if (a[i].exist && (j <= a[i].bottom || j >= a[i].top)) continue;\n\t\t\tif (f[i - 1][j + down[i - 1]] != INT_MAX) cmin(f[i][j], f[i - 1][j + down[i - 1]]);\n\t\t}\n\n\t\tf[i][m] = INT_MAX;\n\t\t// if (a[i].exist) continue;\n\t\tfor (int k = m - up[i - 1]; k <= m; k++) {\n\t\t\tif (f[i - 1][k] != INT_MAX) cmin(f[i][m], f[i - 1][k] + 1);\n\t\t\tif (f[i][k] != INT_MAX) cmin(f[i][m], f[i][k] + 1);\n\t\t}\n\n\t\tif (a[i].exist) for (int j = 1; j <= m; j++) if (j <= a[i].bottom || j >= a[i].top) f[i][j] = INT_MAX;\n\t}\n\n\tint clicks = INT_MAX;\n\tfor (int i = 1; i <= m; i++) cmin(clicks, f[n][i]);\n\n\tif (clicks != INT_MAX) {\n\t\tprintf(\"1\\n%d\\n\", clicks);\n\t} else {\n\t\tint pos = -1;\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tif (f[i][j] != INT_MAX) {\n\t\t\t\t\tpos = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pos != -1) break;\n\t\t}\n\n\t\tint pipeCnt = 0;\n\t\tfor (int i = 1; i <= pos; i++) if (a[i].exist) pipeCnt++;\n\n\t\tprintf(\"0\\n%d\\n\", pipeCnt);\n\t}\n\n\treturn 0;\n}\n```\t\n","slug":"noip2014-bird","published":1,"updated":"2016-11-08T12:07:12.691Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c7u00ljc2xlqe4ely8k"},{"title":"NOIP2013 - BFS + SPFA","date":"2016-11-13T09:00:00.000Z","_content":"\n1.  $ n \\times m $  $ n\\times m $  $ n \\times m - 1 $  $ 1 \\times 1 $ \n2. \n3. \n\n $ q $  $ i $  $ EX_i $  $ EY_i $  $ SX_i $  $ SY_i $  $ TX_i $  $ TY_i $ \n\n B  B \n\n<!-- more -->\n\n### \n[CodeVS 1218](http://codevs.cn/problem/1218/)\n\n### \n  \n\n $ f(i, j, a, b) $  $ (i, j) $ $ a $  $ b $ \n\n\n\n1. \n2. \n\n $ (i, j, k) $    $ (i, j) $  $ k $  $ f(i, j, a, b) $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 30;\nconst int MAXQ = 500;\nconst int di[] = { 1, 0, 0, -1 };\nconst int dj[] = { 0, 1, -1, 0 };\n\nint n, m;\n\nstruct Node {\n\tbool invalid;\n\tint cost[4][4];\n\tint dist;    // BFS prepare\n\tstruct {\n\t\tint dist;\n\t\tbool inq;\n\t} v[4];      // SPFA\n} map[MAXN + 1][MAXN + 1];\n\nstruct Point {\n\tint i, j;\n\n\tPoint() {}\n\tPoint(int i, int j) : i(i), j(j) {}\n\n\tPoint move(int x) {\n\t\treturn Point(i + di[x], j + dj[x]);\n\t}\n\n\tNode *operator->() const {\n\t\treturn &map[i][j];\n\t}\n\n\tbool valid() const {\n\t\treturn i > 0 && j > 0 && i <= n && j <= m;\n\t}\n\n\tbool operator==(const Point &other) const {\n\t\treturn i == other.i && j == other.j;\n\t}\n};\n\nstruct Status {\n\tPoint p;\n\tint d;\n\n\tStatus(Point p, int d) : p(p), d(d) {}\n};\n\ninline int bfs(Point s, Point t, Point p) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tmap[i][j].dist = INT_MAX;\n\t\t}\n\t}\n\n\tstd::queue<Point> q;\n\ts->dist = 0;\n\tq.push(s);\n\n\twhile (!q.empty()) {\n\t\tPoint v = q.front();\n\t\tq.pop();\n\n\t\tif (v == t) return v->dist;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint u = v.move(i);\n\n\t\t\tif (u->invalid || u == p) continue;\n\n\t\t\tif (u->dist > v->dist + 1) {\n\t\t\t\tu->dist = v->dist + 1;\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn INT_MAX;\n}\n\ninline void prepare() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (map[i][j].invalid) continue;\n\n\t\t\tPoint v(i, j);\n\t\t\tfor (int s = 0; s < 4; s++) {\n\t\t\t\tPoint ps = v.move(s);\n\n\t\t\t\tfor (int t = s + 1; t < 4; t++) {\n\t\t\t\t\tPoint pt = v.move(t);\n\n\t\t\t\t\tif (!ps.valid() || ps->invalid || !pt.valid() || pt->invalid) v->cost[s][t] = v->cost[t][s] = INT_MAX;\n\t\t\t\t\telse v->cost[s][t] = v->cost[t][s] = bfs(ps, pt, v);\n\n#ifdef DBG\n\t\t\t\t\tprintf(\"[%d, %d] %d => %d = %d\\n\", v.i, v.j, s, t, v->cost[s][t]);\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int spfa(Status s, Point t) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tmap[i][j].v[k].dist = INT_MAX;\n\t\t\t\tmap[i][j].v[k].inq = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::queue<Status> q;\n\tq.push(s);\n\ts.p->v[s.d].dist = 0;\n\n\twhile (!q.empty()) {\n\t\tStatus status = q.front();\n\t\tq.pop();\n\n\t\tPoint &v = status.p;\n\t\tint &d = status.d;\n\n\t\tv->v[d].inq = false;\n\n\t\t// Move the empty block\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (i == d || v->cost[d][i] == INT_MAX) continue;\n\n\t\t\tif (v->v[i].dist > v->v[d].dist + v->cost[d][i]) {\n\t\t\t\tv->v[i].dist = v->v[d].dist + v->cost[d][i];\n#ifdef DBG\n\t\t\t\tprintf(\"[%d, %d]->v[%d]->dist = %d\\n\", v.i, v.j, i, v->v[i].dist);\n#endif\n\t\t\t\tif (!v->v[i].inq) {\n\t\t\t\t\tv->v[i].inq = true;\n\t\t\t\t\tq.push(Status(v, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Swap\n\t\tif (v->v[d].dist != INT_MAX) {\n\t\t\tPoint u = v.move(d);\n\t\t\tint t = 3 - d;\n\t\t\tif (u->v[t].dist > v->v[d].dist + 1) {\n\t\t\t\tu->v[t].dist = v->v[d].dist + 1;\n\t\t\t\tif (!u->v[t].inq) {\n\t\t\t\t\tu->v[t].inq = true;\n\t\t\t\t\tq.push(Status(u, t));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint res = INT_MAX;\n\tfor (int i = 0; i < 4; i++) {\n\t\tres = std::min(res, t->v[i].dist);\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tint q;\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tmap[i][j].invalid = (x == 0);\n\t\t}\n\t}\n\n\tprepare();\n\n\twhile (q--) {\n\t\tPoint empty, s, t;\n\t\tscanf(\"%d %d %d %d %d %d\", &empty.i, &empty.j, &s.i, &s.j, &t.i, &t.j);\n\n\t\tif (s == t) {\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ans = INT_MAX;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint v = s.move(i);\n\t\t\tif (!v.valid()) continue;\n\n\t\t\tint d1 = bfs(empty, v, s);\n\t\t\tif (d1 == INT_MAX) continue;\n\n\t\t\tint d2 = spfa(Status(s, i), t);\n\t\t\tif (d2 == INT_MAX) continue;\n\n\t\t\tans = std::min(ans, d1 + d2);\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2013-puzzle.md","raw":"title: NOIP2013 - BFS + SPFA\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - \n  - \n  - SPFA\n  - BFS\npermalink: noip2013-puzzle\ndate: 2016-11-13 17:00:00\n---\n\n1.  $ n \\times m $  $ n\\times m $  $ n \\times m - 1 $  $ 1 \\times 1 $ \n2. \n3. \n\n $ q $  $ i $  $ EX_i $  $ EY_i $  $ SX_i $  $ SY_i $  $ TX_i $  $ TY_i $ \n\n B  B \n\n<!-- more -->\n\n### \n[CodeVS 1218](http://codevs.cn/problem/1218/)\n\n### \n  \n\n $ f(i, j, a, b) $  $ (i, j) $ $ a $  $ b $ \n\n\n\n1. \n2. \n\n $ (i, j, k) $    $ (i, j) $  $ k $  $ f(i, j, a, b) $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 30;\nconst int MAXQ = 500;\nconst int di[] = { 1, 0, 0, -1 };\nconst int dj[] = { 0, 1, -1, 0 };\n\nint n, m;\n\nstruct Node {\n\tbool invalid;\n\tint cost[4][4];\n\tint dist;    // BFS prepare\n\tstruct {\n\t\tint dist;\n\t\tbool inq;\n\t} v[4];      // SPFA\n} map[MAXN + 1][MAXN + 1];\n\nstruct Point {\n\tint i, j;\n\n\tPoint() {}\n\tPoint(int i, int j) : i(i), j(j) {}\n\n\tPoint move(int x) {\n\t\treturn Point(i + di[x], j + dj[x]);\n\t}\n\n\tNode *operator->() const {\n\t\treturn &map[i][j];\n\t}\n\n\tbool valid() const {\n\t\treturn i > 0 && j > 0 && i <= n && j <= m;\n\t}\n\n\tbool operator==(const Point &other) const {\n\t\treturn i == other.i && j == other.j;\n\t}\n};\n\nstruct Status {\n\tPoint p;\n\tint d;\n\n\tStatus(Point p, int d) : p(p), d(d) {}\n};\n\ninline int bfs(Point s, Point t, Point p) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tmap[i][j].dist = INT_MAX;\n\t\t}\n\t}\n\n\tstd::queue<Point> q;\n\ts->dist = 0;\n\tq.push(s);\n\n\twhile (!q.empty()) {\n\t\tPoint v = q.front();\n\t\tq.pop();\n\n\t\tif (v == t) return v->dist;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint u = v.move(i);\n\n\t\t\tif (u->invalid || u == p) continue;\n\n\t\t\tif (u->dist > v->dist + 1) {\n\t\t\t\tu->dist = v->dist + 1;\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn INT_MAX;\n}\n\ninline void prepare() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (map[i][j].invalid) continue;\n\n\t\t\tPoint v(i, j);\n\t\t\tfor (int s = 0; s < 4; s++) {\n\t\t\t\tPoint ps = v.move(s);\n\n\t\t\t\tfor (int t = s + 1; t < 4; t++) {\n\t\t\t\t\tPoint pt = v.move(t);\n\n\t\t\t\t\tif (!ps.valid() || ps->invalid || !pt.valid() || pt->invalid) v->cost[s][t] = v->cost[t][s] = INT_MAX;\n\t\t\t\t\telse v->cost[s][t] = v->cost[t][s] = bfs(ps, pt, v);\n\n#ifdef DBG\n\t\t\t\t\tprintf(\"[%d, %d] %d => %d = %d\\n\", v.i, v.j, s, t, v->cost[s][t]);\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int spfa(Status s, Point t) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tmap[i][j].v[k].dist = INT_MAX;\n\t\t\t\tmap[i][j].v[k].inq = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::queue<Status> q;\n\tq.push(s);\n\ts.p->v[s.d].dist = 0;\n\n\twhile (!q.empty()) {\n\t\tStatus status = q.front();\n\t\tq.pop();\n\n\t\tPoint &v = status.p;\n\t\tint &d = status.d;\n\n\t\tv->v[d].inq = false;\n\n\t\t// Move the empty block\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (i == d || v->cost[d][i] == INT_MAX) continue;\n\n\t\t\tif (v->v[i].dist > v->v[d].dist + v->cost[d][i]) {\n\t\t\t\tv->v[i].dist = v->v[d].dist + v->cost[d][i];\n#ifdef DBG\n\t\t\t\tprintf(\"[%d, %d]->v[%d]->dist = %d\\n\", v.i, v.j, i, v->v[i].dist);\n#endif\n\t\t\t\tif (!v->v[i].inq) {\n\t\t\t\t\tv->v[i].inq = true;\n\t\t\t\t\tq.push(Status(v, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Swap\n\t\tif (v->v[d].dist != INT_MAX) {\n\t\t\tPoint u = v.move(d);\n\t\t\tint t = 3 - d;\n\t\t\tif (u->v[t].dist > v->v[d].dist + 1) {\n\t\t\t\tu->v[t].dist = v->v[d].dist + 1;\n\t\t\t\tif (!u->v[t].inq) {\n\t\t\t\t\tu->v[t].inq = true;\n\t\t\t\t\tq.push(Status(u, t));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint res = INT_MAX;\n\tfor (int i = 0; i < 4; i++) {\n\t\tres = std::min(res, t->v[i].dist);\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tint q;\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tmap[i][j].invalid = (x == 0);\n\t\t}\n\t}\n\n\tprepare();\n\n\twhile (q--) {\n\t\tPoint empty, s, t;\n\t\tscanf(\"%d %d %d %d %d %d\", &empty.i, &empty.j, &s.i, &s.j, &t.i, &t.j);\n\n\t\tif (s == t) {\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tint ans = INT_MAX;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint v = s.move(i);\n\t\t\tif (!v.valid()) continue;\n\n\t\t\tint d1 = bfs(empty, v, s);\n\t\t\tif (d1 == INT_MAX) continue;\n\n\t\t\tint d2 = spfa(Status(s, i), t);\n\t\t\tif (d2 == INT_MAX) continue;\n\n\t\t\tans = std::min(ans, d1 + d2);\n\t\t}\n\n\t\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noip2013-puzzle","published":1,"updated":"2016-11-13T10:35:58.177Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c7y00lqc2xl0ywbc2ig"},{"title":"NOIP2013 - ","date":"2016-10-13T08:15:00.000Z","_content":"\n $ n $ \n\n$$ \\sum\\limits_{i = 1} ^ n (a_i - b_i) ^ 2 $$\n\n $ a_i $  $ i $ $ b_i $  $ i $ \n\n\n\n<!-- more -->\n\n### \n[CodeVS 3286](http://codevs.cn/problem/3286/)\n\n### \n $ k \\in [1, n] $ $ k $  $ k $ \n\n $ a $ $ i $  $ k $  $ k $  $ j $  $ a[i] = j $ $ a $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MOD = 99999997;\n\nstruct Match {\n\tint index, rank, value, w;\n} a[MAXN + 1], b[MAXN + 1];\n\nint n;\n\nstruct BinaryIndexedTree {\n\tint a[MAXN + 1];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tint query(int pos) {\n\t\tint res = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(int l, int r) {\n\t\treturn query(r) - query(l - 1);\n\t}\n\n\tvoid update(int pos, int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n} bit;\n\ninline bool byVal(const Match &a, const Match &b) {\n\treturn a.value < b.value;\n}\n\ninline bool byID(const Match &a, const Match &b) {\n\treturn a.index < b.index;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].value), a[i].index = i;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &b[i].value), b[i].index = i;\n\n\tstd::sort(a + 1, a + n + 1, &byVal);\n\tstd::sort(b + 1, b + n + 1, &byVal);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].rank = b[i].rank = i;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tb[i].w = a[i].index;\n\t}\n\n\tstd::sort(b + 1, b + n + 1, &byID);\n\n\t// for (int i = 1; i <= n; i++) printf(\"%d\\n\", b[i].w);\n\n\tlong long ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tans += bit.query(b[i].w + 1, n);\n\t\tbit.update(b[i].w, 1);\n\t}\n\n\tprintf(\"%lld\\n\", ans % MOD);\n\n\treturn 0;\n}\n```","source":"_posts/noip2013-match.md","raw":"title: NOIP2013 - \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - \n  - \npermalink: noip2013-match\ndate: 2016-10-13 16:15:00\n---\n\n $ n $ \n\n$$ \\sum\\limits_{i = 1} ^ n (a_i - b_i) ^ 2 $$\n\n $ a_i $  $ i $ $ b_i $  $ i $ \n\n\n\n<!-- more -->\n\n### \n[CodeVS 3286](http://codevs.cn/problem/3286/)\n\n### \n $ k \\in [1, n] $ $ k $  $ k $ \n\n $ a $ $ i $  $ k $  $ k $  $ j $  $ a[i] = j $ $ a $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MOD = 99999997;\n\nstruct Match {\n\tint index, rank, value, w;\n} a[MAXN + 1], b[MAXN + 1];\n\nint n;\n\nstruct BinaryIndexedTree {\n\tint a[MAXN + 1];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tint query(int pos) {\n\t\tint res = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(int l, int r) {\n\t\treturn query(r) - query(l - 1);\n\t}\n\n\tvoid update(int pos, int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n} bit;\n\ninline bool byVal(const Match &a, const Match &b) {\n\treturn a.value < b.value;\n}\n\ninline bool byID(const Match &a, const Match &b) {\n\treturn a.index < b.index;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i].value), a[i].index = i;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &b[i].value), b[i].index = i;\n\n\tstd::sort(a + 1, a + n + 1, &byVal);\n\tstd::sort(b + 1, b + n + 1, &byVal);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].rank = b[i].rank = i;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tb[i].w = a[i].index;\n\t}\n\n\tstd::sort(b + 1, b + n + 1, &byID);\n\n\t// for (int i = 1; i <= n; i++) printf(\"%d\\n\", b[i].w);\n\n\tlong long ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tans += bit.query(b[i].w + 1, n);\n\t\tbit.update(b[i].w, 1);\n\t}\n\n\tprintf(\"%lld\\n\", ans % MOD);\n\n\treturn 0;\n}\n```","slug":"noip2013-match","published":1,"updated":"2016-11-13T08:15:38.455Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c8300lzc2xll9nv803j"},{"title":"NOIP2013 - ","date":"2016-10-13T08:42:00.000Z","_content":"\n\n\n $ h_1, h_2, \\ldots, h_n $ $ g_1, g_2, \\ldots, g_m $\n\n A $ 1 < i < \\frac{m}{2} $$ g_{2i} > g_{2i - 1} $  $ g_{2i} > g_{2i + 1} $  \n B $ 1 < i < \\frac{m}{2} $$ g_{2i} < g_{2i - 1} $  $ g_{2i} < g_{2i + 1} $\n\n $ m = 1 $  $ m > 1 $   \n\n\n<!-- more -->\n\n### \n[CodeVS 3289](http://codevs.cn/problem/3289/)\n\n### \n\n\n $ x $  $ y $ $ z $ \n\n $ x < y $  $ y > z $$ x > y $  $ y < z $ $ z $  $ + 1 $\n\n $ x < y $  $ y < z $$ x > y $  $ y > z $ $ z $  $ y $ $ z $  $ k < y < z $  $ k $  $ z $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint prev, curr, ans = 1;\n\tscanf(\"%d\", &curr);\n\tfor (int i = 1; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\tif (x == curr) continue;\n\n\t\tif (ans == 1 || (prev < curr) != (curr < x)) {\n\t\t\tans++;\n\t\t\tprev = curr;\n\t\t\tcurr = x;\n\t\t} else {\n\t\t\tif (prev < curr) curr = std::max(curr, x);\n\t\t\telse curr = std::min(curr, x);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/noip2013-flower.md","raw":"title: NOIP2013 - \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - \npermalink: noip2013-flower\ndate: 2016-10-13 16:42:00\n---\n\n\n\n $ h_1, h_2, \\ldots, h_n $ $ g_1, g_2, \\ldots, g_m $\n\n A $ 1 < i < \\frac{m}{2} $$ g_{2i} > g_{2i - 1} $  $ g_{2i} > g_{2i + 1} $  \n B $ 1 < i < \\frac{m}{2} $$ g_{2i} < g_{2i - 1} $  $ g_{2i} < g_{2i + 1} $\n\n $ m = 1 $  $ m > 1 $   \n\n\n<!-- more -->\n\n### \n[CodeVS 3289](http://codevs.cn/problem/3289/)\n\n### \n\n\n $ x $  $ y $ $ z $ \n\n $ x < y $  $ y > z $$ x > y $  $ y < z $ $ z $  $ + 1 $\n\n $ x < y $  $ y < z $$ x > y $  $ y > z $ $ z $  $ y $ $ z $  $ k < y < z $  $ k $  $ z $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint prev, curr, ans = 1;\n\tscanf(\"%d\", &curr);\n\tfor (int i = 1; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\tif (x == curr) continue;\n\n\t\tif (ans == 1 || (prev < curr) != (curr < x)) {\n\t\t\tans++;\n\t\t\tprev = curr;\n\t\t\tcurr = x;\n\t\t} else {\n\t\t\tif (prev < curr) curr = std::max(curr, x);\n\t\t\telse curr = std::min(curr, x);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"noip2013-flower","published":1,"updated":"2016-11-13T08:42:45.336Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c8800m6c2xlonsw0kmd"},{"title":"NOIP2012 - ","date":"2016-01-19T13:20:19.000Z","_content":"\n `x`  $ax  1 ({\\rm mod} \\ b)$ \n\n<!-- more -->\n\n### \n[CodeVS 1200](http://codevs.cn/problem/1200/)  \n[Tyvj 2074](http://tyvj.cn/p/2074)\n\n### \n `x`  `b` `b` \n\n### \n```cpp\n#include <cstdio>\n\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nint main() {\n\tint a, b, g, x, y;\n\tscanf(\"%d %d\", &a, &b);\n\texgcd(a, b, g, x, y);\n\tx = ((x % b) + b) % b;\n\tprintf(\"%d\\n\", x);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2012-mod.md","raw":"title: NOIP2012 - \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - Tyvj\n  - \n  - EXGCD\n  - \npermalink: noip2012-mod\ndate: 2016-01-19 21:20:19\n---\n\n `x`  $ax  1 ({\\rm mod} \\ b)$ \n\n<!-- more -->\n\n### \n[CodeVS 1200](http://codevs.cn/problem/1200/)  \n[Tyvj 2074](http://tyvj.cn/p/2074)\n\n### \n `x`  `b` `b` \n\n### \n```cpp\n#include <cstdio>\n\nvoid exgcd(int a, int b, int g, int &x, int &y) {\n\tif (b == 0) {\n\t\tx = 1, y = 0;\n\t\tg = a;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\nint main() {\n\tint a, b, g, x, y;\n\tscanf(\"%d %d\", &a, &b);\n\texgcd(a, b, g, x, y);\n\tx = ((x % b) + b) % b;\n\tprintf(\"%d\\n\", x);\n\n\treturn 0;\n}\n```\n","slug":"noip2012-mod","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c8c00mbc2xl8o61il2q"},{"title":"NOIP2012 - ","date":"2016-11-13T09:14:00.000Z","_content":"\n A  B  $ 1 $  $ N $  $ i $  $ H_i $ $ i $  $ j $  $ d(i, j) $  $ d(i, j) = |H_i  H_j| $\n\n A  B  A  $ S $  $ X $  A  B  B  A  $ X $ \n\n A \n\n1.  $ X = X_0 $ A  B  B  $ 0 $ A  B \n2.  $ X = X_i $  $ S_i $ A  B \n\n<!-- more -->\n\n### \n[CodeVS 1199](http://codevs.cn/problem/1199/)\n\n### \n +  A  B \n\n $ f(k, i, j) $  A$ k = 0 $ B$ k = 1 $ $ i $ $ 2 ^ j $ $ g(k, i, j, l) $  A$ k = 0 $ B$ k = 1 $ $ i $ $ 2 ^ j $  A$ l = 0 $ B$ l = 1 $ $ l = 2 $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <list>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(100000) = 16.609640474436812\nconst int MAXM = 10000;\n\nstruct Node {\n\tlong long x;\n\tNode *nextA, *nextB;\n\tstd::list<Node *>::iterator it;\n} N[MAXN + 1];\n\nint n, logn, f[2][MAXN + 1][MAXN_LOG + 1];\nlong long g[2][MAXN + 1][MAXN_LOG + 1][3];\n\ninline bool compareNode(Node *a, Node *b) {\n\treturn a->x < b->x;\n}\n\ninline bool comparePair(const std::pair<long long, Node *> &a, const std::pair<long long, Node *> &b) {\n\tif (a.first == b.first) return a.second->x < b.second->x;\n\telse return a.first < b.first;\n}\n\ninline void prepare() {\n\tstd::list<Node *> list;\n\tfor (int i = 1; i <= n; i++) {\n\t\tlist.push_back(&N[i]);\n\t\tN[i].it = --list.end();\n\t}\n\n\tlist.sort(&compareNode);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tstd::vector< std::pair<long long, Node *> > vec;\n\n\t\tstd::list<Node *>::iterator near;\n\t\tnear = N[i].it, near++;\n\n\t\tif (near != list.end()) {\n\t\t\tvec.push_back(std::make_pair(abs((*near)->x - N[i].x), *near));\n\n\t\t\tif (++near != list.end()) {\n\t\t\t\tvec.push_back(std::make_pair(llabs((*near)->x - N[i].x), *near));\n\t\t\t}\n\t\t}\n\n\t\tnear = N[i].it;\n\t\tif (near != list.begin()) {\n\t\t\tnear--;\n\t\t\tvec.push_back(std::make_pair(abs((*near)->x - N[i].x), *near));\n\n\t\t\tif (near != list.begin()) {\n\t\t\t\tnear--;\n\t\t\t\tvec.push_back(std::make_pair(llabs((*near)->x - N[i].x), *near));\n\t\t\t}\n\t\t}\n\n\t\tstd::sort(vec.begin(), vec.end(), comparePair);\n\n\t\tif (vec.size() >= 2) {\n\t\t\tN[i].nextA = vec[1].second;\n#ifdef DBG\n\t\t\tprintf(\"nextA(%lld) = %lld\\n\", N[i].x, N[i].nextA->x);\n#endif\n\t\t} else N[i].nextA = &N[0];\n\n\t\tif (vec.size() >= 1) {\n\t\t\tN[i].nextB = vec[0].second;\n#ifdef DBG\n\t\t\tprintf(\"nextB(%lld) = %lld\\n\", N[i].x, N[i].nextB->x);\n#endif\n\t\t} else N[i].nextB = &N[0];\n\n\t\tlist.erase(N[i].it);\n\t}\n\tN[0].nextA = N[0].nextB = &N[0];\n\n\t// Build graph\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[0][i][0] = N[i].nextA - N;\n\t\tf[0][i][1] = N[i].nextA->nextB - N;\n\t\t\n\t\tf[1][i][0] = N[i].nextB - N;\n\t\tf[1][i][1] = N[i].nextB->nextA - N;\n\n\t\tg[0][i][0][0] = g[0][i][0][2] = N[i].nextA == &N[0] ? 0 : llabs(N[i].x - N[i].nextA->x);\n\t\tg[0][i][0][1] = 0;\n\n\t\tg[1][i][0][1] = g[1][i][0][2] = N[i].nextB == &N[0] ? 0 : llabs(N[i].x - N[i].nextB->x);\n\t\tg[1][i][0][0] = 0;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tg[0][i][1][0] = g[0][i][0][0];\n\t\tg[0][i][1][1] = g[1][N[i].nextA - N][0][1];\n\t\tg[0][i][1][2] = g[0][i][0][0] + g[1][N[i].nextA - N][0][1];\n\n\t\tg[1][i][1][1] = g[1][i][0][1];\n\t\tg[1][i][1][0] = g[0][N[i].nextB - N][0][0];\n\t\tg[1][i][1][2] = g[1][i][0][1] + g[0][N[i].nextB - N][0][0];\n\t}\n\n\twhile ((1 << logn) <= n) logn++;\n\tlogn--;\n\n\tfor (int j = 2; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tfor (int l = 0; l < 3; l++) {\n\t\t\t\t\tg[k][i][j][l] = g[k][i][j - 1][l] + g[k][f[k][i][j - 1]][j - 1][l];\n\t\t\t\t}\n\t\t\t\tf[k][i][j] = f[k][f[k][i][j - 1]][j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef DBG\n\tfor (int j = 0; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tprintf(\"f(%d, %d, %d) = %d [%lld]\\n\\n\", k, i, j, f[k][i][j], N[f[k][i][j]].x);\n\t\t\t\tfor (int l = 0; l < 3; l++) {\n\t\t\t\t\tprintf(\"g(%d, %d, %d, %d) = %lld\\n\", k, i, j, l, g[k][i][j][l]);\n\t\t\t\t}\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t}\n#endif\n}\n\ninline long long solve(int start, long long limit, long long &sumA, long long &sumB) {\n\tint curr = start;\n\tlong long sum = sumA = sumB = 0;\n\tfor (int i = logn; i >= 1 && curr != 0; i--) {\n\t\twhile (curr && limit >= sum + g[0][curr][i][2]) {\n\t\t\tsum += g[0][curr][i][2];\n\t\t\tsumA += g[0][curr][i][0];\n\t\t\tsumB += g[0][curr][i][1];\n\t\t\tcurr = f[0][curr][i];\n\t\t}\n\t}\n\n\tif (curr && limit >= sum + g[0][curr][0][0]) {\n\t\tsumA += g[0][curr][0][0];\n\t\tsum += g[0][curr][0][0];\n\t}\n\n\treturn sum;\n}\n\ninline int solve(long long limit) {\n\tint ans = 0;\n\tdouble k = -1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tlong long tmpA, tmpB;\n\t\tsolve(i, limit, tmpA, tmpB);\n\t\tdouble t = static_cast<double>(tmpA) / static_cast<double>(tmpB);\n\t\tif (k == -1 || t < k || (t == k && N[i].x > N[ans].x)) {\n\t\t\tk = t;\n\t\t\tans = i;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", &N[i].x);\n\n\tprepare();\n\n\tlong long limit;\n\tscanf(\"%lld\", &limit);\n\tprintf(\"%d\\n\", solve(limit));\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint start;\n\t\tlong long limit;\n\t\tscanf(\"%d %lld\", &start, &limit);\n\t\tlong long sumA, sumB;\n\t\tsolve(start, limit, sumA, sumB);\n\t\tprintf(\"%lld %lld\\n\", sumA, sumB);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2012-drive.md","raw":"title: NOIP2012 - \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - \npermalink: noip2012-drive\ndate: 2016-11-13 17:14:00\n---\n\n A  B  $ 1 $  $ N $  $ i $  $ H_i $ $ i $  $ j $  $ d(i, j) $  $ d(i, j) = |H_i  H_j| $\n\n A  B  A  $ S $  $ X $  A  B  B  A  $ X $ \n\n A \n\n1.  $ X = X_0 $ A  B  B  $ 0 $ A  B \n2.  $ X = X_i $  $ S_i $ A  B \n\n<!-- more -->\n\n### \n[CodeVS 1199](http://codevs.cn/problem/1199/)\n\n### \n +  A  B \n\n $ f(k, i, j) $  A$ k = 0 $ B$ k = 1 $ $ i $ $ 2 ^ j $ $ g(k, i, j, l) $  A$ k = 0 $ B$ k = 1 $ $ i $ $ 2 ^ j $  A$ l = 0 $ B$ l = 1 $ $ l = 2 $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <list>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(100000) = 16.609640474436812\nconst int MAXM = 10000;\n\nstruct Node {\n\tlong long x;\n\tNode *nextA, *nextB;\n\tstd::list<Node *>::iterator it;\n} N[MAXN + 1];\n\nint n, logn, f[2][MAXN + 1][MAXN_LOG + 1];\nlong long g[2][MAXN + 1][MAXN_LOG + 1][3];\n\ninline bool compareNode(Node *a, Node *b) {\n\treturn a->x < b->x;\n}\n\ninline bool comparePair(const std::pair<long long, Node *> &a, const std::pair<long long, Node *> &b) {\n\tif (a.first == b.first) return a.second->x < b.second->x;\n\telse return a.first < b.first;\n}\n\ninline void prepare() {\n\tstd::list<Node *> list;\n\tfor (int i = 1; i <= n; i++) {\n\t\tlist.push_back(&N[i]);\n\t\tN[i].it = --list.end();\n\t}\n\n\tlist.sort(&compareNode);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tstd::vector< std::pair<long long, Node *> > vec;\n\n\t\tstd::list<Node *>::iterator near;\n\t\tnear = N[i].it, near++;\n\n\t\tif (near != list.end()) {\n\t\t\tvec.push_back(std::make_pair(abs((*near)->x - N[i].x), *near));\n\n\t\t\tif (++near != list.end()) {\n\t\t\t\tvec.push_back(std::make_pair(llabs((*near)->x - N[i].x), *near));\n\t\t\t}\n\t\t}\n\n\t\tnear = N[i].it;\n\t\tif (near != list.begin()) {\n\t\t\tnear--;\n\t\t\tvec.push_back(std::make_pair(abs((*near)->x - N[i].x), *near));\n\n\t\t\tif (near != list.begin()) {\n\t\t\t\tnear--;\n\t\t\t\tvec.push_back(std::make_pair(llabs((*near)->x - N[i].x), *near));\n\t\t\t}\n\t\t}\n\n\t\tstd::sort(vec.begin(), vec.end(), comparePair);\n\n\t\tif (vec.size() >= 2) {\n\t\t\tN[i].nextA = vec[1].second;\n#ifdef DBG\n\t\t\tprintf(\"nextA(%lld) = %lld\\n\", N[i].x, N[i].nextA->x);\n#endif\n\t\t} else N[i].nextA = &N[0];\n\n\t\tif (vec.size() >= 1) {\n\t\t\tN[i].nextB = vec[0].second;\n#ifdef DBG\n\t\t\tprintf(\"nextB(%lld) = %lld\\n\", N[i].x, N[i].nextB->x);\n#endif\n\t\t} else N[i].nextB = &N[0];\n\n\t\tlist.erase(N[i].it);\n\t}\n\tN[0].nextA = N[0].nextB = &N[0];\n\n\t// Build graph\n\tfor (int i = 1; i <= n; i++) {\n\t\tf[0][i][0] = N[i].nextA - N;\n\t\tf[0][i][1] = N[i].nextA->nextB - N;\n\t\t\n\t\tf[1][i][0] = N[i].nextB - N;\n\t\tf[1][i][1] = N[i].nextB->nextA - N;\n\n\t\tg[0][i][0][0] = g[0][i][0][2] = N[i].nextA == &N[0] ? 0 : llabs(N[i].x - N[i].nextA->x);\n\t\tg[0][i][0][1] = 0;\n\n\t\tg[1][i][0][1] = g[1][i][0][2] = N[i].nextB == &N[0] ? 0 : llabs(N[i].x - N[i].nextB->x);\n\t\tg[1][i][0][0] = 0;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tg[0][i][1][0] = g[0][i][0][0];\n\t\tg[0][i][1][1] = g[1][N[i].nextA - N][0][1];\n\t\tg[0][i][1][2] = g[0][i][0][0] + g[1][N[i].nextA - N][0][1];\n\n\t\tg[1][i][1][1] = g[1][i][0][1];\n\t\tg[1][i][1][0] = g[0][N[i].nextB - N][0][0];\n\t\tg[1][i][1][2] = g[1][i][0][1] + g[0][N[i].nextB - N][0][0];\n\t}\n\n\twhile ((1 << logn) <= n) logn++;\n\tlogn--;\n\n\tfor (int j = 2; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tfor (int l = 0; l < 3; l++) {\n\t\t\t\t\tg[k][i][j][l] = g[k][i][j - 1][l] + g[k][f[k][i][j - 1]][j - 1][l];\n\t\t\t\t}\n\t\t\t\tf[k][i][j] = f[k][f[k][i][j - 1]][j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef DBG\n\tfor (int j = 0; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\tprintf(\"f(%d, %d, %d) = %d [%lld]\\n\\n\", k, i, j, f[k][i][j], N[f[k][i][j]].x);\n\t\t\t\tfor (int l = 0; l < 3; l++) {\n\t\t\t\t\tprintf(\"g(%d, %d, %d, %d) = %lld\\n\", k, i, j, l, g[k][i][j][l]);\n\t\t\t\t}\n\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t}\n#endif\n}\n\ninline long long solve(int start, long long limit, long long &sumA, long long &sumB) {\n\tint curr = start;\n\tlong long sum = sumA = sumB = 0;\n\tfor (int i = logn; i >= 1 && curr != 0; i--) {\n\t\twhile (curr && limit >= sum + g[0][curr][i][2]) {\n\t\t\tsum += g[0][curr][i][2];\n\t\t\tsumA += g[0][curr][i][0];\n\t\t\tsumB += g[0][curr][i][1];\n\t\t\tcurr = f[0][curr][i];\n\t\t}\n\t}\n\n\tif (curr && limit >= sum + g[0][curr][0][0]) {\n\t\tsumA += g[0][curr][0][0];\n\t\tsum += g[0][curr][0][0];\n\t}\n\n\treturn sum;\n}\n\ninline int solve(long long limit) {\n\tint ans = 0;\n\tdouble k = -1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tlong long tmpA, tmpB;\n\t\tsolve(i, limit, tmpA, tmpB);\n\t\tdouble t = static_cast<double>(tmpA) / static_cast<double>(tmpB);\n\t\tif (k == -1 || t < k || (t == k && N[i].x > N[ans].x)) {\n\t\t\tk = t;\n\t\t\tans = i;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", &N[i].x);\n\n\tprepare();\n\n\tlong long limit;\n\tscanf(\"%lld\", &limit);\n\tprintf(\"%d\\n\", solve(limit));\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint start;\n\t\tlong long limit;\n\t\tscanf(\"%d %lld\", &start, &limit);\n\t\tlong long sumA, sumB;\n\t\tsolve(start, limit, sumA, sumB);\n\t\tprintf(\"%lld %lld\\n\", sumA, sumB);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noip2012-drive","published":1,"updated":"2016-11-13T09:14:22.387Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c8h00mjc2xl5a0hda7m"},{"title":"NOIP2012 -  / ","date":"2016-10-08T08:56:00.000Z","_content":"\n $ n $  $ i $  $ r_i $  $ m $  $ d_j, s_j, t_j $ $ s_j $  $ t_j $  $ s_j $  $ t_j $  $ d_j $  \n\n\n\n<!-- more -->\n\n### \n[COGS 1266](http://cogs.pro/cogs/problem/problem.php?pid=1266)  \n[CodeVS 1217](http://codevs.cn/problem/1217/)\n\n### \n#### \n\n\n 100 ** 95 **\n\n#### \n $ x $ +  $ x $ \n\n 100  100 \n\n### \nTLE\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <new>\n\nconst int MAXN = 1000000;\nconst int MAXR = 1000000000;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar a[SIZE * sizeof(T)];\n\tT *p;\n\n\tMemoryPool() : p((T *)a) {}\n\n\tT *alloc() {\n\t\treturn p++;\n\t}\n};\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tint value, min, lazy;\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild) {}\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy) {\n\t\t\t\tif (lchild) lchild->value += lazy, lchild->min += lazy, lchild->lazy += lazy;\n\t\t\t\tif (rchild) rchild->value += lazy, rchild->min += lazy, rchild->lazy += lazy;\n\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tint queryMin(int l, int r) {\n\t\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\t\telse if (l <= this->l && r >= this->r) return min;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tint ans = INT_MAX;\n\t\t\t\tif (lchild) ans = std::min(ans, lchild->queryMin(l, r));\n\t\t\t\tif (rchild) ans = std::min(ans, rchild->queryMin(l, r));\n\t\t\t\treturn ans;\n\t\t\t}\n\t\t}\n\n\t\tvoid update(int l, int r, int x) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) value += x, min += x, lazy += x;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tif (lchild) lchild->update(l, r, x);\n\t\t\t\tif (rchild) rchild->update(l, r, x);\n\n\t\t\t\tmin = INT_MAX;\n\t\t\t\tif (lchild) min = std::min(min, lchild->min);\n\t\t\t\tif (rchild) min = std::min(min, rchild->min);\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(int l, int r) {\n\t\tstatic MemoryPool<Node, MAXN * 2> pool;\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new (pool.alloc()) Node(l, r, NULL, NULL);\n\t\telse return new (pool.alloc()) Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tint queryMin(int l, int r) {\n\t\treturn root->queryMin(l, r);\n\t}\n\n\tvoid update(int l, int r, int x) {\n\t\troot->update(l, r, x);\n\t}\n};\n\nint n, m;\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tchar ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), ch >= '0' && ch <= '9');\n}\n\nint main() {\n\tread(n), read(m);\n\n\tSegmentTree segmentTree(1, n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tread(x);\n\n\t\tsegmentTree.update(i, i, x);\n\t}\n\n\tint day = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x, l, r;\n\t\tread(x), read(l), read(r);\n\n\t\tsegmentTree.update(l, r, -x);\n\t\tif (segmentTree.queryMin(1, n) < 0) {\n\t\t\tday = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (day != 0) printf(\"-1\\n%d\\n\", day);\n\telse puts(\"0\");\n\n\treturn 0;\n}\n```\n\nAC\n```c++\n#include <cstdio>\n\nconst int MAXN = 1e6;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int available[MAXN];\n\tstatic struct Request {\n\t\tint l, r, cnt;\n\t} req[MAXN];\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &available[i]);\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d %d\", &req[i].cnt, &req[i].l, &req[i].r), req[i].l--, req[i].r--;\n\n\tint l = -1, r = m - 1;\n\tstatic int used[MAXN];\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tbool valid = true;\n\n\t\tfor (int i = 0; i < n; i++) used[i] = 0;\n\t\tfor (int i = 0; i <= mid; i++) {\n\t\t\tused[req[i].l] += req[i].cnt;\n\t\t\tif (req[i].r != n - 1) used[req[i].r + 1] -= req[i].cnt;\n\t\t}\n\t\tfor (int i = 1; i < n; i++) used[i] += used[i - 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (used[i] > available[i]) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"[%d, %d] => %d\\n\", l, r, mid);\n#endif\n\n\t\tif (valid) l = mid;\n\t\telse r = mid - 1;\n\t}\n\t\n\n\tif (l == m - 1) puts(\"0\");\n\telse printf(\"-1\\n%d\\n\", l + 1 + 1);\n\n\treturn 0;\n}\n```","source":"_posts/noip2012-classrooms.md","raw":"title: NOIP2012 -  / \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - COGS\n  - \n  - \n  - \npermalink: noip2012-classrooms\ndate: 2016-10-08 16:56:00\n---\n\n $ n $  $ i $  $ r_i $  $ m $  $ d_j, s_j, t_j $ $ s_j $  $ t_j $  $ s_j $  $ t_j $  $ d_j $  \n\n\n\n<!-- more -->\n\n### \n[COGS 1266](http://cogs.pro/cogs/problem/problem.php?pid=1266)  \n[CodeVS 1217](http://codevs.cn/problem/1217/)\n\n### \n#### \n\n\n 100 ** 95 **\n\n#### \n $ x $ +  $ x $ \n\n 100  100 \n\n### \nTLE\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <new>\n\nconst int MAXN = 1000000;\nconst int MAXR = 1000000000;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar a[SIZE * sizeof(T)];\n\tT *p;\n\n\tMemoryPool() : p((T *)a) {}\n\n\tT *alloc() {\n\t\treturn p++;\n\t}\n};\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tint value, min, lazy;\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild) {}\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy) {\n\t\t\t\tif (lchild) lchild->value += lazy, lchild->min += lazy, lchild->lazy += lazy;\n\t\t\t\tif (rchild) rchild->value += lazy, rchild->min += lazy, rchild->lazy += lazy;\n\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tint queryMin(int l, int r) {\n\t\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\t\telse if (l <= this->l && r >= this->r) return min;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tint ans = INT_MAX;\n\t\t\t\tif (lchild) ans = std::min(ans, lchild->queryMin(l, r));\n\t\t\t\tif (rchild) ans = std::min(ans, rchild->queryMin(l, r));\n\t\t\t\treturn ans;\n\t\t\t}\n\t\t}\n\n\t\tvoid update(int l, int r, int x) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) value += x, min += x, lazy += x;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tif (lchild) lchild->update(l, r, x);\n\t\t\t\tif (rchild) rchild->update(l, r, x);\n\n\t\t\t\tmin = INT_MAX;\n\t\t\t\tif (lchild) min = std::min(min, lchild->min);\n\t\t\t\tif (rchild) min = std::min(min, rchild->min);\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(int l, int r) {\n\t\tstatic MemoryPool<Node, MAXN * 2> pool;\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new (pool.alloc()) Node(l, r, NULL, NULL);\n\t\telse return new (pool.alloc()) Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tint queryMin(int l, int r) {\n\t\treturn root->queryMin(l, r);\n\t}\n\n\tvoid update(int l, int r, int x) {\n\t\troot->update(l, r, x);\n\t}\n};\n\nint n, m;\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tchar ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), ch >= '0' && ch <= '9');\n}\n\nint main() {\n\tread(n), read(m);\n\n\tSegmentTree segmentTree(1, n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tread(x);\n\n\t\tsegmentTree.update(i, i, x);\n\t}\n\n\tint day = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x, l, r;\n\t\tread(x), read(l), read(r);\n\n\t\tsegmentTree.update(l, r, -x);\n\t\tif (segmentTree.queryMin(1, n) < 0) {\n\t\t\tday = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (day != 0) printf(\"-1\\n%d\\n\", day);\n\telse puts(\"0\");\n\n\treturn 0;\n}\n```\n\nAC\n```c++\n#include <cstdio>\n\nconst int MAXN = 1e6;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int available[MAXN];\n\tstatic struct Request {\n\t\tint l, r, cnt;\n\t} req[MAXN];\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &available[i]);\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d %d\", &req[i].cnt, &req[i].l, &req[i].r), req[i].l--, req[i].r--;\n\n\tint l = -1, r = m - 1;\n\tstatic int used[MAXN];\n\twhile (l < r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tbool valid = true;\n\n\t\tfor (int i = 0; i < n; i++) used[i] = 0;\n\t\tfor (int i = 0; i <= mid; i++) {\n\t\t\tused[req[i].l] += req[i].cnt;\n\t\t\tif (req[i].r != n - 1) used[req[i].r + 1] -= req[i].cnt;\n\t\t}\n\t\tfor (int i = 1; i < n; i++) used[i] += used[i - 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (used[i] > available[i]) {\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"[%d, %d] => %d\\n\", l, r, mid);\n#endif\n\n\t\tif (valid) l = mid;\n\t\telse r = mid - 1;\n\t}\n\t\n\n\tif (l == m - 1) puts(\"0\");\n\telse printf(\"-1\\n%d\\n\", l + 1 + 1);\n\n\treturn 0;\n}\n```","slug":"noip2012-classrooms","published":1,"updated":"2016-10-08T09:04:11.595Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c8l00moc2xlujgm0ar7"},{"title":"NOIP2012 -  +  + ","date":"2016-11-13T09:44:00.000Z","_content":"\nH  $ n $  $ n $  $ n - 1 $ $ 1 $ \n\nH \n\n H \n\n\n\n<!-- more -->\n\n### \n[CodeVS 1218](http://codevs.cn/problem/1218/)\n\n### \n $ t $ $ t $ \n\n****\n\n $ X $  $ Y $ \n\n $ X $  $ Y $ $ X $  $ Y $  $ X $  $ Y $ \n\n $ X $  $ Y $  $ X $  $ Y $  $ Y $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <list>\n\nconst int MAXN = 50000;\nconst int MAXN_LOG = 16; // Math.log2(50000) = 15.609640474436812\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent;\n\tbool visited, settled, childSettled;\n\tstd::vector<int> arrived;\n} N[MAXN + 1], *seq[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tint w;\n\tbool visited;\n\tstd::list<Edge *>::iterator it;\n\n\tEdge(Node *s, Node *t, int w) : s(s), t(t), next(s->e), w(w) {}\n};\n\ninline void addEdge(int s, int t, int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, m, a[MAXN + 1], logn;\n\nint f[MAXN + 1][MAXN_LOG + 1];\nlong long g[MAXN + 1][MAXN_LOG + 1];\n\ninline void prepare() {\n\tstd::queue<Node *> q;\n\n\tN[1].visited = true;\n\tf[1][0] = 1;\n\tg[1][0] = 0;\n\tq.push(&N[1]);\n\n\tint cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tseq[++cnt] = v;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (!e->t->visited) {\n\t\t\t\te->t->visited = true;\n\t\t\t\te->t->parent = v;\n\t\t\t\tf[e->t - N][0] = v - N;\n\t\t\t\tg[e->t - N][0] = e->w;\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile ((1 << logn) <= n) logn++;\n\tlogn--;\n\n\tfor (int j = 1; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i][j] = f[f[i][j - 1]][j - 1];\n\t\t\tg[i][j] = g[i][j - 1] + g[f[i][j - 1]][j - 1];\n\t\t}\n\t}\n}\n\ninline bool compare(Edge *a, Edge *b) {\n\treturn a->w < b->w;\n}\n\ninline bool check(long long limit) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tN[i].arrived.clear();\n\t\tN[i].settled = false;\n\t\tN[i].childSettled = false;\n\t}\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u = a[i];\n\n\t\tlong long dist = 0;\n\t\tfor (int j = logn; j >= 0; j--) {\n\t\t\tif (dist + g[u][j] <= limit && f[u][j] != 1) {\n\t\t\t\tdist += g[u][j];\n\t\t\t\tu = f[u][j];\n\t\t\t}\n\t\t}\n\n\t\tN[u].arrived.push_back(limit - dist);\n\t}\n\n\tfor (int i = n; i >= 1; i--) {\n\t\tif (seq[i]->e->next || i == 1) { // It's not a leaf\n\t\t\tseq[i]->childSettled = true;\n\t\t\tfor (Edge *e = seq[i]->e; e; e = e->next) {\n\t\t\t\tif (e->t == seq[i]->parent) continue;\n\n\t\t\t\tif (!e->t->settled) {\n\t\t\t\t\tseq[i]->childSettled = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"%lu: childSettled = %d, settled = %d\\n\", seq[i] - N, seq[i]->childSettled, seq[i]->settled);\n#endif\n\n\t\tseq[i]->settled = seq[i]->childSettled;\n\n\t\tif (seq[i]->arrived.size()) {\n\t\t\tseq[i]->settled = true;\n\t\t}\n\t}\n\n\tif (N[1].settled) return true;\n\n\tstd::list< std::pair<int, Edge *> > atRoot;\n\tstd::list<Edge *> needSettle;\n\tfor (Edge *e = N[1].e; e; e = e->next) {\n#ifdef DBG\n\t\tprintf(\"%lu: childSettled = %d\\n\", e->t - N, e->t->childSettled);\n#endif\n\n\t\tstd::vector<int> &vec = e->t->arrived;\n\t\tstd::sort(vec.begin(), vec.end());\n\n\t\tbool remain = e->t->childSettled;\n\t\tfor (size_t i = 0; i < vec.size(); i++) {\n\t\t\tif (vec[i] >= e->w) atRoot.push_back(std::make_pair(vec[i] - e->w, e));\n\t\t\telse remain = true;\n\t\t}\n\n\t\tif (remain) {\n\t\t\te->visited = true;\n\t\t} else {\n\t\t\tneedSettle.push_back(e);\n\t\t\te->it = --needSettle.end();\n\t\t\te->visited = false;\n\t\t}\n\t}\n\n\tatRoot.sort();\n\tneedSettle.sort(&compare);\n\n#ifdef DBG\n\tstd::vector< std::pair<int, Edge *> > _atRoot(atRoot.begin(), atRoot.end());\n\tstd::vector<Edge *> _needSettle(needSettle.begin(), needSettle.end());\n#endif\n\t// std::sort(needSettle.begin(), needSettle.end(), &compare);\n\n\tfor (std::list< std::pair<int, Edge *> >::iterator it = atRoot.begin(); it != atRoot.end(); it++) {\n\t\tif (needSettle.empty()) break;\n\t\tif (!it->second->visited) {\n\t\t\tit->second->visited = true;\n\t\t\tneedSettle.erase(it->second->it);\n\t\t} else {\n\t\t\tif (needSettle.front()->w <= it->first) {\n\t\t\t\tneedSettle.front()->visited = true;\n\t\t\t\tneedSettle.pop_front();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn needSettle.empty();\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tlong long sum = 0;\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\n\t\tsum += w;\n\t\taddEdge(u, v, w);\n\t}\n\n\tprepare();\n\n\tscanf(\"%d\", &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint cnt = 0;\n\tfor (Edge *e = N[1].e; e; e = e->next) cnt++;\n\n\tif (cnt > m) puts(\"-1\");\n\telse {\n\t\tint l = 0, r = sum;\n\t\twhile (l < r) {\n\t\t\tint mid = l + (r - l) / 2;\n#ifdef DBG\n\t\t\tprintf(\"[%d, %d], mid = %d\\n\", l, r, mid);\n#endif\n\t\t\tif (check(mid)) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tprintf(\"%d\\n\", l);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noip2012-blockade.md","raw":"title: NOIP2012 -  +  + \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - \n  - \n  - \npermalink: noip2012-blockade\ndate: 2016-11-13 17:44:00\n---\n\nH  $ n $  $ n $  $ n - 1 $ $ 1 $ \n\nH \n\n H \n\n\n\n<!-- more -->\n\n### \n[CodeVS 1218](http://codevs.cn/problem/1218/)\n\n### \n $ t $ $ t $ \n\n****\n\n $ X $  $ Y $ \n\n $ X $  $ Y $ $ X $  $ Y $  $ X $  $ Y $ \n\n $ X $  $ Y $  $ X $  $ Y $  $ Y $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <list>\n\nconst int MAXN = 50000;\nconst int MAXN_LOG = 16; // Math.log2(50000) = 15.609640474436812\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent;\n\tbool visited, settled, childSettled;\n\tstd::vector<int> arrived;\n} N[MAXN + 1], *seq[MAXN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tint w;\n\tbool visited;\n\tstd::list<Edge *>::iterator it;\n\n\tEdge(Node *s, Node *t, int w) : s(s), t(t), next(s->e), w(w) {}\n};\n\ninline void addEdge(int s, int t, int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, m, a[MAXN + 1], logn;\n\nint f[MAXN + 1][MAXN_LOG + 1];\nlong long g[MAXN + 1][MAXN_LOG + 1];\n\ninline void prepare() {\n\tstd::queue<Node *> q;\n\n\tN[1].visited = true;\n\tf[1][0] = 1;\n\tg[1][0] = 0;\n\tq.push(&N[1]);\n\n\tint cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tseq[++cnt] = v;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (!e->t->visited) {\n\t\t\t\te->t->visited = true;\n\t\t\t\te->t->parent = v;\n\t\t\t\tf[e->t - N][0] = v - N;\n\t\t\t\tg[e->t - N][0] = e->w;\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile ((1 << logn) <= n) logn++;\n\tlogn--;\n\n\tfor (int j = 1; j <= logn; j++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i][j] = f[f[i][j - 1]][j - 1];\n\t\t\tg[i][j] = g[i][j - 1] + g[f[i][j - 1]][j - 1];\n\t\t}\n\t}\n}\n\ninline bool compare(Edge *a, Edge *b) {\n\treturn a->w < b->w;\n}\n\ninline bool check(long long limit) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tN[i].arrived.clear();\n\t\tN[i].settled = false;\n\t\tN[i].childSettled = false;\n\t}\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u = a[i];\n\n\t\tlong long dist = 0;\n\t\tfor (int j = logn; j >= 0; j--) {\n\t\t\tif (dist + g[u][j] <= limit && f[u][j] != 1) {\n\t\t\t\tdist += g[u][j];\n\t\t\t\tu = f[u][j];\n\t\t\t}\n\t\t}\n\n\t\tN[u].arrived.push_back(limit - dist);\n\t}\n\n\tfor (int i = n; i >= 1; i--) {\n\t\tif (seq[i]->e->next || i == 1) { // It's not a leaf\n\t\t\tseq[i]->childSettled = true;\n\t\t\tfor (Edge *e = seq[i]->e; e; e = e->next) {\n\t\t\t\tif (e->t == seq[i]->parent) continue;\n\n\t\t\t\tif (!e->t->settled) {\n\t\t\t\t\tseq[i]->childSettled = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"%lu: childSettled = %d, settled = %d\\n\", seq[i] - N, seq[i]->childSettled, seq[i]->settled);\n#endif\n\n\t\tseq[i]->settled = seq[i]->childSettled;\n\n\t\tif (seq[i]->arrived.size()) {\n\t\t\tseq[i]->settled = true;\n\t\t}\n\t}\n\n\tif (N[1].settled) return true;\n\n\tstd::list< std::pair<int, Edge *> > atRoot;\n\tstd::list<Edge *> needSettle;\n\tfor (Edge *e = N[1].e; e; e = e->next) {\n#ifdef DBG\n\t\tprintf(\"%lu: childSettled = %d\\n\", e->t - N, e->t->childSettled);\n#endif\n\n\t\tstd::vector<int> &vec = e->t->arrived;\n\t\tstd::sort(vec.begin(), vec.end());\n\n\t\tbool remain = e->t->childSettled;\n\t\tfor (size_t i = 0; i < vec.size(); i++) {\n\t\t\tif (vec[i] >= e->w) atRoot.push_back(std::make_pair(vec[i] - e->w, e));\n\t\t\telse remain = true;\n\t\t}\n\n\t\tif (remain) {\n\t\t\te->visited = true;\n\t\t} else {\n\t\t\tneedSettle.push_back(e);\n\t\t\te->it = --needSettle.end();\n\t\t\te->visited = false;\n\t\t}\n\t}\n\n\tatRoot.sort();\n\tneedSettle.sort(&compare);\n\n#ifdef DBG\n\tstd::vector< std::pair<int, Edge *> > _atRoot(atRoot.begin(), atRoot.end());\n\tstd::vector<Edge *> _needSettle(needSettle.begin(), needSettle.end());\n#endif\n\t// std::sort(needSettle.begin(), needSettle.end(), &compare);\n\n\tfor (std::list< std::pair<int, Edge *> >::iterator it = atRoot.begin(); it != atRoot.end(); it++) {\n\t\tif (needSettle.empty()) break;\n\t\tif (!it->second->visited) {\n\t\t\tit->second->visited = true;\n\t\t\tneedSettle.erase(it->second->it);\n\t\t} else {\n\t\t\tif (needSettle.front()->w <= it->first) {\n\t\t\t\tneedSettle.front()->visited = true;\n\t\t\t\tneedSettle.pop_front();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn needSettle.empty();\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tlong long sum = 0;\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\n\t\tsum += w;\n\t\taddEdge(u, v, w);\n\t}\n\n\tprepare();\n\n\tscanf(\"%d\", &m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint cnt = 0;\n\tfor (Edge *e = N[1].e; e; e = e->next) cnt++;\n\n\tif (cnt > m) puts(\"-1\");\n\telse {\n\t\tint l = 0, r = sum;\n\t\twhile (l < r) {\n\t\t\tint mid = l + (r - l) / 2;\n#ifdef DBG\n\t\t\tprintf(\"[%d, %d], mid = %d\\n\", l, r, mid);\n#endif\n\t\t\tif (check(mid)) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tprintf(\"%d\\n\", l);\n\t}\n\n\treturn 0;\n}\n```","slug":"noip2012-blockade","published":1,"updated":"2016-11-13T09:44:18.333Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c8r00myc2xl3qc96ysa"},{"title":"NOIP2010 - ","id":"54","updated":"2016-02-19T08:06:06.000Z","date":"2016-02-19T08:00:26.000Z","_content":"\nS  `N`  `1 ~ N` Z  Z \n\n<!-- more -->\n\n### \n[CodeVS 1069](http://codevs.cn/problem/1069/)  \n[Tyvj 1043](http://tyvj.cn/p/1403)  \n[ 1525](http://www.luogu.org/problem/show?pid=1525)\n\n### \n `x`  `x` \n\n BFS\n\n $ O(n{log}n) $ 100%  Tyvj  TLE \n\n  qwq\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 20000;\nconst int MAXM = 100000;\n\nenum Color {\n\tNone = 0,\n\tRed = 2000,\n\tBlue = 5280\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tColor color;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nint n, m, max;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline Color getReveseColor(Color c) {\n\treturn c == Red ? Blue : Red;\n}\n\ninline bool bfs(Node *start, int limit) {\n\n\treturn true;\n}\n\ninline bool check(int limit) {\n\tfor (int i = 0; i < n; i++) nodes[i].color = None;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].color == None) {\n\t\t\tnodes[i].color = Red;\n\n\t\t\tstd::queue<Node *> q;\n\t\t\tq.push(&nodes[i]);\n\n\t\t\twhile (!q.empty()) {\n\t\t\t\tNode *v = q.front();\n\t\t\t\tq.pop();\n\n\t\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\t\tif (e->w < limit) continue;\n\n\t\t\t\t\tif (e->to->color == None) {\n\t\t\t\t\t\te->to->color = getReveseColor(v->color);\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t} else if (e->to->color == v->color) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\ninline int solve() {\n\tint l = 1, r = max;\n\twhile (l < r) {\n\t\tint mid = (l & r) + ((l ^ r) >> 1);\n\t\t//printf(\"[%d, %d] with `mid` = %d\\n\", l, r, mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l - 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t\tmax = std::max(max, w);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}\n```","source":"_posts/noip2010-prison.md","raw":"title: NOIP2010 - \ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - Vijos\n  - \n  - \n  - \n  - \npermalink: noip2010-prison\nid: 54\nupdated: '2016-02-19 16:06:06'\ndate: 2016-02-19 16:00:26\n---\n\nS  `N`  `1 ~ N` Z  Z \n\n<!-- more -->\n\n### \n[CodeVS 1069](http://codevs.cn/problem/1069/)  \n[Tyvj 1043](http://tyvj.cn/p/1403)  \n[ 1525](http://www.luogu.org/problem/show?pid=1525)\n\n### \n `x`  `x` \n\n BFS\n\n $ O(n{log}n) $ 100%  Tyvj  TLE \n\n  qwq\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 20000;\nconst int MAXM = 100000;\n\nenum Color {\n\tNone = 0,\n\tRed = 2000,\n\tBlue = 5280\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tColor color;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), next(from->firstEdge), w(w) {}\n};\n\nint n, m, max;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline Color getReveseColor(Color c) {\n\treturn c == Red ? Blue : Red;\n}\n\ninline bool bfs(Node *start, int limit) {\n\n\treturn true;\n}\n\ninline bool check(int limit) {\n\tfor (int i = 0; i < n; i++) nodes[i].color = None;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].color == None) {\n\t\t\tnodes[i].color = Red;\n\n\t\t\tstd::queue<Node *> q;\n\t\t\tq.push(&nodes[i]);\n\n\t\t\twhile (!q.empty()) {\n\t\t\t\tNode *v = q.front();\n\t\t\t\tq.pop();\n\n\t\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\t\tif (e->w < limit) continue;\n\n\t\t\t\t\tif (e->to->color == None) {\n\t\t\t\t\t\te->to->color = getReveseColor(v->color);\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t} else if (e->to->color == v->color) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\ninline int solve() {\n\tint l = 1, r = max;\n\twhile (l < r) {\n\t\tint mid = (l & r) + ((l ^ r) >> 1);\n\t\t//printf(\"[%d, %d] with `mid` = %d\\n\", l, r, mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l - 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t\tmax = std::max(max, w);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}\n```","slug":"noip2010-prison","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c8v00n5c2xlsmh6mqzd"},{"title":"NOIP2010 - BFS + DP","date":"2016-11-13T09:23:00.000Z","_content":"\n $ N $  $ M $ \n\n $ 1 $ \n\n $ N $ \n\n<!-- more -->\n\n### \n[CodeVS 1066](http://codevs.cn/problem/1066/)\n\n### \n Floodfill\n\n Floodfill $ m $    DP \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nconst int MAXN = 500;\n\nconst int di[] = { 0, 1, 0, -1 };\nconst int dj[] = { -1, 0, 1, 0 };\n\nstruct Node {\n\tint height;\n\tbool visited;\n} map[MAXN + 2][MAXN + 2];\n\nint n, m;\n\nstruct Point {\n\tint i, j;\n\t\n\tPoint(int i = 0, int j = 0) : i(i), j(j) {}\n\n\tPoint move(int x) {\n\t\treturn Point(i + di[x], j + dj[x]);\n\t}\n\n\tbool valid() {\n\t\treturn i > 0 && j > 0 && i <= n && j <= m;\n\t}\n\n\tNode *operator->() const {\n\t\treturn &map[i][j];\n\t}\n};\n\nstruct Interval {\n\tint l, r;\n\n\tInterval(int l = 0, int r = 0) : l(l), r(r) {}\n\n\tbool operator<(const Interval &other) const {\n\t\treturn (l == other.l) ? (r < other.r) : (l < other.l);\n\t}\n};\n\ninline int bfs(Point start, Interval &interval) {\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) map[i][j].visited = false;\n\n\tstd::queue<Point> q;\n\tif (start.i == 0 && start.j == 0) {\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tmap[1][i].visited = true;\n\t\t\tq.push(Point(1, i));\n\t\t}\n\t} else {\n\t\tq.push(start);\n\t\tstart->visited = true;\n\t}\n\n\twhile (!q.empty()) {\n\t\tPoint v = q.front();\n\t\tq.pop();\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint u = v.move(i);\n\t\t\tif (!u.valid()) continue;\n\n\t\t\tif (u->height < v->height && !u->visited) {\n\t\t\t\tu->visited = true;\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (start.i == 0 && start.j == 0) {\n\t\tint cnt = 0;\n\t\tfor (int i = 1; i <= m; i++) if (!map[n][i].visited) cnt++;\n\t\treturn cnt;\n\t}\n\n\tbool flag = false;\n#ifdef DBG\n\tprintf(\"%d:\", start.j);\n#endif\n\tfor (int i = 1; i <= m + 1; i++) {\n#ifdef DBG\n\t\tif (map[n][i].visited) {\n\t\t\tprintf(\" %d\", i);\n\t\t}\n#endif\n\t\tif (!flag && map[n][i].visited) {\n\t\t\tinterval.l = i;\n\t\t\tflag = true;\n\t\t} else if (flag && !map[n][i].visited) {\n\t\t\tinterval.r = i - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef DBG\n\tprintf(\" = [%d, %d]\\n\", interval.l, interval.r);\n#endif\n\n\treturn flag;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) scanf(\"%d\", &map[i][j].height);\n\n\tInterval tmp;\n\tint cnt = bfs(Point(0, 0), tmp);\n\n\tif (cnt) {\n\t\tprintf(\"0\\n%d\\n\", cnt);\n\t} else {\n\t\tstatic Interval a[MAXN + 1];\n\t\tint k  = 0;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tInterval interval;\n\t\t\tif (bfs(Point(1, i), interval)) {\n\t\t\t\ta[++k] = interval;\n\t\t\t}\n\t\t}\n\n\t\tstd::sort(a + 1, a + k+ 1);\n\n\t\tstatic int f[MAXN + 1];\n\t\tint ans = INT_MAX;\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tf[i] = INT_MAX;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (a[j].r >= a[i].l - 1) {\n\t\t\t\t\tf[i] = std::min(f[i], f[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i].r == m) ans = std::min(ans, f[i]);\n\t\t}\n\n\t\tprintf(\"1\\n%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noip2010-flow.md","raw":"title: NOIP2010 - BFS + DP\ncategories: OI\ntags: \n  - NOIP\n  - CodeVS\n  - BFS\n  - DP\n  -  DP\npermalink: noip2010-flow\ndate: 2016-11-13 17:23:00\n---\n\n $ N $  $ M $ \n\n $ 1 $ \n\n $ N $ \n\n<!-- more -->\n\n### \n[CodeVS 1066](http://codevs.cn/problem/1066/)\n\n### \n Floodfill\n\n Floodfill $ m $    DP \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nconst int MAXN = 500;\n\nconst int di[] = { 0, 1, 0, -1 };\nconst int dj[] = { -1, 0, 1, 0 };\n\nstruct Node {\n\tint height;\n\tbool visited;\n} map[MAXN + 2][MAXN + 2];\n\nint n, m;\n\nstruct Point {\n\tint i, j;\n\t\n\tPoint(int i = 0, int j = 0) : i(i), j(j) {}\n\n\tPoint move(int x) {\n\t\treturn Point(i + di[x], j + dj[x]);\n\t}\n\n\tbool valid() {\n\t\treturn i > 0 && j > 0 && i <= n && j <= m;\n\t}\n\n\tNode *operator->() const {\n\t\treturn &map[i][j];\n\t}\n};\n\nstruct Interval {\n\tint l, r;\n\n\tInterval(int l = 0, int r = 0) : l(l), r(r) {}\n\n\tbool operator<(const Interval &other) const {\n\t\treturn (l == other.l) ? (r < other.r) : (l < other.l);\n\t}\n};\n\ninline int bfs(Point start, Interval &interval) {\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) map[i][j].visited = false;\n\n\tstd::queue<Point> q;\n\tif (start.i == 0 && start.j == 0) {\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tmap[1][i].visited = true;\n\t\t\tq.push(Point(1, i));\n\t\t}\n\t} else {\n\t\tq.push(start);\n\t\tstart->visited = true;\n\t}\n\n\twhile (!q.empty()) {\n\t\tPoint v = q.front();\n\t\tq.pop();\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint u = v.move(i);\n\t\t\tif (!u.valid()) continue;\n\n\t\t\tif (u->height < v->height && !u->visited) {\n\t\t\t\tu->visited = true;\n\t\t\t\tq.push(u);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (start.i == 0 && start.j == 0) {\n\t\tint cnt = 0;\n\t\tfor (int i = 1; i <= m; i++) if (!map[n][i].visited) cnt++;\n\t\treturn cnt;\n\t}\n\n\tbool flag = false;\n#ifdef DBG\n\tprintf(\"%d:\", start.j);\n#endif\n\tfor (int i = 1; i <= m + 1; i++) {\n#ifdef DBG\n\t\tif (map[n][i].visited) {\n\t\t\tprintf(\" %d\", i);\n\t\t}\n#endif\n\t\tif (!flag && map[n][i].visited) {\n\t\t\tinterval.l = i;\n\t\t\tflag = true;\n\t\t} else if (flag && !map[n][i].visited) {\n\t\t\tinterval.r = i - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef DBG\n\tprintf(\" = [%d, %d]\\n\", interval.l, interval.r);\n#endif\n\n\treturn flag;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) scanf(\"%d\", &map[i][j].height);\n\n\tInterval tmp;\n\tint cnt = bfs(Point(0, 0), tmp);\n\n\tif (cnt) {\n\t\tprintf(\"0\\n%d\\n\", cnt);\n\t} else {\n\t\tstatic Interval a[MAXN + 1];\n\t\tint k  = 0;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tInterval interval;\n\t\t\tif (bfs(Point(1, i), interval)) {\n\t\t\t\ta[++k] = interval;\n\t\t\t}\n\t\t}\n\n\t\tstd::sort(a + 1, a + k+ 1);\n\n\t\tstatic int f[MAXN + 1];\n\t\tint ans = INT_MAX;\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tf[i] = INT_MAX;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (a[j].r >= a[i].l - 1) {\n\t\t\t\t\tf[i] = std::min(f[i], f[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a[i].r == m) ans = std::min(ans, f[i]);\n\t\t}\n\n\t\tprintf(\"1\\n%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"noip2010-flow","published":1,"updated":"2016-11-13T09:23:38.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c9500nhc2xl568izctq"},{"title":"NOIP2006 -  DP","id":"19","updated":"2016-01-19T13:04:41.000Z","date":"2016-01-12T21:19:28.000Z","_content":"\nMarsMarsNMarsmrrn$m*r*n$Marsmn\nMars\n\n<!-- more -->\n\n### \n[CodeVS 1154](http://codevs.cn/problem/1154/)  \n[Tyvj 1056](http://tyvj.cn/p/1056)\n\n### \n\n\nDP $a[i]$  `i`  `i + 1`  $f[i][j]$  `i`  `j`  `k` `k` \n\n$$f[i][j]=\\max\\{f[i][k]+f[k+1][j]+a[i]*a[k+1]*a[j+1],k{\\in}[i,j-1]\\}$$\n\n\n\n$$f[i][j]=\\cases{0 & i=j \\\\ a[i]*a[j]*a[j+1] & j=i+1}$$\n\n\n\n $O(n^4)$ $n=100$  TvT\n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\nconst int MAXN = 100;\n\nint n, a[MAXN];\n\nint ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == j) return 0;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j - i == 1) ans[i - 1][j - 1] = a[i - 1] * a[j - 1] * a[(j + 1 - 1) % (n)];\n\t\telse {\n\t\t\tans[i - 1][j - 1] = 0;\n\t\t\tint p = a[i - 1] * a[(j + 1 - 1) % (n)];\n\t\t\tint m = -1;\n\t\t\tfor (int k = i; k <= j - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = std::max(ans[i - 1][j - 1], search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)]);\n\t\t\t\t/*if (search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)] > ans[i - 1][j - 1]) {\n\t\t\t\t\tans[i - 1][j - 1] = search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)];\n\t\t\t\t\tm = k;\n\t\t\t\t}*/\n\t\t\t}\n\t\t\t//printf(\"%d %d %d\\n\", i, (m + 1), (j + 1));\n\t\t\t//printf(\"from k = %d, %d * %d * %d, \", m, a[i - 1], a[(m + 1 - 1) % (n - 1)], a[(j + 1 - 1) % (n - 1)]);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\t\ta[n - 1] = first;\n\n\t\tmemset(calced, 0, sizeof(calced));\n\t\t/*for (int i = 0; i < n; i++) {\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tputchar('\\n');*/\n\t\tans = std::max(ans, search(1, n));\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2006-energy.md","raw":"title: NOIP2006 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - NOIP\n  - Tyvj\n  -  DP\npermalink: noip2006-energy\nid: 19\nupdated: '2016-01-19 21:04:41'\ndate: 2016-01-13 05:19:28\n---\n\nMarsMarsNMarsmrrn$m*r*n$Marsmn\nMars\n\n<!-- more -->\n\n### \n[CodeVS 1154](http://codevs.cn/problem/1154/)  \n[Tyvj 1056](http://tyvj.cn/p/1056)\n\n### \n\n\nDP $a[i]$  `i`  `i + 1`  $f[i][j]$  `i`  `j`  `k` `k` \n\n$$f[i][j]=\\max\\{f[i][k]+f[k+1][j]+a[i]*a[k+1]*a[j+1],k{\\in}[i,j-1]\\}$$\n\n\n\n$$f[i][j]=\\cases{0 & i=j \\\\ a[i]*a[j]*a[j+1] & j=i+1}$$\n\n\n\n $O(n^4)$ $n=100$  TvT\n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\nconst int MAXN = 100;\n\nint n, a[MAXN];\n\nint ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == j) return 0;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j - i == 1) ans[i - 1][j - 1] = a[i - 1] * a[j - 1] * a[(j + 1 - 1) % (n)];\n\t\telse {\n\t\t\tans[i - 1][j - 1] = 0;\n\t\t\tint p = a[i - 1] * a[(j + 1 - 1) % (n)];\n\t\t\tint m = -1;\n\t\t\tfor (int k = i; k <= j - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = std::max(ans[i - 1][j - 1], search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)]);\n\t\t\t\t/*if (search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)] > ans[i - 1][j - 1]) {\n\t\t\t\t\tans[i - 1][j - 1] = search(i, k) + search(k + 1, j) + p * a[(k + 1 - 1) % (n)];\n\t\t\t\t\tm = k;\n\t\t\t\t}*/\n\t\t\t}\n\t\t\t//printf(\"%d %d %d\\n\", i, (m + 1), (j + 1));\n\t\t\t//printf(\"from k = %d, %d * %d * %d, \", m, a[i - 1], a[(m + 1 - 1) % (n - 1)], a[(j + 1 - 1) % (n - 1)]);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\t\ta[n - 1] = first;\n\n\t\tmemset(calced, 0, sizeof(calced));\n\t\t/*for (int i = 0; i < n; i++) {\n\t\t\tprintf(\"%d \", a[i]);\n\t\t}\n\t\tputchar('\\n');*/\n\t\tans = std::max(ans, search(1, n));\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"noip2006-energy","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c9a00npc2xlq3jhcl52"},{"title":"NOIP2006 -  DP +  DP","id":"25","updated":"2016-01-19T13:02:58.000Z","date":"2016-01-16T22:11:03.000Z","_content":"\nN\n\n012N51~5510NN\n\n<!-- more -->\n\n### \n[CodeVS 1155](http://codevs.cn/problem/1155/)  \n[Tyvj 1057](http://tyvj.cn/p/1057)  \n[ 1064](http://www.luogu.org/problem/show?pid=1064)  \n[Vijos 1313](https://vijos.org/p/1313?pid=1313)\n\n### \n DP \n\n 01 \n\n$$ f[v] = \\max(f[v],f[v-c[i]]+w[i]) $$\n\n 01 \n\n `0`  `0` \n\n~~~~\n\nPS TLE  `10`  `10` \n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 60;\nconst int MAXV = 3200;\n\nint n, V;\n\nstruct Tree {\n\tTree *children, *next;\n\tint c, w;\n\tint f[MAXV + 1];\n\n\tTree() {}\n\tTree(Tree *parent, int c, int w) : next(parent->children), c(c), w(w) {\n\t\tmemset(f, 0, sizeof(f));\n\t}\n\n\tvoid solve() {\n\t\tfor (int v = V; v >= c; v--) f[v] = w;\n\t\tfor (Tree *t = children; t; t = t->next) {\n\t\t\tt->solve();\n\t\t\tfor (int v = V - c; v >= t->c; v--) {\n\t\t\t\tfor (int i = t->c; i <= std::min(V - c, v + c); i++) {\n\t\t\t\t\tf[v + c] = std::max(f[v + c], f[v + c - i] + t->f[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} trees[MAXN + 1];\n\ninline void addTree(int id, int parent, int c, int w) {\n\ttrees[parent].children = new (&trees[id]) Tree(&trees[parent], c, w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &V, &n);\n\tV /= 10;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, p, q;\n\t\tscanf(\"%d %d %d\", &c, &p, &q);\n\n\t\taddTree(i + 1, q, c / 10, c * p);\n\t}\n\n\ttrees[0].solve();\n\n\tprintf(\"%d\\n\", trees[0].f[V]);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2006-budget.md","raw":"title: NOIP2006 -  DP +  DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - Tyvj\n  - Vijos\n  -  DP\n  - \n  -  DP\npermalink: noip2006-budget\nid: 25\nupdated: '2016-01-19 21:02:58'\ndate: 2016-01-17 06:11:03\n---\n\nN\n\n012N51~5510NN\n\n<!-- more -->\n\n### \n[CodeVS 1155](http://codevs.cn/problem/1155/)  \n[Tyvj 1057](http://tyvj.cn/p/1057)  \n[ 1064](http://www.luogu.org/problem/show?pid=1064)  \n[Vijos 1313](https://vijos.org/p/1313?pid=1313)\n\n### \n DP \n\n 01 \n\n$$ f[v] = \\max(f[v],f[v-c[i]]+w[i]) $$\n\n 01 \n\n `0`  `0` \n\n~~~~\n\nPS TLE  `10`  `10` \n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 60;\nconst int MAXV = 3200;\n\nint n, V;\n\nstruct Tree {\n\tTree *children, *next;\n\tint c, w;\n\tint f[MAXV + 1];\n\n\tTree() {}\n\tTree(Tree *parent, int c, int w) : next(parent->children), c(c), w(w) {\n\t\tmemset(f, 0, sizeof(f));\n\t}\n\n\tvoid solve() {\n\t\tfor (int v = V; v >= c; v--) f[v] = w;\n\t\tfor (Tree *t = children; t; t = t->next) {\n\t\t\tt->solve();\n\t\t\tfor (int v = V - c; v >= t->c; v--) {\n\t\t\t\tfor (int i = t->c; i <= std::min(V - c, v + c); i++) {\n\t\t\t\t\tf[v + c] = std::max(f[v + c], f[v + c - i] + t->f[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} trees[MAXN + 1];\n\ninline void addTree(int id, int parent, int c, int w) {\n\ttrees[parent].children = new (&trees[id]) Tree(&trees[parent], c, w);\n}\n\nint main() {\n\tscanf(\"%d %d\", &V, &n);\n\tV /= 10;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, p, q;\n\t\tscanf(\"%d %d %d\", &c, &p, &q);\n\n\t\taddTree(i + 1, q, c / 10, c * p);\n\t}\n\n\ttrees[0].solve();\n\n\tprintf(\"%d\\n\", trees[0].f[V]);\n\n\treturn 0;\n}\n```\n","slug":"noip2006-budget","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c9j00nwc2xlb0vtong6"},{"title":"NOIP2003 -  DP","id":"20","updated":"2016-01-19T13:04:15.000Z","date":"2016-01-13T20:23:38.000Z","_content":"\n `n` 50 `m` 9 `m`  10  `k` `k` \n\n<!-- more -->\n\n### \n[CodeVS 1085](http://codevs.cn/problem/1085/)  \n[Tyvj 1901](http://tyvj.cn/p/1901)  \n[ 1043](http://www.luogu.org/problem/show?pid=1043)\n\n### \n DP  ** `10` **\n\n $ f[i][j] $  `i`  `j` \n\n$$ f[i][j] = \\max\\{f[k][j-1]* (({\\sum_{x=k+1}^{i}a[x]}) \\ {\\rm mod} \\ 10),k{\\in}[j-1,i-1]\\} $$\n\n\n\n$$ f[i][1] = ({\\sum_{x=1}^i{a[x]}}) \\ {\\rm mod} \\ 10 $$\n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <typeinfo>\n#include <algorithm>\n\ntypedef const int &(*Extreme)(const int &, const int &);\n\nconst int MAXN = 50;\nconst int MAXM = 9;\n\nint n, m, a[MAXN], prefixSum[MAXN];\nint ans[MAXN][MAXM];\nbool calced[MAXN][MAXM];\n\ninline int mod10(int x) {\n\treturn ((x % 10) + 10) % 10;\n}\n\ninline void initPrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 1; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn mod10(i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1]);\n}\n\nint search(int i, int j, Extreme extreme) {\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j == 1) ans[i - 1][j - 1] = sum(1, i);\n\t\telse {\n\t\t\tfor (int k = j - 1; k <= i - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = extreme(ans[i - 1][j - 1], search(k, j - 1, extreme) * sum(k + 1, i));\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\ninline void work(int &ansMin, int &ansMax) {\n\t/*for (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", a[i]);\n\t}\n\tputchar('\\n');*/\n\n\tinitPrefixSum();\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MIN, calced[i][j] = false;\n\t\t}\n\t}\n\n\tansMax = std::max(ansMax, search(n, m, std::max));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MAX, calced[i][j] = false;\n\t\t}\n\t}\n\tansMin = std::min(ansMin, search(n, m, std::min));\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ansMin = INT_MAX, ansMax = INT_MIN;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\n\t\ta[n - 1] = first;\n\n\t\twork(ansMin, ansMax);\n\t}\n\n\tprintf(\"%d\\n%d\\n\", ansMin, ansMax);\n\n\treturn 0;\n}\n```\n","source":"_posts/noip2003-game.md","raw":"title: NOIP2003 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - NOIP\n  -  DP\n  - \n  - Tyvj\npermalink: noip2003-game\nid: 20\nupdated: '2016-01-19 21:04:15'\ndate: 2016-01-14 04:23:38\n---\n\n `n` 50 `m` 9 `m`  10  `k` `k` \n\n<!-- more -->\n\n### \n[CodeVS 1085](http://codevs.cn/problem/1085/)  \n[Tyvj 1901](http://tyvj.cn/p/1901)  \n[ 1043](http://www.luogu.org/problem/show?pid=1043)\n\n### \n DP  ** `10` **\n\n $ f[i][j] $  `i`  `j` \n\n$$ f[i][j] = \\max\\{f[k][j-1]* (({\\sum_{x=k+1}^{i}a[x]}) \\ {\\rm mod} \\ 10),k{\\in}[j-1,i-1]\\} $$\n\n\n\n$$ f[i][1] = ({\\sum_{x=1}^i{a[x]}}) \\ {\\rm mod} \\ 10 $$\n\n****\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <typeinfo>\n#include <algorithm>\n\ntypedef const int &(*Extreme)(const int &, const int &);\n\nconst int MAXN = 50;\nconst int MAXM = 9;\n\nint n, m, a[MAXN], prefixSum[MAXN];\nint ans[MAXN][MAXM];\nbool calced[MAXN][MAXM];\n\ninline int mod10(int x) {\n\treturn ((x % 10) + 10) % 10;\n}\n\ninline void initPrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 1; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn mod10(i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1]);\n}\n\nint search(int i, int j, Extreme extreme) {\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (j == 1) ans[i - 1][j - 1] = sum(1, i);\n\t\telse {\n\t\t\tfor (int k = j - 1; k <= i - 1; k++) {\n\t\t\t\tans[i - 1][j - 1] = extreme(ans[i - 1][j - 1], search(k, j - 1, extreme) * sum(k + 1, i));\n\t\t\t}\n\t\t}\n\n\t\t//printf(\"f[%d][%d] = %d\\n\", i, j, ans[i - 1][j - 1]);\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\ninline void work(int &ansMin, int &ansMax) {\n\t/*for (int i = 0; i < n; i++) {\n\t\tprintf(\"%d \", a[i]);\n\t}\n\tputchar('\\n');*/\n\n\tinitPrefixSum();\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MIN, calced[i][j] = false;\n\t\t}\n\t}\n\n\tansMax = std::max(ansMax, search(n, m, std::max));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tans[i][j] = INT_MAX, calced[i][j] = false;\n\t\t}\n\t}\n\tansMin = std::min(ansMin, search(n, m, std::min));\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tint ansMin = INT_MAX, ansMax = INT_MIN;\n\tfor (int i = 0; i < n; i++) {\n\t\tint first = a[0];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\ta[i] = a[i + 1];\n\t\t}\n\n\t\ta[n - 1] = first;\n\n\t\twork(ansMin, ansMax);\n\t}\n\n\tprintf(\"%d\\n%d\\n\", ansMin, ansMax);\n\n\treturn 0;\n}\n```\n","slug":"noip2003-game","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c9p00o5c2xljftollwe"},{"title":"NOIP2000 -  DP","id":"16","updated":"2016-01-19T13:05:38.000Z","date":"2016-01-08T21:10:45.000Z","_content":"\n `N`<= 400 `K`<= 6\n\n<!-- more -->\n\n### \n[CodeVS 1017](http://codevs.cn/problem/1017/)\n\n### \n DP `f[n][k]`  `n`  `k`  `a[i][j]`  `i`  `j` \n\n$$ f[n][k] = {\\max}\\{f[i][k - 1] * a[i + 1][n],i{\\in}[k,n)\\} $$\n\n `long long` \n\n### \n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 40;\nconst int MAXK = 6;\n\nint n, k;\nchar num[MAXN + 1];\nlong long a[MAXN][MAXN], ans[MAXN][MAXK];\nbool calced[MAXN][MAXK];\n\ninline void preProcess() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i <= j) {\n\t\t\t\tfor (int k = i; k <= j; k++) {\n\t\t\t\t\ta[i][j] *= 10;\n\t\t\t\t\ta[i][j] += (num[k] - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long search(int n, int k) {\n\tif (k == 0) return a[0][n - 1];\n\n\tif (!calced[n - 1][k - 1]) {\n\t\tfor (int i = k; i < n; i++) {\n\t\t\tans[n - 1][k - 1] = std::max(ans[n - 1][k - 1], search(i, k - 1) * a[i + 1 - 1][n - 1]);\n\t\t}\n\t\t\n\t\tcalced[n - 1][k - 1] = true;\n\t}\n\n\treturn ans[n - 1][k - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\\n%s\", &n, &k, num);\n\tpreProcess();\n\n\tprintf(\"%lld\\n\", search(n, k));\n\treturn 0;\n}\n```\n","source":"_posts/noip2000-cheng-ji-zui-da.md","raw":"title: NOIP2000 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - NOIP\n  -  DP\npermalink: noip2000-cheng-ji-zui-da\nid: 16\nupdated: '2016-01-19 21:05:38'\ndate: 2016-01-09 05:10:45\n---\n\n `N`<= 400 `K`<= 6\n\n<!-- more -->\n\n### \n[CodeVS 1017](http://codevs.cn/problem/1017/)\n\n### \n DP `f[n][k]`  `n`  `k`  `a[i][j]`  `i`  `j` \n\n$$ f[n][k] = {\\max}\\{f[i][k - 1] * a[i + 1][n],i{\\in}[k,n)\\} $$\n\n `long long` \n\n### \n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 40;\nconst int MAXK = 6;\n\nint n, k;\nchar num[MAXN + 1];\nlong long a[MAXN][MAXN], ans[MAXN][MAXK];\nbool calced[MAXN][MAXK];\n\ninline void preProcess() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (i <= j) {\n\t\t\t\tfor (int k = i; k <= j; k++) {\n\t\t\t\t\ta[i][j] *= 10;\n\t\t\t\t\ta[i][j] += (num[k] - '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long search(int n, int k) {\n\tif (k == 0) return a[0][n - 1];\n\n\tif (!calced[n - 1][k - 1]) {\n\t\tfor (int i = k; i < n; i++) {\n\t\t\tans[n - 1][k - 1] = std::max(ans[n - 1][k - 1], search(i, k - 1) * a[i + 1 - 1][n - 1]);\n\t\t}\n\t\t\n\t\tcalced[n - 1][k - 1] = true;\n\t}\n\n\treturn ans[n - 1][k - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\\n%s\", &n, &k, num);\n\tpreProcess();\n\n\tprintf(\"%lld\\n\", search(n, k));\n\treturn 0;\n}\n```\n","slug":"noip2000-cheng-ji-zui-da","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6c9v00odc2xlc5u61jl9"},{"title":"NOI2016 - ","date":"2016-09-05T23:19:00.000Z","_content":"\n $ n $  $ [l_1, r_1], [l_2, r_2] , \\ldots, [l_n, r_n] $ $ m $  $ m $  $ x $ $ [l_i, r_i] $ $ l_i \\leq x \\leq r_i $\n\n $ [l_i, r_i] $  $ r_i  l_i $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 4653](http://www.lydsy.com/JudgeOnline/problem.php?id=4653)\n\n### \n $ m $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 200000;\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tint val, tag;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), lc(lc), rc(rc), val(0) {}\n\n\tvoid cover(const int delta) {\n\t\tval += delta;\n\t\ttag += delta;\n\t}\n\n\tvoid pushDown() {\n\t\tif (tag) {\n\t\t\tlc->cover(tag);\n\t\t\trc->cover(tag);\n\t\t\ttag = 0;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const int delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) cover(delta);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlc->update(l, r, delta);\n\t\t\trc->update(l, r, delta);\n\t\t\tval = std::max(lc->val, rc->val);\n\t\t}\n\t}\n\n\tint query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return val;\n\t\telse {\n\t\t\tpushDown();\n\t\t\treturn std::max(lc->query(l, r), rc->query(l, r));\n\t\t}\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segment;\n\nstruct Interval {\n\tint l, r, len;\n\n\tbool operator<(const Interval &other) const { return len < other.len; }\n} a[MAXN];\n\nint n, m;\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[i].l, &a[i].r), a[i].len = a[i].r - a[i].l;\n\n\tstatic int set[MAXN * 2];\n\tint cnt = 0, max = 0;\n\tfor (int i = 0; i < n; i++) set[cnt++] = a[i].l, set[cnt++] = a[i].r;\n\tstd::sort(set, set + n * 2);\n\tint *end = std::unique(set, set + n * 2);\n\tfor (int i = 0; i < n; i++) a[i].l = std::lower_bound(set, end, a[i].l) - set, a[i].r = std::lower_bound(set, end, a[i].r) - set, max = std::max(max, a[i].r);\n\n\tstd::sort(a, a + n);\n\n\tsegment = SegmentTree::build(0, max);\n\n\tint ans = INT_MAX;\n\tfor (Interval *l = a, *r = a; r != a + n; r++) {\n\t\tsegment->update(r->l, r->r, 1);\n\t\twhile (l <= r && segment->query(0, max) >= m) {\n\t\t\tans = std::min(ans, r->len - l->len);\n\t\t\tsegment->update(l->l, l->r, -1);\n\t\t\tl++;\n\t\t}\n\t}\n\n\tif (ans == INT_MAX) puts(\"-1\");\n\telse printf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2016-interval.md","raw":"title: NOI2016 - \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - \npermalink: noi2016-interval\ndate: 2016-09-06 07:19:00\n---\n\n $ n $  $ [l_1, r_1], [l_2, r_2] , \\ldots, [l_n, r_n] $ $ m $  $ m $  $ x $ $ [l_i, r_i] $ $ l_i \\leq x \\leq r_i $\n\n $ [l_i, r_i] $  $ r_i  l_i $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 4653](http://www.lydsy.com/JudgeOnline/problem.php?id=4653)\n\n### \n $ m $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 200000;\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tint val, tag;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), lc(lc), rc(rc), val(0) {}\n\n\tvoid cover(const int delta) {\n\t\tval += delta;\n\t\ttag += delta;\n\t}\n\n\tvoid pushDown() {\n\t\tif (tag) {\n\t\t\tlc->cover(tag);\n\t\t\trc->cover(tag);\n\t\t\ttag = 0;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const int delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) cover(delta);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlc->update(l, r, delta);\n\t\t\trc->update(l, r, delta);\n\t\t\tval = std::max(lc->val, rc->val);\n\t\t}\n\t}\n\n\tint query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return val;\n\t\telse {\n\t\t\tpushDown();\n\t\t\treturn std::max(lc->query(l, r), rc->query(l, r));\n\t\t}\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\telse {\n\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segment;\n\nstruct Interval {\n\tint l, r, len;\n\n\tbool operator<(const Interval &other) const { return len < other.len; }\n} a[MAXN];\n\nint n, m;\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[i].l, &a[i].r), a[i].len = a[i].r - a[i].l;\n\n\tstatic int set[MAXN * 2];\n\tint cnt = 0, max = 0;\n\tfor (int i = 0; i < n; i++) set[cnt++] = a[i].l, set[cnt++] = a[i].r;\n\tstd::sort(set, set + n * 2);\n\tint *end = std::unique(set, set + n * 2);\n\tfor (int i = 0; i < n; i++) a[i].l = std::lower_bound(set, end, a[i].l) - set, a[i].r = std::lower_bound(set, end, a[i].r) - set, max = std::max(max, a[i].r);\n\n\tstd::sort(a, a + n);\n\n\tsegment = SegmentTree::build(0, max);\n\n\tint ans = INT_MAX;\n\tfor (Interval *l = a, *r = a; r != a + n; r++) {\n\t\tsegment->update(r->l, r->r, 1);\n\t\twhile (l <= r && segment->query(0, max) >= m) {\n\t\t\tans = std::min(ans, r->len - l->len);\n\t\t\tsegment->update(l->l, l->r, -1);\n\t\t\tl++;\n\t\t}\n\t}\n\n\tif (ans == INT_MAX) puts(\"-1\");\n\telse printf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"noi2016-interval","published":1,"updated":"2016-09-05T23:39:11.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6ca000ojc2xlpt1gw5qo"},{"title":"NOI2016 - ","date":"2016-09-08T11:40:00.000Z","_content":"\n $ n \\times m $  $ c $ \n\n<!-- more -->\n\n### \n[BZOJ 4651](http://www.lydsy.com/JudgeOnline/problem.php?id=4651)  \n[UOJ #220](http://uoj.ac/problem/220)\n\n### \n $ 2 $$ -1 $$ 0 $$ 1 $ \n\n#### \n\n\n1. \n2. \n\n $ n \\times m = c $  $ n $  $ m $ $ n \\times m = c + 2 $ $ | x_1 - x_2 | + | y_1 - y_2 | = 1 $ \n\n####  $ 0 $\n $ 0 $ ****\n\n FloodFill $ O(c) $ \n\n  ****\n\n FloodFill**** $ 0 $\n\n####  $ 1 $\n $ 1 $ ****\n\n\n\n\n\n```plain\n.......\n...111.\n...1*1.\n.11111.\n.1*1...\n.111...\n.......\n```\n\n $ 1 $   \n\n****\n\n```plain\n..22222\n..21112\n2221*12\n2111112\n21*1222\n21112..\n22222..\n```\n\n** $ 1 $ **\n\n#### \n $ 1 $\n\n $ 0 $\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\n#define HASH(x, y) (static_cast<unsigned long long>(x) << 32) | static_cast<unsigned long long>(y)\n#define inline inline __attribute__((always_inline))\n\nconst int MAXC = 100000;\nconst int MAXN = MAXC * 24;\nconst int dx[4] = { 1, -1, 0, 0 };\nconst int dy[4] = { 0, 0, 1, -1 };\n\ntemplate <typename Tk, typename Tv>\nstruct HashMap {\n\tconst static size_t HASH_SIZE = 7979717;\n\tstruct Node {\n\t\tstruct Pair {\n\t\t\tTk first;\n\t\t\tTv second;\n\t\t} p;\n\t\tint time;\n\t} N[HASH_SIZE];\n\n\ttypedef typename Node::Pair *iterator;\n\n\tint time;\n\n\tinline HashMap() : time(1) {}\n\n\tinline int hash(const Tk &k) {\n\t\treturn k % HASH_SIZE;\n\t}\n\n\tinline Node *locate(const Tk &k) {\n\t\tregister int i;\n\t\tfor (i = hash(k); N[i].time == time && N[i].p.first != k; (++i == HASH_SIZE) && (i = 0));\n\t\treturn &N[i];\n\t}\n\n\tinline iterator find(const Tk &k) {\n\t\tregister Node *v = locate(k);\n\t\tif (v->time != time || v->p.first != k) return end();\n\t\treturn &v->p;\n\t}\n\n\tinline Tv &operator[](const Tk &k) {\n\t\tregister Node *v = locate(k);\n\t\tif (v->time != time || v->p.first != k) {\n\t\t\tv->time = time, v->p.first = k, v->p.second = Tv();\n\t\t}\n\t\treturn v->p.second;\n\t}\n\n\tinline void clear() { time++; }\n\n\tinline iterator end() const { return NULL; }\n};\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint type, dfn, low;\n\tbool v, pushed, flag;\n\tint x, y;\n} N[MAXN], *p = N;\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tinline Edge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(Node *s, Node *t) {\n\ts->e = new Edge(s, t);\n}\n\nint n, m, c;\nstruct Point {\n\tint x, y;\n\n\tinline Point(const int x = 0, const int y = 0) : x(x), y(y) {}\n\n\tinline bool operator<(const Point &other) const {\n\t\treturn y < other.y;\n\t}\n} a[MAXN];\n\nHashMap<unsigned long long, Node *> map;\n\ninline Node *clear(Node *p) {\n\tfor (Edge *&e = p->e, *next; e; next = e->next, delete e, e = next);\n\tmemset(p, 0, sizeof(Node));\n\treturn p;\n}\n\n#ifdef DBG\nchar str[1000][1000];\n#endif\n\ninline void getNodes(const int x, const int y, const bool second = false) {\n\tfor (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(x + fx < 1 || x + fx > n || y + fy < 1 || y + fy > m)) {\n\t\tregister int nx = x + fx, ny = y + fy;\n\t\tregister HashMap<unsigned long long, Node *>::iterator it = map.find(HASH(nx, ny));\n\t\tif (it == map.end() || it->second != NULL) {\n\t\t\tNode *v;\n\t\t\tif (it == map.end()) {\n\t\t\t\tv = map[HASH(nx, ny)] = clear(p++);\n\t\t\t\tv->x = nx, v->y = ny;\n\t\t\t} else v = it->second;\n\t\t\tv->type = 1;\n#ifdef DBG\n\t\t\tstr[v->x][v->y] = 'A';\n#endif\n\t\t\tif (second) for (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(nx + fx < 1 || nx + fx > n || ny + fy < 1 || ny + fy > m)) {\n\t\t\t\tregister int nx2 = nx + fx, ny2 = ny + fy;\n\t\t\t\tregister HashMap<unsigned long long, Node *>::iterator it = map.find(HASH(nx2, ny2));\n\t\t\t\tif (it == map.end()) {\n\t\t\t\t\tclear(p);\n\t\t\t\t\tp->type = 2;\n\t\t\t\t\tp->x = nx2, p->y = ny2;\n#ifdef DBG\n\t\t\t\t\tstr[p->x][p->y] = 'B';\n#endif\n\t\t\t\t\tmap[HASH(nx2, ny2)] = p++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void addEdges() {\n\t// for (HashMap<unsigned long long, Node *>::iterator it = map.begin(); it != map.end(); it++) if (it->second) {\n\tfor (Node *v = N; v != p; v++) {\n\t\tregister int &x = v->x, &y = v->y;\n\t\tfor (register int i = 0; i < 4; i++) if (!(x + dx[i] < 1 || x + dx[i] > n || y + dy[i] < 1 || y + dy[i] > m)) {\n\t\t\tregister int nx = x + dx[i], ny = y + dy[i];\n\t\t\tregister HashMap<unsigned long long, Node *>::iterator it2 = map.find(HASH(nx, ny));\n\t\t\tif (it2 != map.end() && it2->second) {\n#ifdef DBG\n\t\t\t\tprintf(\"[%d, %d] -> [%d, %d]\\n\", v->x, v->y, it2->second->x, it2->second->y);\n#endif\n\t\t\t\taddEdge(v, it2->second);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int tarjan() {\n\tregister int ts = 0, cnt = 0;\n\tfor (Node *start = N; start != p; start++) {\n\t\tif (start->v) continue;\n\n\t\tstatic Node *s[MAXN];\n\t\tNode **top = s;\n\t\tstart->pushed = true;\n\t\t*top = start;\n\n\t\twhile (top != s - 1) {\n\t\t\tNode *v = *top;\n\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t\tv->c = v->e;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v && e->t != v->p) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) *++top = e->t, e->t->pushed = true, e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != start) for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t->low >= v->dfn) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (v->flag && v->type == 1) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\n\t\t\t\ttop--;\n\t\t\t}\n\t\t}\n\n\t\tint ch = 0;\n\t\tfor (Edge *e = start->e; e; e = e->next) if (e->t->p == start) ch++;\n\t\tstart->flag = ch >= 2;\n\t\tif (start->flag && start->type == 1) cnt++;\n\t}\n\n\treturn cnt;\n}\n\ninline bool isOne() {\n\tfor (register int i = 0; i < c; i++) {\n\t\tregister int &x = a[i].x, &y = a[i].y;\n\t\tmap[HASH(x, y)] = NULL;\n\t}\n\n\tp = N;\n\n\tfor (register int i = 0; i < c; i++) {\n\t\tgetNodes(a[i].x, a[i].y, true);\n\t}\n\n\taddEdges();\n\n\treturn tarjan() != 0;\n}\n\ninline bool bfsCount() {\n\tbool flag = false;\n\tfor (Node *start = N; start != p; start++) {\n\t\tif (start->v) continue;\n\t\tif (flag) return true;\n\t\tflag = true;\n\n\t\tstatic Node *q[MAXN];\n\t\tNode **l = q, **r = q;\n\t\tstart->v = true;\n\t\t*l = start;\n\n\t\twhile (l <= r) {\n\t\t\tNode *v = *l++;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->v) {\n\t\t\t\te->t->v = true;\n\t\t\t\t*++r = e->t;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\ninline bool isZero() {\n\tstatic HashMap<unsigned long long, bool> map2;\n\tmap2.clear();\n\tfor (register int i = 0; i < c; i++) {\n\t\tmap2[HASH(a[i].x, a[i].y)] = false;\n\t}\n\tbool ans = false;\n#ifdef DBG\n\tint id = 0;\n#endif\n\tfor (int i = 0; i < c; i++) {\n\t\tregister int &x = a[i].x, &y = a[i].y;\n\t\tregister bool &f = map2[HASH(x, y)];\n\t\tif (f) continue;\n\t\tf = true;\n\n#ifdef DBG\n\t\tid++;\n#endif\n\n\t\tstatic Point vec[MAXC];\n\t\tint cnt = 0;\n\n\t\tmap.clear();\n\t\tp = N;\n\n\t\tstatic Point q[MAXC];\n\t\tPoint *l = q, *r = q;\n\t\t*l = Point(x, y);\n\t\twhile (l <= r) {\n\t\t\tPoint p = *l++;\n\n#ifdef DBG\n\t\t\tstr[p.x][p.y] = id + '0';\n#endif\n\n\t\t\tmap[HASH(p.x, p.y)] = NULL;\n\t\t\tvec[cnt++] = p;\n\n\t\t\tfor (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(p.x + fx < 1 || p.x + fx > n || p.y + fy < 1 || p.y + fy > m)) {\n\t\t\t\tregister int nx = p.x + fx, ny = p.y + fy;\n\t\t\t\tHashMap<unsigned long long, bool>::iterator it = map2.find(HASH(nx, ny));\n\t\t\t\tif (it != map2.end() && it->second == false) {\n\t\t\t\t\tit->second = true;\n\t\t\t\t\t*++r = Point(nx, ny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) getNodes(vec[i].x, vec[i].y);\n\t\taddEdges();\n\t\tif (bfsCount()) {\n\t\t\tans = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmap.clear();\n\treturn ans;\n}\n\ninline bool isInvalid() {\n\tconst unsigned long long r = static_cast<unsigned long long>(n) * m - c;\n\tif (r < 2) return true;\n\telse if (r == 2) {\n\t\tstatic bool flag[MAXC];\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tflag[(a[i].x - 1) * m + a[i].y - 1] = true;\n\t\t}\n\n\t\tPoint pts[2];\n\t\tfor (int i = 0, cnt = 0; i < n; i++) for (int j = 0; j < m; j++) {\n\t\t\tif (!flag[i * m + j]) pts[cnt++] = Point(i, j);\n\t\t\tflag[i * m + j] = false;\n\t\t}\n\n\t\treturn abs(pts[0].x - pts[1].x) + abs(pts[0].y - pts[1].y) == 1;\n\t} else return false;\n}\n\ninline const char *special() {\n\tstd::sort(a, a + c);\n\tint last = 0, cnt = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tif (a[i].y != last + 1) {\n\t\t\tcnt++;\n\t\t}\n\t\tlast = a[i].y;\n\t}\n\tif (last != m) cnt++;\n\treturn cnt == 1 ? \"1\" : \"0\";\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar_unlocked(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar_unlocked(), (ch >= '0' && ch <= '9'));\n}\n\nint main() {\n\tint t;\n\tread(t);\n\twhile (t--) {\n\t\tread(n), read(m), read(c);\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tread(a[i].x), read(a[i].y);\n\t\t\tif (n > m) std::swap(a[i].x, a[i].y);\n\t\t}\n\n\t\tif (n > m) std::swap(n, m);\n\n\t\tif (isInvalid()) puts(\"-1\");\n\t\telse if (n == 1) puts(special());\n\t\telse if (isZero()) puts(\"0\");\n\t\telse if (isOne()) puts(\"1\");\n\t\telse puts(\"2\");\n\n#ifdef DBG\n\t\tfor (Node *v = N; v != p; v++) {\n\t\t\tprintf(\"[%d, %d] => %d\\n\", v->x, v->y, v->type);\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tHashMap<unsigned long long, Node *>::iterator it = map.find(HASH(i, j));\n\t\t\t\tif (it == map.end()) putchar('-');\n\t\t\t\telse if (!it->second) putchar('X');\n\t\t\t\telse putchar('0' + it->second->type);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\n\t\t/*\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tputchar(str[i][j] ? str[i][j] : '-');\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t\t*/\n#endif\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2016-grid.md","raw":"title: NOI2016 - \ncategories: OI\ntags: \n  - BZOJ\n  - NOI\n  - Tarjan\n  - \n  - \npermalink: noi2016-grid\ndate: 2016-09-08 19:40:00\n---\n\n $ n \\times m $  $ c $ \n\n<!-- more -->\n\n### \n[BZOJ 4651](http://www.lydsy.com/JudgeOnline/problem.php?id=4651)  \n[UOJ #220](http://uoj.ac/problem/220)\n\n### \n $ 2 $$ -1 $$ 0 $$ 1 $ \n\n#### \n\n\n1. \n2. \n\n $ n \\times m = c $  $ n $  $ m $ $ n \\times m = c + 2 $ $ | x_1 - x_2 | + | y_1 - y_2 | = 1 $ \n\n####  $ 0 $\n $ 0 $ ****\n\n FloodFill $ O(c) $ \n\n  ****\n\n FloodFill**** $ 0 $\n\n####  $ 1 $\n $ 1 $ ****\n\n\n\n\n\n```plain\n.......\n...111.\n...1*1.\n.11111.\n.1*1...\n.111...\n.......\n```\n\n $ 1 $   \n\n****\n\n```plain\n..22222\n..21112\n2221*12\n2111112\n21*1222\n21112..\n22222..\n```\n\n** $ 1 $ **\n\n#### \n $ 1 $\n\n $ 0 $\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\n#define HASH(x, y) (static_cast<unsigned long long>(x) << 32) | static_cast<unsigned long long>(y)\n#define inline inline __attribute__((always_inline))\n\nconst int MAXC = 100000;\nconst int MAXN = MAXC * 24;\nconst int dx[4] = { 1, -1, 0, 0 };\nconst int dy[4] = { 0, 0, 1, -1 };\n\ntemplate <typename Tk, typename Tv>\nstruct HashMap {\n\tconst static size_t HASH_SIZE = 7979717;\n\tstruct Node {\n\t\tstruct Pair {\n\t\t\tTk first;\n\t\t\tTv second;\n\t\t} p;\n\t\tint time;\n\t} N[HASH_SIZE];\n\n\ttypedef typename Node::Pair *iterator;\n\n\tint time;\n\n\tinline HashMap() : time(1) {}\n\n\tinline int hash(const Tk &k) {\n\t\treturn k % HASH_SIZE;\n\t}\n\n\tinline Node *locate(const Tk &k) {\n\t\tregister int i;\n\t\tfor (i = hash(k); N[i].time == time && N[i].p.first != k; (++i == HASH_SIZE) && (i = 0));\n\t\treturn &N[i];\n\t}\n\n\tinline iterator find(const Tk &k) {\n\t\tregister Node *v = locate(k);\n\t\tif (v->time != time || v->p.first != k) return end();\n\t\treturn &v->p;\n\t}\n\n\tinline Tv &operator[](const Tk &k) {\n\t\tregister Node *v = locate(k);\n\t\tif (v->time != time || v->p.first != k) {\n\t\t\tv->time = time, v->p.first = k, v->p.second = Tv();\n\t\t}\n\t\treturn v->p.second;\n\t}\n\n\tinline void clear() { time++; }\n\n\tinline iterator end() const { return NULL; }\n};\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint type, dfn, low;\n\tbool v, pushed, flag;\n\tint x, y;\n} N[MAXN], *p = N;\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tinline Edge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(Node *s, Node *t) {\n\ts->e = new Edge(s, t);\n}\n\nint n, m, c;\nstruct Point {\n\tint x, y;\n\n\tinline Point(const int x = 0, const int y = 0) : x(x), y(y) {}\n\n\tinline bool operator<(const Point &other) const {\n\t\treturn y < other.y;\n\t}\n} a[MAXN];\n\nHashMap<unsigned long long, Node *> map;\n\ninline Node *clear(Node *p) {\n\tfor (Edge *&e = p->e, *next; e; next = e->next, delete e, e = next);\n\tmemset(p, 0, sizeof(Node));\n\treturn p;\n}\n\n#ifdef DBG\nchar str[1000][1000];\n#endif\n\ninline void getNodes(const int x, const int y, const bool second = false) {\n\tfor (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(x + fx < 1 || x + fx > n || y + fy < 1 || y + fy > m)) {\n\t\tregister int nx = x + fx, ny = y + fy;\n\t\tregister HashMap<unsigned long long, Node *>::iterator it = map.find(HASH(nx, ny));\n\t\tif (it == map.end() || it->second != NULL) {\n\t\t\tNode *v;\n\t\t\tif (it == map.end()) {\n\t\t\t\tv = map[HASH(nx, ny)] = clear(p++);\n\t\t\t\tv->x = nx, v->y = ny;\n\t\t\t} else v = it->second;\n\t\t\tv->type = 1;\n#ifdef DBG\n\t\t\tstr[v->x][v->y] = 'A';\n#endif\n\t\t\tif (second) for (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(nx + fx < 1 || nx + fx > n || ny + fy < 1 || ny + fy > m)) {\n\t\t\t\tregister int nx2 = nx + fx, ny2 = ny + fy;\n\t\t\t\tregister HashMap<unsigned long long, Node *>::iterator it = map.find(HASH(nx2, ny2));\n\t\t\t\tif (it == map.end()) {\n\t\t\t\t\tclear(p);\n\t\t\t\t\tp->type = 2;\n\t\t\t\t\tp->x = nx2, p->y = ny2;\n#ifdef DBG\n\t\t\t\t\tstr[p->x][p->y] = 'B';\n#endif\n\t\t\t\t\tmap[HASH(nx2, ny2)] = p++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void addEdges() {\n\t// for (HashMap<unsigned long long, Node *>::iterator it = map.begin(); it != map.end(); it++) if (it->second) {\n\tfor (Node *v = N; v != p; v++) {\n\t\tregister int &x = v->x, &y = v->y;\n\t\tfor (register int i = 0; i < 4; i++) if (!(x + dx[i] < 1 || x + dx[i] > n || y + dy[i] < 1 || y + dy[i] > m)) {\n\t\t\tregister int nx = x + dx[i], ny = y + dy[i];\n\t\t\tregister HashMap<unsigned long long, Node *>::iterator it2 = map.find(HASH(nx, ny));\n\t\t\tif (it2 != map.end() && it2->second) {\n#ifdef DBG\n\t\t\t\tprintf(\"[%d, %d] -> [%d, %d]\\n\", v->x, v->y, it2->second->x, it2->second->y);\n#endif\n\t\t\t\taddEdge(v, it2->second);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int tarjan() {\n\tregister int ts = 0, cnt = 0;\n\tfor (Node *start = N; start != p; start++) {\n\t\tif (start->v) continue;\n\n\t\tstatic Node *s[MAXN];\n\t\tNode **top = s;\n\t\tstart->pushed = true;\n\t\t*top = start;\n\n\t\twhile (top != s - 1) {\n\t\t\tNode *v = *top;\n\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->dfn = v->low = ++ts;\n\t\t\t\tv->c = v->e;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v && e->t != v->p) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) *++top = e->t, e->t->pushed = true, e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != start) for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t->low >= v->dfn) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (v->flag && v->type == 1) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\n\t\t\t\ttop--;\n\t\t\t}\n\t\t}\n\n\t\tint ch = 0;\n\t\tfor (Edge *e = start->e; e; e = e->next) if (e->t->p == start) ch++;\n\t\tstart->flag = ch >= 2;\n\t\tif (start->flag && start->type == 1) cnt++;\n\t}\n\n\treturn cnt;\n}\n\ninline bool isOne() {\n\tfor (register int i = 0; i < c; i++) {\n\t\tregister int &x = a[i].x, &y = a[i].y;\n\t\tmap[HASH(x, y)] = NULL;\n\t}\n\n\tp = N;\n\n\tfor (register int i = 0; i < c; i++) {\n\t\tgetNodes(a[i].x, a[i].y, true);\n\t}\n\n\taddEdges();\n\n\treturn tarjan() != 0;\n}\n\ninline bool bfsCount() {\n\tbool flag = false;\n\tfor (Node *start = N; start != p; start++) {\n\t\tif (start->v) continue;\n\t\tif (flag) return true;\n\t\tflag = true;\n\n\t\tstatic Node *q[MAXN];\n\t\tNode **l = q, **r = q;\n\t\tstart->v = true;\n\t\t*l = start;\n\n\t\twhile (l <= r) {\n\t\t\tNode *v = *l++;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->v) {\n\t\t\t\te->t->v = true;\n\t\t\t\t*++r = e->t;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\ninline bool isZero() {\n\tstatic HashMap<unsigned long long, bool> map2;\n\tmap2.clear();\n\tfor (register int i = 0; i < c; i++) {\n\t\tmap2[HASH(a[i].x, a[i].y)] = false;\n\t}\n\tbool ans = false;\n#ifdef DBG\n\tint id = 0;\n#endif\n\tfor (int i = 0; i < c; i++) {\n\t\tregister int &x = a[i].x, &y = a[i].y;\n\t\tregister bool &f = map2[HASH(x, y)];\n\t\tif (f) continue;\n\t\tf = true;\n\n#ifdef DBG\n\t\tid++;\n#endif\n\n\t\tstatic Point vec[MAXC];\n\t\tint cnt = 0;\n\n\t\tmap.clear();\n\t\tp = N;\n\n\t\tstatic Point q[MAXC];\n\t\tPoint *l = q, *r = q;\n\t\t*l = Point(x, y);\n\t\twhile (l <= r) {\n\t\t\tPoint p = *l++;\n\n#ifdef DBG\n\t\t\tstr[p.x][p.y] = id + '0';\n#endif\n\n\t\t\tmap[HASH(p.x, p.y)] = NULL;\n\t\t\tvec[cnt++] = p;\n\n\t\t\tfor (register int fx = -1; fx <= 1; fx++) for (register int fy = -1; fy <= 1; fy++) if (!(fx == 0 && fy == 0) && !(p.x + fx < 1 || p.x + fx > n || p.y + fy < 1 || p.y + fy > m)) {\n\t\t\t\tregister int nx = p.x + fx, ny = p.y + fy;\n\t\t\t\tHashMap<unsigned long long, bool>::iterator it = map2.find(HASH(nx, ny));\n\t\t\t\tif (it != map2.end() && it->second == false) {\n\t\t\t\t\tit->second = true;\n\t\t\t\t\t*++r = Point(nx, ny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) getNodes(vec[i].x, vec[i].y);\n\t\taddEdges();\n\t\tif (bfsCount()) {\n\t\t\tans = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmap.clear();\n\treturn ans;\n}\n\ninline bool isInvalid() {\n\tconst unsigned long long r = static_cast<unsigned long long>(n) * m - c;\n\tif (r < 2) return true;\n\telse if (r == 2) {\n\t\tstatic bool flag[MAXC];\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tflag[(a[i].x - 1) * m + a[i].y - 1] = true;\n\t\t}\n\n\t\tPoint pts[2];\n\t\tfor (int i = 0, cnt = 0; i < n; i++) for (int j = 0; j < m; j++) {\n\t\t\tif (!flag[i * m + j]) pts[cnt++] = Point(i, j);\n\t\t\tflag[i * m + j] = false;\n\t\t}\n\n\t\treturn abs(pts[0].x - pts[1].x) + abs(pts[0].y - pts[1].y) == 1;\n\t} else return false;\n}\n\ninline const char *special() {\n\tstd::sort(a, a + c);\n\tint last = 0, cnt = 0;\n\tfor (int i = 0; i < c; i++) {\n\t\tif (a[i].y != last + 1) {\n\t\t\tcnt++;\n\t\t}\n\t\tlast = a[i].y;\n\t}\n\tif (last != m) cnt++;\n\treturn cnt == 1 ? \"1\" : \"0\";\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar_unlocked(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + ch - '0'; while (ch = getchar_unlocked(), (ch >= '0' && ch <= '9'));\n}\n\nint main() {\n\tint t;\n\tread(t);\n\twhile (t--) {\n\t\tread(n), read(m), read(c);\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tread(a[i].x), read(a[i].y);\n\t\t\tif (n > m) std::swap(a[i].x, a[i].y);\n\t\t}\n\n\t\tif (n > m) std::swap(n, m);\n\n\t\tif (isInvalid()) puts(\"-1\");\n\t\telse if (n == 1) puts(special());\n\t\telse if (isZero()) puts(\"0\");\n\t\telse if (isOne()) puts(\"1\");\n\t\telse puts(\"2\");\n\n#ifdef DBG\n\t\tfor (Node *v = N; v != p; v++) {\n\t\t\tprintf(\"[%d, %d] => %d\\n\", v->x, v->y, v->type);\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tHashMap<unsigned long long, Node *>::iterator it = map.find(HASH(i, j));\n\t\t\t\tif (it == map.end()) putchar('-');\n\t\t\t\telse if (!it->second) putchar('X');\n\t\t\t\telse putchar('0' + it->second->type);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\n\t\t/*\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tputchar(str[i][j] ? str[i][j] : '-');\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t\t*/\n#endif\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noi2016-grid","published":1,"updated":"2016-09-11T23:54:29.201Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6ca500opc2xlm4k8cd1c"},{"title":"NOI2016 - Hash","date":"2016-09-05T23:34:00.000Z","_content":"\n `AABB`  $ A $  $ B $ \n\n `aabaabaa` $ A = \\texttt{aab}, B = \\texttt{a} $ `AABB` \n\n $ A = \\texttt{a}, B = \\texttt{baa} $ `AABB`  `abaabaa` \n\n $ n $  $ S $\n\n<!-- more -->\n\n### \n[](https://blog.sengxian.com/solutions/bzoj-4650)\n\n### \nHash T  \n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <cstring>\n#include <algorithm>\n\ntypedef unsigned __int128 hash1_t;\n\nconst int MAXN = 30000;\nconst hash1_t BASE1 = 233;\n// const hash2_t BASE2 = 233;\n// const hash3_t BASE3 = 53;\n\nchar s[MAXN];\nint n;\nlong long forward[MAXN + 1], backward[MAXN + 1];\n\nhash1_t hash1[MAXN], base1[MAXN + 1];\n// hash2_t hash2[MAXN], base2[MAXN + 1];\n// hash3_t hash3[MAXN], base3[MAXN + 1];\n\ninline __attribute__((always_inline)) bool compare(const int a, const int b, const int len) {\n\treturn hash1[b + len - 1] - hash1[b - 1] * base1[len] == hash1[a + len - 1] - hash1[a - 1] * base1[len];\n\t\t// && hash2[b + len - 1] - hash2[b - 1] * base2[len] == hash2[a + len - 1] - hash2[a - 1] * base2[len]\n\t\t// && hash3[b + len - 1] - hash3[b - 1] * base3[len] == hash3[a + len - 1] - hash3[a - 1] * base3[len];\n\t// register long long h1 = ((hash[b + len - 1] - hash[b - 1] * base[len] % MOD) % MOD + MOD) % MOD;\n\t// register long long h2 = ((hash[a + len - 1] - hash[a - 1] * base[len] % MOD) % MOD + MOD) % MOD;\n\t// register hash_t h1 = hash[b + len - 1] - hash[b - 1] * base[len];\n\t// register hash_t h2 = hash[a + len - 1] - hash[a - 1] * base[len];\n\t// const bool res = h1 == h2;\n\t// assert(res == (memcmp(&s[a], &s[b], len) == 0));\n\t// return h1 == h2;\n\t// return memcmp(&s[a], &s[b], len) == 0;\n}\n\ninline __attribute__((always_inline)) int lcp(register int a, register int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a < 0 || b >= n) return 0;\n\tregister int l = 0, r = n - b;\n\twhile (l != r) {\n\t\tconst register int m = l + (r - l) / 2 + 1;\n\t\tif (compare(a, b, m)) {\n\t\t\tl = m;\n\t\t} else r = m - 1;\n\t}\n\treturn l;\n}\n\ninline __attribute__((always_inline)) int lcs(register int a, register int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a < 0 || b >= n) return 0;\n\tregister int l = 0, r = a + 1;\n\twhile (l != r) {\n\t\tconst register int m = l + (r - l) / 2 + 1;\n\t\tif (compare(a - m + 1, b - m + 1, m)) {\n\t\t\tl = m;\n\t\t} else r = m - 1;\n\t}\n\treturn l;\n}\n\nint main() {\n\t// base1[0] = base2[0] = base3[0] = 1;\n\tbase1[0] = 1;\n\t// for (int i = 1; i <= MAXN; i++) base[i] = base[i - 1] * BASE % MOD;\n\tfor (register int i = 1; i <= MAXN; i++) {\n\t\tbase1[i] = base1[i - 1] * BASE1;\n\t\t// base2[i] = base2[i - 1] * BASE2;\n\t\t// base3[i] = base3[i - 1] * BASE3;\n\t}\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tfor (register int i = 0; i < n; i++) s[i] -= 'a' - 1;\n\n\t\t// hash1[0] = hash2[0] = hash3[0] = s[0];\n\t\thash1[0] = s[0];\n\t\t// for (int i = 1; i < n; i++) hash[i] = (hash[i - 1] * BASE + s[i]) % MOD;\n\t\tfor (register int i = 1; i < n; i++) {\n\t\t\thash1[i] = (hash1[i - 1] * BASE1 + s[i]);\n\t\t\t// hash2[i] = (hash2[i - 1] * BASE2 + s[i]);\n\t\t\t// hash3[i] = (hash3[i - 1] * BASE3 + s[i]);\n\t\t}\n\n\t\tfor (register int k = 1; k <= n / 2; k++) {\n\t\t\t// printf(\"k = %d\\n\", k);\n\t\t\tfor (register int i = 0; i < n; i += k) {\n\t\t\t\tconst register int a = std::min(lcs(i, i + k), k) - 1, b = std::min(lcp(i, i + k), k);\n\t\t\t\t// printf(\"lcs(%d, %d) - 1 = %d, lcp(%d, %d) = %d\\n\", i, i + k, a, i, i + k, b);\n\t\t\t\tif (a + b >= k) {\n\t\t\t\t\tregister int l, r;\n\t\t\t\t\tl = i + k + k - a - 1, r = l + (a + b - k);\n\t\t\t\t\t// l = std::max(i + k + k - a, i + k), r = std::min(l + (a + b - k), i + k + k - 1);\n\t\t\t\t\t// printf(\"[%d, %d]\\n\", l, r);\n\t\t\t\t\t// for (int i = l; i <= r; i++) backward[i]++;\n\t\t\t\t\tbackward[l]++, backward[r + 1]--;\n\t\t\t\t\tr = r - 2 * k + 1, l = l - 2 * k + 1;\n\t\t\t\t\t// for (int i = l; i <= r; i++) forward[i]++;\n\t\t\t\t\tforward[l]++, forward[r + 1]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (register int i = 1; i < n; i++) forward[i] += forward[i - 1], backward[i] += backward[i - 1];\n\n\t\tregister long long ans = 0;\n\t\tfor (register int i = 1; i < n; i++) ans += backward[i - 1] * forward[i];\n\n\t\tfor (register int i = 0; i < n; i++) {\n\t\t\thash1[i] = 0;\n\t\t\t// hash2[i] = 0;\n\t\t\t// hash3[i] = 0;\n\t\t\tbackward[i] = forward[i] = 0;\n\t\t}\n\t\tforward[n] = backward[n] = 0;\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noi2016-excellent.md","raw":"title: NOI2016 - Hash\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - \n  - Hash\npermalink: noi2016-excellent\ndate: 2016-09-06 07:34:00\n---\n\n `AABB`  $ A $  $ B $ \n\n `aabaabaa` $ A = \\texttt{aab}, B = \\texttt{a} $ `AABB` \n\n $ A = \\texttt{a}, B = \\texttt{baa} $ `AABB`  `abaabaa` \n\n $ n $  $ S $\n\n<!-- more -->\n\n### \n[](https://blog.sengxian.com/solutions/bzoj-4650)\n\n### \nHash T  \n```c++\n#pragma GCC optimize(\"O3\")\n\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <cstring>\n#include <algorithm>\n\ntypedef unsigned __int128 hash1_t;\n\nconst int MAXN = 30000;\nconst hash1_t BASE1 = 233;\n// const hash2_t BASE2 = 233;\n// const hash3_t BASE3 = 53;\n\nchar s[MAXN];\nint n;\nlong long forward[MAXN + 1], backward[MAXN + 1];\n\nhash1_t hash1[MAXN], base1[MAXN + 1];\n// hash2_t hash2[MAXN], base2[MAXN + 1];\n// hash3_t hash3[MAXN], base3[MAXN + 1];\n\ninline __attribute__((always_inline)) bool compare(const int a, const int b, const int len) {\n\treturn hash1[b + len - 1] - hash1[b - 1] * base1[len] == hash1[a + len - 1] - hash1[a - 1] * base1[len];\n\t\t// && hash2[b + len - 1] - hash2[b - 1] * base2[len] == hash2[a + len - 1] - hash2[a - 1] * base2[len]\n\t\t// && hash3[b + len - 1] - hash3[b - 1] * base3[len] == hash3[a + len - 1] - hash3[a - 1] * base3[len];\n\t// register long long h1 = ((hash[b + len - 1] - hash[b - 1] * base[len] % MOD) % MOD + MOD) % MOD;\n\t// register long long h2 = ((hash[a + len - 1] - hash[a - 1] * base[len] % MOD) % MOD + MOD) % MOD;\n\t// register hash_t h1 = hash[b + len - 1] - hash[b - 1] * base[len];\n\t// register hash_t h2 = hash[a + len - 1] - hash[a - 1] * base[len];\n\t// const bool res = h1 == h2;\n\t// assert(res == (memcmp(&s[a], &s[b], len) == 0));\n\t// return h1 == h2;\n\t// return memcmp(&s[a], &s[b], len) == 0;\n}\n\ninline __attribute__((always_inline)) int lcp(register int a, register int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a < 0 || b >= n) return 0;\n\tregister int l = 0, r = n - b;\n\twhile (l != r) {\n\t\tconst register int m = l + (r - l) / 2 + 1;\n\t\tif (compare(a, b, m)) {\n\t\t\tl = m;\n\t\t} else r = m - 1;\n\t}\n\treturn l;\n}\n\ninline __attribute__((always_inline)) int lcs(register int a, register int b) {\n\tif (a > b) std::swap(a, b);\n\tif (a < 0 || b >= n) return 0;\n\tregister int l = 0, r = a + 1;\n\twhile (l != r) {\n\t\tconst register int m = l + (r - l) / 2 + 1;\n\t\tif (compare(a - m + 1, b - m + 1, m)) {\n\t\t\tl = m;\n\t\t} else r = m - 1;\n\t}\n\treturn l;\n}\n\nint main() {\n\t// base1[0] = base2[0] = base3[0] = 1;\n\tbase1[0] = 1;\n\t// for (int i = 1; i <= MAXN; i++) base[i] = base[i - 1] * BASE % MOD;\n\tfor (register int i = 1; i <= MAXN; i++) {\n\t\tbase1[i] = base1[i - 1] * BASE1;\n\t\t// base2[i] = base2[i - 1] * BASE2;\n\t\t// base3[i] = base3[i - 1] * BASE3;\n\t}\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tfor (register int i = 0; i < n; i++) s[i] -= 'a' - 1;\n\n\t\t// hash1[0] = hash2[0] = hash3[0] = s[0];\n\t\thash1[0] = s[0];\n\t\t// for (int i = 1; i < n; i++) hash[i] = (hash[i - 1] * BASE + s[i]) % MOD;\n\t\tfor (register int i = 1; i < n; i++) {\n\t\t\thash1[i] = (hash1[i - 1] * BASE1 + s[i]);\n\t\t\t// hash2[i] = (hash2[i - 1] * BASE2 + s[i]);\n\t\t\t// hash3[i] = (hash3[i - 1] * BASE3 + s[i]);\n\t\t}\n\n\t\tfor (register int k = 1; k <= n / 2; k++) {\n\t\t\t// printf(\"k = %d\\n\", k);\n\t\t\tfor (register int i = 0; i < n; i += k) {\n\t\t\t\tconst register int a = std::min(lcs(i, i + k), k) - 1, b = std::min(lcp(i, i + k), k);\n\t\t\t\t// printf(\"lcs(%d, %d) - 1 = %d, lcp(%d, %d) = %d\\n\", i, i + k, a, i, i + k, b);\n\t\t\t\tif (a + b >= k) {\n\t\t\t\t\tregister int l, r;\n\t\t\t\t\tl = i + k + k - a - 1, r = l + (a + b - k);\n\t\t\t\t\t// l = std::max(i + k + k - a, i + k), r = std::min(l + (a + b - k), i + k + k - 1);\n\t\t\t\t\t// printf(\"[%d, %d]\\n\", l, r);\n\t\t\t\t\t// for (int i = l; i <= r; i++) backward[i]++;\n\t\t\t\t\tbackward[l]++, backward[r + 1]--;\n\t\t\t\t\tr = r - 2 * k + 1, l = l - 2 * k + 1;\n\t\t\t\t\t// for (int i = l; i <= r; i++) forward[i]++;\n\t\t\t\t\tforward[l]++, forward[r + 1]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (register int i = 1; i < n; i++) forward[i] += forward[i - 1], backward[i] += backward[i - 1];\n\n\t\tregister long long ans = 0;\n\t\tfor (register int i = 1; i < n; i++) ans += backward[i - 1] * forward[i];\n\n\t\tfor (register int i = 0; i < n; i++) {\n\t\t\thash1[i] = 0;\n\t\t\t// hash2[i] = 0;\n\t\t\t// hash3[i] = 0;\n\t\t\tbackward[i] = forward[i] = 0;\n\t\t}\n\t\tforward[n] = backward[n] = 0;\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"noi2016-excellent","published":1,"updated":"2016-09-05T23:42:03.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6caa00owc2xl0wb51qrs"},{"title":"NOI2015 -  + ","date":"2016-06-26T10:14:00.000Z","_content":"\n $ S $  $ f(i) $ $ r \\in [0,\\ n - 1] $\n\n1.  $ \\mathrm {LCP}(\\mathrm{suffix}(i),\\ \\mathrm{suffix}(j)) \\geq r $  $ (i,\\ j) $ \n2.  $ (i, j) $  $ f(i) \\times f(j) $ \n\n<!-- more -->\n\n### \n[BZOJ 4199](http://www.lydsy.com/JudgeOnline/problem.php?id=4199)  \n[UOJ #130](http://uoj.ac/problem/130)\n\n### \n LCP LCP  $ \\geq r $**** $ x $  $ \\frac{x (x + 1)}{2} $\n\n $ f(i) $  $ f(i) $ \n\n\n\n $ r $  $ r $  $ \\mathrm{height}(i) $ $ \\mathrm{height} $ ****\n\n `long long`\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <stack>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nconst int MAXN = 300000;\n\nchar s[MAXN + 1];\nint a[MAXN], A[MAXN], n, rk[MAXN], sa[MAXN], ht[MAXN];\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\t\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = i + t >= n ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\t\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) printf(\"%3d %2d %s\\n\", ::a[sa[i]], ht[i], &s[sa[i]]);\n\tputs(\"----------------\");\n#endif\n}\n\nstruct UnionFindSet {\n\tint f[MAXN], size[MAXN];\n\tint max[MAXN], max2[MAXN], min[MAXN], min2[MAXN];\n#ifdef DBG\n\tbool invalid[MAXN];\n\tint top[MAXN], bottom[MAXN];\n#endif\n\n\tvoid init() {\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\ti[f] = i;\n\t\t\ti[size] = 1;\n\t\t\tif (A[i] > A[i - 1]) i[max] = i[min2] = i, i[min] = i[max2] = i - 1;\n\t\t\telse i[max] = i[min2] = i - 1, i[min] = i[max2] = i;\n#ifdef DBG\n\t\t\ti[top] = i[bottom] = i;\n\t\t\ti[invalid] = false;\n#endif\n\t\t}\n\t}\n\n\ttemplate <typename T>\n\tvoid updateMinMax(int &m, int &m2, const int x, T compare) {\n\t\tif (compare(A[x], A[m])) m2 = m, m = x;\n\t\telse if (x != m && compare(A[x], A[m2])) m2 = x;\n\t}\n\n\tvoid addTo(const int a, const int b) {\n#ifdef DBG\n\t\ta[invalid] = true;\n\t\tb[top] = std::min(b[top], a[top]);\n\t\tb[bottom] = std::max(b[bottom], a[bottom]);\n#endif\n\t\tb[size] = a[size] + b[size];\n\t\ta[size] = 0;\n\n\t\tupdateMinMax(b[max], b[max2], a[max], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[max2], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[min], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[min2], std::greater<int>());\n\n\t\tupdateMinMax(b[min], b[min2], a[min], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[min2], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[max], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[max2], std::less<int>());\n\t}\n\n\tint find(const int x, int *size = NULL, int *max = NULL, int *max2 = NULL, int *min = NULL, int *min2 = NULL) {\n\t\tint res = x;\n\t\twhile (res[f] != res) res = res[f];\n\t\tfor (int i = x, tmp; i != res; ) {\n\t\t\ttmp = i[f];\n\t\t\taddTo(i, res);\n\t\t\ti[f] = res;\n\t\t\ti = tmp;\n\t\t}\n\n\t\tif (size) *size = this->size[res];\n\t\tif (max) *max = A[this->max[res]];\n\t\tif (max2) *max2 = A[this->max2[res]];\n\t\tif (min) *min = A[this->min[res]];\n\t\tif (min2) *min2 = A[this->min2[res]];\n\n\t\treturn res;\n\t}\n\n\tbool test(const int a, const int b) {\n\t\treturn find(a) == find(b);\n\t}\n\n\tvoid merge(const int a, const int b) {\n\t\t// printf(\"merge(%d, %d)\\n\", a, b);\n\t\tint x = find(a), y = find(b);\n\t\t// printf(\"-- merge(%d, %d)\\n\", x, y);\n\t\tassert(x != y);\n\t\taddTo(x, y);\n\t\tx[f] = y;\n\t}\n\n#ifdef DBG\n\tvoid print() {\n\t\tfor (int i = 1; i < n; i++) find(i);\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (invalid[i]) continue;\n\t\t\tprintf(\"[%d]: \", i);\n\t\t\tif (f[i] == i) printf(\"root, \");\n\t\t\telse printf(\"f = %d, \", f[i]);\n\n\t\t\tprintf(\"[%d, %d], size = %d, max = [%d] -> %d, max2 = [%d] -> %d, min = [%d] -> %d, min2 = [%d] -> %d\\n\", top[i], bottom[i], size[i], max[i], max[i][sa][::a], max2[i], max2[i][sa][::a], min[i], min[i][sa][::a], min2[i], min2[i][sa][::a]);\n\t\t}\n\t}\n#endif\n} ufs;\n\ninline long long calcCnt(const int x) {\n\tint size;\n\tufs.find(x, &size);\n\tlong long cnt = static_cast<long long>(size) * (size + 1) / 2;\n\t// printf(\"cnt(%d) = %d\\n\", x, cnt);\n\treturn cnt;\n}\n\ninline long long calcMax(const int x) {\n\tint max, max2, min, min2;\n\tufs.find(x, NULL, &max, &max2, &min, &min2);\n\treturn std::max(static_cast<long long>(max) * max2, static_cast<long long>(min) * min2);\n}\n\nint main() {\n\tscanf(\"%d\\n%s\", &n, s);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tsuffixArray();\n\n\tfor (int i = 0; i < n; i++) A[i] = a[sa[i]];\n\n\tufs.init();\n\n\tstd::vector<int> v[MAXN];\n\tfor (int i = 1; i < n; i++) v[ht[i]].push_back(i);\n\n\tlong long cnt = 0, max = LLONG_MIN;\n\tstd::stack< std::pair<long long, long long> > stack;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (std::vector<int>::const_iterator it = v[i].begin(); it != v[i].end(); it++) {\n\t\t\t// printf(\"ht[%d] = %d\\n\", *it, ht[*it]);\n\n\t\t\tif (!(it != v[i].end() - 1 && ufs.test(*(it + 1), *it + 1))) {\n\t\t\t\tif (*it != n - 1) {\n\t\t\t\t\tif (ht[*it + 1] >= ht[*it] && !ufs.test(*it + 1, *it)) {\n\t\t\t\t\t\t// puts(\"------- + 1\");\n\t\t\t\t\t\tcnt -= calcCnt(*it + 1);\n\t\t\t\t\t\tufs.merge(*it, *it + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (*it != 1 && ht[*it - 1] >= ht[*it] && !ufs.test(*it - 1, *it)) {\n\t\t\t\t// puts(\"------- - 1\");\n\t\t\t\tcnt -= calcCnt(*it - 1);\n\t\t\t\tufs.merge(*it, *it - 1);\n\t\t\t}\n\n\t\t\t// puts(\"+++++++\");\n\t\t\tcnt += calcCnt(*it);\n\t\t\tmax = std::max(max, calcMax(*it));\n#ifdef DBG\n\t\t\tprintf(\"calcMax(%d) = %lld\\n\", *it, calcMax(*it));\n#endif\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"%lld %lld\\n\", cnt, max == LLONG_MIN ? 0 : max);\n\t\tif (cnt != 0) ufs.print();\n#else\n\t\tstack.push(std::make_pair(cnt, max == LLONG_MIN ? 0 : max));\n#endif\n\t}\n\n#ifndef DBG\n\twhile (!stack.empty()) {\n\t\tprintf(\"%lld %lld\\n\", stack.top().first, stack.top().second);\n\t\tstack.pop();\n\t}\n#endif\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2015-savour.md","raw":"title: NOI2015 -  + \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - \n  - \n  - \npermalink: noi2015-savour\ndate: 2016-06-26 18:14:00\n---\n\n $ S $  $ f(i) $ $ r \\in [0,\\ n - 1] $\n\n1.  $ \\mathrm {LCP}(\\mathrm{suffix}(i),\\ \\mathrm{suffix}(j)) \\geq r $  $ (i,\\ j) $ \n2.  $ (i, j) $  $ f(i) \\times f(j) $ \n\n<!-- more -->\n\n### \n[BZOJ 4199](http://www.lydsy.com/JudgeOnline/problem.php?id=4199)  \n[UOJ #130](http://uoj.ac/problem/130)\n\n### \n LCP LCP  $ \\geq r $**** $ x $  $ \\frac{x (x + 1)}{2} $\n\n $ f(i) $  $ f(i) $ \n\n\n\n $ r $  $ r $  $ \\mathrm{height}(i) $ $ \\mathrm{height} $ ****\n\n `long long`\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <stack>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nconst int MAXN = 300000;\n\nchar s[MAXN + 1];\nint a[MAXN], A[MAXN], n, rk[MAXN], sa[MAXN], ht[MAXN];\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\t\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = i + t >= n ? -1 : fir[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int j = 0, i; j < n; j++) i = tmp[j], sa[--buc[fir[i]]] = i;\n\n\t\tfor (int j = 0, i, last = -1; j < n; j++) {\n\t\t\ti = sa[j];\n\t\t\tif (last == -1) rk[i] = 0;\n\t\t\telse if (fir[i] == fir[last] && sec[i] == sec[last]) rk[i] = rk[last];\n\t\t\telse rk[i] = rk[last] + 1;\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (rk[i] == 0) k = 0;\n\t\telse {\n\t\t\tif (k > 0) k--;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t}\n\t\tht[rk[i]] = k;\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\t\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) printf(\"%3d %2d %s\\n\", ::a[sa[i]], ht[i], &s[sa[i]]);\n\tputs(\"----------------\");\n#endif\n}\n\nstruct UnionFindSet {\n\tint f[MAXN], size[MAXN];\n\tint max[MAXN], max2[MAXN], min[MAXN], min2[MAXN];\n#ifdef DBG\n\tbool invalid[MAXN];\n\tint top[MAXN], bottom[MAXN];\n#endif\n\n\tvoid init() {\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\ti[f] = i;\n\t\t\ti[size] = 1;\n\t\t\tif (A[i] > A[i - 1]) i[max] = i[min2] = i, i[min] = i[max2] = i - 1;\n\t\t\telse i[max] = i[min2] = i - 1, i[min] = i[max2] = i;\n#ifdef DBG\n\t\t\ti[top] = i[bottom] = i;\n\t\t\ti[invalid] = false;\n#endif\n\t\t}\n\t}\n\n\ttemplate <typename T>\n\tvoid updateMinMax(int &m, int &m2, const int x, T compare) {\n\t\tif (compare(A[x], A[m])) m2 = m, m = x;\n\t\telse if (x != m && compare(A[x], A[m2])) m2 = x;\n\t}\n\n\tvoid addTo(const int a, const int b) {\n#ifdef DBG\n\t\ta[invalid] = true;\n\t\tb[top] = std::min(b[top], a[top]);\n\t\tb[bottom] = std::max(b[bottom], a[bottom]);\n#endif\n\t\tb[size] = a[size] + b[size];\n\t\ta[size] = 0;\n\n\t\tupdateMinMax(b[max], b[max2], a[max], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[max2], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[min], std::greater<int>());\n\t\tupdateMinMax(b[max], b[max2], a[min2], std::greater<int>());\n\n\t\tupdateMinMax(b[min], b[min2], a[min], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[min2], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[max], std::less<int>());\n\t\tupdateMinMax(b[min], b[min2], a[max2], std::less<int>());\n\t}\n\n\tint find(const int x, int *size = NULL, int *max = NULL, int *max2 = NULL, int *min = NULL, int *min2 = NULL) {\n\t\tint res = x;\n\t\twhile (res[f] != res) res = res[f];\n\t\tfor (int i = x, tmp; i != res; ) {\n\t\t\ttmp = i[f];\n\t\t\taddTo(i, res);\n\t\t\ti[f] = res;\n\t\t\ti = tmp;\n\t\t}\n\n\t\tif (size) *size = this->size[res];\n\t\tif (max) *max = A[this->max[res]];\n\t\tif (max2) *max2 = A[this->max2[res]];\n\t\tif (min) *min = A[this->min[res]];\n\t\tif (min2) *min2 = A[this->min2[res]];\n\n\t\treturn res;\n\t}\n\n\tbool test(const int a, const int b) {\n\t\treturn find(a) == find(b);\n\t}\n\n\tvoid merge(const int a, const int b) {\n\t\t// printf(\"merge(%d, %d)\\n\", a, b);\n\t\tint x = find(a), y = find(b);\n\t\t// printf(\"-- merge(%d, %d)\\n\", x, y);\n\t\tassert(x != y);\n\t\taddTo(x, y);\n\t\tx[f] = y;\n\t}\n\n#ifdef DBG\n\tvoid print() {\n\t\tfor (int i = 1; i < n; i++) find(i);\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (invalid[i]) continue;\n\t\t\tprintf(\"[%d]: \", i);\n\t\t\tif (f[i] == i) printf(\"root, \");\n\t\t\telse printf(\"f = %d, \", f[i]);\n\n\t\t\tprintf(\"[%d, %d], size = %d, max = [%d] -> %d, max2 = [%d] -> %d, min = [%d] -> %d, min2 = [%d] -> %d\\n\", top[i], bottom[i], size[i], max[i], max[i][sa][::a], max2[i], max2[i][sa][::a], min[i], min[i][sa][::a], min2[i], min2[i][sa][::a]);\n\t\t}\n\t}\n#endif\n} ufs;\n\ninline long long calcCnt(const int x) {\n\tint size;\n\tufs.find(x, &size);\n\tlong long cnt = static_cast<long long>(size) * (size + 1) / 2;\n\t// printf(\"cnt(%d) = %d\\n\", x, cnt);\n\treturn cnt;\n}\n\ninline long long calcMax(const int x) {\n\tint max, max2, min, min2;\n\tufs.find(x, NULL, &max, &max2, &min, &min2);\n\treturn std::max(static_cast<long long>(max) * max2, static_cast<long long>(min) * min2);\n}\n\nint main() {\n\tscanf(\"%d\\n%s\", &n, s);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tsuffixArray();\n\n\tfor (int i = 0; i < n; i++) A[i] = a[sa[i]];\n\n\tufs.init();\n\n\tstd::vector<int> v[MAXN];\n\tfor (int i = 1; i < n; i++) v[ht[i]].push_back(i);\n\n\tlong long cnt = 0, max = LLONG_MIN;\n\tstd::stack< std::pair<long long, long long> > stack;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (std::vector<int>::const_iterator it = v[i].begin(); it != v[i].end(); it++) {\n\t\t\t// printf(\"ht[%d] = %d\\n\", *it, ht[*it]);\n\n\t\t\tif (!(it != v[i].end() - 1 && ufs.test(*(it + 1), *it + 1))) {\n\t\t\t\tif (*it != n - 1) {\n\t\t\t\t\tif (ht[*it + 1] >= ht[*it] && !ufs.test(*it + 1, *it)) {\n\t\t\t\t\t\t// puts(\"------- + 1\");\n\t\t\t\t\t\tcnt -= calcCnt(*it + 1);\n\t\t\t\t\t\tufs.merge(*it, *it + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (*it != 1 && ht[*it - 1] >= ht[*it] && !ufs.test(*it - 1, *it)) {\n\t\t\t\t// puts(\"------- - 1\");\n\t\t\t\tcnt -= calcCnt(*it - 1);\n\t\t\t\tufs.merge(*it, *it - 1);\n\t\t\t}\n\n\t\t\t// puts(\"+++++++\");\n\t\t\tcnt += calcCnt(*it);\n\t\t\tmax = std::max(max, calcMax(*it));\n#ifdef DBG\n\t\t\tprintf(\"calcMax(%d) = %lld\\n\", *it, calcMax(*it));\n#endif\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"%lld %lld\\n\", cnt, max == LLONG_MIN ? 0 : max);\n\t\tif (cnt != 0) ufs.print();\n#else\n\t\tstack.push(std::make_pair(cnt, max == LLONG_MIN ? 0 : max));\n#endif\n\t}\n\n#ifndef DBG\n\twhile (!stack.empty()) {\n\t\tprintf(\"%lld %lld\\n\", stack.top().first, stack.top().second);\n\t\tstack.pop();\n\t}\n#endif\n\n\treturn 0;\n}\n```\n","slug":"noi2015-savour","published":1,"updated":"2016-07-01T01:28:39.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cag00p2c2xlewpaymrt"},{"title":"NOI2015 -  + ","id":"34","updated":"2016-01-21T13:36:13.000Z","date":"2016-01-21T13:32:49.000Z","_content":"\n `n` $x_i=x_j$$x_ix_j$ / \n\n<!-- more -->\n\n### \n[CodeVS 4600](http://codevs.cn/problem/4600/)  \n[BZOJ 4195](http://www.lydsy.com/JudgeOnline/problem.php?id=4195)\n\n### \n`x` \n\n\n\n### \n#### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <new>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar preAlloc[SIZE * sizeof(T)];\n\tT *curr;\n\tT *recycle[SIZE];\n\tint i;\n\n\tvoid init() {\n\t\tcurr = (T *)preAlloc;\n\t\ti = -1;\n\t}\n\n\tT *alloc() {\n\t\tif (curr != (T *)preAlloc + SIZE) return curr++;\n\t\telse return recycle[i++];\n\t}\n\n\tvoid free(T *p) {\n\t\trecycle[++i] = p;\n\t}\n};\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstruct Node {\n\t\tint key;\n\t\tT value;\n\t\tNode *next;\n\n\t\tNode(int key, const T &value, Node *next) : key(key), value(value), next(next) {}\n\t} *list[HASH_SIZE];\n\tMemoryPool<Node, SIZE> pool;\n\n\tvoid init() {\n\t\tpool.init();\n\t\tmemset(list, 0, sizeof(list));\n\t}\n\n\tint hash(int x) {\n\t\treturn (unsigned int)((x << 16) | (x >> 16)) % HASH_SIZE;\n\t}\n\n\tT &operator[](int key) {\n\t\tint i = hash(key);\n\t\tfor (Node *v = list[i]; v; v = v->next) {\n\t\t\tif (v->key == key) return v->value;\n\t\t}\n\t\tlist[i] = new(pool.alloc()) Node(key, DEFAULT, list[i]);\n\t\treturn list[i]->value;\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n\n#### STL\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <tr1/unordered_map>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstd::tr1::unordered_map<int, T> map;\n\n\tvoid init() {\n\t\tmap.clear();\n\t}\n\n\tT &operator[](int key) {\n\t\tif (map.count(key) == 0) map[key] = -1;\n\t\treturn map[key];\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2015-prog.md","raw":"title: NOI2015 -  + \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - CodeVS\n  - \n  - \n  - \n  - map\npermalink: noi2015-prog\nid: 34\nupdated: '2016-01-21 21:36:13'\ndate: 2016-01-21 21:32:49\n---\n\n `n` $x_i=x_j$$x_ix_j$ / \n\n<!-- more -->\n\n### \n[CodeVS 4600](http://codevs.cn/problem/4600/)  \n[BZOJ 4195](http://www.lydsy.com/JudgeOnline/problem.php?id=4195)\n\n### \n`x` \n\n\n\n### \n#### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <new>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar preAlloc[SIZE * sizeof(T)];\n\tT *curr;\n\tT *recycle[SIZE];\n\tint i;\n\n\tvoid init() {\n\t\tcurr = (T *)preAlloc;\n\t\ti = -1;\n\t}\n\n\tT *alloc() {\n\t\tif (curr != (T *)preAlloc + SIZE) return curr++;\n\t\telse return recycle[i++];\n\t}\n\n\tvoid free(T *p) {\n\t\trecycle[++i] = p;\n\t}\n};\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstruct Node {\n\t\tint key;\n\t\tT value;\n\t\tNode *next;\n\n\t\tNode(int key, const T &value, Node *next) : key(key), value(value), next(next) {}\n\t} *list[HASH_SIZE];\n\tMemoryPool<Node, SIZE> pool;\n\n\tvoid init() {\n\t\tpool.init();\n\t\tmemset(list, 0, sizeof(list));\n\t}\n\n\tint hash(int x) {\n\t\treturn (unsigned int)((x << 16) | (x >> 16)) % HASH_SIZE;\n\t}\n\n\tT &operator[](int key) {\n\t\tint i = hash(key);\n\t\tfor (Node *v = list[i]; v; v = v->next) {\n\t\t\tif (v->key == key) return v->value;\n\t\t}\n\t\tlist[i] = new(pool.alloc()) Node(key, DEFAULT, list[i]);\n\t\treturn list[i]->value;\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n\n#### STL\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <tr1/unordered_map>\n\nconst int HASH_SIZE = 10000007;\nconst int MAXN = 1000000;\n\ntemplate <typename T, T DEFAULT, size_t SIZE>\nstruct HashMap {\n\tstd::tr1::unordered_map<int, T> map;\n\n\tvoid init() {\n\t\tmap.clear();\n\t}\n\n\tT &operator[](int key) {\n\t\tif (map.count(key) == 0) map[key] = -1;\n\t\treturn map[key];\n\t}\n};\n\ntemplate <size_t SIZE>\nstruct UnionFindSet {\n\tint p[SIZE];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) p[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn p[x] == x ? x : p[x] = find(p[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tp[find(y)] = find(x);\n\t}\n};\n\nstruct Query {\n\tint x, y, e, fx, fy;\n} queries[MAXN];\n\nHashMap<int, -1, MAXN * 2> map;\nUnionFindSet<MAXN * 2> ufs;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 0; i < t; i++) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\n\t\tmap.init();\n\t\tufs.init(n * 2);\n\t\tint k = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &queries[i].x, &queries[i].y, &queries[i].e);\n\n\t\t\tint &fx = map[queries[i].x], &fy = map[queries[i].y];\n\t\t\tif (fx == -1) fx = k++;\n\t\t\tif (fy == -1) fy = k++;\n\t\t\tqueries[i].fx = fx, queries[i].fy = fy;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 1) {\n\t\t\t\tif (ufs.find(queries[i].fx) != ufs.find(queries[i].fy)) ufs.merge(queries[i].fx, queries[i].fy);\n\t\t\t}\n\t\t}\n\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (queries[i].e == 0) {\n\t\t\t\tif (ufs.find(queries[i].fx) == ufs.find(queries[i].fy)) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (flag) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noi2015-prog","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6car00p9c2xlcfkmm59g"},{"title":"NOI2015 - ","id":"35","updated":"2016-01-29T00:22:32.000Z","date":"2016-01-23T02:10:12.000Z","_content":"\n A  B A  B BA 0  0 \n\n<!-- more -->\n\n### \n[CodeVS 4621](http://codevs.cn/problem/4621/)  \n[BZOJ 4196](http://www.lydsy.com/JudgeOnline/problem.php?id=4196)\n\n### \n\n\n1. \n2. \n3. \n4. \n\n DFS DFS  DFS  DFS  DFS  DFS \n\n### \n```cpp\n#include <cstdio>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\n\nstruct Tree;\nstruct SegmentTree;\nstruct Path;\n\nstruct SegmentTree {\n\tenum LazyTag {\n\t\tCover = 1,\n\t\tNull = 0,\n\t\tUncover = -1\n\t};\n\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tLazyTag lazy;\n\t\tbool covered;\n\t\tint count;\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy != Null) {\n\t\t\t\tif (lazy == Cover) {\n\t\t\t\t\tif (lchild) lchild->cover(true);\n\t\t\t\t\tif (rchild) rchild->cover(true);\n\t\t\t\t} else {\n\t\t\t\t\tif (lchild) lchild->cover(false);\n\t\t\t\t\tif (rchild) rchild->cover(false);\n\t\t\t\t}\n\n\t\t\t\tlazy = Null;\n\t\t\t}\n\t\t}\n\n\t\tvoid cover(bool flag) {\n\t\t\tif (flag) count = r - l + 1, covered = true, lazy = Cover;\n\t\t\telse count = 0, covered = false, lazy = Uncover;\n\t\t}\n\n\t\tvoid cover(int l, int r, bool flag) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) cover(flag);\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tcount = 0;\n\t\t\t\tif (lchild) lchild->cover(l, r, flag), count += lchild->count;\n\t\t\t\tif (rchild) rchild->cover(l, r, flag), count += rchild->count;\n\t\t\t}\n\t\t}\n\n\t\tint query(int l, int r) {\n\t\t\tif (l > this->r || r < this->l) return 0;\n\t\t\telse if (l <= this->l && r >= this->r) return count;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\treturn (lchild ? lchild->query(l, r) : 0) + (rchild ? rchild->query(l, r) : 0);\n\t\t\t}\n\t\t}\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), covered(false), count(0), lazy(Null) {}\n\t} *root;\n\n\tstatic Node *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tint query(int l, int r) {\n\t\treturn root->query(l, r);\n\t}\n\n\tvoid cover(int l, int r, bool flag) {\n\t\troot->cover(l, r, flag);\n\t}\n};\n\nstruct Path {\n\tTree *top;\n\n\tPath(Tree *top) : top(top) {}\n};\n\nstruct Tree {\n\tPath *path;\n\tTree *parent, *children, *next;\n\n\tTree *maxSizeChild;\n\tint size, pos, posEnd;\n\tbool visited;\n\n\tTree() : children(NULL) {}\n\tTree(Tree *parent) : parent(parent), next(parent->children), path(NULL), maxSizeChild(NULL), size(1) {}\n} trees[MAXN + 1];\n\nint n, q;\nTree *dfsOrder[MAXN + 1];\nSegmentTree *segment;\n\ninline void addEdge(int parent, int child) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent]);\n}\n\ninline void cutTree(Tree *root) {\n\tstd::stack<Tree *> s;\n\ts.push(root);\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\ts.push(c);\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) {\n\t\t\t\t\tt->maxSizeChild = c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\tint i = 0;\n\ts.push(root);\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tdfsOrder[t->pos = i++] = t;\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\n\t\t\tif (t == root || t != t->parent->maxSizeChild) {\n\t\t\t\tt->path = new Path(t);\n\t\t\t} else {\n\t\t\t\tt->path = t->parent->path;\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tt->posEnd = i - 1;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = new SegmentTree(0, n - 1);\n}\n\nint install(Tree *t) {\n\tint ans = 0;\n\twhile (t) {\n\t\tans += (t->pos - t->path->top->pos + 1) - segment->query(t->path->top->pos, t->pos);\n\t\tsegment->cover(t->path->top->pos, t->pos, true);\n\t\tt = t->path->top->parent;\n\t}\n\n\treturn ans;\n}\n\nint uninstall(Tree *t) {\n\tint ans = segment->query(t->pos, t->posEnd);\n\tsegment->cover(t->pos, t->posEnd, false);\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d\", &p);\n\n\t\taddEdge(p, i);\n\t}\n\n\tcutTree(&trees[0]);\n\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tchar command[9 + 1];\n\t\tint u;\n\t\tscanf(\"%s %d\", command, &u);\n\n\t\tif (command[0] == 'i') {\n\t\t\tprintf(\"%d\\n\", install(&trees[u]));\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", uninstall(&trees[u]));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noi2015-manager.md","raw":"title: NOI2015 - \ncategories: OI\ntags: \n  - NOI\n  - CodeVS\n  - BZOJ\n  - \n  - \n  - \npermalink: noi2015-manager\nid: 35\nupdated: '2016-01-29 08:22:32'\ndate: 2016-01-23 10:10:12\n---\n\n A  B A  B BA 0  0 \n\n<!-- more -->\n\n### \n[CodeVS 4621](http://codevs.cn/problem/4621/)  \n[BZOJ 4196](http://www.lydsy.com/JudgeOnline/problem.php?id=4196)\n\n### \n\n\n1. \n2. \n3. \n4. \n\n DFS DFS  DFS  DFS  DFS  DFS \n\n### \n```cpp\n#include <cstdio>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 100000;\n\nstruct Tree;\nstruct SegmentTree;\nstruct Path;\n\nstruct SegmentTree {\n\tenum LazyTag {\n\t\tCover = 1,\n\t\tNull = 0,\n\t\tUncover = -1\n\t};\n\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tLazyTag lazy;\n\t\tbool covered;\n\t\tint count;\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy != Null) {\n\t\t\t\tif (lazy == Cover) {\n\t\t\t\t\tif (lchild) lchild->cover(true);\n\t\t\t\t\tif (rchild) rchild->cover(true);\n\t\t\t\t} else {\n\t\t\t\t\tif (lchild) lchild->cover(false);\n\t\t\t\t\tif (rchild) rchild->cover(false);\n\t\t\t\t}\n\n\t\t\t\tlazy = Null;\n\t\t\t}\n\t\t}\n\n\t\tvoid cover(bool flag) {\n\t\t\tif (flag) count = r - l + 1, covered = true, lazy = Cover;\n\t\t\telse count = 0, covered = false, lazy = Uncover;\n\t\t}\n\n\t\tvoid cover(int l, int r, bool flag) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) cover(flag);\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\tcount = 0;\n\t\t\t\tif (lchild) lchild->cover(l, r, flag), count += lchild->count;\n\t\t\t\tif (rchild) rchild->cover(l, r, flag), count += rchild->count;\n\t\t\t}\n\t\t}\n\n\t\tint query(int l, int r) {\n\t\t\tif (l > this->r || r < this->l) return 0;\n\t\t\telse if (l <= this->l && r >= this->r) return count;\n\t\t\telse {\n\t\t\t\tpushDown();\n\t\t\t\treturn (lchild ? lchild->query(l, r) : 0) + (rchild ? rchild->query(l, r) : 0);\n\t\t\t}\n\t\t}\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild), covered(false), count(0), lazy(Null) {}\n\t} *root;\n\n\tstatic Node *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tint query(int l, int r) {\n\t\treturn root->query(l, r);\n\t}\n\n\tvoid cover(int l, int r, bool flag) {\n\t\troot->cover(l, r, flag);\n\t}\n};\n\nstruct Path {\n\tTree *top;\n\n\tPath(Tree *top) : top(top) {}\n};\n\nstruct Tree {\n\tPath *path;\n\tTree *parent, *children, *next;\n\n\tTree *maxSizeChild;\n\tint size, pos, posEnd;\n\tbool visited;\n\n\tTree() : children(NULL) {}\n\tTree(Tree *parent) : parent(parent), next(parent->children), path(NULL), maxSizeChild(NULL), size(1) {}\n} trees[MAXN + 1];\n\nint n, q;\nTree *dfsOrder[MAXN + 1];\nSegmentTree *segment;\n\ninline void addEdge(int parent, int child) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent]);\n}\n\ninline void cutTree(Tree *root) {\n\tstd::stack<Tree *> s;\n\ts.push(root);\n\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\ts.push(c);\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tt->size += c->size;\n\t\t\t\tif (t->maxSizeChild == NULL || t->maxSizeChild->size < c->size) {\n\t\t\t\t\tt->maxSizeChild = c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) trees[i].visited = false;\n\n\tint i = 0;\n\ts.push(root);\n\twhile (!s.empty()) {\n\t\tTree *t = s.top();\n\t\tif (!t->visited) {\n\t\t\tdfsOrder[t->pos = i++] = t;\n\t\t\tfor (Tree *c = t->children; c; c = c->next) {\n\t\t\t\tif (c != t->maxSizeChild) s.push(c);\n\t\t\t}\n\t\t\tif (t->maxSizeChild) s.push(t->maxSizeChild);\n\n\t\t\tif (t == root || t != t->parent->maxSizeChild) {\n\t\t\t\tt->path = new Path(t);\n\t\t\t} else {\n\t\t\t\tt->path = t->parent->path;\n\t\t\t}\n\n\t\t\tt->visited = true;\n\t\t} else {\n\t\t\tt->posEnd = i - 1;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tsegment = new SegmentTree(0, n - 1);\n}\n\nint install(Tree *t) {\n\tint ans = 0;\n\twhile (t) {\n\t\tans += (t->pos - t->path->top->pos + 1) - segment->query(t->path->top->pos, t->pos);\n\t\tsegment->cover(t->path->top->pos, t->pos, true);\n\t\tt = t->path->top->parent;\n\t}\n\n\treturn ans;\n}\n\nint uninstall(Tree *t) {\n\tint ans = segment->query(t->pos, t->posEnd);\n\tsegment->cover(t->pos, t->posEnd, false);\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint p;\n\t\tscanf(\"%d\", &p);\n\n\t\taddEdge(p, i);\n\t}\n\n\tcutTree(&trees[0]);\n\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tchar command[9 + 1];\n\t\tint u;\n\t\tscanf(\"%s %d\", command, &u);\n\n\t\tif (command[0] == 'i') {\n\t\t\tprintf(\"%d\\n\", install(&trees[u]));\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", uninstall(&trees[u]));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"noi2015-manager","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cb200plc2xl5b9caggl"},{"title":"NOI2015 - DP + ","date":"2016-06-29T10:33:00.000Z","_content":"\n $ n $ \n\n1.  $ 45 ^ \\circ $ $ 45 ^ \\circ $ ********\n2.  (1) \n3.  (1) **** $ 45 ^ \\circ $ $ 45 ^ \\circ $  DAG DAG \n\n<!-- more -->\n\n### \n[BZOJ 4200](http://www.lydsy.com/JudgeOnline/problem.php?id=4200)  \n[UOJ #132](http://uoj.ac/problem/132)\n\n### \n#### \n $ (x_1, y_1) $  $ (x_2, y_2) $ $ y_1 = y_2 $ $ x_1 + y_1 = x_2 + y_2 $  $ x_1 - y_1 = x_2 - y_2 $\n\n\n\n\n\n1. \n2. \n\n  \n\n $ a $$ b $$ a $  $ b $  $ a $  $ b $  $ a $  $ a $  $ b $\n\n $ a $  $ b $  $ a $  $ 1 $  $ b $ \n\n|   | 1 | 2 | 3 | 4 | 5 |\n|:-:|:-:|:-:|:-:|:-:|:-:|\n| 5 | 0 | 1 | 2 | 3 | 4 |\n| 5 | 4 | 0 | 2 | 3 | 4 |\n| 5 | 4 | 3 | 0 | 3 | 4 |\n| 5 | 4 | 3 | 2 | 0 | 4 |\n| 5 | 4 | 3 | 2 | 1 | 0 |\n\n $ b $  $ b $  $ O(\\log n) $ \n\n $ O(n \\log n) $\n\n#### \n\n\n\n\n#### \n\n\n $ 1 $ $ +\\infty $ \n\n\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <tr1/unordered_map>\n#include <tr1/functional>\n\nconst int MAXN = 50000 + 1;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l, in;\n} N[MAXN + 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].c = N[i].e, N[i].l = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f;\n\t\t\t\te->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"dinic(%d, %d, %d) = %d\\n\", s, t, n, res);\n#endif\n\t\treturn res;\n\t}\n} dinic;\n\ninline Edge *addEdge(const int s, const int t, const int c) {\n#ifdef DBG\n\tprintf(\"E(%d, %d, %d)\\n\", s, t, c);\n#endif\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\treturn (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void addEdge(const int s, const int t, const int l, const int r) {\n\tN[s].in -= l;\n\tN[t].in += l;\n\taddEdge(s, t, r - l);\n}\n\ninline int minFlow(const int s, const int t, const int n) {\n\tconst int S = n, T = n + 1;\n\tint full = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].in > 0) addEdge(S, i, N[i].in), full += N[i].in;\n\t\telse if (N[i].in < 0) addEdge(i, T, -N[i].in);\n\t}\n\tEdge *e = addEdge(t, s, INT_MAX);\n\n\tassert(dinic(S, T, n + 2) == full);\n\n\tint f = e->f;\n\n\te->c = e->r->c = 0;\n\tfor (e = N[s].e; e; e = e->next) e->c = e->r->c = 0;\n\tfor (e = N[t].e; e; e = e->next) e->c = e->r->c = 0;\n\n\treturn f - dinic(t, s, n);\n}\n\nstruct DPValue;\nstruct Point;\n\nstruct DPValue {\n\tPoint *prec;\n\tint x;\n\n\tDPValue(Point *prec = NULL, const int x = 0) : prec(prec), x(x) {}\n\n\tDPValue extend(Point &p, const int delta) { return DPValue(&p, x + delta); }\n\n\toperator int() const { return x; }\n};\n\nstruct Point {\n\tint id, x, y, lineIndex;\n\tstd::vector< std::tr1::reference_wrapper<Point> >::iterator itX, itDiagonal1, itDiagonal2;\n\tDPValue dpUp, dpInline;\n\tbool flagUp, flagInline;\n\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorY() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorX() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorDiagonal1() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorDiagonal2() const;\n};\n\nbool compareByY(const Point &a, const Point &b) { return a.y > b.y; }\nbool compareByX(const Point &a, const Point &b) { return a.x > b.x; }\nbool compareByDiagonal1(const Point &a, const Point &b) { return a.x > b.x; }\nbool compareByDiagonal2(const Point &a, const Point &b) { return a.x < b.x; }\n\nint n, lineCnt;\nPoint a[MAXN];\nstd::vector< std::tr1::reference_wrapper<Point> > lines[MAXN];\nstd::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > > mapX, mapDiagonal1, mapDiagonal2;\n\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorY() const { return lines[lineIndex]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorX() const { return mapX[x]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorDiagonal1() const { return mapDiagonal1[x + y]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorDiagonal2() const { return mapDiagonal2[x - y]; }\n\ninline void dpUp(const int lineIndex) {\n\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[lineIndex];\n\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = v.begin(); it != v.end(); it++) {\n\t\tPoint &p = it->get();\n\t\t// p.dpUp = DPValue(NULL, 1);\n\n\t\tif (p.itX != p.getVectorX().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itX - 1)->get().dpInline.extend((p.itX - 1)->get(), 1));\n\t\t}\n\n\t\tif (p.itDiagonal1 != p.getVectorDiagonal1().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itDiagonal1 - 1)->get().dpInline.extend((p.itDiagonal1 - 1)->get(), 1));\n\t\t}\n\n\t\tif (p.itDiagonal2 != p.getVectorDiagonal2().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itDiagonal2 - 1)->get().dpInline.extend((p.itDiagonal2 - 1)->get(), 1));\n\t\t}\n\t}\n}\n\ninline void dpInline(const int lineIndex) {\n\tstruct SegmentTree {\n\t\tint l, r, m;\n\t\tSegmentTree *lc, *rc;\n\t\tDPValue val;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + (r - l) / 2), lc(lc), rc(rc) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid update(const int pos, const DPValue &val) {\n\t\t\tif (l == r) this->val = val;\n\t\t\telse (pos <= m ? lc : rc)->update(pos, val), this->val = std::max(lc->val, rc->val);\n\t\t}\n\n\t\tDPValue query() { return val; }\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tint m = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, m), build(m + 1, r));\n\t\t\t}\n\t\t}\n\t} *segment;\n\n\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[lineIndex];\n\n\tsegment = SegmentTree::build(0, v.size() - 1);\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tsegment->update(i, v[i].get().dpUp.extend(v[i].get(), i));\n\t}\n\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tv[i].get().dpInline = segment->query();\n\t\tif (i < v.size() - 1) {\n\t\t\tsegment->update(i, v[i].get().dpUp.extend(v[i].get(), v.size() - i - 1));\n\t\t\tsegment->update(i + 1, v[i + 1].get().dpUp.extend(v[i + 1].get(), 0));\n\t\t}\n\t}\n\n\tdelete segment;\n}\n\ninline void dp() {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i != 0) dpUp(i);\n\t\tdpInline(i);\n\t}\n}\n\ninline void getInlinePath(std::vector<Point *> &v, Point *s, Point *t) {\n\tstd::vector< std::tr1::reference_wrapper<Point> > &line = s->getVectorY();\n\tstd::vector< std::tr1::reference_wrapper<Point> >::iterator a = std::lower_bound(line.begin(), line.end(), *s, &compareByX), b = std::lower_bound(line.begin(), line.end(), *t, &compareByX);\n\n\tassert(&a->get() == s);\n\tassert(&b->get() == t);\n\n#ifdef DBG\n\tprintf(\"getInlinePath(%d(%d, %d), %d(%d, %d))\\n\", s->id, s->x, s->y, t->id, t->x, t->y);\n#endif\n\n\tif (a < b) {\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a - 1; it >= line.begin(); it--) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"reverse!\");\n#endif\n\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a + 1; it <= b; it++) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\t} else {\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a + 1; it != line.end(); it++) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"reverse!\");\n#endif\n\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a - 1; it >= b; it--) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\t}\n}\n\ninline void getPath(std::vector<Point *> &v) {\n\tPoint *p = &a[n - 1];\n\tbool flag = false;\n\twhile (p->dpUp.x || (!flag && p->dpInline.x && p->dpInline.prec != p)) {\n\t\tif (flag || p->dpInline.prec == p || p->dpInline.x <= p->dpUp.x) {\n#ifdef DBG\n\t\t\tprintf(\"%d(%d, %d) -> %d(%d, %d)\\n\", p->id, p->x, p->y, p->dpUp.prec->id, p->dpUp.prec->x, p->dpUp.prec->y);\n#endif\n\t\t\tp = p->dpUp.prec;\n\t\t\tv.push_back(p);\n\t\t\tflag = false;\n\t\t} else {\n\t\t\tgetInlinePath(v, p, p->dpInline.prec);\n\t\t\tp = p->dpInline.prec;\n\t\t\tflag = true;\n\t\t}\n\t}\n}\n\ninline void getEdges(std::vector< std::pair<Point *, Point *> > &E) {\n\tstruct SegmentTree {\n\t\tint l, r, m;\n\t\tSegmentTree *lc, *rc;\n\t\tDPValue val;\n\t\tbool flag;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + (r - l) / 2), lc(lc), rc(rc), flag(false) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (flag) pushDown();\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (flag) {\n\t\t\t\tif (lc || rc) {\n\t\t\t\t\tif (val.x == lc->val.x) lc->flag = true;\n\t\t\t\t\tif (val.x == rc->val.x) rc->flag = true;\n\t\t\t\t} else {\n\t\t\t\t\tval.prec->flagInline = true;\n\t\t\t\t}\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid update(const int pos, const DPValue &val) {\n\t\t\tpushDown();\n\t\t\tif (l == r) this->val = val;\n\t\t\telse (pos <= m ? lc : rc)->update(pos, val), this->val = std::max(lc->val, rc->val);\n\t\t}\n\n\t\tDPValue query() { return val; }\n\n\t\tvoid mark() { flag = true; }\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tint m = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, m), build(m + 1, r));\n\t\t\t}\n\t\t}\n\t} *segment;\n\n\ta[n - 1].flagUp = true;\n\n\tfor (int i = lineCnt - 1; i >= 0; i--) {\n\t\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[i];\n\t\tsegment = SegmentTree::build(0, v.size() - 1);\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tsegment->update(j, v[j].get().dpUp.extend(v[j].get(), j));\n\t\t}\n\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tif (v[j].get().flagUp) {\n\t\t\t\tsegment->mark();\n\t\t\t}\n\n\t\t\tif (j < v.size() - 1) {\n\t\t\t\tsegment->update(j, v[j].get().dpUp.extend(v[j].get(), v.size() - j - 1));\n\t\t\t\tsegment->update(j + 1, v[j + 1].get().dpUp.extend(v[j + 1].get(), 0));\n\t\t\t}\n\t\t}\n\n\t\tdelete segment;\n\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tif (v[j].get().flagInline) {\n\t\t\t\tPoint &p = v[j].get();\n\t\t\t\t// p.dpUp = DPValue(NULL, 1);\n\n\t\t\t\tif (p.itX != p.getVectorX().begin() && p.dpUp.x == (p.itX - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itX - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itX - 1)->get().x, (p.itX - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itX - 1)->get()));\n\t\t\t\t}\n\n\t\t\t\tif (p.itDiagonal1 != p.getVectorDiagonal1().begin() && p.dpUp.x == (p.itDiagonal1 - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itDiagonal1 - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itDiagonal1 - 1)->get().x, (p.itDiagonal1 - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itDiagonal1 - 1)->get()));\n\t\t\t\t}\n\n\t\t\t\tif (p.itDiagonal2 != p.getVectorDiagonal2().begin() && p.dpUp.x == (p.itDiagonal2 - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itDiagonal2 - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itDiagonal2 - 1)->get().x, (p.itDiagonal2 - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itDiagonal2 - 1)->get()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void sort() {\n\tfor (int i = 0; i < lineCnt; i++) {\n\t\tstd::sort(lines[i].begin(), lines[i].end(), &compareByX);\n\t}\n\t\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapX.begin(); it != mapX.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByY);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itX = it2;\n\t\t}\n\t}\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapDiagonal1.begin(); it != mapDiagonal1.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByDiagonal2);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itDiagonal1 = it2;\n\t\t}\n\t}\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapDiagonal2.begin(); it != mapDiagonal2.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByDiagonal1);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itDiagonal2 = it2;\n\t\t}\n\t}\n}\n\n#ifdef DBG\ninline void debugPrint() {\n\tfor (int i = 0; i < lineCnt; i++) {\n\t\tprintf(\"lines[%d] = { \", i);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it = lines[i].begin(); it != lines[i].end(); it++) {\n\t\t\tconst Point &p = *it;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it + 1 == lines[i].end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapX.begin(); it != mapX.end(); it++) {\n\t\tprintf(\"x[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapDiagonal1.begin(); it != mapDiagonal1.end(); it++) {\n\t\tprintf(\"diagonal1[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapDiagonal2.begin(); it != mapDiagonal2.end(); it++) {\n\t\tprintf(\"diagonal2[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"(%d, %d): \", a[i].x, a[i].y);\n\t\tif (a[i].dpUp.prec) printf(\"dpUp[%d] = { (%d, %d), %d }, \", i, a[i].dpUp.prec->x, a[i].dpUp.prec->y, a[i].dpUp.x);\n\t\telse printf(\"dpUp[%d] = { nullptr, %d }, \", i, a[i].dpUp.x);\n\t\tif (a[i].dpInline.prec) printf(\"dpInline[%d] = { (%d, %d), %d }\\n\", i, a[i].dpInline.prec->x, a[i].dpInline.prec->y, a[i].dpInline.x);\n\t\telse printf(\"dpInline[%d] = { nullptr, %d }\\n\", i, a[i].dpInline.x);\n\t}\n}\n#endif\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].x, &a[i].y);\n\t\ta[i].id = i;\n\t}\n\ta[n].x = 0, a[n].y = 0, a[n].id = n, n++;\n\n\tstd::sort(a, a + n, &compareByY);\n\n\tfor (int i = 0, last; i < n; i++) {\n\t\tPoint &p = a[i];\n\n\t\tif (!i || p.y != a[last].y) ++lineCnt;\n\t\tlines[lineCnt - 1].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tp.lineIndex = lineCnt - 1;\n\n\t\tmapX[p.x].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tmapDiagonal1[p.x + p.y].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tmapDiagonal2[p.x - p.y].push_back(std::tr1::reference_wrapper<Point>(p));\n\n\t\tlast = i;\n\t}\n\n\tsort();\n\n\n#ifdef DBG\n\tdebugPrint();\n#endif\n\t\n\tdp();\n\n\tint cnt = a[n - 1].dpInline.x;\n\tprintf(\"%d\\n\", cnt);\n\n\tstd::vector<Point *> v;\n\tgetPath(v);\n#ifdef DBG\n\tfor (size_t i = 0; i < v.size(); i++) printf(\"%d: (%d, %d)\\n\", v[i]->id + 1, v[i]->x, v[i]->y);\n#else\n\tfor (size_t i = 0; i < v.size(); i++) printf(\"%d%c\", v[i]->id + 1, i == v.size() - 1 ? '\\n' : ' ');\n#endif\n\n\tstd::vector< std::pair<Point *, Point *> > E;\n\tgetEdges(E);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, INT_MAX), addEdge(i, t, INT_MAX);\n\tfor (std::vector< std::pair<Point *, Point *> >::const_iterator it = E.begin(); it != E.end(); it++) {\n\t\taddEdge(it->first->id + 1, it->second->id + 1, 1, INT_MAX);\n\t}\n\n\tprintf(\"%d\\n\", minFlow(s, t, n + 2));\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2015-farm.md","raw":"title: NOI2015 - DP + \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - DP\n  - \n  - \n  - Dinic\npermalink: noi2015-farm\ndate: 2016-06-29 18:33:00\n---\n\n $ n $ \n\n1.  $ 45 ^ \\circ $ $ 45 ^ \\circ $ ********\n2.  (1) \n3.  (1) **** $ 45 ^ \\circ $ $ 45 ^ \\circ $  DAG DAG \n\n<!-- more -->\n\n### \n[BZOJ 4200](http://www.lydsy.com/JudgeOnline/problem.php?id=4200)  \n[UOJ #132](http://uoj.ac/problem/132)\n\n### \n#### \n $ (x_1, y_1) $  $ (x_2, y_2) $ $ y_1 = y_2 $ $ x_1 + y_1 = x_2 + y_2 $  $ x_1 - y_1 = x_2 - y_2 $\n\n\n\n\n\n1. \n2. \n\n  \n\n $ a $$ b $$ a $  $ b $  $ a $  $ b $  $ a $  $ a $  $ b $\n\n $ a $  $ b $  $ a $  $ 1 $  $ b $ \n\n|   | 1 | 2 | 3 | 4 | 5 |\n|:-:|:-:|:-:|:-:|:-:|:-:|\n| 5 | 0 | 1 | 2 | 3 | 4 |\n| 5 | 4 | 0 | 2 | 3 | 4 |\n| 5 | 4 | 3 | 0 | 3 | 4 |\n| 5 | 4 | 3 | 2 | 0 | 4 |\n| 5 | 4 | 3 | 2 | 1 | 0 |\n\n $ b $  $ b $  $ O(\\log n) $ \n\n $ O(n \\log n) $\n\n#### \n\n\n\n\n#### \n\n\n $ 1 $ $ +\\infty $ \n\n\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <cassert>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <tr1/unordered_map>\n#include <tr1/functional>\n\nconst int MAXN = 50000 + 1;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l, in;\n} N[MAXN + 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].c = N[i].e, N[i].l = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f;\n\t\t\t\te->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"dinic(%d, %d, %d) = %d\\n\", s, t, n, res);\n#endif\n\t\treturn res;\n\t}\n} dinic;\n\ninline Edge *addEdge(const int s, const int t, const int c) {\n#ifdef DBG\n\tprintf(\"E(%d, %d, %d)\\n\", s, t, c);\n#endif\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\treturn (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void addEdge(const int s, const int t, const int l, const int r) {\n\tN[s].in -= l;\n\tN[t].in += l;\n\taddEdge(s, t, r - l);\n}\n\ninline int minFlow(const int s, const int t, const int n) {\n\tconst int S = n, T = n + 1;\n\tint full = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].in > 0) addEdge(S, i, N[i].in), full += N[i].in;\n\t\telse if (N[i].in < 0) addEdge(i, T, -N[i].in);\n\t}\n\tEdge *e = addEdge(t, s, INT_MAX);\n\n\tassert(dinic(S, T, n + 2) == full);\n\n\tint f = e->f;\n\n\te->c = e->r->c = 0;\n\tfor (e = N[s].e; e; e = e->next) e->c = e->r->c = 0;\n\tfor (e = N[t].e; e; e = e->next) e->c = e->r->c = 0;\n\n\treturn f - dinic(t, s, n);\n}\n\nstruct DPValue;\nstruct Point;\n\nstruct DPValue {\n\tPoint *prec;\n\tint x;\n\n\tDPValue(Point *prec = NULL, const int x = 0) : prec(prec), x(x) {}\n\n\tDPValue extend(Point &p, const int delta) { return DPValue(&p, x + delta); }\n\n\toperator int() const { return x; }\n};\n\nstruct Point {\n\tint id, x, y, lineIndex;\n\tstd::vector< std::tr1::reference_wrapper<Point> >::iterator itX, itDiagonal1, itDiagonal2;\n\tDPValue dpUp, dpInline;\n\tbool flagUp, flagInline;\n\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorY() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorX() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorDiagonal1() const;\n\tstd::vector< std::tr1::reference_wrapper<Point> > &getVectorDiagonal2() const;\n};\n\nbool compareByY(const Point &a, const Point &b) { return a.y > b.y; }\nbool compareByX(const Point &a, const Point &b) { return a.x > b.x; }\nbool compareByDiagonal1(const Point &a, const Point &b) { return a.x > b.x; }\nbool compareByDiagonal2(const Point &a, const Point &b) { return a.x < b.x; }\n\nint n, lineCnt;\nPoint a[MAXN];\nstd::vector< std::tr1::reference_wrapper<Point> > lines[MAXN];\nstd::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > > mapX, mapDiagonal1, mapDiagonal2;\n\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorY() const { return lines[lineIndex]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorX() const { return mapX[x]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorDiagonal1() const { return mapDiagonal1[x + y]; }\nstd::vector< std::tr1::reference_wrapper<Point> > &Point::getVectorDiagonal2() const { return mapDiagonal2[x - y]; }\n\ninline void dpUp(const int lineIndex) {\n\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[lineIndex];\n\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = v.begin(); it != v.end(); it++) {\n\t\tPoint &p = it->get();\n\t\t// p.dpUp = DPValue(NULL, 1);\n\n\t\tif (p.itX != p.getVectorX().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itX - 1)->get().dpInline.extend((p.itX - 1)->get(), 1));\n\t\t}\n\n\t\tif (p.itDiagonal1 != p.getVectorDiagonal1().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itDiagonal1 - 1)->get().dpInline.extend((p.itDiagonal1 - 1)->get(), 1));\n\t\t}\n\n\t\tif (p.itDiagonal2 != p.getVectorDiagonal2().begin()) {\n\t\t\tp.dpUp = std::max(p.dpUp, (p.itDiagonal2 - 1)->get().dpInline.extend((p.itDiagonal2 - 1)->get(), 1));\n\t\t}\n\t}\n}\n\ninline void dpInline(const int lineIndex) {\n\tstruct SegmentTree {\n\t\tint l, r, m;\n\t\tSegmentTree *lc, *rc;\n\t\tDPValue val;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + (r - l) / 2), lc(lc), rc(rc) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid update(const int pos, const DPValue &val) {\n\t\t\tif (l == r) this->val = val;\n\t\t\telse (pos <= m ? lc : rc)->update(pos, val), this->val = std::max(lc->val, rc->val);\n\t\t}\n\n\t\tDPValue query() { return val; }\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tint m = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, m), build(m + 1, r));\n\t\t\t}\n\t\t}\n\t} *segment;\n\n\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[lineIndex];\n\n\tsegment = SegmentTree::build(0, v.size() - 1);\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tsegment->update(i, v[i].get().dpUp.extend(v[i].get(), i));\n\t}\n\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tv[i].get().dpInline = segment->query();\n\t\tif (i < v.size() - 1) {\n\t\t\tsegment->update(i, v[i].get().dpUp.extend(v[i].get(), v.size() - i - 1));\n\t\t\tsegment->update(i + 1, v[i + 1].get().dpUp.extend(v[i + 1].get(), 0));\n\t\t}\n\t}\n\n\tdelete segment;\n}\n\ninline void dp() {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i != 0) dpUp(i);\n\t\tdpInline(i);\n\t}\n}\n\ninline void getInlinePath(std::vector<Point *> &v, Point *s, Point *t) {\n\tstd::vector< std::tr1::reference_wrapper<Point> > &line = s->getVectorY();\n\tstd::vector< std::tr1::reference_wrapper<Point> >::iterator a = std::lower_bound(line.begin(), line.end(), *s, &compareByX), b = std::lower_bound(line.begin(), line.end(), *t, &compareByX);\n\n\tassert(&a->get() == s);\n\tassert(&b->get() == t);\n\n#ifdef DBG\n\tprintf(\"getInlinePath(%d(%d, %d), %d(%d, %d))\\n\", s->id, s->x, s->y, t->id, t->x, t->y);\n#endif\n\n\tif (a < b) {\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a - 1; it >= line.begin(); it--) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"reverse!\");\n#endif\n\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a + 1; it <= b; it++) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\t} else {\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a + 1; it != line.end(); it++) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\n#ifdef DBG\n\t\tputs(\"reverse!\");\n#endif\n\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it = a - 1; it >= b; it--) {\n#ifdef DBG\n\t\t\tprintf(\"to %d(%d, %d)\\n\", it->get().id, it->get().x, it->get().y);\n#endif\n\t\t\tv.push_back(&it->get());\n\t\t}\n\t}\n}\n\ninline void getPath(std::vector<Point *> &v) {\n\tPoint *p = &a[n - 1];\n\tbool flag = false;\n\twhile (p->dpUp.x || (!flag && p->dpInline.x && p->dpInline.prec != p)) {\n\t\tif (flag || p->dpInline.prec == p || p->dpInline.x <= p->dpUp.x) {\n#ifdef DBG\n\t\t\tprintf(\"%d(%d, %d) -> %d(%d, %d)\\n\", p->id, p->x, p->y, p->dpUp.prec->id, p->dpUp.prec->x, p->dpUp.prec->y);\n#endif\n\t\t\tp = p->dpUp.prec;\n\t\t\tv.push_back(p);\n\t\t\tflag = false;\n\t\t} else {\n\t\t\tgetInlinePath(v, p, p->dpInline.prec);\n\t\t\tp = p->dpInline.prec;\n\t\t\tflag = true;\n\t\t}\n\t}\n}\n\ninline void getEdges(std::vector< std::pair<Point *, Point *> > &E) {\n\tstruct SegmentTree {\n\t\tint l, r, m;\n\t\tSegmentTree *lc, *rc;\n\t\tDPValue val;\n\t\tbool flag;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), m(l + (r - l) / 2), lc(lc), rc(rc), flag(false) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (flag) pushDown();\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (flag) {\n\t\t\t\tif (lc || rc) {\n\t\t\t\t\tif (val.x == lc->val.x) lc->flag = true;\n\t\t\t\t\tif (val.x == rc->val.x) rc->flag = true;\n\t\t\t\t} else {\n\t\t\t\t\tval.prec->flagInline = true;\n\t\t\t\t}\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid update(const int pos, const DPValue &val) {\n\t\t\tpushDown();\n\t\t\tif (l == r) this->val = val;\n\t\t\telse (pos <= m ? lc : rc)->update(pos, val), this->val = std::max(lc->val, rc->val);\n\t\t}\n\n\t\tDPValue query() { return val; }\n\n\t\tvoid mark() { flag = true; }\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tint m = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, m), build(m + 1, r));\n\t\t\t}\n\t\t}\n\t} *segment;\n\n\ta[n - 1].flagUp = true;\n\n\tfor (int i = lineCnt - 1; i >= 0; i--) {\n\t\tstd::vector< std::tr1::reference_wrapper<Point> > &v = lines[i];\n\t\tsegment = SegmentTree::build(0, v.size() - 1);\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tsegment->update(j, v[j].get().dpUp.extend(v[j].get(), j));\n\t\t}\n\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tif (v[j].get().flagUp) {\n\t\t\t\tsegment->mark();\n\t\t\t}\n\n\t\t\tif (j < v.size() - 1) {\n\t\t\t\tsegment->update(j, v[j].get().dpUp.extend(v[j].get(), v.size() - j - 1));\n\t\t\t\tsegment->update(j + 1, v[j + 1].get().dpUp.extend(v[j + 1].get(), 0));\n\t\t\t}\n\t\t}\n\n\t\tdelete segment;\n\n\t\tfor (size_t j = 0; j < v.size(); j++) {\n\t\t\tif (v[j].get().flagInline) {\n\t\t\t\tPoint &p = v[j].get();\n\t\t\t\t// p.dpUp = DPValue(NULL, 1);\n\n\t\t\t\tif (p.itX != p.getVectorX().begin() && p.dpUp.x == (p.itX - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itX - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itX - 1)->get().x, (p.itX - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itX - 1)->get()));\n\t\t\t\t}\n\n\t\t\t\tif (p.itDiagonal1 != p.getVectorDiagonal1().begin() && p.dpUp.x == (p.itDiagonal1 - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itDiagonal1 - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itDiagonal1 - 1)->get().x, (p.itDiagonal1 - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itDiagonal1 - 1)->get()));\n\t\t\t\t}\n\n\t\t\t\tif (p.itDiagonal2 != p.getVectorDiagonal2().begin() && p.dpUp.x == (p.itDiagonal2 - 1)->get().dpInline.x + 1) {\n\t\t\t\t\t(p.itDiagonal2 - 1)->get().flagUp = true;\n#ifdef DBG\n\t\t\t\t\tprintf(\"(%d, %d) flagUp (%d, %d)\\n\", p.x, p.y, (p.itDiagonal2 - 1)->get().x, (p.itDiagonal2 - 1)->get().y);\n#endif\n\t\t\t\t\tE.push_back(std::make_pair(&p, &(p.itDiagonal2 - 1)->get()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void sort() {\n\tfor (int i = 0; i < lineCnt; i++) {\n\t\tstd::sort(lines[i].begin(), lines[i].end(), &compareByX);\n\t}\n\t\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapX.begin(); it != mapX.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByY);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itX = it2;\n\t\t}\n\t}\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapDiagonal1.begin(); it != mapDiagonal1.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByDiagonal2);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itDiagonal1 = it2;\n\t\t}\n\t}\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::iterator it = mapDiagonal2.begin(); it != mapDiagonal2.end(); it++) {\n\t\tstd::sort(it->second.begin(), it->second.end(), &compareByDiagonal1);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tPoint &p = *it2;\n\t\t\tp.itDiagonal2 = it2;\n\t\t}\n\t}\n}\n\n#ifdef DBG\ninline void debugPrint() {\n\tfor (int i = 0; i < lineCnt; i++) {\n\t\tprintf(\"lines[%d] = { \", i);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it = lines[i].begin(); it != lines[i].end(); it++) {\n\t\t\tconst Point &p = *it;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it + 1 == lines[i].end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapX.begin(); it != mapX.end(); it++) {\n\t\tprintf(\"x[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapDiagonal1.begin(); it != mapDiagonal1.end(); it++) {\n\t\tprintf(\"diagonal1[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (std::tr1::unordered_map< int, std::vector< std::tr1::reference_wrapper<Point> > >::const_iterator it = mapDiagonal2.begin(); it != mapDiagonal2.end(); it++) {\n\t\tprintf(\"diagonal2[%d] = { \", it->first);\n\t\tfor (std::vector< std::tr1::reference_wrapper<Point> >::const_iterator it2 = it->second.begin(); it2 != it->second.end(); it2++) {\n\t\t\tconst Point &p = *it2;\n\t\t\tprintf(\"(%d, %d)%s\", p.x, p.y, it2 + 1 == it->second.end() ? \" }\\n\" : \", \");\n\t\t}\n\t}\n\tputchar('\\n');\n\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"(%d, %d): \", a[i].x, a[i].y);\n\t\tif (a[i].dpUp.prec) printf(\"dpUp[%d] = { (%d, %d), %d }, \", i, a[i].dpUp.prec->x, a[i].dpUp.prec->y, a[i].dpUp.x);\n\t\telse printf(\"dpUp[%d] = { nullptr, %d }, \", i, a[i].dpUp.x);\n\t\tif (a[i].dpInline.prec) printf(\"dpInline[%d] = { (%d, %d), %d }\\n\", i, a[i].dpInline.prec->x, a[i].dpInline.prec->y, a[i].dpInline.x);\n\t\telse printf(\"dpInline[%d] = { nullptr, %d }\\n\", i, a[i].dpInline.x);\n\t}\n}\n#endif\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].x, &a[i].y);\n\t\ta[i].id = i;\n\t}\n\ta[n].x = 0, a[n].y = 0, a[n].id = n, n++;\n\n\tstd::sort(a, a + n, &compareByY);\n\n\tfor (int i = 0, last; i < n; i++) {\n\t\tPoint &p = a[i];\n\n\t\tif (!i || p.y != a[last].y) ++lineCnt;\n\t\tlines[lineCnt - 1].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tp.lineIndex = lineCnt - 1;\n\n\t\tmapX[p.x].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tmapDiagonal1[p.x + p.y].push_back(std::tr1::reference_wrapper<Point>(p));\n\t\tmapDiagonal2[p.x - p.y].push_back(std::tr1::reference_wrapper<Point>(p));\n\n\t\tlast = i;\n\t}\n\n\tsort();\n\n\n#ifdef DBG\n\tdebugPrint();\n#endif\n\t\n\tdp();\n\n\tint cnt = a[n - 1].dpInline.x;\n\tprintf(\"%d\\n\", cnt);\n\n\tstd::vector<Point *> v;\n\tgetPath(v);\n#ifdef DBG\n\tfor (size_t i = 0; i < v.size(); i++) printf(\"%d: (%d, %d)\\n\", v[i]->id + 1, v[i]->x, v[i]->y);\n#else\n\tfor (size_t i = 0; i < v.size(); i++) printf(\"%d%c\", v[i]->id + 1, i == v.size() - 1 ? '\\n' : ' ');\n#endif\n\n\tstd::vector< std::pair<Point *, Point *> > E;\n\tgetEdges(E);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, INT_MAX), addEdge(i, t, INT_MAX);\n\tfor (std::vector< std::pair<Point *, Point *> >::const_iterator it = E.begin(); it != E.end(); it++) {\n\t\taddEdge(it->first->id + 1, it->second->id + 1, 1, INT_MAX);\n\t}\n\n\tprintf(\"%d\\n\", minFlow(s, t, n + 2));\n\n\treturn 0;\n}\n```\n","slug":"noi2015-farm","published":1,"updated":"2016-11-01T11:59:21.067Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cb900ptc2xlqa5g371x"},{"title":"NOI2015 - ","date":"2016-07-01T01:27:00.000Z","_content":"\n $ n $  $ 1 $  $ n $  $ i $  $ W_i $ $ k $  $ S_i $  $ i $  $ 1 \\leq i,j \\leq n,\\ i \\neq j $$ S_i $  $ S_j $ \n\n1. \n2.  $ S_i $ \n\n<!-- more -->\n\n### \n[BZOJ 4198](http://www.lydsy.com/JudgeOnline/problem.php?id=4198)  \n[UOJ #130](http://uoj.ac/problem/130)\n\n### \n $ k = 2 $ \n\n$ k \\neq 2 $ $ k $ \n\n $ S_i $  $ S_i $ \n\n $ k $  $ 1 $  $ k $  $ k - 1 $  $ n - 1 $   $ W_i = 0 $ $ (n - 1) \\bmod (k - 1) = 0 $ \n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 100000;\nconst int MAXK = 9;\n\nint main() {\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\n\tstd::priority_queue< std::pair<long long, int>, std::vector< std::pair<long long, int> >, std::greater< std::pair<long long, int> > > q;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tlong long x;\n\t\tscanf(\"%lld\", &x);\n\t\tq.push(std::make_pair(x, 0));\n\t}\n\n\twhile ((q.size() - 1) % (k - 1) != 0) q.push(std::make_pair(0, 0));\n\n\tlong long ans = 0;\n\twhile (q.size() > 1) {\n\t\tstd::pair<long long, int> newNode;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tstd::pair<long long, int> p = q.top();\n\t\t\tq.pop();\n\t\t\tans += p.first;\n\t\t\tnewNode.first += p.first;\n\t\t\tnewNode.second = std::max(newNode.second, p.second);\n\t\t}\n\n\t\tnewNode.second++;\n\n\t\tq.push(newNode);\n\t}\n\n\tstd::pair<long long, int> p = q.top();\n\tprintf(\"%lld\\n%d\\n\", ans, p.second);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2015-epic.md","raw":"title: NOI2015 - \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - \n  - \n  - \npermalink: noi2015-epic\ndate: 2016-07-01 09:27:00\n---\n\n $ n $  $ 1 $  $ n $  $ i $  $ W_i $ $ k $  $ S_i $  $ i $  $ 1 \\leq i,j \\leq n,\\ i \\neq j $$ S_i $  $ S_j $ \n\n1. \n2.  $ S_i $ \n\n<!-- more -->\n\n### \n[BZOJ 4198](http://www.lydsy.com/JudgeOnline/problem.php?id=4198)  \n[UOJ #130](http://uoj.ac/problem/130)\n\n### \n $ k = 2 $ \n\n$ k \\neq 2 $ $ k $ \n\n $ S_i $  $ S_i $ \n\n $ k $  $ 1 $  $ k $  $ k - 1 $  $ n - 1 $   $ W_i = 0 $ $ (n - 1) \\bmod (k - 1) = 0 $ \n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 100000;\nconst int MAXK = 9;\n\nint main() {\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\n\tstd::priority_queue< std::pair<long long, int>, std::vector< std::pair<long long, int> >, std::greater< std::pair<long long, int> > > q;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tlong long x;\n\t\tscanf(\"%lld\", &x);\n\t\tq.push(std::make_pair(x, 0));\n\t}\n\n\twhile ((q.size() - 1) % (k - 1) != 0) q.push(std::make_pair(0, 0));\n\n\tlong long ans = 0;\n\twhile (q.size() > 1) {\n\t\tstd::pair<long long, int> newNode;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tstd::pair<long long, int> p = q.top();\n\t\t\tq.pop();\n\t\t\tans += p.first;\n\t\t\tnewNode.first += p.first;\n\t\t\tnewNode.second = std::max(newNode.second, p.second);\n\t\t}\n\n\t\tnewNode.second++;\n\n\t\tq.push(newNode);\n\t}\n\n\tstd::pair<long long, int> p = q.top();\n\tprintf(\"%lld\\n%d\\n\", ans, p.second);\n\n\treturn 0;\n}\n```\n","slug":"noi2015-epic","published":1,"updated":"2016-07-01T01:28:31.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cbg00q2c2xlfl2zijy5"},{"title":"NOI2015 -  DP","date":"2016-07-01T05:23:00.000Z","_content":"\n $ 2 $ ~ $ n $  $ n - 1 $  $ a $  $ b $ $ \\gcd(a, b) = 1 $\n\n<!-- more -->\n\n### \n[BZOJ 4197](http://www.lydsy.com/JudgeOnline/problem.php?id=4197)  \n[UOJ #129](http://uoj.ac/problem/129)\n\n### \n $ f(a, b) $$ a $$ b $  $ a $ $ b $ \n\n $ x $  $ \\sqrt x $  $ 8 $   $ 2, 3, 5, 7, 11, 13, 17, 19 $\n\n $ z $ $ z $  $ z $ \n\n $ z $  $ i $  $ S_i $\n\n $ f(a, b) $ **** $ a $ $ b $ \n\n $ g(i, k, a, b) $  $ i $  $ k $  $ a $ $ b $ \n\n $ x $ $ g(i - 1, 0) $  $ g(i - 1, 1) $  $ g(i, 0) $  $ g(i, 1) $\n\n$$\n\\begin{aligned}\ng(i, 0, a, b) &=\n  \\begin{cases}\n  f(a, b) & S_i \\cap b \\neq \\emptyset \\\\\n  \\sum\\limits_{a' \\cup S_i = a} g(i - 1, a', b) + f(a, b) & S_i \\cap b = \\emptyset\n  \\end{cases} \\\\\ng(i, 1, a, b) &=\n  \\begin{cases}\n  f(a, b) & S_i \\cap a \\neq \\emptyset \\\\\n  \\sum\\limits_{b' \\cup S_i = b} g(i - 1, a, b') + f(a, b) & S_i \\cap a = \\emptyset\n  \\end{cases}\n\\end{aligned}\n$$\n\n $ a' $  $ b' $  $ a' $  $ b' $  $ a $  $ b $  $ a' \\leq a $$ b' \\leq b $ $ i $ $ a $  $ b $ $ g(0) $  $ g(1) $\n\n$$\n\\mathrm {for \\ each} \\ i.\\ a = U \\to \\emptyset,\\ b = U \\to \\emptyset \\\\\n\\begin{aligned}\ng(0, a \\cup S_i, b) \\leftarrow g(0, a \\cup S_i, b) + g(0, a, b) && S_i \\cap b = \\emptyset \\\\\ng(0, a, b \\cup S_i) \\leftarrow g(0, a, b \\cup S_i) + g(0, a, b) && S_i \\cap a = \\emptyset \\\\\n\\end{aligned}\n$$\n\n $ \\sqrt x $  $ x $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 500;\nconst int MAXK = 8;\nconst int MAXSTAT = 1 << 8;\nconst int PRIMES[] = { 2, 3, 5, 7, 11, 13, 17, 19 };\n\nint main() {\n\tint n, p;\n\tscanf(\"%d %d\", &n, &p);\n\n\tstd::vector< std::vector<int> > v;\n\tstd::vector< std::pair<int, int> > tmp;\n\tfor (int i = 2; i <= n; i++) {\n\t\tint x = i, t = 0;\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tif (x % PRIMES[j] == 0) {\n\t\t\t\twhile (x % PRIMES[j] == 0) x /= PRIMES[j];\n\t\t\t\tt |= 1 << j;\n\t\t\t}\n\t\t}\n\n\t\ttmp.push_back(std::make_pair(x, t));\n\t}\n\n\tstd::sort(tmp.begin(), tmp.end());\n\n\tfor (std::vector< std::pair<int, int> >::const_iterator it = tmp.begin(); it != tmp.end(); it++) {\n\t\tif (it == tmp.begin() || it->first == 1 || it->first != (it - 1)->first) {\n\t\t\tv.resize(v.size() + 1);\n\t\t}\n\t\tv.back().push_back(it->second);\n\t}\n\n\tstatic int f[MAXSTAT][MAXSTAT], g[2][MAXSTAT][MAXSTAT];\n\tf[0][0] = 1;\n\tfor (std::vector< std::vector<int> >::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tmemcpy(g[0], f, sizeof(f));\n\t\tmemcpy(g[1], f, sizeof(f));\n\n\t\t// puts(\"new\");\n\t\tfor (std::vector<int>::const_iterator it2 = it->begin(); it2 != it->end(); it2++) {\n\t\t\t// printf(\"%d\\n\", *it2);\n\t\t\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\t\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\t\t\t// printf(\"%d %d\\n\", a, b);\n\t\t\t\t\tif (!(b & *it2)) /* printf(\"[0] += %d\\n\", g[0][a][b]), */ (g[0][a | (*it2)][b] += g[0][a][b]) %= p;\n\t\t\t\t\tif (!(a & *it2)) /* printf(\"[1] += %d\\n\", g[1][a][b]), */ (g[1][a][b | (*it2)] += g[1][a][b]) %= p;\n\t\t\t\t\t// printf(\"%d\\n\", *it2);\n\t\t\t\t\t// printf(\"%d %d\\n\", g[0][a][b], g[1][a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\t\tf[a][b] = ((g[0][a][b] + g[1][a][b] - f[a][b]) % p + p) % p;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\tif (!(a & b)) (ans += f[a][b]) %= p;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2015-dinner.md","raw":"title: NOI2015 -  DP\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - DP\n  -  DP\n  -  DP\npermalink: noi2015-dinner\ndate: 2016-07-01 13:23:00\n---\n\n $ 2 $ ~ $ n $  $ n - 1 $  $ a $  $ b $ $ \\gcd(a, b) = 1 $\n\n<!-- more -->\n\n### \n[BZOJ 4197](http://www.lydsy.com/JudgeOnline/problem.php?id=4197)  \n[UOJ #129](http://uoj.ac/problem/129)\n\n### \n $ f(a, b) $$ a $$ b $  $ a $ $ b $ \n\n $ x $  $ \\sqrt x $  $ 8 $   $ 2, 3, 5, 7, 11, 13, 17, 19 $\n\n $ z $ $ z $  $ z $ \n\n $ z $  $ i $  $ S_i $\n\n $ f(a, b) $ **** $ a $ $ b $ \n\n $ g(i, k, a, b) $  $ i $  $ k $  $ a $ $ b $ \n\n $ x $ $ g(i - 1, 0) $  $ g(i - 1, 1) $  $ g(i, 0) $  $ g(i, 1) $\n\n$$\n\\begin{aligned}\ng(i, 0, a, b) &=\n  \\begin{cases}\n  f(a, b) & S_i \\cap b \\neq \\emptyset \\\\\n  \\sum\\limits_{a' \\cup S_i = a} g(i - 1, a', b) + f(a, b) & S_i \\cap b = \\emptyset\n  \\end{cases} \\\\\ng(i, 1, a, b) &=\n  \\begin{cases}\n  f(a, b) & S_i \\cap a \\neq \\emptyset \\\\\n  \\sum\\limits_{b' \\cup S_i = b} g(i - 1, a, b') + f(a, b) & S_i \\cap a = \\emptyset\n  \\end{cases}\n\\end{aligned}\n$$\n\n $ a' $  $ b' $  $ a' $  $ b' $  $ a $  $ b $  $ a' \\leq a $$ b' \\leq b $ $ i $ $ a $  $ b $ $ g(0) $  $ g(1) $\n\n$$\n\\mathrm {for \\ each} \\ i.\\ a = U \\to \\emptyset,\\ b = U \\to \\emptyset \\\\\n\\begin{aligned}\ng(0, a \\cup S_i, b) \\leftarrow g(0, a \\cup S_i, b) + g(0, a, b) && S_i \\cap b = \\emptyset \\\\\ng(0, a, b \\cup S_i) \\leftarrow g(0, a, b \\cup S_i) + g(0, a, b) && S_i \\cap a = \\emptyset \\\\\n\\end{aligned}\n$$\n\n $ \\sqrt x $  $ x $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 500;\nconst int MAXK = 8;\nconst int MAXSTAT = 1 << 8;\nconst int PRIMES[] = { 2, 3, 5, 7, 11, 13, 17, 19 };\n\nint main() {\n\tint n, p;\n\tscanf(\"%d %d\", &n, &p);\n\n\tstd::vector< std::vector<int> > v;\n\tstd::vector< std::pair<int, int> > tmp;\n\tfor (int i = 2; i <= n; i++) {\n\t\tint x = i, t = 0;\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tif (x % PRIMES[j] == 0) {\n\t\t\t\twhile (x % PRIMES[j] == 0) x /= PRIMES[j];\n\t\t\t\tt |= 1 << j;\n\t\t\t}\n\t\t}\n\n\t\ttmp.push_back(std::make_pair(x, t));\n\t}\n\n\tstd::sort(tmp.begin(), tmp.end());\n\n\tfor (std::vector< std::pair<int, int> >::const_iterator it = tmp.begin(); it != tmp.end(); it++) {\n\t\tif (it == tmp.begin() || it->first == 1 || it->first != (it - 1)->first) {\n\t\t\tv.resize(v.size() + 1);\n\t\t}\n\t\tv.back().push_back(it->second);\n\t}\n\n\tstatic int f[MAXSTAT][MAXSTAT], g[2][MAXSTAT][MAXSTAT];\n\tf[0][0] = 1;\n\tfor (std::vector< std::vector<int> >::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tmemcpy(g[0], f, sizeof(f));\n\t\tmemcpy(g[1], f, sizeof(f));\n\n\t\t// puts(\"new\");\n\t\tfor (std::vector<int>::const_iterator it2 = it->begin(); it2 != it->end(); it2++) {\n\t\t\t// printf(\"%d\\n\", *it2);\n\t\t\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\t\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\t\t\t// printf(\"%d %d\\n\", a, b);\n\t\t\t\t\tif (!(b & *it2)) /* printf(\"[0] += %d\\n\", g[0][a][b]), */ (g[0][a | (*it2)][b] += g[0][a][b]) %= p;\n\t\t\t\t\tif (!(a & *it2)) /* printf(\"[1] += %d\\n\", g[1][a][b]), */ (g[1][a][b | (*it2)] += g[1][a][b]) %= p;\n\t\t\t\t\t// printf(\"%d\\n\", *it2);\n\t\t\t\t\t// printf(\"%d %d\\n\", g[0][a][b], g[1][a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\t\tf[a][b] = ((g[0][a][b] + g[1][a][b] - f[a][b]) % p + p) % p;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int a = MAXSTAT - 1; a >= 0; a--) {\n\t\tfor (int b = MAXSTAT - 1; b >= 0; b--) {\n\t\t\tif (!(a & b)) (ans += f[a][b]) %= p;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"noi2015-dinner","published":1,"updated":"2016-10-24T23:37:15.002Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cbn00qbc2xl7v5sx37n"},{"title":"NOI2014 - KMP","date":"2016-07-11T15:41:00.000Z","_content":"\n $ S $  $ i $  $ \\mathrm {num}(i) $\n\n$$\n\\prod\\limits_{i = 1} ^ n (\\mathrm{num}(i) + 1) \\pmod {1000000007}\n$$\n\n<!-- more -->\n\n### \n[BZOJ 3670](http://www.lydsy.com/JudgeOnline/problem.php?id=3670)  \n[UOJ #5](http://uoj.ac/problem/5)\n\n### \n DP  $ \\mathrm{num}(i) = \\mathrm{num}(\\mathrm{next}(i)) + 1 $\n\n   $ \\mathrm{next} $  $ \\mathrm{next2} $ $ \\mathrm{num} $ $ \\mathrm{num2} $ $ \\mathrm{num2}(i) = \\mathrm{num2}(\\mathrm{next2}(i)) + 1 $ \n\n$$ \\mathrm{num2}(i) = \\mathrm{num}(\\mathrm{next2}(i)) + 1 $$\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 5;\nconst int MAXN = 1000000;\nconst unsigned long long MOD = 1000000007;\n\nint n, next[MAXN + 1], next2[MAXN + 1], num[MAXN + 1], num2[MAXN + 1];\nchar s[MAXN + 1];\n\ninline unsigned long long kmp() {\n\tnext[0] = next[1] = num[0] = num[1] = 0;\n\tfor (int i = 2, t = 0, k = 0; i <= n; i++) {\n\t\twhile (t && s[t] != s[i - 1]) t = next[t];\n\t\twhile ((k && s[k] != s[i - 1]) || k >= i / 2) k = next[k];\n\n\t\tif (s[k] == s[i - 1]) num2[i] = num[++k] + 1;\n\t\telse num2[i] = 0;\n\n\t\tif (s[t] == s[i - 1]) next[i] = ++t, num[i] = num[t] + 1;\n\t\telse next[i] = num[i] = 0;\n\t}\n\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", f[i], i == n ? '\\n' : ' ');\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", num[i], i == n ? '\\n' : ' ');\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", num2[i], i == n ? '\\n' : ' ');\n\n\tunsigned long long ans = 1;\n\tfor (int i = 1; i <= n; i++) (ans *= (num2[i] + 1)) %= MOD;\n\treturn ans;\n}\n\nint main() {\n\tint t = 1;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\n\t\tprintf(\"%llu\\n\", kmp());\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2014-zoo.md","raw":"title: NOI2014 - KMP\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - KMP\n  - \npermalink: noi2014-zoo\ndate: 2016-07-11 23:41:00\n---\n\n $ S $  $ i $  $ \\mathrm {num}(i) $\n\n$$\n\\prod\\limits_{i = 1} ^ n (\\mathrm{num}(i) + 1) \\pmod {1000000007}\n$$\n\n<!-- more -->\n\n### \n[BZOJ 3670](http://www.lydsy.com/JudgeOnline/problem.php?id=3670)  \n[UOJ #5](http://uoj.ac/problem/5)\n\n### \n DP  $ \\mathrm{num}(i) = \\mathrm{num}(\\mathrm{next}(i)) + 1 $\n\n   $ \\mathrm{next} $  $ \\mathrm{next2} $ $ \\mathrm{num} $ $ \\mathrm{num2} $ $ \\mathrm{num2}(i) = \\mathrm{num2}(\\mathrm{next2}(i)) + 1 $ \n\n$$ \\mathrm{num2}(i) = \\mathrm{num}(\\mathrm{next2}(i)) + 1 $$\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 5;\nconst int MAXN = 1000000;\nconst unsigned long long MOD = 1000000007;\n\nint n, next[MAXN + 1], next2[MAXN + 1], num[MAXN + 1], num2[MAXN + 1];\nchar s[MAXN + 1];\n\ninline unsigned long long kmp() {\n\tnext[0] = next[1] = num[0] = num[1] = 0;\n\tfor (int i = 2, t = 0, k = 0; i <= n; i++) {\n\t\twhile (t && s[t] != s[i - 1]) t = next[t];\n\t\twhile ((k && s[k] != s[i - 1]) || k >= i / 2) k = next[k];\n\n\t\tif (s[k] == s[i - 1]) num2[i] = num[++k] + 1;\n\t\telse num2[i] = 0;\n\n\t\tif (s[t] == s[i - 1]) next[i] = ++t, num[i] = num[t] + 1;\n\t\telse next[i] = num[i] = 0;\n\t}\n\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", f[i], i == n ? '\\n' : ' ');\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", num[i], i == n ? '\\n' : ' ');\n\t// for (int i = 1; i <= n; i++) printf(\"%d%c\", num2[i], i == n ? '\\n' : ' ');\n\n\tunsigned long long ans = 1;\n\tfor (int i = 1; i <= n; i++) (ans *= (num2[i] + 1)) %= MOD;\n\treturn ans;\n}\n\nint main() {\n\tint t = 1;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\n\t\tprintf(\"%llu\\n\", kmp());\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noi2014-zoo","published":1,"updated":"2016-07-11T15:41:47.623Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cbt00qic2xlhyboh5bi"},{"title":"NOI2014 -  + ","date":"2016-04-03T14:39:31.000Z","_content":"\ndrd drd  $ n $  $ \\rm op $  $ t $ $ \\rm OR $$ \\rm XOR $$ \\rm AND $  $ x $ $ x ~ {\\rm op} ~ t $ drd  $ x $  $ n $ \n atm  $ 0 $  $ m $  $ 0 $$ 1 $$  $$ m $  $ m $  drd \n\n<!-- more -->\n\n### \n[BZOJ 3668](http://www.lydsy.com/JudgeOnline/problem.php?id=3668)\n\n### \n $ 0 $  $ 1 $ $ 1 $ $ 1 $  $ 1 $\n\n `unsigned int`\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 100000;\nconst int MAXM = 1e9;\n\nenum OperatorType {\n\tAnd = 0, Or = 1, Xor = 2\n};\n\nstruct BitwiseOperator {\n\tOperatorType type;\n\tbool bits[32];\n} ops[MAXN];\n\nint n;\nunsigned int m;\n\ninline bool check(const int k, const bool value) {\n\tbool flag = value;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (ops[i].type == And) flag &= ops[i].bits[k];\n\t\telse if (ops[i].type == Or) flag |= ops[i].bits[k];\n\t\telse if (ops[i].type == Xor) flag ^= ops[i].bits[k];\n\t}\n\n\treturn flag;\n}\n\ninline unsigned int solve() {\n\tunsigned int num = 0, ans = 0;\n\tfor (int i = 32 - 1; i >= 0; i--) {\n\t\tif (check(i, 0)) ans |= (1 << i);\n\t\telse if ((num | (1 << i)) <= m && check(i, 1)) ans |= (1 << i), num |= (1 << i);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"sleep.in\", \"r\", stdin);\n\t// freopen(\"sleep.out\", \"w\", stdout);\n\n\tscanf(\"%d %u\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tBitwiseOperator &op = ops[i];\n\t\tchar str[sizeof(\"AND\")];\n\t\tint x;\n\t\tscanf(\"%s %d\", str, &x);\n\t\tif (str[0] == 'A') op.type = And;\n\t\telse if (str[0] == 'O') op.type = Or;\n\t\telse if (str[0] == 'X') op.type = Xor;\n\n\t\tfor (int i = 0; i < 32; i++) op.bits[i] = ((x & (1 << i)) == 0) ? false : true;\n\t\t// for (int i = 0; i < 32; i++) putchar(op.bits[i] ? '1' : '0');\n\t\t// putchar('\\n');\n\t}\n\n\tprintf(\"%u\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2014-sleep.md","raw":"title: NOI2014 -  + \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - \n  - \npermalink: noi2014-sleep\ndate: 2016-04-03 22:39:31\n---\n\ndrd drd  $ n $  $ \\rm op $  $ t $ $ \\rm OR $$ \\rm XOR $$ \\rm AND $  $ x $ $ x ~ {\\rm op} ~ t $ drd  $ x $  $ n $ \n atm  $ 0 $  $ m $  $ 0 $$ 1 $$  $$ m $  $ m $  drd \n\n<!-- more -->\n\n### \n[BZOJ 3668](http://www.lydsy.com/JudgeOnline/problem.php?id=3668)\n\n### \n $ 0 $  $ 1 $ $ 1 $ $ 1 $  $ 1 $\n\n `unsigned int`\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 100000;\nconst int MAXM = 1e9;\n\nenum OperatorType {\n\tAnd = 0, Or = 1, Xor = 2\n};\n\nstruct BitwiseOperator {\n\tOperatorType type;\n\tbool bits[32];\n} ops[MAXN];\n\nint n;\nunsigned int m;\n\ninline bool check(const int k, const bool value) {\n\tbool flag = value;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (ops[i].type == And) flag &= ops[i].bits[k];\n\t\telse if (ops[i].type == Or) flag |= ops[i].bits[k];\n\t\telse if (ops[i].type == Xor) flag ^= ops[i].bits[k];\n\t}\n\n\treturn flag;\n}\n\ninline unsigned int solve() {\n\tunsigned int num = 0, ans = 0;\n\tfor (int i = 32 - 1; i >= 0; i--) {\n\t\tif (check(i, 0)) ans |= (1 << i);\n\t\telse if ((num | (1 << i)) <= m && check(i, 1)) ans |= (1 << i), num |= (1 << i);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"sleep.in\", \"r\", stdin);\n\t// freopen(\"sleep.out\", \"w\", stdout);\n\n\tscanf(\"%d %u\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tBitwiseOperator &op = ops[i];\n\t\tchar str[sizeof(\"AND\")];\n\t\tint x;\n\t\tscanf(\"%s %d\", str, &x);\n\t\tif (str[0] == 'A') op.type = And;\n\t\telse if (str[0] == 'O') op.type = Or;\n\t\telse if (str[0] == 'X') op.type = Xor;\n\n\t\tfor (int i = 0; i < 32; i++) op.bits[i] = ((x & (1 << i)) == 0) ? false : true;\n\t\t// for (int i = 0; i < 32; i++) putchar(op.bits[i] ? '1' : '0');\n\t\t// putchar('\\n');\n\t}\n\n\tprintf(\"%u\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"noi2014-sleep","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cby00qoc2xlwc42qho2"},{"title":"NOI2014 - LCT","date":"2016-07-11T15:50:00.000Z","_content":"\n $ N $  $ M $  $ 1 \\ldots N $ $ 1 \\ldots M $ E  $ 1 $ $ N $\n\n $ E_i $  $ A_i $  $ B_i $ A  $ A_i $ B  $ B_i $\n\n E \n\n<!-- more -->\n\n### \n[BZOJ 3669](http://www.lydsy.com/JudgeOnline/problem.php?id=3669)  \n[UOJ #3](http://uoj.ac/problem/3)\n\n### \n $ A_i $  $ B_i $  LCT  $ B_i $  $ 1 $  $ n $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\n\nstruct LinkCutTree {\n\tstruct Node {\n\t\tNode *c[2], *p, *pp, *max;\n\t\tint w;\n\t\tbool rev;\n\n\t\tNode() : p(NULL), pp(NULL), max(this), w(0) {}\n\n\t\tint relation() { return this == p->c[0] ? 0 : 1; }\n\n\t\tvoid maintain() {\n\t\t\tmax = this;\n\t\t\tif (c[0] && c[0]->max->w > max->w) max = c[0]->max;\n\t\t\tif (c[1] && c[1]->max->w > max->w) max = c[1]->max;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (rev) {\n\t\t\t\tstd::swap(c[0], c[1]);\n\t\t\t\tif (c[0]) c[0]->rev ^= 1;\n\t\t\t\tif (c[1]) c[1]->rev ^= 1;\n\t\t\t\trev = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tstd::swap(pp, p->pp);\n\t\t\tint r = relation();\n\t\t\tNode *o = p;\n\t\t\t\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\n\t\t\to->c[r] = c[r ^ 1];\n\t\t\tif (c[r ^ 1]) c[r ^ 1]->p = o;\n\n\t\t\tc[r ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (p) {\n\t\t\t\tif (p->p) p->p->pushDown();\n\t\t\t\tp->pushDown(), pushDown();\n\n\t\t\t\tif (!p->p) rotate();\n\t\t\t\telse if (p->relation() == relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (c[1]) {\n\t\t\t\tstd::swap(c[1]->p, c[1]->pp);\n\t\t\t\tc[1] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pp) return false;\n\t\t\tpp->expose();\n\t\t\tpp->c[1] = this;\n\t\t\tpp->maintain();\n\t\t\tstd::swap(p, pp);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\trev ^= 1;\n\t\t}\n\t} N[MAXN], E[MAXM], *a[MAXM][2];\n\n\tvoid link(Node *u, Node *v) {\n\t\t// printf(\"Linking %ld as %ld's parent.\\n\", u - N + 1, v - N + 1);\n\t\tv->evert();\n\t\tu->expose();\n\t\tv->pp = u;\n\t}\n\n\tvoid link(const int u, const int v, const int i, const int w) {\n\t\tE[i].w = w;\n\t\ta[i][0] = &N[u];\n\t\ta[i][1] = &N[v];\n\t\tlink(&N[u], &E[i]);\n\t\tlink(&E[i], &N[v]);\n\t}\n\n\tvoid cut(Node *u, Node *v) {\n\t\tv->evert();\n\t\tv->expose();\n\t\tu->splay();\n\t\tu->pp = NULL;\n\t}\n\n\tvoid cut(const int i) {\n\t\tcut(a[i][0], &E[i]);\n\t\tcut(&E[i], a[i][1]);\n\t}\n\n\tNode *find(const int u) {\n\t\tNode *v = &N[u];\n\t\tv->access();\n\t\tv->splay();\n\t\tif (!v->c[0]) {\n\t\t\t// printf(\"find(%d) = %ld\\n\", u + 1, v - N + 1);\n\t\t\treturn v;\n\t\t}\n\t\twhile (v->c[0]) v = v->c[0];\n\t\t// printf(\"find(%d) = %ld\\n\", u + 1, v - N + 1);\n\t\treturn v;\n\t}\n\n\tbool test(const int u, const int v) {\n\t\treturn find(u) == find(v);\n\t}\n\n\tint queryMax(const int u, const int v) {\n\t\tN[u].evert();\n\t\tN[v].access();\n\t\tN[v].splay();\n\t\tassert(N[v].max >= E);\n\t\treturn N[v].max - E;\n\t}\n} lct;\n\nstruct Edge {\n\tint u, v, a, b;\n\n\tbool operator<(const Edge &other) const { return a < other.a; }\n} E[MAXM];\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d %d %d\", &E[i].u, &E[i].v, &E[i].a, &E[i].b), E[i].u--, E[i].v--;\n\tstd::sort(E, E + m);\n\n\tint ans = INT_MAX;\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\tif (e.u == e.v) continue;\n\t\tif (lct.test(e.u, e.v)) {\n\t\t\t// printf(\"[%d, %d, %d, %d] will lead to a circle!\\n\", e.u + 1, e.v + 1, e.a, e.b);\n\t\t\tint max = lct.queryMax(e.u, e.v);\n\t\t\t// printf(\"max = %d\\n\", max);\n\t\t\tif (E[max].b > e.b) {\n\t\t\t\tlct.cut(max);\n\t\t\t\tlct.link(e.u, e.v, i, e.b);\n\t\t\t}\n\t\t} else {\n\t\t\t// printf(\"Connecting [%d, %d, %d, %d] ...\\n\", e.u + 1, e.v + 1, e.a, e.b);\n\t\t\tlct.link(e.u, e.v, i, e.b);\n\t\t}\n\n\t\tif (lct.test(0, n - 1)) ans = std::min(ans, e.a + E[lct.queryMax(0, n - 1)].b);\n\t}\n\n\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2014-forest.md","raw":"title: NOI2014 - LCT\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - LCT\n  - \npermalink: noi2014-forest\ndate: 2016-07-11 23:50:00\n---\n\n $ N $  $ M $  $ 1 \\ldots N $ $ 1 \\ldots M $ E  $ 1 $ $ N $\n\n $ E_i $  $ A_i $  $ B_i $ A  $ A_i $ B  $ B_i $\n\n E \n\n<!-- more -->\n\n### \n[BZOJ 3669](http://www.lydsy.com/JudgeOnline/problem.php?id=3669)  \n[UOJ #3](http://uoj.ac/problem/3)\n\n### \n $ A_i $  $ B_i $  LCT  $ B_i $  $ 1 $  $ n $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\n\nstruct LinkCutTree {\n\tstruct Node {\n\t\tNode *c[2], *p, *pp, *max;\n\t\tint w;\n\t\tbool rev;\n\n\t\tNode() : p(NULL), pp(NULL), max(this), w(0) {}\n\n\t\tint relation() { return this == p->c[0] ? 0 : 1; }\n\n\t\tvoid maintain() {\n\t\t\tmax = this;\n\t\t\tif (c[0] && c[0]->max->w > max->w) max = c[0]->max;\n\t\t\tif (c[1] && c[1]->max->w > max->w) max = c[1]->max;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (rev) {\n\t\t\t\tstd::swap(c[0], c[1]);\n\t\t\t\tif (c[0]) c[0]->rev ^= 1;\n\t\t\t\tif (c[1]) c[1]->rev ^= 1;\n\t\t\t\trev = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tstd::swap(pp, p->pp);\n\t\t\tint r = relation();\n\t\t\tNode *o = p;\n\t\t\t\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\n\t\t\to->c[r] = c[r ^ 1];\n\t\t\tif (c[r ^ 1]) c[r ^ 1]->p = o;\n\n\t\t\tc[r ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (p) {\n\t\t\t\tif (p->p) p->p->pushDown();\n\t\t\t\tp->pushDown(), pushDown();\n\n\t\t\t\tif (!p->p) rotate();\n\t\t\t\telse if (p->relation() == relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\tpushDown();\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tif (c[1]) {\n\t\t\t\tstd::swap(c[1]->p, c[1]->pp);\n\t\t\t\tc[1] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pp) return false;\n\t\t\tpp->expose();\n\t\t\tpp->c[1] = this;\n\t\t\tpp->maintain();\n\t\t\tstd::swap(p, pp);\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\trev ^= 1;\n\t\t}\n\t} N[MAXN], E[MAXM], *a[MAXM][2];\n\n\tvoid link(Node *u, Node *v) {\n\t\t// printf(\"Linking %ld as %ld's parent.\\n\", u - N + 1, v - N + 1);\n\t\tv->evert();\n\t\tu->expose();\n\t\tv->pp = u;\n\t}\n\n\tvoid link(const int u, const int v, const int i, const int w) {\n\t\tE[i].w = w;\n\t\ta[i][0] = &N[u];\n\t\ta[i][1] = &N[v];\n\t\tlink(&N[u], &E[i]);\n\t\tlink(&E[i], &N[v]);\n\t}\n\n\tvoid cut(Node *u, Node *v) {\n\t\tv->evert();\n\t\tv->expose();\n\t\tu->splay();\n\t\tu->pp = NULL;\n\t}\n\n\tvoid cut(const int i) {\n\t\tcut(a[i][0], &E[i]);\n\t\tcut(&E[i], a[i][1]);\n\t}\n\n\tNode *find(const int u) {\n\t\tNode *v = &N[u];\n\t\tv->access();\n\t\tv->splay();\n\t\tif (!v->c[0]) {\n\t\t\t// printf(\"find(%d) = %ld\\n\", u + 1, v - N + 1);\n\t\t\treturn v;\n\t\t}\n\t\twhile (v->c[0]) v = v->c[0];\n\t\t// printf(\"find(%d) = %ld\\n\", u + 1, v - N + 1);\n\t\treturn v;\n\t}\n\n\tbool test(const int u, const int v) {\n\t\treturn find(u) == find(v);\n\t}\n\n\tint queryMax(const int u, const int v) {\n\t\tN[u].evert();\n\t\tN[v].access();\n\t\tN[v].splay();\n\t\tassert(N[v].max >= E);\n\t\treturn N[v].max - E;\n\t}\n} lct;\n\nstruct Edge {\n\tint u, v, a, b;\n\n\tbool operator<(const Edge &other) const { return a < other.a; }\n} E[MAXM];\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d %d %d\", &E[i].u, &E[i].v, &E[i].a, &E[i].b), E[i].u--, E[i].v--;\n\tstd::sort(E, E + m);\n\n\tint ans = INT_MAX;\n\tfor (int i = 0; i < m; i++) {\n\t\tEdge &e = E[i];\n\t\tif (e.u == e.v) continue;\n\t\tif (lct.test(e.u, e.v)) {\n\t\t\t// printf(\"[%d, %d, %d, %d] will lead to a circle!\\n\", e.u + 1, e.v + 1, e.a, e.b);\n\t\t\tint max = lct.queryMax(e.u, e.v);\n\t\t\t// printf(\"max = %d\\n\", max);\n\t\t\tif (E[max].b > e.b) {\n\t\t\t\tlct.cut(max);\n\t\t\t\tlct.link(e.u, e.v, i, e.b);\n\t\t\t}\n\t\t} else {\n\t\t\t// printf(\"Connecting [%d, %d, %d, %d] ...\\n\", e.u + 1, e.v + 1, e.a, e.b);\n\t\t\tlct.link(e.u, e.v, i, e.b);\n\t\t}\n\n\t\tif (lct.test(0, n - 1)) ans = std::min(ans, e.a + E[lct.queryMax(0, n - 1)].b);\n\t}\n\n\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\n\treturn 0;\n}\n```\n","slug":"noi2014-forest","published":1,"updated":"2016-07-11T15:54:43.005Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cc300quc2xliza3k2sd"},{"title":"NOI2012 - ","date":"2016-10-07T23:29:00.000Z","_content":"\n\n\n$$ x_{n + 1} = (a x_n + c) \\bmod m $$\n\n $ m, a, c, x_0, n, g $ $ x_n \\bmod g $\n\n<!-- more -->\n\n### \n[BZOJ 2875](www.lydsy.com/JudgeOnline/problem.php?id=2875)  \n[COGS 963](http://cogs.pro/cogs/problem/problem.php?pid=963)\n\n### \n\n\n $ 2 $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst long long MAXN = 1e18;\nconst long long MAXG = 1e8;\n\nlong long mod;\n\nstruct Matrix {\n\tlong long a[2][2];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < 2; i++) a[i][i] = 1;\n\t}\n\n\tlong long &operator()(const int i, const int j) { return a[i][j]; }\n\tconst long long &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nlong long mul(long long a, long long b) {\n\tlong long res = 0;\n\tfor (; b; b >>= 1, a = (a + a) % mod) if (b & 1) res = (res + a) % mod;\n\treturn res;\n}\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) (res(i, j) += mul(a(i, k), b(k, j))) %= mod;\n\treturn res;\n}\n\nMatrix pow(Matrix a, long long n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"randoma.in\", \"r\", stdin);\n\tfreopen(\"randoma.out\", \"w\", stdout);\n\n\tlong long a, c, x, n, g;\n\tscanf(\"%lld %lld %lld %lld %lld %lld\", &mod, &a, &c, &x, &n, &g);\n\t// mod = 1e9 + 7;\n\n\tMatrix init(false);\n\tinit(0, 0) = x;\n\tinit(1, 0) = c;\n\n\tMatrix shift(false);\n\tshift(0, 0) = a, shift(0, 1) = 1;\n\tshift(1, 0) = 0, shift(1, 1) = 1;\n\n#ifdef FORCE\n\tMatrix res = init;\n\tfor (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) printf(\"%lld%c\", res(j, k), k == 2 - 1 ? '\\n' : ' ');\n\tputs(\"----------------------\");\n\tfor (int i = 0; i < n; i++) {\n\t\tres = shift * res;\n\t\tfor (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) printf(\"%lld%c\", res(j, k), k == 2 - 1 ? '\\n' : ' ');\n\t\tputs(\"----------------------\");\n\t}\n#else\n\tMatrix res = pow(shift, n) * init;\n#endif\n\n\tprintf(\"%lld\\n\", res(0, 0) % g);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/noi2012-random.md","raw":"title: NOI2012 - \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - COGS\n  - \npermalink: noi2012-random\ndate: 2016-10-08 07:29:00\n---\n\n\n\n$$ x_{n + 1} = (a x_n + c) \\bmod m $$\n\n $ m, a, c, x_0, n, g $ $ x_n \\bmod g $\n\n<!-- more -->\n\n### \n[BZOJ 2875](www.lydsy.com/JudgeOnline/problem.php?id=2875)  \n[COGS 963](http://cogs.pro/cogs/problem/problem.php?pid=963)\n\n### \n\n\n $ 2 $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst long long MAXN = 1e18;\nconst long long MAXG = 1e8;\n\nlong long mod;\n\nstruct Matrix {\n\tlong long a[2][2];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) for (int i = 0; i < 2; i++) a[i][i] = 1;\n\t}\n\n\tlong long &operator()(const int i, const int j) { return a[i][j]; }\n\tconst long long &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nlong long mul(long long a, long long b) {\n\tlong long res = 0;\n\tfor (; b; b >>= 1, a = (a + a) % mod) if (b & 1) res = (res + a) % mod;\n\treturn res;\n}\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) (res(i, j) += mul(a(i, k), b(k, j))) %= mod;\n\treturn res;\n}\n\nMatrix pow(Matrix a, long long n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"randoma.in\", \"r\", stdin);\n\tfreopen(\"randoma.out\", \"w\", stdout);\n\n\tlong long a, c, x, n, g;\n\tscanf(\"%lld %lld %lld %lld %lld %lld\", &mod, &a, &c, &x, &n, &g);\n\t// mod = 1e9 + 7;\n\n\tMatrix init(false);\n\tinit(0, 0) = x;\n\tinit(1, 0) = c;\n\n\tMatrix shift(false);\n\tshift(0, 0) = a, shift(0, 1) = 1;\n\tshift(1, 0) = 0, shift(1, 1) = 1;\n\n#ifdef FORCE\n\tMatrix res = init;\n\tfor (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) printf(\"%lld%c\", res(j, k), k == 2 - 1 ? '\\n' : ' ');\n\tputs(\"----------------------\");\n\tfor (int i = 0; i < n; i++) {\n\t\tres = shift * res;\n\t\tfor (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) printf(\"%lld%c\", res(j, k), k == 2 - 1 ? '\\n' : ' ');\n\t\tputs(\"----------------------\");\n\t}\n#else\n\tMatrix res = pow(shift, n) * init;\n#endif\n\n\tprintf(\"%lld\\n\", res(0, 0) % g);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"noi2012-random","published":1,"updated":"2016-10-07T23:36:47.010Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cc900r1c2xl5prwgqg9"},{"title":"NOI2011 - AC ","date":"2016-09-11T23:38:00.000Z","_content":"\n $ 28 $  $ 26 $  `B``P` \n\n\n\n* \n*  `B` \n*  `P` \n\n $ 1 $  $ n $ $ (x, y) $ $ 1 \\leq x, y \\leq n $ $ x $  $ y $ \n\n<!-- more -->\n\n### \n[BZOJ 2434](http://www.lydsy.com/JudgeOnline/problem.php?id=2434)\n\n### \n Trie  Trie \n\n AC  $ y $  $ x $ $ y $  `fail`  $ x $ AC  $ y $  `fail`  $ x $\n\n `fail`  Fail  Fail  AC  `fail` AC  $ y $  Fail  $ x $ \n\n   AC  $ y $ Fail  $ 1 $ $ y $  $ x $ $ x $  Fail \n\n DFS  +  AC  Fail  $ 1 $ $ 0 $ $ y $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 1e5;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next, *p;\n\t\tint id;\n\t\tbool isWord;\n\t\tstruct Query {\n\t\t\tNode *x;\n\t\t\tint *ans;\n\n\t\t\tQuery(Node *x, int *ans) : x(x), ans(ans) {}\n\t\t};\n\t\tstd::vector<Query> q;\n\n\t\tNode(Node *p, bool isWord, const int id) : fail(NULL), next(NULL), p(p), id(id), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tint init(const char *s, std::vector<Node *> &vec) {\n\t\tint cnt = 0;\n\t\tNode *v = root = new Node(NULL, false, cnt++);\n\t\tfor (const char *p = s; *p; p++) {\n\t\t\tassert(*p == 'P' || *p == 'B' || (*p >= 'a' && *p <= 'z'));\n\t\t\tif (*p == 'P') v->isWord = true, vec.push_back(v);\n\t\t\telse if (*p == 'B') v = v->p;\n\t\t\telse {\n\t\t\t\tif (!v->c[*p - BASE_CHAR]) v->c[*p - BASE_CHAR] = new Node(v, false, cnt++);\n\t\t\t\tv = v->c[*p - BASE_CHAR];\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\troot->fail = root, root->next = NULL;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tassert(v->q.size() < MAXN);\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t\tassert(v->q.size() < MAXN);\n\t\t\t\tassert(c->q.size() < MAXN);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tNode *p, *c, *next;\n\tint l, r;\n\tbool v;\n} N[MAXN];\n\nint n;\n\ninline void addEdge(const int p, const int c) {\n\t// printf(\"addEdge(%d, %d)\\n\", p, c);\n\tN[c].next = N[p].c;\n\tN[p].c = &N[c];\n\tN[c].p = &N[p];\n}\n\ninline void buildFailTree() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tTrie::Node *&c = v->c[i];\n\t\t\tif (!c) continue;\n\t\t\taddEdge(c->fail->id, c->id);\n\t\t\tq.push(c);\n\t\t}\n\t}\n}\n\ninline void dfs() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ts = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->v) {\n\t\t\tv->v = true;\n\t\t\tv->l = ++ts;\n\t\t\tfor (Node *c = v->c; c; c = c->next) s.push(c);\n\t\t} else {\n\t\t\tv->r = ts;\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n\nstruct BinaryIndexedTree {\n\tint a[MAXN + 1], n;\n\n\tvoid init(const int n) { this->n = n; }\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tvoid update(const int pos, const int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n\n\tint query(const int pos) {\n\t\tint ans = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) ans += a[i];\n\t\treturn ans;\n\t}\n} bit;\n\nchar op[MAXN + 1];\ninline void solve() {\n\tbit.init(n);\n\tTrie::Node *y = t.root;\n\tfor (const char *p = op; *p; p++) {\n\t\tif (*p == 'P') {\n\t\t\tfor (std::vector<Trie::Node::Query>::iterator it = y->q.begin(); it != y->q.end(); it++) {\n\t\t\t\t*it->ans = bit.query(N[it->x->id].r) - bit.query(N[it->x->id].l - 1);\n\t\t\t}\n\t\t} else if (*p == 'B') {\n\t\t\tbit.update(N[y->id].l, -1);\n\t\t\ty = y->p;\n\t\t} else {\n\t\t\ty = y->c[*p - BASE_CHAR];\n\t\t\tbit.update(N[y->id].l, 1);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%s\", op);\n\n\tstd::vector<Trie::Node *> vec;\n\tn = t.init(op, vec);\n\tt.build();\n\n\tbuildFailTree();\n\tdfs();\n\n\tint m;\n\tstatic int ans[MAXN];\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y), x--, y--;\n\t\tvec[y]->q.push_back(Trie::Node::Query(vec[x], &ans[i]));\n\t}\n\n\tsolve();\n\tfor (int i = 0; i < m; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```","source":"_posts/noi2011-type.md","raw":"title: NOI2011 - AC \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - \n  - AC \npermalink: noi2011-type\ndate: 2016-09-12 07:38:00\n---\n\n $ 28 $  $ 26 $  `B``P` \n\n\n\n* \n*  `B` \n*  `P` \n\n $ 1 $  $ n $ $ (x, y) $ $ 1 \\leq x, y \\leq n $ $ x $  $ y $ \n\n<!-- more -->\n\n### \n[BZOJ 2434](http://www.lydsy.com/JudgeOnline/problem.php?id=2434)\n\n### \n Trie  Trie \n\n AC  $ y $  $ x $ $ y $  `fail`  $ x $ AC  $ y $  `fail`  $ x $\n\n `fail`  Fail  Fail  AC  `fail` AC  $ y $  Fail  $ x $ \n\n   AC  $ y $ Fail  $ 1 $ $ y $  $ x $ $ x $  Fail \n\n DFS  +  AC  Fail  $ 1 $ $ 0 $ $ y $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 1e5;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next, *p;\n\t\tint id;\n\t\tbool isWord;\n\t\tstruct Query {\n\t\t\tNode *x;\n\t\t\tint *ans;\n\n\t\t\tQuery(Node *x, int *ans) : x(x), ans(ans) {}\n\t\t};\n\t\tstd::vector<Query> q;\n\n\t\tNode(Node *p, bool isWord, const int id) : fail(NULL), next(NULL), p(p), id(id), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tint init(const char *s, std::vector<Node *> &vec) {\n\t\tint cnt = 0;\n\t\tNode *v = root = new Node(NULL, false, cnt++);\n\t\tfor (const char *p = s; *p; p++) {\n\t\t\tassert(*p == 'P' || *p == 'B' || (*p >= 'a' && *p <= 'z'));\n\t\t\tif (*p == 'P') v->isWord = true, vec.push_back(v);\n\t\t\telse if (*p == 'B') v = v->p;\n\t\t\telse {\n\t\t\t\tif (!v->c[*p - BASE_CHAR]) v->c[*p - BASE_CHAR] = new Node(v, false, cnt++);\n\t\t\t\tv = v->c[*p - BASE_CHAR];\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\troot->fail = root, root->next = NULL;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tassert(v->q.size() < MAXN);\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t\tassert(v->q.size() < MAXN);\n\t\t\t\tassert(c->q.size() < MAXN);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tNode *p, *c, *next;\n\tint l, r;\n\tbool v;\n} N[MAXN];\n\nint n;\n\ninline void addEdge(const int p, const int c) {\n\t// printf(\"addEdge(%d, %d)\\n\", p, c);\n\tN[c].next = N[p].c;\n\tN[p].c = &N[c];\n\tN[c].p = &N[p];\n}\n\ninline void buildFailTree() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tTrie::Node *&c = v->c[i];\n\t\t\tif (!c) continue;\n\t\t\taddEdge(c->fail->id, c->id);\n\t\t\tq.push(c);\n\t\t}\n\t}\n}\n\ninline void dfs() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ts = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->v) {\n\t\t\tv->v = true;\n\t\t\tv->l = ++ts;\n\t\t\tfor (Node *c = v->c; c; c = c->next) s.push(c);\n\t\t} else {\n\t\t\tv->r = ts;\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n\nstruct BinaryIndexedTree {\n\tint a[MAXN + 1], n;\n\n\tvoid init(const int n) { this->n = n; }\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tvoid update(const int pos, const int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n\n\tint query(const int pos) {\n\t\tint ans = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) ans += a[i];\n\t\treturn ans;\n\t}\n} bit;\n\nchar op[MAXN + 1];\ninline void solve() {\n\tbit.init(n);\n\tTrie::Node *y = t.root;\n\tfor (const char *p = op; *p; p++) {\n\t\tif (*p == 'P') {\n\t\t\tfor (std::vector<Trie::Node::Query>::iterator it = y->q.begin(); it != y->q.end(); it++) {\n\t\t\t\t*it->ans = bit.query(N[it->x->id].r) - bit.query(N[it->x->id].l - 1);\n\t\t\t}\n\t\t} else if (*p == 'B') {\n\t\t\tbit.update(N[y->id].l, -1);\n\t\t\ty = y->p;\n\t\t} else {\n\t\t\ty = y->c[*p - BASE_CHAR];\n\t\t\tbit.update(N[y->id].l, 1);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%s\", op);\n\n\tstd::vector<Trie::Node *> vec;\n\tn = t.init(op, vec);\n\tt.build();\n\n\tbuildFailTree();\n\tdfs();\n\n\tint m;\n\tstatic int ans[MAXN];\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y), x--, y--;\n\t\tvec[y]->q.push_back(Trie::Node::Query(vec[x], &ans[i]));\n\t}\n\n\tsolve();\n\tfor (int i = 0; i < m; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```","slug":"noi2011-type","published":1,"updated":"2016-09-11T23:53:53.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cce00r7c2xl14zkxu1u"},{"title":"NOI2008 -  + ","date":"2016-12-23T10:00:00.000Z","_content":"\n $ \\mathrm{len} $ \n\n1.  $ t $  $ [l, r] $\n2.  $ t $  $ [l, r] $ \n3.  $ t $ \n\n $ 0 $**** $ 0 $ **** $ \\mathrm{len} $ \n\n<!-- more -->\n\n### \n[BZOJ 1062](http://www.lydsy.com/JudgeOnline/problem.php?id=1062)\n\n### \n $ [0, 2\\mathrm{len}] $ $ 2\\mathrm{len} $ $ 0 $  $ 2\\mathrm{len} $ \n\n![ 2len ](noi2008-candy/1.svg?)\n\n $ t $  $ [l, r] $ $ 0 $  $ 2\\mathrm{len} $  $ x $$ x \\in [0, 2\\mathrm{len}) $ $ x \\equiv t - l \\pmod {2\\mathrm{len}} $ $ x \\equiv t + l \\pmod {2\\mathrm{len}} $ $ y = r - l $ $ (x, y) $ \n\n $ t $  $ [l, r] $  $ t = 0 $  $ 0 $  $ [0, \\mathrm{len}] $ \n\n*  $ 0 $  $ 0 $  $ l $\n*  $ -1 $  $ 0 $  $ -1 $  $ 2 \\mathrm{len} - 1 $  $ 0 $  $ 0 $  $ 1 $  $ l - 1 $\n*  $ -2 $  $ l - 2 $\n* \n*  $ -l $  $ 0 $\n* \n*  $ -r $  $ 0 $\n*  $ -r - 1 $  $ 0 $  $ r + 1 $ \n\n\n\n![](noi2008-candy/2.svg)\n\n $ A $  $ 1 $  $ 0 $  $ B $  $ 0 $  $ 0 $ $ A $  $ B $ $ B $ $ B $  $ A $ $ A $  $ B $ \n\n $ A $  $ 1 $  $ 0 $  $ 2\\mathrm{len} - 1 $  $ 2\\mathrm{len} - 1 $  $ 1 $  $ A $  $ l - 1 $ \n\n\n\n*  $ 0 $  $ 2 $  $ l - 2 $\n* \n*  $ l $  $ 0 $\n* \n*  $ r $  $ 0 $\n*  $ r + 1 $  $ 0 $  $ r + 1 $ \n\n\n\n![](noi2008-candy/3.svg)\n\n $ t \\neq 0 $ $ t \\in [0, 2\\mathrm{len}) $ $ 1 $  $ 1 $  $ 0 $   \n\n $ 1 $  $ 2\\mathrm{len} $  $ 2\\mathrm{len} $ \n\n![](noi2008-candy/4.svg)\n\n**** $ t \\neq 0 $  $ [0, 2\\mathrm{len}) $  $ 0 $  $ [0, 2\\mathrm{len}) $  $ [2\\mathrm{len}, 4\\mathrm{len}) $\n\n $ r = \\mathrm{len} $ \n\n![](noi2008-candy/5.svg)\n\n $ +1 $\n\n $ l = r = 0 $ \n\n\n\n   $ y $  $ 1 $  $ -1 $\n\n![](noi2008-candy/6.svg)\n\n $ 2\\mathrm{len} $\n\n![](noi2008-candy/7.svg)\n\n $ 4\\mathrm{len} $  $ 4\\mathrm{len} $\n\n\n\n  \n\n $ O(n \\log ^ 2 \\mathrm{len}) $ $ O(\\mathrm{len} ^ 2) $ $ 32 $ \n\n### \n\n\n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n\nconst int MAXLEN = 1000;\nconst int MAXC = 1000000;\n\nstruct BinaryIndexedTree {\n\tint a[MAXLEN * 4 + 10][MAXLEN * 4 + 10], n, m;\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid init(int n, int m) {\n\t\tthis->n = n, this->m = m;\n\t}\n\n\tvoid update(int x, int y, int delta) {\n\t\tfor (int i = x + 1; i <= n + 5; i += lowbit(i)) {\n\t\t\tfor (int j = y + 1; j <= m + 5; j += lowbit(j)) {\n\t\t\t\ta[i - 1][j - 1] += delta;\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(int x, int y) {\n\t\tint res = 0;\n\t\tfor (int i = x + 1; i > 0; i -= lowbit(i)) {\n\t\t\tfor (int j = y + 1; j > 0; j -= lowbit(j)) {\n\t\t\t\tres += a[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tint query(int x1, int y1, int x2, int y2) {\n\t\tint res = query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n\t\treturn res;\n\t}\n} bit1, bit2;\n\nstruct Cloud {\n\tint t, l, r, d;\n} cloud[MAXC + 1];\n\nint len;\n\ninline void transform(int &x, int &y, int i) {\n\tif (i == 1) {\n\t\ty += x;\n\t} else {\n\t\ty += 4 * len - x;\n\t}\n}\n\ninline void add(int x, int y) {\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n}\n\ninline void add(int t, int c, int l, int r, int d) {\n\tint y = r - l;\n\tif (d == 1) {\n\t\tt -= l;\n\t} else {\n\t\tt += l;\n\t}\n\tt = (t % (len * 2) + (len * 2)) % (len * 2);\n\n\tcloud[c].t = t, cloud[c].l = l, cloud[c].r = r, cloud[c].d = d;\n\n\tadd(t, y);\n}\n\ninline void del(int x, int y) {\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n}\n\ninline void del(int c) {\n\tdel(cloud[c].t, cloud[c].r - cloud[c].l);\n}\n\ninline int query(int t, int l, int r) {\n\tt %= (len * 2);\n\tint ans = 0;\n\n\tint x1, x2, y1, y2;\n\tx1 = t, y1 = l, x2 = t + r, y2 = len;\n\ttransform(x1, y1, 1), transform(x2, y2, 1);\n\tans += bit1.query(x1, y1, x2, y2);\n\n\tif (r != 0) {\n\t\tx1 = 2 * len - r + t, y1 = l - r, x2 = 2 * len + t - 1, y2 = len + r;\n\t\ttransform(x1, y1, 2), transform(x2, y2, 2);\n\t\tif (r == len) x1++;\n\t\tans += bit2.query(x1, y1, x2, y2);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d %d\", &n, &len);\n\tbit1.init(len * 4 + 1, len * 4 + 1);\n\tbit2.init(len * 4 + 1, len * 4 + 1);\n\twhile (n--) {\n\t\tint cmd;\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint t, c, l, r, d;\n\t\t\tscanf(\"%d %d %d %d %d\", &t, &c, &l, &r, &d);\n\t\t\tadd(t, c, l, r, d);\n\t\t} else if (cmd == 2) {\n\t\t\tint t, l, r;\n\t\t\tscanf(\"%d %d %d\", &t, &l, &r);\n\t\t\tprintf(\"%d\\n\", query(t, l, r));\n\t\t} else {\n\t\t\tint t, c;\n\t\t\tscanf(\"%d %d\", &t, &c);\n\t\t\tdel(c);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n\n\n\n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n\nconst int MAXLEN = 1000;\nconst int MAXC = 1000000;\n\n#ifndef FORCE\nstruct BinaryIndexedTree;\nBinaryIndexedTree *_bit1, *_bit2;\nstruct BinaryIndexedTree {\n\tint a[MAXLEN * 4 + 10][MAXLEN * 4 + 10], n, m;\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid init(int n, int m) {\n#ifdef DBG_BIT\n\t\tprintf(\"init(%d, %d)\\n\", n, m);\n#endif\n\t\tthis->n = n, this->m = m;\n\t}\n\n\tvoid update(int x, int y, int delta) {\n#ifdef DBG_BIT\n\t\tprintf(\"update(%d, %d, %d, %d)\\n\", this == ::_bit1 ? 1 : 2, x, y, delta);\n#endif\n\t\tassert(x >= 0);\n\t\tassert(y >= 0);\n#ifdef FORCE_BIT\n\t\ta[x][y] += delta;\n#else\n\t\tfor (int i = x + 1; i <= n + 5; i += lowbit(i)) {\n\t\t\tfor (int j = y + 1; j <= m + 5; j += lowbit(j)) {\n\t\t\t\ta[i - 1][j - 1] += delta;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\tint query(int x, int y) {\n\t\tint res = 0;\n#ifdef FORCE_BIT\n\t\tfor (int i = x; i >= 0; i--) {\n\t\t\tfor (int j = y; j >= 0; j--) {\n\t\t\t\tres += a[i][j];\n\t\t\t}\n\t\t}\n#else\n\t\tfor (int i = x + 1; i > 0; i -= lowbit(i)) {\n\t\t\tfor (int j = y + 1; j > 0; j -= lowbit(j)) {\n\t\t\t\tres += a[i - 1][j - 1];\n\t\t\t}\n\t\t}\n#endif\n\t\treturn res;\n\t}\n\n\tint query(int x1, int y1, int x2, int y2) {\n#ifdef FORCE_BIT\n\t\tint res = 0;\n\t\tfor (int i = x1; i <= x2; i++) {\n\t\t\tfor (int j = y1; j <= y2; j++) {\n\t\t\t\tres += a[i][j];\n\t\t\t}\n\t\t}\n#else\n\t\tint res = query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n#endif\n#ifdef DBG_BIT\n\t\tprintf(\"query(%d, %d, %d, %d, %d) = %d\\n\", this == ::_bit1 ? 1 : 2, x1, y1, x2, y2, res);\n#endif\n\t\treturn res;\n\t}\n} bit1, bit2;\n#endif\n\nstruct Cloud {\n\tint t, l, r, d;\n} cloud[MAXC + 1];\n\nint len;\n#ifdef FORCE\nint a[MAXLEN * 4 + 5][MAXLEN * 2 + 5];\n#endif\n\ninline void transform(int &x, int &y, int i) {\n#ifdef DBG\n\tprintf(\"transform(%d, %d, %d) = \", x, y, i);\n#endif\n\tif (i == 1) {\n\t\ty += x;\n\t} else {\n\t\ty += 4 * len - x;\n\t}\n#ifdef DBG\n\tprintf(\"(%d, %d)\\n\", x, y);\n#endif\n}\n\ninline void add(int x, int y) {\n\t// printf(\"add(%d, %d)\\n\", x, y);\n#ifdef FORCE\n\ta[x][y]++;\n\t// a[x + len * 2][y]++;\n#else\n#ifdef DBG\n\tprintf(\"add(%d, %d)\\n\", x, y);\n#endif\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n\t/*\n\tbit1.update(x, y + x, 1);\n\tbit2.update(x, y + (len * 2 - x), 1);\n\n\tbit1.update(x + len * 2, y + x, 1);\n\tbit2.update(x + len * 2, y + (len * 2 - x), 1);\n\t*/\n#endif\n}\n\ninline void add(int t, int c, int l, int r, int d) {\n\tint y = r - l;\n\tif (d == 1) {\n\t\tt -= l;\n\t} else {\n\t\tt += l;\n\t}\n\tt = (t % (len * 2) + (len * 2)) % (len * 2);\n\n\tcloud[c].t = t, cloud[c].l = l, cloud[c].r = r, cloud[c].d = d;\n\n\tadd(t, y);\n}\n\ninline void del(int x, int y) {\n#ifdef FORCE\n\ta[x][y]--;\n\t// a[x + len * 2][y]--;\n#else\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n#endif\n}\n\ninline void del(int c) {\n\tdel(cloud[c].t, cloud[c].r - cloud[c].l);\n}\n\ninline int query(int t, int l, int r) {\n\tt %= (len * 2);\n#ifdef FORCE\n\t// printf(\"query(%d, %d, %d)\\n\", t, l, r);\n\tstatic bool added[MAXLEN * 2 + 5][MAXLEN + 5];\n\tmemset(added, 0, sizeof(added));\n\tint ans = 0;\n\tfor (int i = 0, start = l; i <= r; i++, start--) {\n\t\tfor (int j = start; j <= start + (len + r - l); j++) {\n\t\t\tif (j >= 0) {\n\t\t\t\t// printf(\"[%d, %d]\\n\", (i + t) % (len * 2), j);\n\t\t\t\tint tmp = (i + t) % (len * 2);\n\t\t\t\tif (a[tmp][j] && !added[tmp][j]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tadded[tmp][j] = true;\n\t\t\t\t\t// printf(\"query(%d, %d, %d) [%d, %d]\\n\", t, l, r, (i + t) % (len * 2), j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = len * 2, start = l; i >= len * 2 - r; i--, start--) {\n\t\tfor (int j = start; j <= start + (len + r - l); j++) {\n\t\t\tif (j >= 0) {\n\t\t\t\t// printf(\"[%d, %d]\\n\", (i + t) % (len * 2), j);\n\t\t\t\tint tmp = (i + t) % (len * 2);\n\t\t\t\tif (a[tmp][j] && !added[tmp][j]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tadded[tmp][j] = true;\n\t\t\t\t\t// printf(\"query(%d, %d, %d) [%d, %d]\\n\", t, l, r, (i + t) % (len * 2), j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n#else\n#ifdef DBG\n\tprintf(\"query([%d, %d], [%d, %d], [%d, %d], [%d, %d])\\n\", 0 + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len + r, //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  0 + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l,       //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len,     //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l - r);  //\n\tprintf(\"query([%d, %d], [%d, %d], [%d, %d], [%d, %d])\\n\", 2 * len - r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len,     //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  2 * len - r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l - r,   //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  2 * len + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l,       //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  2 * len + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len + r);//\n#endif\n\n\tint ans = 0;\n\n\tint x1, x2, y1, y2;\n\tx1 = t, y1 = l, x2 = t + r, y2 = len;\n\ttransform(x1, y1, 1), transform(x2, y2, 1);\n\tans += bit1.query(x1, y1, x2, y2);\n\n\tif (r != 0) {\n\t\tx1 = 2 * len - r + t, y1 = l - r, x2 = 2 * len + t - 1, y2 = len + r;\n\t\ttransform(x1, y1, 2), transform(x2, y2, 2);\n\t\tif (r == len) x1++;\n\t\tans += bit2.query(x1, y1, x2, y2);\n\t}\n\treturn ans;\n#endif\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d %d\", &n, &len);\n#ifndef FORCE_BIT\n\tbit1.init(len * 4 + 1, len * 4 + 1);\n\tbit2.init(len * 4 + 1, len * 4 + 1);\n\t_bit1 = &bit1, _bit2 = &bit2;\n#endif\n\twhile (n--) {\n\t\tint cmd;\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint t, c, l, r, d;\n\t\t\tscanf(\"%d %d %d %d %d\", &t, &c, &l, &r, &d);\n\t\t\tadd(t, c, l, r, d);\n\t\t} else if (cmd == 2) {\n\t\t\tint t, l, r;\n\t\t\tscanf(\"%d %d %d\", &t, &l, &r);\n\t\t\tprintf(\"%d\\n\", query(t, l, r));\n\t\t} else {\n\t\t\tint t, c;\n\t\t\tscanf(\"%d %d\", &t, &c);\n\t\t\tdel(c);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/noi2008-candy.md","raw":"title: NOI2008 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - NOI\n  - \n  - \n  - \npermalink: noi2008-candy\ndate: 2016-12-23 18:00:00\n---\n\n $ \\mathrm{len} $ \n\n1.  $ t $  $ [l, r] $\n2.  $ t $  $ [l, r] $ \n3.  $ t $ \n\n $ 0 $**** $ 0 $ **** $ \\mathrm{len} $ \n\n<!-- more -->\n\n### \n[BZOJ 1062](http://www.lydsy.com/JudgeOnline/problem.php?id=1062)\n\n### \n $ [0, 2\\mathrm{len}] $ $ 2\\mathrm{len} $ $ 0 $  $ 2\\mathrm{len} $ \n\n![ 2len ](noi2008-candy/1.svg?)\n\n $ t $  $ [l, r] $ $ 0 $  $ 2\\mathrm{len} $  $ x $$ x \\in [0, 2\\mathrm{len}) $ $ x \\equiv t - l \\pmod {2\\mathrm{len}} $ $ x \\equiv t + l \\pmod {2\\mathrm{len}} $ $ y = r - l $ $ (x, y) $ \n\n $ t $  $ [l, r] $  $ t = 0 $  $ 0 $  $ [0, \\mathrm{len}] $ \n\n*  $ 0 $  $ 0 $  $ l $\n*  $ -1 $  $ 0 $  $ -1 $  $ 2 \\mathrm{len} - 1 $  $ 0 $  $ 0 $  $ 1 $  $ l - 1 $\n*  $ -2 $  $ l - 2 $\n* \n*  $ -l $  $ 0 $\n* \n*  $ -r $  $ 0 $\n*  $ -r - 1 $  $ 0 $  $ r + 1 $ \n\n\n\n![](noi2008-candy/2.svg)\n\n $ A $  $ 1 $  $ 0 $  $ B $  $ 0 $  $ 0 $ $ A $  $ B $ $ B $ $ B $  $ A $ $ A $  $ B $ \n\n $ A $  $ 1 $  $ 0 $  $ 2\\mathrm{len} - 1 $  $ 2\\mathrm{len} - 1 $  $ 1 $  $ A $  $ l - 1 $ \n\n\n\n*  $ 0 $  $ 2 $  $ l - 2 $\n* \n*  $ l $  $ 0 $\n* \n*  $ r $  $ 0 $\n*  $ r + 1 $  $ 0 $  $ r + 1 $ \n\n\n\n![](noi2008-candy/3.svg)\n\n $ t \\neq 0 $ $ t \\in [0, 2\\mathrm{len}) $ $ 1 $  $ 1 $  $ 0 $   \n\n $ 1 $  $ 2\\mathrm{len} $  $ 2\\mathrm{len} $ \n\n![](noi2008-candy/4.svg)\n\n**** $ t \\neq 0 $  $ [0, 2\\mathrm{len}) $  $ 0 $  $ [0, 2\\mathrm{len}) $  $ [2\\mathrm{len}, 4\\mathrm{len}) $\n\n $ r = \\mathrm{len} $ \n\n![](noi2008-candy/5.svg)\n\n $ +1 $\n\n $ l = r = 0 $ \n\n\n\n   $ y $  $ 1 $  $ -1 $\n\n![](noi2008-candy/6.svg)\n\n $ 2\\mathrm{len} $\n\n![](noi2008-candy/7.svg)\n\n $ 4\\mathrm{len} $  $ 4\\mathrm{len} $\n\n\n\n  \n\n $ O(n \\log ^ 2 \\mathrm{len}) $ $ O(\\mathrm{len} ^ 2) $ $ 32 $ \n\n### \n\n\n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n\nconst int MAXLEN = 1000;\nconst int MAXC = 1000000;\n\nstruct BinaryIndexedTree {\n\tint a[MAXLEN * 4 + 10][MAXLEN * 4 + 10], n, m;\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid init(int n, int m) {\n\t\tthis->n = n, this->m = m;\n\t}\n\n\tvoid update(int x, int y, int delta) {\n\t\tfor (int i = x + 1; i <= n + 5; i += lowbit(i)) {\n\t\t\tfor (int j = y + 1; j <= m + 5; j += lowbit(j)) {\n\t\t\t\ta[i - 1][j - 1] += delta;\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(int x, int y) {\n\t\tint res = 0;\n\t\tfor (int i = x + 1; i > 0; i -= lowbit(i)) {\n\t\t\tfor (int j = y + 1; j > 0; j -= lowbit(j)) {\n\t\t\t\tres += a[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tint query(int x1, int y1, int x2, int y2) {\n\t\tint res = query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n\t\treturn res;\n\t}\n} bit1, bit2;\n\nstruct Cloud {\n\tint t, l, r, d;\n} cloud[MAXC + 1];\n\nint len;\n\ninline void transform(int &x, int &y, int i) {\n\tif (i == 1) {\n\t\ty += x;\n\t} else {\n\t\ty += 4 * len - x;\n\t}\n}\n\ninline void add(int x, int y) {\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n}\n\ninline void add(int t, int c, int l, int r, int d) {\n\tint y = r - l;\n\tif (d == 1) {\n\t\tt -= l;\n\t} else {\n\t\tt += l;\n\t}\n\tt = (t % (len * 2) + (len * 2)) % (len * 2);\n\n\tcloud[c].t = t, cloud[c].l = l, cloud[c].r = r, cloud[c].d = d;\n\n\tadd(t, y);\n}\n\ninline void del(int x, int y) {\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n}\n\ninline void del(int c) {\n\tdel(cloud[c].t, cloud[c].r - cloud[c].l);\n}\n\ninline int query(int t, int l, int r) {\n\tt %= (len * 2);\n\tint ans = 0;\n\n\tint x1, x2, y1, y2;\n\tx1 = t, y1 = l, x2 = t + r, y2 = len;\n\ttransform(x1, y1, 1), transform(x2, y2, 1);\n\tans += bit1.query(x1, y1, x2, y2);\n\n\tif (r != 0) {\n\t\tx1 = 2 * len - r + t, y1 = l - r, x2 = 2 * len + t - 1, y2 = len + r;\n\t\ttransform(x1, y1, 2), transform(x2, y2, 2);\n\t\tif (r == len) x1++;\n\t\tans += bit2.query(x1, y1, x2, y2);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d %d\", &n, &len);\n\tbit1.init(len * 4 + 1, len * 4 + 1);\n\tbit2.init(len * 4 + 1, len * 4 + 1);\n\twhile (n--) {\n\t\tint cmd;\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint t, c, l, r, d;\n\t\t\tscanf(\"%d %d %d %d %d\", &t, &c, &l, &r, &d);\n\t\t\tadd(t, c, l, r, d);\n\t\t} else if (cmd == 2) {\n\t\t\tint t, l, r;\n\t\t\tscanf(\"%d %d %d\", &t, &l, &r);\n\t\t\tprintf(\"%d\\n\", query(t, l, r));\n\t\t} else {\n\t\t\tint t, c;\n\t\t\tscanf(\"%d %d\", &t, &c);\n\t\t\tdel(c);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n\n\n\n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n\nconst int MAXLEN = 1000;\nconst int MAXC = 1000000;\n\n#ifndef FORCE\nstruct BinaryIndexedTree;\nBinaryIndexedTree *_bit1, *_bit2;\nstruct BinaryIndexedTree {\n\tint a[MAXLEN * 4 + 10][MAXLEN * 4 + 10], n, m;\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid init(int n, int m) {\n#ifdef DBG_BIT\n\t\tprintf(\"init(%d, %d)\\n\", n, m);\n#endif\n\t\tthis->n = n, this->m = m;\n\t}\n\n\tvoid update(int x, int y, int delta) {\n#ifdef DBG_BIT\n\t\tprintf(\"update(%d, %d, %d, %d)\\n\", this == ::_bit1 ? 1 : 2, x, y, delta);\n#endif\n\t\tassert(x >= 0);\n\t\tassert(y >= 0);\n#ifdef FORCE_BIT\n\t\ta[x][y] += delta;\n#else\n\t\tfor (int i = x + 1; i <= n + 5; i += lowbit(i)) {\n\t\t\tfor (int j = y + 1; j <= m + 5; j += lowbit(j)) {\n\t\t\t\ta[i - 1][j - 1] += delta;\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\tint query(int x, int y) {\n\t\tint res = 0;\n#ifdef FORCE_BIT\n\t\tfor (int i = x; i >= 0; i--) {\n\t\t\tfor (int j = y; j >= 0; j--) {\n\t\t\t\tres += a[i][j];\n\t\t\t}\n\t\t}\n#else\n\t\tfor (int i = x + 1; i > 0; i -= lowbit(i)) {\n\t\t\tfor (int j = y + 1; j > 0; j -= lowbit(j)) {\n\t\t\t\tres += a[i - 1][j - 1];\n\t\t\t}\n\t\t}\n#endif\n\t\treturn res;\n\t}\n\n\tint query(int x1, int y1, int x2, int y2) {\n#ifdef FORCE_BIT\n\t\tint res = 0;\n\t\tfor (int i = x1; i <= x2; i++) {\n\t\t\tfor (int j = y1; j <= y2; j++) {\n\t\t\t\tres += a[i][j];\n\t\t\t}\n\t\t}\n#else\n\t\tint res = query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n#endif\n#ifdef DBG_BIT\n\t\tprintf(\"query(%d, %d, %d, %d, %d) = %d\\n\", this == ::_bit1 ? 1 : 2, x1, y1, x2, y2, res);\n#endif\n\t\treturn res;\n\t}\n} bit1, bit2;\n#endif\n\nstruct Cloud {\n\tint t, l, r, d;\n} cloud[MAXC + 1];\n\nint len;\n#ifdef FORCE\nint a[MAXLEN * 4 + 5][MAXLEN * 2 + 5];\n#endif\n\ninline void transform(int &x, int &y, int i) {\n#ifdef DBG\n\tprintf(\"transform(%d, %d, %d) = \", x, y, i);\n#endif\n\tif (i == 1) {\n\t\ty += x;\n\t} else {\n\t\ty += 4 * len - x;\n\t}\n#ifdef DBG\n\tprintf(\"(%d, %d)\\n\", x, y);\n#endif\n}\n\ninline void add(int x, int y) {\n\t// printf(\"add(%d, %d)\\n\", x, y);\n#ifdef FORCE\n\ta[x][y]++;\n\t// a[x + len * 2][y]++;\n#else\n#ifdef DBG\n\tprintf(\"add(%d, %d)\\n\", x, y);\n#endif\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, 1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, 1);\n\t/*\n\tbit1.update(x, y + x, 1);\n\tbit2.update(x, y + (len * 2 - x), 1);\n\n\tbit1.update(x + len * 2, y + x, 1);\n\tbit2.update(x + len * 2, y + (len * 2 - x), 1);\n\t*/\n#endif\n}\n\ninline void add(int t, int c, int l, int r, int d) {\n\tint y = r - l;\n\tif (d == 1) {\n\t\tt -= l;\n\t} else {\n\t\tt += l;\n\t}\n\tt = (t % (len * 2) + (len * 2)) % (len * 2);\n\n\tcloud[c].t = t, cloud[c].l = l, cloud[c].r = r, cloud[c].d = d;\n\n\tadd(t, y);\n}\n\ninline void del(int x, int y) {\n#ifdef FORCE\n\ta[x][y]--;\n\t// a[x + len * 2][y]--;\n#else\n\tint newX, newY;\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 1);\n\tbit1.update(newX, newY, -1);\n\n\tnewX = x, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n\n\tnewX = x + len * 2, newY = y;\n\ttransform(newX, newY, 2);\n\tbit2.update(newX, newY, -1);\n#endif\n}\n\ninline void del(int c) {\n\tdel(cloud[c].t, cloud[c].r - cloud[c].l);\n}\n\ninline int query(int t, int l, int r) {\n\tt %= (len * 2);\n#ifdef FORCE\n\t// printf(\"query(%d, %d, %d)\\n\", t, l, r);\n\tstatic bool added[MAXLEN * 2 + 5][MAXLEN + 5];\n\tmemset(added, 0, sizeof(added));\n\tint ans = 0;\n\tfor (int i = 0, start = l; i <= r; i++, start--) {\n\t\tfor (int j = start; j <= start + (len + r - l); j++) {\n\t\t\tif (j >= 0) {\n\t\t\t\t// printf(\"[%d, %d]\\n\", (i + t) % (len * 2), j);\n\t\t\t\tint tmp = (i + t) % (len * 2);\n\t\t\t\tif (a[tmp][j] && !added[tmp][j]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tadded[tmp][j] = true;\n\t\t\t\t\t// printf(\"query(%d, %d, %d) [%d, %d]\\n\", t, l, r, (i + t) % (len * 2), j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = len * 2, start = l; i >= len * 2 - r; i--, start--) {\n\t\tfor (int j = start; j <= start + (len + r - l); j++) {\n\t\t\tif (j >= 0) {\n\t\t\t\t// printf(\"[%d, %d]\\n\", (i + t) % (len * 2), j);\n\t\t\t\tint tmp = (i + t) % (len * 2);\n\t\t\t\tif (a[tmp][j] && !added[tmp][j]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tadded[tmp][j] = true;\n\t\t\t\t\t// printf(\"query(%d, %d, %d) [%d, %d]\\n\", t, l, r, (i + t) % (len * 2), j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n#else\n#ifdef DBG\n\tprintf(\"query([%d, %d], [%d, %d], [%d, %d], [%d, %d])\\n\", 0 + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len + r, //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  0 + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l,       //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len,     //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l - r);  //\n\tprintf(\"query([%d, %d], [%d, %d], [%d, %d], [%d, %d])\\n\", 2 * len - r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len,     //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  2 * len - r + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l - r,   //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  2 * len + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  l,       //\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  2 * len + t,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  len + r);//\n#endif\n\n\tint ans = 0;\n\n\tint x1, x2, y1, y2;\n\tx1 = t, y1 = l, x2 = t + r, y2 = len;\n\ttransform(x1, y1, 1), transform(x2, y2, 1);\n\tans += bit1.query(x1, y1, x2, y2);\n\n\tif (r != 0) {\n\t\tx1 = 2 * len - r + t, y1 = l - r, x2 = 2 * len + t - 1, y2 = len + r;\n\t\ttransform(x1, y1, 2), transform(x2, y2, 2);\n\t\tif (r == len) x1++;\n\t\tans += bit2.query(x1, y1, x2, y2);\n\t}\n\treturn ans;\n#endif\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d %d\", &n, &len);\n#ifndef FORCE_BIT\n\tbit1.init(len * 4 + 1, len * 4 + 1);\n\tbit2.init(len * 4 + 1, len * 4 + 1);\n\t_bit1 = &bit1, _bit2 = &bit2;\n#endif\n\twhile (n--) {\n\t\tint cmd;\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint t, c, l, r, d;\n\t\t\tscanf(\"%d %d %d %d %d\", &t, &c, &l, &r, &d);\n\t\t\tadd(t, c, l, r, d);\n\t\t} else if (cmd == 2) {\n\t\t\tint t, l, r;\n\t\t\tscanf(\"%d %d %d\", &t, &l, &r);\n\t\t\tprintf(\"%d\\n\", query(t, l, r));\n\t\t} else {\n\t\t\tint t, c;\n\t\t\tscanf(\"%d %d\", &t, &c);\n\t\t\tdel(c);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"noi2008-candy","published":1,"updated":"2016-12-23T10:00:56.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cck00rdc2xlc04v9w81"},{"title":"NOI2006 - ","date":"2016-03-10T11:33:42.000Z","_content":"\n $ N $  $ i $  $ Pi $$ 1  i  N $ $ M $  $ i $  $ Ai $, $ Bi $  $ Ci $ $ Ai $  $ Bi $  $ Ci $$ 1  i  M $$ 1  Ai $$ Bi  N $\n\n<!-- more -->\n\n### \n[CodeVS 1789](http://codevs.cn/problem/1789/)  \n[BZOJ 1497](http://www.lydsy.com/JudgeOnline/problem.php?id=1497)\n\n### \n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 5000;\nconst int MAXM = 50000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->flow < e->capacity) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->flow < e->capacity) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, a[MAXN];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint sum = 0;\n\tfor (int i = n + 1; i <= n + m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\n\t\tsum += c;\n\t\taddEdge(s, i, c);\n\n\t\taddEdge(i, a, INT_MAX);\n\t\taddEdge(i, b, INT_MAX);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2006-profit.md","raw":"title: NOI2006 - \ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - CodeVS\n  - \n  - \n  - \n  - \n  - Dinic\npermalink: noi2006-profit\ndate: 2016-03-10 19:33:42\n---\n\n $ N $  $ i $  $ Pi $$ 1  i  N $ $ M $  $ i $  $ Ai $, $ Bi $  $ Ci $ $ Ai $  $ Bi $  $ Ci $$ 1  i  M $$ 1  Ai $$ Bi  N $\n\n<!-- more -->\n\n### \n[CodeVS 1789](http://codevs.cn/problem/1789/)  \n[BZOJ 1497](http://www.lydsy.com/JudgeOnline/problem.php?id=1497)\n\n### \n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 5000;\nconst int MAXM = 50000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->flow < e->capacity) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->flow < e->capacity) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint n, m, a[MAXN];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\t\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint sum = 0;\n\tfor (int i = n + 1; i <= n + m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\n\t\tsum += c;\n\t\taddEdge(s, i, c);\n\n\t\taddEdge(i, a, INT_MAX);\n\t\taddEdge(i, b, INT_MAX);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"noi2006-profit","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cdh00rmc2xl7v3m0v3k"},{"title":"NOI2004 - Splay","id":"37","updated":"2016-01-24T15:11:06.000Z","date":"2016-01-24T15:09:03.000Z","_content":"\n `k` \n\n<!-- more -->\n\n### \n[BZOJ 1503](http://www.lydsy.com/JudgeOnline/problem.php?id=1503)  \n[CodeVS 1286](http://codevs.cn/problem/1286/)\n\n### \n Splay \n\n $[-{\\infty}+1,min-1]$ \n\n\n\n Splay\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 200100;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, lazy;\n\t\tint size, count;\n\n\t\tNode(Node *parent, Node **root, const T &value) : parent(parent), root(root), value(value), size(1), count(1), lazy(0) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->update(lazy);\n\t\t\t\tif (child[R]) child[R]->update(lazy);\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\t\t\tsize = count;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\t\t}\n\n\t\tvoid update(const T &value) {\n\t\t\tif (this->value != INF && this->value != -INF) this->value += value;\n\t\t\tthis->lazy += value;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tpushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tparent->pushDown(), pushDown();\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tv->pushDown();\n\t\t\tif (value < v->value) v = v->child[L];\n\t\t\telse v = v->child[R];\n\t\t}\n\n\t\tif (v) v->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->size++;\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->pushDown();\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) target = &parent->child[L];\n\t\t\telse target = &parent->child[R];\n\t\t}\n\n\t\t*target = new Node(parent, &root, value);\n\t\t(*target)->splay();\n\t\treturn root;\n\t}\n\n\tconst T &select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (v->pushDown(), !(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + v->count, v = v->child[R];\n\t\t}\n\t\tv->splay();\n\t\treturn v->value;\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count > 1) v->count--;\n\t\telse erase(v, v);\n\t}\n\n\tvoid erase(Node *l, Node *r) {\n\t\tNode *pred = l->pred();\n\t\tNode *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\tNode *vl = find(l), *vr = find(r);\n\t\tif (!vl) vl = insert(l);\n\t\tif (!vr) vr = insert(r);\n\t\terase(vl, vr);\n\t}\n\n\tvoid update(const T &value) {\n\t\troot->update(value);\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint result = v->rank();\n\t\t\terase(v);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint n, min, deletedCount;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth = 0) {\n\tif (!v) return;\n\tv->pushDown();\n\tdfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d\\n\", v->value);\n\tdfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\ninline void print() {\n\tdfs(splay.root);\n\tputs(\"----------------------\");\n}\n\ninline bool isValid(char c) {\n\treturn c == 'I' || c == 'A' || c == 'S' || c == 'F';\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &min);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tchar c;\n\t\tint k;\n\t\twhile (!isValid(c = getchar()));\n\t\tscanf(\"%d\", &k);\n\t\t//printf(\"{ command: '%c', k: '%d' }\\n\", c, k);\n\t\tif (c == 'I') {\n\t\t\tif (k >= min) splay.insert(k);\n\t\t} else if (c == 'A') {\n\t\t\tsplay.update(k);\n\t\t} else if (c == 'S') {\n\t\t\tsplay.update(-k);\n\t\t\tint oldSize = splay.size();\n\t\t\tsplay.erase(-INT_MAX + 1, min - 1);\n\t\t\tdeletedCount += oldSize - Splay.size();\n\t\t} else if (c == 'F') {\n\t\t\tif (k < 1 || k > splay.size()) puts(\"-1\");\n\t\t\telse printf(\"%d\\n\", splay.select(splay.size() - k + 1));\n\t\t}\n\n\t\t//print();\n\t}\n\n\tprintf(\"%d\\n\", deletedCount);\n\n\treturn 0;\n}\n```","source":"_posts/noi2004-cashier.md","raw":"title: NOI2004 - Splay\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - CodeVS\n  - Splay\n  - \n  - \npermalink: noi2004-cashier\nid: 37\nupdated: '2016-01-24 23:11:06'\ndate: 2016-01-24 23:09:03\n---\n\n `k` \n\n<!-- more -->\n\n### \n[BZOJ 1503](http://www.lydsy.com/JudgeOnline/problem.php?id=1503)  \n[CodeVS 1286](http://codevs.cn/problem/1286/)\n\n### \n Splay \n\n $[-{\\infty}+1,min-1]$ \n\n\n\n Splay\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 200100;\n\ntemplate <typename T, T INF>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, lazy;\n\t\tint size, count;\n\n\t\tNode(Node *parent, Node **root, const T &value) : parent(parent), root(root), value(value), size(1), count(1), lazy(0) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->update(lazy);\n\t\t\t\tif (child[R]) child[R]->update(lazy);\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\t\t\tsize = count;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\t\t}\n\n\t\tvoid update(const T &value) {\n\t\t\tif (this->value != INF && this->value != -INF) this->value += value;\n\t\t\tthis->lazy += value;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tpushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tparent->pushDown(), pushDown();\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tinsert(INF), insert(-INF);\n\t}\n\n\t~Splay() {\n\t\tdelete root;\n\t}\n\n\tNode *find(const T &value) {\n\t\tNode *v = root;\n\t\twhile (v && value != v->value) {\n\t\t\tv->pushDown();\n\t\t\tif (value < v->value) v = v->child[L];\n\t\t\telse v = v->child[R];\n\t\t}\n\n\t\tif (v) v->splay();\n\t\treturn v;\n\t}\n\n\tNode *insert(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) {\n\t\t\tv->count++, v->size++;\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &root, *parent = NULL;\n\t\twhile (*target) {\n\t\t\tparent = *target;\n\t\t\tparent->pushDown();\n\t\t\tparent->size++;\n\t\t\tif (value < parent->value) target = &parent->child[L];\n\t\t\telse target = &parent->child[R];\n\t\t}\n\n\t\t*target = new Node(parent, &root, value);\n\t\t(*target)->splay();\n\t\treturn root;\n\t}\n\n\tconst T &select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (v->pushDown(), !(v->rank() + 1 <= k && v->rank() + v->count >= k)) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + v->count, v = v->child[R];\n\t\t}\n\t\tv->splay();\n\t\treturn v->value;\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->count > 1) v->count--;\n\t\telse erase(v, v);\n\t}\n\n\tvoid erase(Node *l, Node *r) {\n\t\tNode *pred = l->pred();\n\t\tNode *succ = r->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(pred);\n\n\t\tdelete succ->child[L];\n\t\tsucc->child[L] = NULL;\n\t\tsucc->maintain(), pred->maintain();\n\t}\n\n\tvoid erase(const T &l, const T &r) {\n\t\tNode *vl = find(l), *vr = find(r);\n\t\tif (!vl) vl = insert(l);\n\t\tif (!vr) vr = insert(r);\n\t\terase(vl, vr);\n\t}\n\n\tvoid update(const T &value) {\n\t\troot->update(value);\n\t}\n\n\tint rank(const T &value) {\n\t\tNode *v = find(value);\n\t\tif (v) return v->rank();\n\t\telse {\n\t\t\tv = insert(value);\n\t\t\tint result = v->rank();\n\t\t\terase(v);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint n, min, deletedCount;\nSplay<int, INT_MAX> splay;\n\nvoid dfs(Splay<int, INT_MAX>::Node *v, int depth = 0) {\n\tif (!v) return;\n\tv->pushDown();\n\tdfs(v->child[Splay<int, INT_MAX>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d\\n\", v->value);\n\tdfs(v->child[Splay<int, INT_MAX>::R], depth + 1);\n}\n\ninline void print() {\n\tdfs(splay.root);\n\tputs(\"----------------------\");\n}\n\ninline bool isValid(char c) {\n\treturn c == 'I' || c == 'A' || c == 'S' || c == 'F';\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &min);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tchar c;\n\t\tint k;\n\t\twhile (!isValid(c = getchar()));\n\t\tscanf(\"%d\", &k);\n\t\t//printf(\"{ command: '%c', k: '%d' }\\n\", c, k);\n\t\tif (c == 'I') {\n\t\t\tif (k >= min) splay.insert(k);\n\t\t} else if (c == 'A') {\n\t\t\tsplay.update(k);\n\t\t} else if (c == 'S') {\n\t\t\tsplay.update(-k);\n\t\t\tint oldSize = splay.size();\n\t\t\tsplay.erase(-INT_MAX + 1, min - 1);\n\t\t\tdeletedCount += oldSize - Splay.size();\n\t\t} else if (c == 'F') {\n\t\t\tif (k < 1 || k > splay.size()) puts(\"-1\");\n\t\t\telse printf(\"%d\\n\", splay.select(splay.size() - k + 1));\n\t\t}\n\n\t\t//print();\n\t}\n\n\tprintf(\"%d\\n\", deletedCount);\n\n\treturn 0;\n}\n```","slug":"noi2004-cashier","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cdq00rxc2xlay02lzkk"},{"title":"NOI2003 - Splay","date":"2016-03-06T11:49:35.000Z","_content":"\n|                |  |  |\n|:----------------------:|:----------------:| ---- |\n| $ {\\rm MOVE}(k) $      | `Move k`         |  $ k $  $ k=0 $ |\n| $ {\\rm INSERT}(n, s) $ | `Insert n S`     |  $ n $  $ s $$ n  1 $ |\n| $ {\\rm DELETE}(n) $    | `Delete n`       |  $ n $ $ n  1 $ |\n| $ {\\rm GET}(n) $       | `Get n`          |  $ n $ $ n  1 $ |\n| $ {\\rm PREV}() $       | `Prev`           | \n| $ {\\rm NEXT}() $       | `Next`           | \n\n<!-- more -->\n\n### \n[BZOJ 1507](http://www.lydsy.com/JudgeOnline/problem.php?id=1507)\n\n### \n Splay w\n\n `build`  $ \\log $\n\n### \n```cpp\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nconst int MAXM = 50000 + 4000 + 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), size(1), bound(bound) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\t//if (child[L]) child[L]->maintain();\n\t\t\t//if (child[R]) child[R]->maintain();\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent){\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\n\t\t*v = new Node(parent, 0, &root, true);\n\t}\n\n\tNode *build(const T *a, int l, int r, Node *parent = NULL) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tv->child[L] = build(a, l, mid - 1, v);\n\t\tv->child[R] = build(a, mid + 1, r, v);\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\t//printf(\"select(%d) in size = %d\\n\", k, root->size);\n\t\tNode *v = root;\n\t\twhile (v->maintain(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *&select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid insert(const T *a, int n, int pos) {\n\t\tNode *&v = select(pos + 1, pos);\n\t\tv = build(a, 1, n, root->child[R]);\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid erase(int l, int r) {\n\t\tNode *&v = select(l, r);\n\t\tdelete v;\n\t\tv = NULL;\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid fetch(T *a, int l, int r) {\n\t\tint i = 0;\n\t\tdfs(select(l, r), a, i);\n\t}\n\n\tvoid dfs(Node *v, T *a, int &i) {\n\t\tif (!v) return;\n\t\tdfs(v->child[L], a, i);\n\t\ta[i++] = v->value;\n\t\tdfs(v->child[R], a, i);\n\t}\n};\n\nint t, pos;\nSplay<char> splay;\n\ninline bool isValid(char ch) {\n\treturn ch >= 32 && ch <= 126;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\tstatic std::vector<char> buffers;\n\tfor (int i = 0; i < t; i++) {\n\t\tchar command[sizeof(\"Insert\")];\n\t\tscanf(\"%s\", command);\n\n\t\tif (command[0] == 'M') {\n\t\t\tscanf(\"%d\", &pos);\n\t\t} else if (command[0] == 'I') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.reserve(n);\n\n\t\t\tchar ch;\n\t\t\tfor (int i = 0; i < n; ) {\n\t\t\t\tif (isValid(ch = getchar())) {\n\t\t\t\t\tbuffers.push_back(ch);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsplay.insert(buffers.data(), n, pos);\n\t\t} else if (command[0] == 'D') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\t\t\tsplay.erase(pos + 1, pos + n);\n\t\t} else if (command[0] == 'G') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.resize(n + 1);\n\n\t\t\tsplay.fetch(const_cast<char *>(buffers.data()), pos + 1, pos + n);\n\t\t\tbuffers[n] = '\\0';\n\n\t\t\tprintf(\"%s\\n\", buffers.data());\n\t\t} else if (command[0] == 'P') pos--;\n\t\telse if (command[0] == 'N') pos++;\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/noi2003-editor.md","raw":"title: NOI2003 - Splay\ncategories: OI\ntags: \n  - NOI\n  - BZOJ\n  - Splay\n  - \n  - \npermalink: noi2003-editor\ndate: 2016-03-06 19:49:35\n---\n\n|                |  |  |\n|:----------------------:|:----------------:| ---- |\n| $ {\\rm MOVE}(k) $      | `Move k`         |  $ k $  $ k=0 $ |\n| $ {\\rm INSERT}(n, s) $ | `Insert n S`     |  $ n $  $ s $$ n  1 $ |\n| $ {\\rm DELETE}(n) $    | `Delete n`       |  $ n $ $ n  1 $ |\n| $ {\\rm GET}(n) $       | `Get n`          |  $ n $ $ n  1 $ |\n| $ {\\rm PREV}() $       | `Prev`           | \n| $ {\\rm NEXT}() $       | `Next`           | \n\n<!-- more -->\n\n### \n[BZOJ 1507](http://www.lydsy.com/JudgeOnline/problem.php?id=1507)\n\n### \n Splay w\n\n `build`  $ \\log $\n\n### \n```cpp\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nconst int MAXM = 50000 + 4000 + 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), size(1), bound(bound) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\t//if (child[L]) child[L]->maintain();\n\t\t\t//if (child[R]) child[R]->maintain();\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent){\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\n\t\t*v = new Node(parent, 0, &root, true);\n\t}\n\n\tNode *build(const T *a, int l, int r, Node *parent = NULL) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tv->child[L] = build(a, l, mid - 1, v);\n\t\tv->child[R] = build(a, mid + 1, r, v);\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\t//printf(\"select(%d) in size = %d\\n\", k, root->size);\n\t\tNode *v = root;\n\t\twhile (v->maintain(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *&select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid insert(const T *a, int n, int pos) {\n\t\tNode *&v = select(pos + 1, pos);\n\t\tv = build(a, 1, n, root->child[R]);\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid erase(int l, int r) {\n\t\tNode *&v = select(l, r);\n\t\tdelete v;\n\t\tv = NULL;\n\t\troot->child[R]->maintain(), root->maintain();\n\t}\n\n\tvoid fetch(T *a, int l, int r) {\n\t\tint i = 0;\n\t\tdfs(select(l, r), a, i);\n\t}\n\n\tvoid dfs(Node *v, T *a, int &i) {\n\t\tif (!v) return;\n\t\tdfs(v->child[L], a, i);\n\t\ta[i++] = v->value;\n\t\tdfs(v->child[R], a, i);\n\t}\n};\n\nint t, pos;\nSplay<char> splay;\n\ninline bool isValid(char ch) {\n\treturn ch >= 32 && ch <= 126;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\tstatic std::vector<char> buffers;\n\tfor (int i = 0; i < t; i++) {\n\t\tchar command[sizeof(\"Insert\")];\n\t\tscanf(\"%s\", command);\n\n\t\tif (command[0] == 'M') {\n\t\t\tscanf(\"%d\", &pos);\n\t\t} else if (command[0] == 'I') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.reserve(n);\n\n\t\t\tchar ch;\n\t\t\tfor (int i = 0; i < n; ) {\n\t\t\t\tif (isValid(ch = getchar())) {\n\t\t\t\t\tbuffers.push_back(ch);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsplay.insert(buffers.data(), n, pos);\n\t\t} else if (command[0] == 'D') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\t\t\tsplay.erase(pos + 1, pos + n);\n\t\t} else if (command[0] == 'G') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tbuffers.clear();\n\t\t\tbuffers.resize(n + 1);\n\n\t\t\tsplay.fetch(const_cast<char *>(buffers.data()), pos + 1, pos + n);\n\t\t\tbuffers[n] = '\\0';\n\n\t\t\tprintf(\"%s\\n\", buffers.data());\n\t\t} else if (command[0] == 'P') pos--;\n\t\telse if (command[0] == 'N') pos++;\n\t}\n\n\treturn 0;\n}\n```\n","slug":"noi2003-editor","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cdx00s5c2xl39w35ogs"},{"title":"NOI2002 - ","id":"2","updated":"2016-01-19T13:08:24.000Z","date":"2015-11-22T17:14:53.000Z","_content":"\n 30000 \n\n1. `x`  `y`   \n2. `x`  `y`  `x`  `y` \n\n 500,000 \n\n<!-- more -->\n\n### \n[CodeVS 1540](http://codevs.cn/problem/1540/)\n\n### \n  \n****\n\n```cpp\nunsigned int find_head(unsigned int x) {\n\treturn head[x] == x ? x : find_head(head[x]);\n}\n\nunsigned int find_tail(unsigned int x) {\n\treturn tail[x] == x ? x : find_tail(tail[x]);\n}\n\nvoid merge(unsigned int x, unsigned int y) {\n\tunsigned int head_x = find_head(x);\n\tunsigned int tail_y = find_tail(y);\n\thead[head_x] = tail_y;\n\ttail[tail_y] = head_x;\n}\n```\n\n```cpp\nunsigned int sum(unsigned int x, unsigned int y) {\n\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n}\n```\n`pre(x)`  `head`  `find_head(x)`  `x`  `x` \n```cpp\nunsigned int pre(unsigned int x) {\n\tregister unsigned int result = 0;\n\t\n\twhile (head[x] != x) {\n\t\tresult++;\n\t\tx = head[x];\n\t}\n\treturn result;\n}\n```\n $O(nm)$  \n  Boom  \n\n `x`  `head[x]`  `prefix[x]`  \n `find(x)`  `pre(x)`  `prefix[x]`  `pre(head[x])`** `x` **  \n\n  \n 1.** `prefix[x]` **  \n 2.** `head[x] == x` **0  \n\n```cpp\nunsigned int find_head(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn x;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); //  prefix[] \n\t\t}\n\n\t\thead[x] = find_head(head[x]); // \n\t}\n\n\treturn head[x];\n}\n\nunsigned int pre(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn prefix[x] = 0;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); //  prefix[] \n\t\t}\n\t\thead[x] = find_head(head[x]); // \n\t}\n\n\treturn prefix[x];\n}\n```\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 30000;\nconst unsigned int MAXM = 500000;\n\nunsigned int m;\n\nstruct unionfind {\n\tunsigned int head[MAXN], tail[MAXN], prefix[MAXN];\n\n\tvoid init(unsigned int n) {\n\t\tfor (unsigned int i = 0; i < n; i++) {\n\t\t\thead[i] = i;\n\t\t\ttail[i] = i;\n\t\t}\n\t}\n\n\tunsigned int find_head(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn x;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\n\t\treturn head[x];\n\t}\n\n\tunsigned int find_tail(unsigned int x) {\n\t\treturn tail[x] == x ? x : tail[x] = find_tail(tail[x]);\n\t}\n\n\tunsigned int pre(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn prefix[x] = 0;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\t\t\n\t\treturn prefix[x];\n\t}\n\n\tunsigned int sum(unsigned int x, unsigned int y) {\n\t\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n\t}\n\n\tvoid merge(unsigned int x, unsigned int y) {\n\t\tunsigned int head_x = find_head(x);\n\t\tunsigned int tail_y = find_tail(y);\n\t\thead[head_x] = tail_y;\n\t\ttail[tail_y] = head_x;\n\t\tprefix[head_x] = 1;\n\t}\n} uf;\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\ninline bool iscommand(char ch) {\n\treturn ch == 'C' || ch == 'M';\n}\n\nint main() {\n\tread(m);\n\n\tuf.init(MAXN);\n\tfor (unsigned int i = 0; i < m; i++) {\n\t\tregister char command;\n\t\tregister unsigned int x, y;\n\n\t\twhile (!iscommand(command = getchar()));\n\t\tread(x), read(y);\n\t\tx--, y--;\n\n\t\tif (command == 'M') {\n\t\t\tuf.merge(x, y);\n\t\t} else {\n\t\t\tif (uf.find_head(x) == uf.find_head(y)) {\n\t\t\t\tprintf(\"%u\\n\", uf.sum(x, y));\n\t\t\t} else {\n\t\t\t\tputs(\"-1\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n### \n NOI2002   \n    \n A ","source":"_posts/noi2002-galaxy.md","raw":"title: NOI2002 - \ncategories: OI\ntags: \n  - CodeVS\n  - NOI\n  - \npermalink: noi2002-galaxy\nid: 2\nupdated: '2016-01-19 21:08:24'\ndate: 2015-11-23 01:14:53\n---\n\n 30000 \n\n1. `x`  `y`   \n2. `x`  `y`  `x`  `y` \n\n 500,000 \n\n<!-- more -->\n\n### \n[CodeVS 1540](http://codevs.cn/problem/1540/)\n\n### \n  \n****\n\n```cpp\nunsigned int find_head(unsigned int x) {\n\treturn head[x] == x ? x : find_head(head[x]);\n}\n\nunsigned int find_tail(unsigned int x) {\n\treturn tail[x] == x ? x : find_tail(tail[x]);\n}\n\nvoid merge(unsigned int x, unsigned int y) {\n\tunsigned int head_x = find_head(x);\n\tunsigned int tail_y = find_tail(y);\n\thead[head_x] = tail_y;\n\ttail[tail_y] = head_x;\n}\n```\n\n```cpp\nunsigned int sum(unsigned int x, unsigned int y) {\n\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n}\n```\n`pre(x)`  `head`  `find_head(x)`  `x`  `x` \n```cpp\nunsigned int pre(unsigned int x) {\n\tregister unsigned int result = 0;\n\t\n\twhile (head[x] != x) {\n\t\tresult++;\n\t\tx = head[x];\n\t}\n\treturn result;\n}\n```\n $O(nm)$  \n  Boom  \n\n `x`  `head[x]`  `prefix[x]`  \n `find(x)`  `pre(x)`  `prefix[x]`  `pre(head[x])`** `x` **  \n\n  \n 1.** `prefix[x]` **  \n 2.** `head[x] == x` **0  \n\n```cpp\nunsigned int find_head(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn x;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); //  prefix[] \n\t\t}\n\n\t\thead[x] = find_head(head[x]); // \n\t}\n\n\treturn head[x];\n}\n\nunsigned int pre(unsigned int x) {\n\tif (head[x] == x) {\n\t\treturn prefix[x] = 0;\n\t} else {\n\t\tif (head[head[x]] != head[x]) {\n\t\t\tprefix[x] += pre(head[x]); //  prefix[] \n\t\t}\n\t\thead[x] = find_head(head[x]); // \n\t}\n\n\treturn prefix[x];\n}\n```\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 30000;\nconst unsigned int MAXM = 500000;\n\nunsigned int m;\n\nstruct unionfind {\n\tunsigned int head[MAXN], tail[MAXN], prefix[MAXN];\n\n\tvoid init(unsigned int n) {\n\t\tfor (unsigned int i = 0; i < n; i++) {\n\t\t\thead[i] = i;\n\t\t\ttail[i] = i;\n\t\t}\n\t}\n\n\tunsigned int find_head(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn x;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\n\t\treturn head[x];\n\t}\n\n\tunsigned int find_tail(unsigned int x) {\n\t\treturn tail[x] == x ? x : tail[x] = find_tail(tail[x]);\n\t}\n\n\tunsigned int pre(unsigned int x) {\n\t\tif (head[x] == x) {\n\t\t\treturn prefix[x] = 0;\n\t\t} else {\n\t\t\tif (head[head[x]] != head[x]) {\n\t\t\t\tprefix[x] += pre(head[x]);\n\t\t\t}\n\t\t\thead[x] = find_head(head[x]);\n\t\t}\n\t\t\n\t\treturn prefix[x];\n\t}\n\n\tunsigned int sum(unsigned int x, unsigned int y) {\n\t\treturn std::max(pre(x), pre(y)) - std::min(pre(x), pre(y)) - 1;\n\t}\n\n\tvoid merge(unsigned int x, unsigned int y) {\n\t\tunsigned int head_x = find_head(x);\n\t\tunsigned int tail_y = find_tail(y);\n\t\thead[head_x] = tail_y;\n\t\ttail[tail_y] = head_x;\n\t\tprefix[head_x] = 1;\n\t}\n} uf;\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\ninline bool iscommand(char ch) {\n\treturn ch == 'C' || ch == 'M';\n}\n\nint main() {\n\tread(m);\n\n\tuf.init(MAXN);\n\tfor (unsigned int i = 0; i < m; i++) {\n\t\tregister char command;\n\t\tregister unsigned int x, y;\n\n\t\twhile (!iscommand(command = getchar()));\n\t\tread(x), read(y);\n\t\tx--, y--;\n\n\t\tif (command == 'M') {\n\t\t\tuf.merge(x, y);\n\t\t} else {\n\t\t\tif (uf.find_head(x) == uf.find_head(y)) {\n\t\t\t\tprintf(\"%u\\n\", uf.sum(x, y));\n\t\t\t} else {\n\t\t\t\tputs(\"-1\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n### \n NOI2002   \n    \n A ","slug":"noi2002-galaxy","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6ce300scc2xla2jph1yg"},{"title":"","date":"2016-06-17T08:36:00.000Z","_content":"\n\n\n<!-- more -->\n\n****\n\n![](node-devide-notes/tree1.svg)\n\n $ 1 $  $ 1 $ \n\n $ n $ $ n $  $ 1 $ \n\n $ O(n) $  $ O(n ^ 2) $\n\n $ 5 $    $ 5 $  $ 1 $ \n\n### \n********\n\n> \n\n  \n $ n \\over 2 $ $ n + 2 $ \n\n DFS    DFS $ {\\rm size}(i) = \\sum\\limits_{j \\in {\\rm child}(i)} {\\rm size}(j) + 1 $ $ {\\rm max}(i) = \\max\\limits_{j \\in {\\rm child}(i)} \\{ {\\rm size}(j) \\} $ $ \\max \\{ \\max(i),\\ n - \\max(i) \\} $  $ i $ \n\n\n\n$$ T(n) = 2 T(\\frac{n}{2}) + O(n) = O(n \\log n) $$\n\n\n\n![](node-devide-notes/tree2.svg)\n\n### \n `solved` $ n $ \n\n```c++\ninline Node *center(Node *start) {\n    std::stack<Node *> s;\n    s.push(start);\n    start->parent = NULL;\n    start->visited = false;\n\n    static Node *a[MAXN];\n    int cnt = 0;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            a[cnt++] = v;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n                e->t->parent = v;\n                e->t->visited = false;\n                s.push(e->t);\n            }\n        } else {\n            v->size = 1;\n            v->max = 0;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n                v->size += e->t->size;\n                v->max = std::max(v->max, e->t->size);\n            }\n            s.pop();\n        }\n    }\n\n\n    Node *res = NULL;\n    for (int i = 0; i < cnt; i++) {\n        a[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n        if (!res || res->max > a[i]->max) res = a[i];\n    }\n\n    return res;\n}\n\ninline int solve() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n\n    int ans = 0;\n    while (!s.empty()) {\n        Node *v = s.top();\n        s.pop();\n\n        Node *root = center(v);\n        root->solved = true;\n\n        ans += calc(root);\n\n        for (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n            s.push(e->t);\n        }\n    }\n\n    return ans;\n}\n```\n","source":"_posts/node-devide-notes.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \npermalink: node-devide-notes\ndate: 2016-06-17 16:36:00\n---\n\n\n\n<!-- more -->\n\n****\n\n![](node-devide-notes/tree1.svg)\n\n $ 1 $  $ 1 $ \n\n $ n $ $ n $  $ 1 $ \n\n $ O(n) $  $ O(n ^ 2) $\n\n $ 5 $    $ 5 $  $ 1 $ \n\n### \n********\n\n> \n\n  \n $ n \\over 2 $ $ n + 2 $ \n\n DFS    DFS $ {\\rm size}(i) = \\sum\\limits_{j \\in {\\rm child}(i)} {\\rm size}(j) + 1 $ $ {\\rm max}(i) = \\max\\limits_{j \\in {\\rm child}(i)} \\{ {\\rm size}(j) \\} $ $ \\max \\{ \\max(i),\\ n - \\max(i) \\} $  $ i $ \n\n\n\n$$ T(n) = 2 T(\\frac{n}{2}) + O(n) = O(n \\log n) $$\n\n\n\n![](node-devide-notes/tree2.svg)\n\n### \n `solved` $ n $ \n\n```c++\ninline Node *center(Node *start) {\n    std::stack<Node *> s;\n    s.push(start);\n    start->parent = NULL;\n    start->visited = false;\n\n    static Node *a[MAXN];\n    int cnt = 0;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            a[cnt++] = v;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n                e->t->parent = v;\n                e->t->visited = false;\n                s.push(e->t);\n            }\n        } else {\n            v->size = 1;\n            v->max = 0;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n                v->size += e->t->size;\n                v->max = std::max(v->max, e->t->size);\n            }\n            s.pop();\n        }\n    }\n\n\n    Node *res = NULL;\n    for (int i = 0; i < cnt; i++) {\n        a[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n        if (!res || res->max > a[i]->max) res = a[i];\n    }\n\n    return res;\n}\n\ninline int solve() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n\n    int ans = 0;\n    while (!s.empty()) {\n        Node *v = s.top();\n        s.pop();\n\n        Node *root = center(v);\n        root->solved = true;\n\n        ans += calc(root);\n\n        for (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n            s.push(e->t);\n        }\n    }\n\n    return ans;\n}\n```\n","slug":"node-devide-notes","published":1,"updated":"2016-06-17T08:37:21.034Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cea00shc2xlzm3j55me"},{"title":"","date":"2016-04-13T04:11:17.000Z","_content":"\n OI \n\n\n\n<!-- more -->\n\n### \n $ {\\rm mod} \\ p $  $ x $  $ x ^ {-1} $  \n\n\n$$ x \\times x ^ {-1} \\equiv 1 \\pmod p $$\n\n\n\n$$ \\frac{x}{y} \\equiv x \\times y ^ {-1} \\pmod p $$\n\n### \n$$ a ^ {p - 1} \\equiv 1 \\pmod p $$\n\n $ p $ \n\n\n\n$$ a \\times a ^ {p - 2} \\equiv 1 \\pmod p $$\n\n$ a ^ {p - 2} $  $ a $ \n\n $ a ^ {p - 2} $ $ O(\\log a) $\n\n#### \n```c++\ninline int pow(const int n, const int k) {\n\tlong long ans = 1;\n\tfor (long long num = n, t = k; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\ninline int inv(const int num) {\n\treturn pow(num, MOD - 2);\n}\n```\n\n### \nEXGCD $ O(\\log \\max(a, b)) $  $ x $$ y $ \n\n\n$$ ax + by = \\gcd(a, b) $$\n\n\n\n $ b $ $ \\gcd(a, b) = 1 $\n\n$$ ax \\equiv 1 \\pmod b $$\n\n $ O(\\log a) $\n\n#### \n```c++\nvoid exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int num) {\n\tint g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn ((x % MOD) + MOD) % MOD;\n}\n```\n\n### \n $ p = k \\times i + r $$ r < i $$ 1 < i < p $\n\n$$ k \\times i + r \\equiv 0 \\pmod p $$\n\n $ r ^ {-1} + i ^ {-1} $\n\n$$ k \\times r ^ {-1} + i ^ {-1} \\equiv 0 \\pmod p $$\n\n\n\n$$ i ^ {-1} \\equiv -k \\times r ^ {-1} \\pmod p $$\n\n\n\n$$ i ^ {-1} \\equiv - \\lfloor \\frac{p}{i} \\rfloor \\times (p \\bmod i) ^ {-1} \\pmod p $$\n\n $ 1 ^ {-1} \\equiv 1 \\pmod p $ $ O(n) $\n\n#### \n```c++\ninv[1] = 1;\nfor (int i = 2; i <= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;\n```\n","source":"_posts/mul-inverse.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - \npermalink: mul-inverse\ndate: 2016-04-13 12:11:17\n---\n\n OI \n\n\n\n<!-- more -->\n\n### \n $ {\\rm mod} \\ p $  $ x $  $ x ^ {-1} $  \n\n\n$$ x \\times x ^ {-1} \\equiv 1 \\pmod p $$\n\n\n\n$$ \\frac{x}{y} \\equiv x \\times y ^ {-1} \\pmod p $$\n\n### \n$$ a ^ {p - 1} \\equiv 1 \\pmod p $$\n\n $ p $ \n\n\n\n$$ a \\times a ^ {p - 2} \\equiv 1 \\pmod p $$\n\n$ a ^ {p - 2} $  $ a $ \n\n $ a ^ {p - 2} $ $ O(\\log a) $\n\n#### \n```c++\ninline int pow(const int n, const int k) {\n\tlong long ans = 1;\n\tfor (long long num = n, t = k; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\ninline int inv(const int num) {\n\treturn pow(num, MOD - 2);\n}\n```\n\n### \nEXGCD $ O(\\log \\max(a, b)) $  $ x $$ y $ \n\n\n$$ ax + by = \\gcd(a, b) $$\n\n\n\n $ b $ $ \\gcd(a, b) = 1 $\n\n$$ ax \\equiv 1 \\pmod b $$\n\n $ O(\\log a) $\n\n#### \n```c++\nvoid exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int num) {\n\tint g, x, y;\n\texgcd(num, MOD, g, x, y);\n\treturn ((x % MOD) + MOD) % MOD;\n}\n```\n\n### \n $ p = k \\times i + r $$ r < i $$ 1 < i < p $\n\n$$ k \\times i + r \\equiv 0 \\pmod p $$\n\n $ r ^ {-1} + i ^ {-1} $\n\n$$ k \\times r ^ {-1} + i ^ {-1} \\equiv 0 \\pmod p $$\n\n\n\n$$ i ^ {-1} \\equiv -k \\times r ^ {-1} \\pmod p $$\n\n\n\n$$ i ^ {-1} \\equiv - \\lfloor \\frac{p}{i} \\rfloor \\times (p \\bmod i) ^ {-1} \\pmod p $$\n\n $ 1 ^ {-1} \\equiv 1 \\pmod p $ $ O(n) $\n\n#### \n```c++\ninv[1] = 1;\nfor (int i = 2; i <= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;\n```\n","slug":"mul-inverse","published":1,"updated":"2016-05-11T09:33:24.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cem00soc2xls64g54ho"},{"title":"","date":"2016-01-14T21:44:45.000Z","_content":"\n DP \n\n<!-- more -->\n\n### \n\n\n `priority_queue`  $O(1)$  $O({\\log}n)$  `set` $\\log$  TLE \n\n $O(1)$ \n\n### \n `Q` `M` `M`  `Q` \n\n `Q`  `x`  `M`  `M`  ** `x` ** `x`  `x` ** `x` **\n\n `Q`  `M`  `M` **** `M`  `Q`  `M`  `M`  `Q` \n\n### \n $f[x]=\\max\\{g(k)\\}+w[x]$ \n\n### \n `deque`  `queue`\n```cpp\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n```\n","source":"_posts/monotone-queue-notes.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  -   \npermalink: monotone-queue-notes\ndate: 2016-01-15 05:44:45\n---\n\n DP \n\n<!-- more -->\n\n### \n\n\n `priority_queue`  $O(1)$  $O({\\log}n)$  `set` $\\log$  TLE \n\n $O(1)$ \n\n### \n `Q` `M` `M`  `Q` \n\n `Q`  `x`  `M`  `M`  ** `x` ** `x`  `x` ** `x` **\n\n `Q`  `M`  `M` **** `M`  `Q`  `M`  `M`  `Q` \n\n### \n $f[x]=\\max\\{g(k)\\}+w[x]$ \n\n### \n `deque`  `queue`\n```cpp\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n```\n","slug":"monotone-queue-notes","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cer00svc2xln823gqim"},{"title":"","date":"2016-05-01T00:14:50.000Z","_content":"\n $ [1,\\ n] $ $ [l,\\ r] $ \n\n<!-- more -->\n\n $ [l,\\ r] $  $ [l,\\ r + 1] $$ [l,\\ r - 1] $$ [l - 1,\\ r] $$ [l + 1,\\ r] $  $ O(1) $ $ O(n) $  $ O(n ^ 2) $\n\n $ \\sqrt n $  $ \\sqrt n $********\n\n $ O(\\sqrt n) $  $ O(\\sqrt n) $  $ O((\\sqrt n) ^ 2) = O(n) $ $ O(\\sqrt n) $ $ O((\\sqrt n) ^ 2) = O(n) $  $ O(n) $  $ O(\\sqrt n) $ $ O(n \\sqrt n) $\n\n\n","source":"_posts/mo-algorithm-notes.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \npermalink: mo-algorithm-notes\ndate: 2016-05-01 08:14:50\n---\n\n $ [1,\\ n] $ $ [l,\\ r] $ \n\n<!-- more -->\n\n $ [l,\\ r] $  $ [l,\\ r + 1] $$ [l,\\ r - 1] $$ [l - 1,\\ r] $$ [l + 1,\\ r] $  $ O(1) $ $ O(n) $  $ O(n ^ 2) $\n\n $ \\sqrt n $  $ \\sqrt n $********\n\n $ O(\\sqrt n) $  $ O(\\sqrt n) $  $ O((\\sqrt n) ^ 2) = O(n) $ $ O(\\sqrt n) $ $ O((\\sqrt n) ^ 2) = O(n) $  $ O(n) $  $ O(\\sqrt n) $ $ O(n \\sqrt n) $\n\n\n","slug":"mo-algorithm-notes","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cey00t2c2xl1uqvp0r4"},{"title":" && ","date":"2016-01-01T22:08:50.000Z","_content":"\n\n\n ~\n\n<!-- more -->\n\n### \n\n#### Kruskal \n****\n\n\n\n $O(m{\\log}m)$ `m` \n\n\n\n```cpp\nstruct UndirectedEdge {\n\tint u, v, w;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n#### Prim \nPrim  Kruskal ****\n\n Prim  Dijkstra \n\n\n\n $O(m{\\log}n)$ `n` `m`   \n $O(n^2)$ `n` \n\n\n\n```C++\nstruct Node {\n\tEdge *edges;\n\tbool visited;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\tbool used;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges), used(false) {}\n\n\tstruct Compare {\n\t\tbool operator()(Edge *a, Edge *b) const {\n\t\t\treturn a->w > b->w;\n\t\t}\n\t};\n};\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int prim() {\n\tstd::priority_queue<Edge *, vector<Edge *>, Edge::Compare> q;\n\tint sum = 0;\n\tNode *node = &nodes[0];\n\tnode->visited = true;\n\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\tq.push(edge);\n\t}\n\n\tint count = 0;\n\twhile (!q.empty()) {\n\t\tEdge *minEdge = q.top();\n\t\tq.pop();\n\t\tif (minEdge->to->visited) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsum += minEdge->w;\n\t\tminEdge->used = true;\n\t\tminEdge->to->visited = true;\n\t\tcount++;\n\n\t\tif (count == n - 1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (Edge *edge = minEdge->to->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\tq.push(edge);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n### \n********\n\n****\n\n#### \n\n\n**** `(u, v, w)` `u`  `v` ****\n\n\n\n#### POJ 1679\n[POJ 1679](http://poj.org/problem?id=1679)\n\n\n\n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXT = 20;\nconst int MAXN = 100;\nconst int MAXM = MAXN * (MAXN - 1) / 2;\nconst int MAXLOGN = 7;\n\nstruct UndirectedEdge {\n\tint u, v, w;\n\tbool used;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w), used(false) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tint id;\n\tint depth;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nstruct SparseTable {\n\tNode *target;\n\tint max;\n} f[MAXN][MAXLOGN + 1];\n\nint t, n, m, logn;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\t\t\tedges[i].used = true;\n\t\t\taddEdge(edges[i].u, edges[i].v, edges[i].w);\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\ninline int log(int x) {\n\tint i = 0;\n\twhile ((1 << i) <= x) {\n\t\ti++;\n\t}\n\n\treturn i;\n}\n\ninline void makeST() {\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].id = i;\n\t}\n\n\tf[0][0].target = &nodes[0];\n\tf[0][0].max = 0;\n\n\tnodes[0].depth = 1;\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->depth == 0) {\n\t\t\t\tedge->to->depth = node->depth + 1;\n\t\t\t\tq.push(edge->to);\n\t\t\t\tf[edge->to->id][0].target = node;\n\t\t\t\tf[edge->to->id][0].max = edge->w;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int j = 1; j <= logn; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i][j].target = f[f[i][j - 1].target->id][j - 1].target;\n\t\t\tf[i][j].max = std::max(f[i][j - 1].max, f[f[i][j - 1].target->id][j - 1].max);\n\t\t}\n\t}\n}\n\ninline int queryMax(int u, int v) {\n\tNode *a = &nodes[u], *b = &nodes[v];\n\n\tif (a->depth < b->depth) {\n\t\tstd::swap(a, b);\n\t}\n\n\tint max = 0;\n\n\tif (a->depth != b->depth) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target->depth >= b->depth) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (a != b) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target != f[b->id][i].target) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\tmax = std::max(max, f[b->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t\tb = f[b->id][i].target;\n\t\t\t}\n\t\t}\n\n\t\tmax = std::max(max, f[a->id][0].max);\n\t\tmax = std::max(max, f[b->id][0].max);\n\t}\n\n\treturn max;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\twhile (~scanf(\"%d %d\", &n, &m)) {\n\t\tlogn = log(n);\n\t\tmemset(edges, 0, sizeof(edges));\n\t\tmemset(nodes, 0, sizeof(nodes));\n\t\tmemset(f, 0, sizeof(f));\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u, v, w;\n\t\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\t\tu--, v--;\n\n\t\t\tedges[i] = UndirectedEdge(u, v, w);\n\t\t}\n\n\t\tint sum = kruskal();\n\t\tmakeST();\n\n\t\tint ans = int_MAX;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (!edges[i].used) {\n\t\t\t\tans = std::min(ans, sum - queryMax(edges[i].u, edges[i].v) + edges[i].w);\n\t\t\t}\n\t\t}\n\n\t\tif (sum == ans) {\n\t\t\tputs(\"Not Unique!\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", sum);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/minimum-spanning-tree-notes.md","raw":"title: ' && '\ncategories: OI\ntags: \n  - Kruskal\n  - POJ\n  - Prim\n  - \n  - \n  - \n  - \n  - \n  -   \npermalink: minimum-spanning-tree-notes\ndate: 2016-01-02 06:08:50\n---\n\n\n\n ~\n\n<!-- more -->\n\n### \n\n#### Kruskal \n****\n\n\n\n $O(m{\\log}m)$ `m` \n\n\n\n```cpp\nstruct UndirectedEdge {\n\tint u, v, w;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n#### Prim \nPrim  Kruskal ****\n\n Prim  Dijkstra \n\n\n\n $O(m{\\log}n)$ `n` `m`   \n $O(n^2)$ `n` \n\n\n\n```C++\nstruct Node {\n\tEdge *edges;\n\tbool visited;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint w;\n\tEdge *next;\n\tbool used;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges), used(false) {}\n\n\tstruct Compare {\n\t\tbool operator()(Edge *a, Edge *b) const {\n\t\t\treturn a->w > b->w;\n\t\t}\n\t};\n};\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int prim() {\n\tstd::priority_queue<Edge *, vector<Edge *>, Edge::Compare> q;\n\tint sum = 0;\n\tNode *node = &nodes[0];\n\tnode->visited = true;\n\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\tq.push(edge);\n\t}\n\n\tint count = 0;\n\twhile (!q.empty()) {\n\t\tEdge *minEdge = q.top();\n\t\tq.pop();\n\t\tif (minEdge->to->visited) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tsum += minEdge->w;\n\t\tminEdge->used = true;\n\t\tminEdge->to->visited = true;\n\t\tcount++;\n\n\t\tif (count == n - 1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (Edge *edge = minEdge->to->edges; edge; edge = edge->next) {\n\t\t\tif (!edge->to->visited) {\n\t\t\t\tq.push(edge);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n```\n\n### \n********\n\n****\n\n#### \n\n\n**** `(u, v, w)` `u`  `v` ****\n\n\n\n#### POJ 1679\n[POJ 1679](http://poj.org/problem?id=1679)\n\n\n\n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXT = 20;\nconst int MAXN = 100;\nconst int MAXM = MAXN * (MAXN - 1) / 2;\nconst int MAXLOGN = 7;\n\nstruct UndirectedEdge {\n\tint u, v, w;\n\tbool used;\n\n\tUndirectedEdge() {}\n\tUndirectedEdge(int u, int v, int w) : u(u), v(v), w(w), used(false) {}\n\n\tbool operator<(const UndirectedEdge &other) const {\n\t\treturn w < other.w;\n\t}\n} edges[MAXM];\n\nstruct UnionFindSet {\n\tint f[MAXN];\n\n\tUnionFindSet(int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i] = i;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\treturn f[x] == x ? x : f[x] = find(f[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tf[find(x)] = find(y);\n\t}\n};\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n\tEdge *edges;\n\tint id;\n\tint depth;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\tint w;\n\n\tEdge(Node *from, Node *to, int w) : from(from), to(to), w(w), next(from->edges) {}\n};\n\nstruct SparseTable {\n\tNode *target;\n\tint max;\n} f[MAXN][MAXLOGN + 1];\n\nint t, n, m, logn;\n\ninline void addEdge(int u, int v, int w) {\n\tnodes[u].edges = new Edge(&nodes[u], &nodes[v], w);\n\tnodes[v].edges = new Edge(&nodes[v], &nodes[u], w);\n}\n\ninline int kruskal() {\n\tint sum = 0, count = 0;\n\tUnionFindSet ufs(n);\n\tstd::sort(edges, edges + m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (ufs.find(edges[i].u) != ufs.find(edges[i].v)) {\n\t\t\tufs.merge(edges[i].u, edges[i].v);\n\t\t\tsum += edges[i].w;\n\t\t\tcount++;\n\t\t\tedges[i].used = true;\n\t\t\taddEdge(edges[i].u, edges[i].v, edges[i].w);\n\n\t\t\tif (count == n - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum;\n}\n\ninline int log(int x) {\n\tint i = 0;\n\twhile ((1 << i) <= x) {\n\t\ti++;\n\t}\n\n\treturn i;\n}\n\ninline void makeST() {\n\tfor (int i = 0; i < n; i++) {\n\t\tnodes[i].id = i;\n\t}\n\n\tf[0][0].target = &nodes[0];\n\tf[0][0].max = 0;\n\n\tnodes[0].depth = 1;\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\n\twhile (!q.empty()) {\n\t\tNode *node = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *edge = node->edges; edge; edge = edge->next) {\n\t\t\tif (edge->to->depth == 0) {\n\t\t\t\tedge->to->depth = node->depth + 1;\n\t\t\t\tq.push(edge->to);\n\t\t\t\tf[edge->to->id][0].target = node;\n\t\t\t\tf[edge->to->id][0].max = edge->w;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int j = 1; j <= logn; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf[i][j].target = f[f[i][j - 1].target->id][j - 1].target;\n\t\t\tf[i][j].max = std::max(f[i][j - 1].max, f[f[i][j - 1].target->id][j - 1].max);\n\t\t}\n\t}\n}\n\ninline int queryMax(int u, int v) {\n\tNode *a = &nodes[u], *b = &nodes[v];\n\n\tif (a->depth < b->depth) {\n\t\tstd::swap(a, b);\n\t}\n\n\tint max = 0;\n\n\tif (a->depth != b->depth) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target->depth >= b->depth) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (a != b) {\n\t\tfor (int i = logn; i >= 0; i--) {\n\t\t\tif (f[a->id][i].target != f[b->id][i].target) {\n\t\t\t\tmax = std::max(max, f[a->id][i].max);\n\t\t\t\tmax = std::max(max, f[b->id][i].max);\n\t\t\t\ta = f[a->id][i].target;\n\t\t\t\tb = f[b->id][i].target;\n\t\t\t}\n\t\t}\n\n\t\tmax = std::max(max, f[a->id][0].max);\n\t\tmax = std::max(max, f[b->id][0].max);\n\t}\n\n\treturn max;\n}\n\nint main() {\n\tscanf(\"%d\", &t);\n\n\twhile (~scanf(\"%d %d\", &n, &m)) {\n\t\tlogn = log(n);\n\t\tmemset(edges, 0, sizeof(edges));\n\t\tmemset(nodes, 0, sizeof(nodes));\n\t\tmemset(f, 0, sizeof(f));\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u, v, w;\n\t\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\t\tu--, v--;\n\n\t\t\tedges[i] = UndirectedEdge(u, v, w);\n\t\t}\n\n\t\tint sum = kruskal();\n\t\tmakeST();\n\n\t\tint ans = int_MAX;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (!edges[i].used) {\n\t\t\t\tans = std::min(ans, sum - queryMax(edges[i].u, edges[i].v) + edges[i].w);\n\t\t\t}\n\t\t}\n\n\t\tif (sum == ans) {\n\t\t\tputs(\"Not Unique!\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", sum);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"minimum-spanning-tree-notes","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cf800t8c2xlmfscwldu"},{"title":" - LYOI'15","date":"2016-11-20T08:19:00.000Z","_content":"\n<div style=\"width: 100%; text-align: center; \">\n<div id=\"aplayer\" class=\"aplayer\" style=\"width: 100%; max-width: 550px; text-align: left; display: inline-block; background: #fff; \"></div>\n</div>\n<style>\n.post .post-content .aplayer {\n\tmargin-top: 20px;\n}\n</style>\n<script>\nvar ap = new APlayer({\n    element: document.getElementById('aplayer'),\n    narrow: false,\n    autoplay: false,\n    showlrc: 3,\n    mutex: true,\n    theme: '#615754',\n    music: {\n        title: '',\n        author: '',\n        url: 'https://dn-menci.qbox.me/music/pfzl.ogg',\n        pic: 'https://dn-menci.qbox.me/music/pfzl.jpg',\n        lrc: '/lyoi-pingfan/pfzl.lrc'\n    }\n});\n</script>\n\nNOIP2016  LYOI \n\n<!-- more -->\n\nNOIP  LYOI  LYOI'14   \n\n LYOI'15 \n\n  \n\n47  \n\n\n\n\n \n\nAK \n\n OI   \n\n\n\n g++  gdb\n VIMAtom  Npp\n elementary  OS X\n\n\n CS  Jokebird\n lyx  tst\n\n\nLYOI \n\n\n\n\n","source":"_posts/lyoi-pingfan.md","raw":"title:  - LYOI'15\ncategories: Diary\npermalink: lyoi-pingfan\ndate: 2016-11-20 16:19:00\n---\n\n<div style=\"width: 100%; text-align: center; \">\n<div id=\"aplayer\" class=\"aplayer\" style=\"width: 100%; max-width: 550px; text-align: left; display: inline-block; background: #fff; \"></div>\n</div>\n<style>\n.post .post-content .aplayer {\n\tmargin-top: 20px;\n}\n</style>\n<script>\nvar ap = new APlayer({\n    element: document.getElementById('aplayer'),\n    narrow: false,\n    autoplay: false,\n    showlrc: 3,\n    mutex: true,\n    theme: '#615754',\n    music: {\n        title: '',\n        author: '',\n        url: 'https://dn-menci.qbox.me/music/pfzl.ogg',\n        pic: 'https://dn-menci.qbox.me/music/pfzl.jpg',\n        lrc: '/lyoi-pingfan/pfzl.lrc'\n    }\n});\n</script>\n\nNOIP2016  LYOI \n\n<!-- more -->\n\nNOIP  LYOI  LYOI'14   \n\n LYOI'15 \n\n  \n\n47  \n\n\n\n\n \n\nAK \n\n OI   \n\n\n\n g++  gdb\n VIMAtom  Npp\n elementary  OS X\n\n\n CS  Jokebird\n lyx  tst\n\n\nLYOI \n\n\n\n\n","slug":"lyoi-pingfan","published":1,"updated":"2016-11-20T15:48:41.098Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cfn00tlc2xlx761f4p6"},{"title":"Link-Cut Tree ","date":"2016-01-19T12:50:40.000Z","_content":"\nLink-Cut Tree  Splay Link-Cut Tree  $O({\\log}n)$\n\n<!-- more -->\n\n### \n Link-Cut Tree ********\n\n Splay \n\n Splay Splay  `Path Parent` Splay **** Splay  `Path Parent`  Splay  `Path Parent` \n\n`value` `sum`  `max` `reversed`  Splay \n\n```cpp\nstruct Node {\n\tNode *child[2], *parent, *pathParent;\n\tT value, sum, max;\n\tbool reversed;\n}\n```\n### \nLink-Cut Tree \n\n1. `Access(u)` `u`\n2. `Evert(u)` `u` \n3. `Link(u, v)` `u`  `v`  `u`  `v` \n4. `Cut(u, v)` `u`  `v`  `v` \n5. `FindRoot(u)` `u` \n6. `MakeTree()`\n\n### `Access` \n#### `Expose` \n `Access`  `Expose` \n\n1.  `Splay`  Splay \n2. \n\n\n\n```cpp\nvoid expose() {\n\tsplay();\n\tpushDown();\n\tif (child[R]) {\n\t\tchild[R]->parent = NULL;\n\t\tchild[R]->pathParent = this;\n\t\tchild[R] = NULL;\n\t\tmaintain();\n\t}\n}\n```\n#### `Splice` \n `Splice` ********\n\n1.  `Splay`  Splay \n2.  `Path Parent` `Splice` \n3.  `Path Parent`  `Expose` \n4.  `Path Parent`  `Path Parent` \n\n```cpp\nbool splice() {\n\tsplay();\n\tif (!pathParent) return false;\n\n\tpathParent->expose();\n\tpathParent->child[R] = this;\n\tparent = pathParent;\n\tpathParent = NULL;\n\tparent->maintain();\n\n\treturn true;\n}\n```\n\n#### `Access` \n `Expose`  `Splice``Access` `Expose`  `Splice` \n\n```cpp\nvoid access() {\n\texpose();\n\twhile (splice());\n}\n```\n\n### `Evert` \n `Access`\n\n```cpp\nvoid evert() {\n\taccess();\n\tsplay();\n\treversed ^= 1;\n}\n```\n\n### `Link` \n `v`  `Path Parent`  `u` \n\n```cpp\nvoid link(int u, int v) {\n\tnodes[v - 1]->evert();\n\tnodes[v - 1]->pathParent = nodes[u - 1];\n}\n```\n\n### `Cut` \n`Cut` \n\n1.  `u`  `v`  `u` \n2.  `v`  `Access`  `v`  `u` \n3.  `v`  `Splay`  `v` ** Splay **\n4.  `v` \n\n```cpp\nvoid cut(int u, int v) {\n\tnodes[u - 1]->evert();\n\tnodes[v - 1]->access();\n\tnodes[v - 1]->splay();\n\tnodes[v - 1]->pushDown();\n\tnodes[v - 1]->child[L]->parent = NULL;\n\tnodes[v - 1]->child[L] = NULL;\n\tnodes[v - 1]->maintain();\n}\n```\n\n### `Query`  `Update` \n `QueryMax(u, v)`  `Node`  `max`  `Maintain()` \n\n `Access(u)` `Splay`  Splay  `u`  `max`  `u` \n\n `Evert` \n\n```cpp\nconst T &Node::queryMax() {\n\taccess();\n\tsplay();\n\treturn max;\n}\n\nconst T &queryMax(int u, int v) {\n\tnodes[u - 1]->evert();\n\treturn nodes[v - 1]->queryMax();\n}\n```\n\n `Splay`  Splay \n\n```cpp\nvoid update(int u, const T &value) {\n\tnodes[u - 1]->splay();\n\tnodes[u - 1]->value = value;\n\tnodes[u - 1]->maintain();\n}\n```\n\n### `MakeTree` \n\n\n```cpp\nvoid makeTree(int u, const T &value) {\n\tnodes[u - 1] = new Node(value);\n}\n```\n\n###  & \n1.  `Splay`  `Rotate` \n2. `Rotate`  `Path Parent`  `Path Parent`  `Path Parent`  Splay \n\n```cpp\nvoid pushDown() {\n\tif (reversed) {\n\t\tstd::swap(child[L], child[R]);\n\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\treversed = false;\n\t}\n}\n\nvoid maintain() {\n\tsum = value;\n\tif (child[L]) sum += child[L]->sum;\n\tif (child[R]) sum += child[R]->sum;\n\n\tmax = value;\n\tif (child[L]) max = std::max(max, child[L]->max);\n\tif (child[R]) max = std::max(max, child[R]->max);\n}\n\nvoid rotate() {\n\tif (parent->parent) parent->parent->pushDown();\n\tparent->pushDown(), pushDown();\n\tstd::swap(pathParent, parent->pathParent);\n\n\tRelation x = relation();\n\tNode *oldParent = parent;\n\n\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\tparent = oldParent->parent;\n\n\toldParent->child[x] = child[x ^ 1];\n\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\tchild[x ^ 1] = oldParent;\n\toldParent->parent = this;\n\n\toldParent->maintain(), maintain();\n}\n\nvoid splay() {\n\twhile (parent) {\n\t\tif (!parent->parent) rotate();\n\t\telse {\n\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\telse rotate(), rotate();\n\t\t}\n\t}\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 30000;\n\nvoid print(void *p);\n\ntemplate <typename T>\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tT value, sum, max;\n\t\tbool reversed;\n\n\t\tNode(const T &value) : reversed(false), value(value), sum(value), max(value), parent(NULL), pathParent(NULL) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (child[L]) sum += child[L]->sum;\n\t\t\tif (child[R]) sum += child[R]->sum;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent) {\n\t\t\t\tif (!parent->parent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tpushDown();\n\t\t\tif (child[R]) {\n\t\t\t\tchild[R]->parent = NULL;\n\t\t\t\tchild[R]->pathParent = this;\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tparent = pathParent;\n\t\t\tpathParent = NULL;\n\t\t\tparent->maintain();\n\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tconst T &querySum() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn sum;\n\t\t}\n\n\t\tconst T &queryMax() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn max;\n\t\t}\n\t};\n\n\tNode *nodes[MAXN];\n\n\tvoid makeTree(int u, const T &value) {\n\t\tnodes[u - 1] = new Node(value);\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1]->evert();\n\t\tnodes[v - 1]->pathParent = nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\tnodes[v - 1]->access();\n\t\tnodes[v - 1]->splay();\n\t\tnodes[v - 1]->pushDown();\n\t\tnodes[v - 1]->child[L]->parent = NULL;\n\t\tnodes[v - 1]->child[L] = NULL;\n\t\tnodes[v - 1]->maintain();\n\t}\n\n\tconst T &querySum(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->querySum();\n\t}\n\n\tconst T &queryMax(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->queryMax();\n\t}\n\n\tvoid update(int u, const T &value) {\n\t\tnodes[u - 1]->splay();\n\t\tnodes[u - 1]->value = value;\n\t\tnodes[u - 1]->maintain();\n\t}\n};\n\nstruct UndirectedEdge {\n\tint u, v;\n\n\tUndirectedEdge() {}\n\n\tUndirectedEdge(int u, int v) : u(u), v(v) {}\n} edges[MAXN - 1];\n\nint n, q;\nLinkCutTree<int> lct;\n\nvoid dfs(LinkCutTree<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[LinkCutTree<int>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d, max = %d, sum = %d\\n\", v->value, v->max, v->sum);\n\tdfs(v->child[LinkCutTree<int>::R], depth + 1);\n}\n\nvoid print(void *p) {\n\tdfs((LinkCutTree<int>::Node *)p, 0);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tedges[i] = UndirectedEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint value;\n\t\tscanf(\"%d\", &value);\n\t\tlct.makeTree(i, value);\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tlct.link(edges[i].u, edges[i].v);\n\t}\n\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; i++) {\n\t\tchar str[6 + 1];\n\t\tscanf(\"%s\", str);\n\t\tif (str[1] == 'H') {\n\t\t\tint u, t;\n\t\t\tscanf(\"%d %d\", &u, &t);\n\t\t\tlct.update(u, t);\n\t\t} else if (str[1] == 'M') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.queryMax(u, v));\n\t\t} else if (str[1] == 'S') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.querySum(u, v));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/link-cut-tree-notes.md","raw":"title: Link-Cut Tree \ncategories: OI\ntags: \n  - Link-Cut Tree\n  - \n  - Splay\n  - \n  - \n  -   \npermalink: link-cut-tree-notes\ndate: 2016-01-19 20:50:40\n---\n\nLink-Cut Tree  Splay Link-Cut Tree  $O({\\log}n)$\n\n<!-- more -->\n\n### \n Link-Cut Tree ********\n\n Splay \n\n Splay Splay  `Path Parent` Splay **** Splay  `Path Parent`  Splay  `Path Parent` \n\n`value` `sum`  `max` `reversed`  Splay \n\n```cpp\nstruct Node {\n\tNode *child[2], *parent, *pathParent;\n\tT value, sum, max;\n\tbool reversed;\n}\n```\n### \nLink-Cut Tree \n\n1. `Access(u)` `u`\n2. `Evert(u)` `u` \n3. `Link(u, v)` `u`  `v`  `u`  `v` \n4. `Cut(u, v)` `u`  `v`  `v` \n5. `FindRoot(u)` `u` \n6. `MakeTree()`\n\n### `Access` \n#### `Expose` \n `Access`  `Expose` \n\n1.  `Splay`  Splay \n2. \n\n\n\n```cpp\nvoid expose() {\n\tsplay();\n\tpushDown();\n\tif (child[R]) {\n\t\tchild[R]->parent = NULL;\n\t\tchild[R]->pathParent = this;\n\t\tchild[R] = NULL;\n\t\tmaintain();\n\t}\n}\n```\n#### `Splice` \n `Splice` ********\n\n1.  `Splay`  Splay \n2.  `Path Parent` `Splice` \n3.  `Path Parent`  `Expose` \n4.  `Path Parent`  `Path Parent` \n\n```cpp\nbool splice() {\n\tsplay();\n\tif (!pathParent) return false;\n\n\tpathParent->expose();\n\tpathParent->child[R] = this;\n\tparent = pathParent;\n\tpathParent = NULL;\n\tparent->maintain();\n\n\treturn true;\n}\n```\n\n#### `Access` \n `Expose`  `Splice``Access` `Expose`  `Splice` \n\n```cpp\nvoid access() {\n\texpose();\n\twhile (splice());\n}\n```\n\n### `Evert` \n `Access`\n\n```cpp\nvoid evert() {\n\taccess();\n\tsplay();\n\treversed ^= 1;\n}\n```\n\n### `Link` \n `v`  `Path Parent`  `u` \n\n```cpp\nvoid link(int u, int v) {\n\tnodes[v - 1]->evert();\n\tnodes[v - 1]->pathParent = nodes[u - 1];\n}\n```\n\n### `Cut` \n`Cut` \n\n1.  `u`  `v`  `u` \n2.  `v`  `Access`  `v`  `u` \n3.  `v`  `Splay`  `v` ** Splay **\n4.  `v` \n\n```cpp\nvoid cut(int u, int v) {\n\tnodes[u - 1]->evert();\n\tnodes[v - 1]->access();\n\tnodes[v - 1]->splay();\n\tnodes[v - 1]->pushDown();\n\tnodes[v - 1]->child[L]->parent = NULL;\n\tnodes[v - 1]->child[L] = NULL;\n\tnodes[v - 1]->maintain();\n}\n```\n\n### `Query`  `Update` \n `QueryMax(u, v)`  `Node`  `max`  `Maintain()` \n\n `Access(u)` `Splay`  Splay  `u`  `max`  `u` \n\n `Evert` \n\n```cpp\nconst T &Node::queryMax() {\n\taccess();\n\tsplay();\n\treturn max;\n}\n\nconst T &queryMax(int u, int v) {\n\tnodes[u - 1]->evert();\n\treturn nodes[v - 1]->queryMax();\n}\n```\n\n `Splay`  Splay \n\n```cpp\nvoid update(int u, const T &value) {\n\tnodes[u - 1]->splay();\n\tnodes[u - 1]->value = value;\n\tnodes[u - 1]->maintain();\n}\n```\n\n### `MakeTree` \n\n\n```cpp\nvoid makeTree(int u, const T &value) {\n\tnodes[u - 1] = new Node(value);\n}\n```\n\n###  & \n1.  `Splay`  `Rotate` \n2. `Rotate`  `Path Parent`  `Path Parent`  `Path Parent`  Splay \n\n```cpp\nvoid pushDown() {\n\tif (reversed) {\n\t\tstd::swap(child[L], child[R]);\n\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\treversed = false;\n\t}\n}\n\nvoid maintain() {\n\tsum = value;\n\tif (child[L]) sum += child[L]->sum;\n\tif (child[R]) sum += child[R]->sum;\n\n\tmax = value;\n\tif (child[L]) max = std::max(max, child[L]->max);\n\tif (child[R]) max = std::max(max, child[R]->max);\n}\n\nvoid rotate() {\n\tif (parent->parent) parent->parent->pushDown();\n\tparent->pushDown(), pushDown();\n\tstd::swap(pathParent, parent->pathParent);\n\n\tRelation x = relation();\n\tNode *oldParent = parent;\n\n\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\tparent = oldParent->parent;\n\n\toldParent->child[x] = child[x ^ 1];\n\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\tchild[x ^ 1] = oldParent;\n\toldParent->parent = this;\n\n\toldParent->maintain(), maintain();\n}\n\nvoid splay() {\n\twhile (parent) {\n\t\tif (!parent->parent) rotate();\n\t\telse {\n\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\telse rotate(), rotate();\n\t\t}\n\t}\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 30000;\n\nvoid print(void *p);\n\ntemplate <typename T>\nstruct LinkCutTree {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, *pathParent;\n\t\tT value, sum, max;\n\t\tbool reversed;\n\n\t\tNode(const T &value) : reversed(false), value(value), sum(value), max(value), parent(NULL), pathParent(NULL) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tstd::swap(child[L], child[R]);\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\treversed = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (child[L]) sum += child[L]->sum;\n\t\t\tif (child[R]) sum += child[R]->sum;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\t\t\tstd::swap(pathParent, parent->pathParent);\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t}\n\n\t\tvoid splay() {\n\t\t\twhile (parent) {\n\t\t\t\tif (!parent->parent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid evert() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treversed ^= 1;\n\t\t}\n\n\t\tvoid expose() {\n\t\t\tsplay();\n\t\t\tpushDown();\n\t\t\tif (child[R]) {\n\t\t\t\tchild[R]->parent = NULL;\n\t\t\t\tchild[R]->pathParent = this;\n\t\t\t\tchild[R] = NULL;\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\n\t\tbool splice() {\n\t\t\tsplay();\n\t\t\tif (!pathParent) return false;\n\n\t\t\tpathParent->expose();\n\t\t\tpathParent->child[R] = this;\n\t\t\tparent = pathParent;\n\t\t\tpathParent = NULL;\n\t\t\tparent->maintain();\n\n\t\t\treturn true;\n\t\t}\n\n\t\tvoid access() {\n\t\t\texpose();\n\t\t\twhile (splice());\n\t\t}\n\n\t\tconst T &querySum() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn sum;\n\t\t}\n\n\t\tconst T &queryMax() {\n\t\t\taccess();\n\t\t\tsplay();\n\t\t\treturn max;\n\t\t}\n\t};\n\n\tNode *nodes[MAXN];\n\n\tvoid makeTree(int u, const T &value) {\n\t\tnodes[u - 1] = new Node(value);\n\t}\n\n\tvoid link(int u, int v) {\n\t\tnodes[v - 1]->evert();\n\t\tnodes[v - 1]->pathParent = nodes[u - 1];\n\t}\n\n\tvoid cut(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\tnodes[v - 1]->access();\n\t\tnodes[v - 1]->splay();\n\t\tnodes[v - 1]->pushDown();\n\t\tnodes[v - 1]->child[L]->parent = NULL;\n\t\tnodes[v - 1]->child[L] = NULL;\n\t\tnodes[v - 1]->maintain();\n\t}\n\n\tconst T &querySum(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->querySum();\n\t}\n\n\tconst T &queryMax(int u, int v) {\n\t\tnodes[u - 1]->evert();\n\t\treturn nodes[v - 1]->queryMax();\n\t}\n\n\tvoid update(int u, const T &value) {\n\t\tnodes[u - 1]->splay();\n\t\tnodes[u - 1]->value = value;\n\t\tnodes[u - 1]->maintain();\n\t}\n};\n\nstruct UndirectedEdge {\n\tint u, v;\n\n\tUndirectedEdge() {}\n\n\tUndirectedEdge(int u, int v) : u(u), v(v) {}\n} edges[MAXN - 1];\n\nint n, q;\nLinkCutTree<int> lct;\n\nvoid dfs(LinkCutTree<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[LinkCutTree<int>::L], depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' ');\n\tprintf(\"%d, max = %d, sum = %d\\n\", v->value, v->max, v->sum);\n\tdfs(v->child[LinkCutTree<int>::R], depth + 1);\n}\n\nvoid print(void *p) {\n\tdfs((LinkCutTree<int>::Node *)p, 0);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tedges[i] = UndirectedEdge(u, v);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint value;\n\t\tscanf(\"%d\", &value);\n\t\tlct.makeTree(i, value);\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tlct.link(edges[i].u, edges[i].v);\n\t}\n\n\tscanf(\"%d\", &q);\n\n\tfor (int i = 0; i < q; i++) {\n\t\tchar str[6 + 1];\n\t\tscanf(\"%s\", str);\n\t\tif (str[1] == 'H') {\n\t\t\tint u, t;\n\t\t\tscanf(\"%d %d\", &u, &t);\n\t\t\tlct.update(u, t);\n\t\t} else if (str[1] == 'M') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.queryMax(u, v));\n\t\t} else if (str[1] == 'S') {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tprintf(\"%d\\n\", lct.querySum(u, v));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"link-cut-tree-notes","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cfu00tnc2xlvjxdiny8"},{"title":"KMP ","date":"2015-12-29T20:19:36.000Z","_content":"\nKMPKnuth-Morris-Pratt\n\n<!-- more -->\n\n### \n `pattern`  `\"utqqutnu\"` `target`  `\"utqlwutqqutnu`\"`\"-\"` `\"|\"` \n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n `'l'` \n\n```\nutqqutlwutqqutnu\n |\n utqqutnu\n```\n\n \n\n `\"ut\"` \n\n```\nutqqutlwutqqutnu\n    --|\n    utqqutnu\n```\n\n `'t'`  `'l'` \n\n```\nutqqutlwutqqutnu\n      |\n      utqqutnu\n```\n\nKMP ****\n\n### \n************************\n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n `\"utqqut\"` `\"ut\"` `\"ut\"`  `\"ut\"` \n\n `\"ttitty\"` `\"ttittitty\"`\n\n```\nttittittypoi\n-----|\nttitty\n```\n\n `\"ttitt\"` `\"tt\"`  `\"t\"` `\"t\"` \n\n```\nttittittypoi\n    -|\n    ttitty\n```\n\n `'t'` \n\n `\"tt\"` \n\n```\nttittittypoi\n   ------\n   ttitty\n```\n\n\n\n****\n\n### \nKMP ********\n\n `fail`  `i`  `i` ****\n\n```\n      | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8\ntarget| u | t | q | q | u | t | n | u\nfail  | 0 | 0 | 0 | 0 | 1 | 2 | 0 | 1\n```\n\n `fail[i]` \n\n1.  `fail[i - 1]`  0 `i`  `fail[i - 1] +`  `fail[i]`  `fail[i - 1] + 1`\n2.  `fail[i - 1]`  0 `i`  `fail[i] = 1` `fail[i] = 0`\n3.  `fail[i - 1]`  0 `i`  `fail[i - 1] +` **** `i`  `fail[fail[i - 1]] + 1`  0\n\n*agct*agc**a**gct*agct*\n\n `'a'`  `'t'`  `\"agctagc\"`  `'c'` **** `'t'` `\"agct\"` \n\n### \n `fail` \n\n1. \n2. ****\n3. ****************\n\n### POJ 3461\n 2016  12  26 \n\n![zyz ](kmp-notes/zyz.png)\n\n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 1000000;\n\ninline int kmp(char *a, char *b) //  a  b\n{\n\t// \n\tint na = strlen(a + 1), nb = strlen(b + 1);\n\tstatic int fail[MAXN + 1];\n\n\tfail[1] = 0;\n\tfor (int i = 2; i <= nb; i++)\n\t{\n\t\t//  fail \n\t\tint j = fail[i - 1];\n\t\t//  fail  0 \n\t\twhile (j != 0 && b[j + 1] != b[i]) j = fail[j];\n\n\t\t//  fail \n\t\tif (b[j + 1] == b[i]) fail[i] = j + 1;\n\t\telse fail[i] = 0; // \n\t}\n\n\tint res = 0; // \n\tfor (int i = 1, j = 0; i <= na; i++)\n\t{\n\t\t//  fail \n\t\twhile (j != 0 && b[j + 1] != a[i]) j = fail[j];\n\n\t\t// \n\t\tif (b[j + 1] == a[i]) j++;\n\n\t\t// \n\t\tif (j == nb)\n\t\t{\n\t\t\tres++;\n\t\t\tj = fail[j]; // \n\t\t\t// j = 0 // \n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile (T--)\n\t{\n\t\tstatic char a[MAXN + 2], b[MAXN + 2];\n\t\t//  1 \n\t\tscanf(\"%s %s\", a + 1, b + 1);\n\t\tprintf(\"%d\\n\", kmp(b, a));\n\t}\n\treturn 0;\n}\n```\n\n<!--\n### CodeVS 1204\n C++  `0` \n\n```cpp\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <string>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::string;\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100;\n\ninline size_t KMP(const string &target, const string &pattern) {\n\tuint fail[MAXN] = { 0 };\n\n\tfail[0] = 0;\n\tfor (uint i = 1; i < pattern.length(); i++) {\n\t\tuint k = fail[i - 1];\n\t\tchar ch = pattern[i];\n\n\t\twhile (k && pattern[k] != ch) {\n\t\t\tk = fail[k - 1];\n\t\t}\n\n\t\tif (pattern[k] == ch) {\n\t\t\tfail[i] = k + 1;\n\t\t} else {\n\t\t\tfail[i] = 0;\n\t\t}\n\t}\n\n\tfor (uint i = 0; i < pattern.length(); i++) {\n\t\tcout << fail[i] << endl;\n\t}\n\n\tuint i = 0, j = 0;\n\twhile (i < target.length() && j < pattern.length()) {\n\t\tif (target[i] == pattern[j]) {\n\t\t\ti++, j++;\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tj = fail[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (j == pattern.length()) {\n\t\treturn i - j;\n\t} else {\n\t\treturn string::npos;\n\t}\n}\n\nint main() {\n\tstring target, pattern;\n\tcin >> target >> pattern;\n\tcout << KMP(target, pattern) << endl;\n\treturn 0;\n}\n```\n-->\n","source":"_posts/kmp-notes.md","raw":"title: KMP \ncategories: OI\ntags: \n  - CodeVS\n  - KMP\n  - \n  - \n  -   \npermalink: kmp-notes\ndate: 2015-12-30 04:19:36\n---\n\nKMPKnuth-Morris-Pratt\n\n<!-- more -->\n\n### \n `pattern`  `\"utqqutnu\"` `target`  `\"utqlwutqqutnu`\"`\"-\"` `\"|\"` \n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n `'l'` \n\n```\nutqqutlwutqqutnu\n |\n utqqutnu\n```\n\n \n\n `\"ut\"` \n\n```\nutqqutlwutqqutnu\n    --|\n    utqqutnu\n```\n\n `'t'`  `'l'` \n\n```\nutqqutlwutqqutnu\n      |\n      utqqutnu\n```\n\nKMP ****\n\n### \n************************\n\n```\nutqqutlwutqqutnu\n------|\nutqqutnu\n```\n\n `\"utqqut\"` `\"ut\"` `\"ut\"`  `\"ut\"` \n\n `\"ttitty\"` `\"ttittitty\"`\n\n```\nttittittypoi\n-----|\nttitty\n```\n\n `\"ttitt\"` `\"tt\"`  `\"t\"` `\"t\"` \n\n```\nttittittypoi\n    -|\n    ttitty\n```\n\n `'t'` \n\n `\"tt\"` \n\n```\nttittittypoi\n   ------\n   ttitty\n```\n\n\n\n****\n\n### \nKMP ********\n\n `fail`  `i`  `i` ****\n\n```\n      | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8\ntarget| u | t | q | q | u | t | n | u\nfail  | 0 | 0 | 0 | 0 | 1 | 2 | 0 | 1\n```\n\n `fail[i]` \n\n1.  `fail[i - 1]`  0 `i`  `fail[i - 1] +`  `fail[i]`  `fail[i - 1] + 1`\n2.  `fail[i - 1]`  0 `i`  `fail[i] = 1` `fail[i] = 0`\n3.  `fail[i - 1]`  0 `i`  `fail[i - 1] +` **** `i`  `fail[fail[i - 1]] + 1`  0\n\n*agct*agc**a**gct*agct*\n\n `'a'`  `'t'`  `\"agctagc\"`  `'c'` **** `'t'` `\"agct\"` \n\n### \n `fail` \n\n1. \n2. ****\n3. ****************\n\n### POJ 3461\n 2016  12  26 \n\n![zyz ](kmp-notes/zyz.png)\n\n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 1000000;\n\ninline int kmp(char *a, char *b) //  a  b\n{\n\t// \n\tint na = strlen(a + 1), nb = strlen(b + 1);\n\tstatic int fail[MAXN + 1];\n\n\tfail[1] = 0;\n\tfor (int i = 2; i <= nb; i++)\n\t{\n\t\t//  fail \n\t\tint j = fail[i - 1];\n\t\t//  fail  0 \n\t\twhile (j != 0 && b[j + 1] != b[i]) j = fail[j];\n\n\t\t//  fail \n\t\tif (b[j + 1] == b[i]) fail[i] = j + 1;\n\t\telse fail[i] = 0; // \n\t}\n\n\tint res = 0; // \n\tfor (int i = 1, j = 0; i <= na; i++)\n\t{\n\t\t//  fail \n\t\twhile (j != 0 && b[j + 1] != a[i]) j = fail[j];\n\n\t\t// \n\t\tif (b[j + 1] == a[i]) j++;\n\n\t\t// \n\t\tif (j == nb)\n\t\t{\n\t\t\tres++;\n\t\t\tj = fail[j]; // \n\t\t\t// j = 0 // \n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile (T--)\n\t{\n\t\tstatic char a[MAXN + 2], b[MAXN + 2];\n\t\t//  1 \n\t\tscanf(\"%s %s\", a + 1, b + 1);\n\t\tprintf(\"%d\\n\", kmp(b, a));\n\t}\n\treturn 0;\n}\n```\n\n<!--\n### CodeVS 1204\n C++  `0` \n\n```cpp\n#include <climits>\n#include <cstring>\n#include <iostream>\n#include <string>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::string;\n\ntypedef unsigned int uint;\n\nconst uint MAXN = 100;\n\ninline size_t KMP(const string &target, const string &pattern) {\n\tuint fail[MAXN] = { 0 };\n\n\tfail[0] = 0;\n\tfor (uint i = 1; i < pattern.length(); i++) {\n\t\tuint k = fail[i - 1];\n\t\tchar ch = pattern[i];\n\n\t\twhile (k && pattern[k] != ch) {\n\t\t\tk = fail[k - 1];\n\t\t}\n\n\t\tif (pattern[k] == ch) {\n\t\t\tfail[i] = k + 1;\n\t\t} else {\n\t\t\tfail[i] = 0;\n\t\t}\n\t}\n\n\tfor (uint i = 0; i < pattern.length(); i++) {\n\t\tcout << fail[i] << endl;\n\t}\n\n\tuint i = 0, j = 0;\n\twhile (i < target.length() && j < pattern.length()) {\n\t\tif (target[i] == pattern[j]) {\n\t\t\ti++, j++;\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tj = fail[j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tif (j == pattern.length()) {\n\t\treturn i - j;\n\t} else {\n\t\treturn string::npos;\n\t}\n}\n\nint main() {\n\tstring target, pattern;\n\tcin >> target >> pattern;\n\tcout << KMP(target, pattern) << endl;\n\treturn 0;\n}\n```\n-->\n","slug":"kmp-notes","published":1,"updated":"2016-12-27T02:35:35.355Z","_id":"cix2l6cg200tvc2xldrn3l8co","comments":1,"layout":"post","photos":[],"link":""},{"title":"JSOI2016 -  + RMQ","date":"2016-04-20T14:56:35.000Z","_content":"\nJSOI  $ N $  $ i $  $ h_i $ $ N $ \n\n $ i $  $ p \\ (p \\geq 0) $ JYY  $ j $ \n\n$$ h_j \\leq h_i + p - \\sqrt{\\mid i - j \\mid} $$\n\nJSOI JYY  JYY \n\n<!-- more -->\n\n### \n\n\n$$ p_i = \\min\\limits_{j = 1} ^ n \\{ h_j - h_i + \\lceil \\sqrt{\\mid i - j \\mid} \\rceil \\} $$\n\n $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $  $ O(\\sqrt{n}) $ $ j $ \n\n $ j $  $ p_i $  $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $  $ h_j $  $ j $  $ p_j $ \n\n i $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $  $ h_j $  RMQ \n\n $ O(n \\log n + n \\sqrt n) $ 3s \n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\n\nint n, a[MAXN];\nint st[MAXN][MAXLOGN + 1];\n\ntemplate <typename T> inline T sqr(const T x) { return x * x; }\ntemplate <typename T> inline void cmax(T &x, const T &y) { if (y > x) x = y; }\ntemplate <typename T> inline void cmin(T &x, const T &y) { if (y < x) x = y; }\n\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = std::max(a[i], a[i + 1]);\n\tst[n - 1][0] = a[n - 1];\n\n\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tst[i][j] = std::max(st[i][j - 1], st[std::min(i + (1 << (j - 1)), n - 1)][j - 1]);\n\t\t}\n\t}\n}\n\ninline int query(const int l, const int r) {\n\t/*\n\tif (l > r) return 0;\n\tint res = 0;\n\tfor (int i = l; i <= r; i++) cmax(res, a[i - 1]);\n\treturn res;\n\t*/\n\n\tif (l > r) return 0;\n\telse if (l == r) return a[l - 1];\n\telse {\n\t\tint t = floor(log2(r - l));\n\t\treturn std::max(st[l - 1][t], st[r - 1 - (1 << t)][t]);\n\t}\n}\n\ninline void getRange(const int i, const int s, int &l1, int &r1, int &l2, int &r2) {\n\tif (s == 0) l1 = r1 = l2 = r2 = i;\n\telse if (s == 1) l1 = r1 = i - 1, l2 = r2 = i + 1;\n\telse {\n\t\tint l = sqr(s - 1) + 1, r = sqr(s);\n\t\tl1 = i - r, r1 = i - l, l2 = i + l, r2 = i + r;\n\t}\n\n\tif (l1 < 1) l1 = 1;\n\tif (l2 < 1) l2 = 1;\n\tif (r1 > n) r1 = n;\n\tif (r2 > n) r2 = n;\n\n\t// printf(\"i = %d, s = %d, [%d, %d], [%d, %d]\\n\", i, s, l1, r1, l2, r2);\n}\n\ninline int solve(const int i) {\n\tint max = 0;\n\tstatic int lim = ceil(sqrt(n));\n\tfor (int s = 0; s <= lim; s++) {\n\t\tint l1, r1, l2, r2;\n\t\tgetRange(i, s, l1, r1, l2, r2);\n\t\t\n\t\tcmax(max, query(l1, r1) - a[i - 1] + s);\n\t\tcmax(max, query(l2, r2) - a[i - 1] + s);\n\t}\n\treturn max;\n\n\t/*\n\tint p = 0;\n\tfor (int j = 1; j <= n; j++) {\n\t\tint s = ceil(sqrt(abs(i - j)));\n\t\tprintf(\"(%d, %d) -> %d\\n\", i, j ,s);\n\t\tp = std::max(p, a[j - 1] + s - a[i - 1]);\n\t\n\t}\n\treturn p;\n\t*/\n}\n\nint main() {\n\tfreopen(\"light.in\", \"r\", stdin);\n\t// freopen(\"light.out\", \"w\", stdout);\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tsparseTable();\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tprintf(\"%d\\n\", solve(i));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/jsoi2016-light.md","raw":"title: JSOI2016 -  + RMQ\ncategories: OI\ntags: \n  - JSOI\n  - \n  - \n  - RMQ\npermalink: jsoi2016-light\ndate: 2016-04-20 22:56:35\n---\n\nJSOI  $ N $  $ i $  $ h_i $ $ N $ \n\n $ i $  $ p \\ (p \\geq 0) $ JYY  $ j $ \n\n$$ h_j \\leq h_i + p - \\sqrt{\\mid i - j \\mid} $$\n\nJSOI JYY  JYY \n\n<!-- more -->\n\n### \n\n\n$$ p_i = \\min\\limits_{j = 1} ^ n \\{ h_j - h_i + \\lceil \\sqrt{\\mid i - j \\mid} \\rceil \\} $$\n\n $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $  $ O(\\sqrt{n}) $ $ j $ \n\n $ j $  $ p_i $  $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $  $ h_j $  $ j $  $ p_j $ \n\n i $ \\lceil \\sqrt{\\mid i - j \\mid} \\rceil $  $ h_j $  RMQ \n\n $ O(n \\log n + n \\sqrt n) $ 3s \n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\n\nint n, a[MAXN];\nint st[MAXN][MAXLOGN + 1];\n\ntemplate <typename T> inline T sqr(const T x) { return x * x; }\ntemplate <typename T> inline void cmax(T &x, const T &y) { if (y > x) x = y; }\ntemplate <typename T> inline void cmin(T &x, const T &y) { if (y < x) x = y; }\n\ninline void sparseTable() {\n\tfor (int i = 0; i < n - 1; i++) st[i][0] = std::max(a[i], a[i + 1]);\n\tst[n - 1][0] = a[n - 1];\n\n\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tst[i][j] = std::max(st[i][j - 1], st[std::min(i + (1 << (j - 1)), n - 1)][j - 1]);\n\t\t}\n\t}\n}\n\ninline int query(const int l, const int r) {\n\t/*\n\tif (l > r) return 0;\n\tint res = 0;\n\tfor (int i = l; i <= r; i++) cmax(res, a[i - 1]);\n\treturn res;\n\t*/\n\n\tif (l > r) return 0;\n\telse if (l == r) return a[l - 1];\n\telse {\n\t\tint t = floor(log2(r - l));\n\t\treturn std::max(st[l - 1][t], st[r - 1 - (1 << t)][t]);\n\t}\n}\n\ninline void getRange(const int i, const int s, int &l1, int &r1, int &l2, int &r2) {\n\tif (s == 0) l1 = r1 = l2 = r2 = i;\n\telse if (s == 1) l1 = r1 = i - 1, l2 = r2 = i + 1;\n\telse {\n\t\tint l = sqr(s - 1) + 1, r = sqr(s);\n\t\tl1 = i - r, r1 = i - l, l2 = i + l, r2 = i + r;\n\t}\n\n\tif (l1 < 1) l1 = 1;\n\tif (l2 < 1) l2 = 1;\n\tif (r1 > n) r1 = n;\n\tif (r2 > n) r2 = n;\n\n\t// printf(\"i = %d, s = %d, [%d, %d], [%d, %d]\\n\", i, s, l1, r1, l2, r2);\n}\n\ninline int solve(const int i) {\n\tint max = 0;\n\tstatic int lim = ceil(sqrt(n));\n\tfor (int s = 0; s <= lim; s++) {\n\t\tint l1, r1, l2, r2;\n\t\tgetRange(i, s, l1, r1, l2, r2);\n\t\t\n\t\tcmax(max, query(l1, r1) - a[i - 1] + s);\n\t\tcmax(max, query(l2, r2) - a[i - 1] + s);\n\t}\n\treturn max;\n\n\t/*\n\tint p = 0;\n\tfor (int j = 1; j <= n; j++) {\n\t\tint s = ceil(sqrt(abs(i - j)));\n\t\tprintf(\"(%d, %d) -> %d\\n\", i, j ,s);\n\t\tp = std::max(p, a[j - 1] + s - a[i - 1]);\n\t\n\t}\n\treturn p;\n\t*/\n}\n\nint main() {\n\tfreopen(\"light.in\", \"r\", stdin);\n\t// freopen(\"light.out\", \"w\", stdout);\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tsparseTable();\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tprintf(\"%d\\n\", solve(i));\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"jsoi2016-light","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cg900u2c2xl5k11bdgb"},{"title":"JSOI2016 -  + ","date":"2016-04-23T16:41:33.000Z","_content":"\nJSOI  $ N $  $ 1 $  $ N $ $ i $  $ j $  $ T_{i, j} $ $ T_{i, j} $  $ T_{j, i} $ \n\n $ k $  $ P_k $ \n\nJS Airways  $ M $  $ i $  $ D_i $  $ X_i $  $ Y_i $ \n\n JS Airway  $ 0 $  JS Airways \n\nJYY  JS Airways  $ M $ \n\n<!-- more -->\n\n### \n $ i $  $ k $  $ j $  $ i $$ j $  $ T[i][k] + P[k] + T[k][j] $ Floyd \n\n $ A $  $ B $ $ A $  $ B $\n\n1. $ A $  $ B $  $ A $  $ B $ \n2. $ A $  $ A $  $ B $  $ B $ \n\n$ A \\Rightarrow B $  $ A $  $ B $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 500;\nconst int MAXM = 500;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e, *c;\n    int l;\n    bool flag;\n} N[MAXM * 2 + 2];\n\nstruct Edge {\n    Node *s, *t;\n    int f, c;\n    Edge *next, *r;\n\n    Edge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c) {\n    // printf(\"(%d, %d, %d)\\n\", s, t, c);\n    N[s].e = new Edge(&N[s], &N[t], c);\n    N[t].e = new Edge(&N[t], &N[s], 0);\n    N[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct Dinic {\n    bool makeLevelGraph(Node *const s, Node *const t, const int n) {\n        for (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n        std::queue<Node *> q;\n        q.push(s);\n        s->l = 1;\n\n        while (!q.empty()) {\n            Node *v = q.front();\n            q.pop();\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n                e->t->l = v->l + 1;\n                if (e->t == t) return true;\n                else q.push(e->t);\n            }\n        }\n\n        return false;\n    }\n\n    int findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n        if (s == t) return limit;\n\n        for (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n            int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n            if (f > 0) {\n                e->f += f, e->r->f -= f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n\n    int operator()(const int s, const int t, const int n) {\n        int ans = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            int f;\n            while ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n        }\n        \n        return ans;\n    }\n} dinic;\n\nstruct Airline {\n    int s, t, time;\n} A[MAXM];\n\nint n, m, p[MAXN], t[MAXN][MAXN], d[MAXN][MAXN];\nint S, T;\n\ninline void floyd() {\n    for (int k = 0; k < n; k++) for (int i = 0; i < n; i++) for (int j = 0; j < n; j++)\n        if (i != j)\n            d[i][j] = std::min(d[i][j], d[i][k] + p[k] + d[k][j]);\n\n    // for (int i = 0; i < n; i++) {\n    //     for (int j = 0; j < n; j++) printf(\"%d \", d[i][j]);\n    //     putchar('\\n');\n    // }\n}\n\ninline void addEdge(const int u, const int v) {\n    // printf(\"(%d, %d)\\n\", u, v);\n    if (!N[u].flag) addEdge(S, u, 1), N[u].flag = true;\n    addEdge(u, v + m, INT_MAX);\n    if (!N[v + m].flag) addEdge(v + m, T, 1), N[v + m].flag = true;\n}\n\nint main() {\n\tfreopen(\"flight.in\", \"r\", stdin);\n\t// freopen(\"flight.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &p[i]);\n    for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) scanf(\"%d\", &t[i][j]), d[i][j] = t[i][j];\n\n    floyd();\n\n    for (int i = 0; i < m; i++) scanf(\"%d %d %d\", &A[i].s, &A[i].t, &A[i].time), A[i].s--, A[i].t--;\n\n    // for (int i = 0; i < n; i++) printf(\"%d\\n\", p[i]);\n    // for (int i = 0; i < m; i++) printf(\"%d %d %d\\n\", A[i].s, A[i].t, A[i].time);\n\n    S = 0, T = m * 2 + 1;\n    for (int i = 1; i <= m; i++) {\n        Airline &a = A[i - 1];\n        for (int j = 1; j <= m; j++) {\n            Airline &b = A[j - 1];\n\n            if (   (a.time + t[a.s][a.t] + p[a.t] + d[a.t][b.s] + p[b.s] <= b.time)\n                || (a.time + t[a.s][a.t] + p[a.t] <= b.time && a.t == b.s)\n               ) {\n                addEdge(i, j);\n            }\n        }\n    }\n\n    int flow = dinic(S, T, m * 2 + 2);\n    printf(\"%d\\n\", m - flow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/jsoi2016-flight.md","raw":"title: JSOI2016 -  + \ncategories: OI\ntags: \n  - JSOI\n  - \n  - Dinic\n  - \n  - Floyd\npermalink: jsoi2016-flight\ndate: 2016-04-24 00:41:33\n---\n\nJSOI  $ N $  $ 1 $  $ N $ $ i $  $ j $  $ T_{i, j} $ $ T_{i, j} $  $ T_{j, i} $ \n\n $ k $  $ P_k $ \n\nJS Airways  $ M $  $ i $  $ D_i $  $ X_i $  $ Y_i $ \n\n JS Airway  $ 0 $  JS Airways \n\nJYY  JS Airways  $ M $ \n\n<!-- more -->\n\n### \n $ i $  $ k $  $ j $  $ i $$ j $  $ T[i][k] + P[k] + T[k][j] $ Floyd \n\n $ A $  $ B $ $ A $  $ B $\n\n1. $ A $  $ B $  $ A $  $ B $ \n2. $ A $  $ A $  $ B $  $ B $ \n\n$ A \\Rightarrow B $  $ A $  $ B $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 500;\nconst int MAXM = 500;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e, *c;\n    int l;\n    bool flag;\n} N[MAXM * 2 + 2];\n\nstruct Edge {\n    Node *s, *t;\n    int f, c;\n    Edge *next, *r;\n\n    Edge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c) {\n    // printf(\"(%d, %d, %d)\\n\", s, t, c);\n    N[s].e = new Edge(&N[s], &N[t], c);\n    N[t].e = new Edge(&N[t], &N[s], 0);\n    N[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct Dinic {\n    bool makeLevelGraph(Node *const s, Node *const t, const int n) {\n        for (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n        std::queue<Node *> q;\n        q.push(s);\n        s->l = 1;\n\n        while (!q.empty()) {\n            Node *v = q.front();\n            q.pop();\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n                e->t->l = v->l + 1;\n                if (e->t == t) return true;\n                else q.push(e->t);\n            }\n        }\n\n        return false;\n    }\n\n    int findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n        if (s == t) return limit;\n\n        for (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n            int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n            if (f > 0) {\n                e->f += f, e->r->f -= f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n\n    int operator()(const int s, const int t, const int n) {\n        int ans = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            int f;\n            while ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n        }\n        \n        return ans;\n    }\n} dinic;\n\nstruct Airline {\n    int s, t, time;\n} A[MAXM];\n\nint n, m, p[MAXN], t[MAXN][MAXN], d[MAXN][MAXN];\nint S, T;\n\ninline void floyd() {\n    for (int k = 0; k < n; k++) for (int i = 0; i < n; i++) for (int j = 0; j < n; j++)\n        if (i != j)\n            d[i][j] = std::min(d[i][j], d[i][k] + p[k] + d[k][j]);\n\n    // for (int i = 0; i < n; i++) {\n    //     for (int j = 0; j < n; j++) printf(\"%d \", d[i][j]);\n    //     putchar('\\n');\n    // }\n}\n\ninline void addEdge(const int u, const int v) {\n    // printf(\"(%d, %d)\\n\", u, v);\n    if (!N[u].flag) addEdge(S, u, 1), N[u].flag = true;\n    addEdge(u, v + m, INT_MAX);\n    if (!N[v + m].flag) addEdge(v + m, T, 1), N[v + m].flag = true;\n}\n\nint main() {\n\tfreopen(\"flight.in\", \"r\", stdin);\n\t// freopen(\"flight.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &p[i]);\n    for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) scanf(\"%d\", &t[i][j]), d[i][j] = t[i][j];\n\n    floyd();\n\n    for (int i = 0; i < m; i++) scanf(\"%d %d %d\", &A[i].s, &A[i].t, &A[i].time), A[i].s--, A[i].t--;\n\n    // for (int i = 0; i < n; i++) printf(\"%d\\n\", p[i]);\n    // for (int i = 0; i < m; i++) printf(\"%d %d %d\\n\", A[i].s, A[i].t, A[i].time);\n\n    S = 0, T = m * 2 + 1;\n    for (int i = 1; i <= m; i++) {\n        Airline &a = A[i - 1];\n        for (int j = 1; j <= m; j++) {\n            Airline &b = A[j - 1];\n\n            if (   (a.time + t[a.s][a.t] + p[a.t] + d[a.t][b.s] + p[b.s] <= b.time)\n                || (a.time + t[a.s][a.t] + p[a.t] <= b.time && a.t == b.s)\n               ) {\n                addEdge(i, j);\n            }\n        }\n    }\n\n    int flow = dinic(S, T, m * 2 + 2);\n    printf(\"%d\\n\", m - flow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"jsoi2016-flight","published":1,"updated":"2016-05-11T09:33:58.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cgk00uac2xloq8g88ro"},{"title":"JSOI2009 - AC  + ","date":"2016-09-18T09:29:00.000Z","_content":"\n $ n $  $ m $  $ i $  $ {p_i \\over q_i} (0 \\leq p_i \\leq q_i) $$ T $  $ T $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1444](http://www.lydsy.com/JudgeOnline/problem.php?id=1444)\n\n### \n AC  AC  AC \n\n $ p(i) = \\frac{p_i}{q_i} $ $ u $  $ v $  $ \\{ c_i \\} $ $ u $  $ v $  $ P(u, v) = \\sum p(c_i) $\n\n AC **** $ i $  $ x_i $\n\n$$\n\\begin{aligned}\nx_i &= \\sum\\limits_{j} x_j P(j, i) \\\\\n-x_i + \\sum\\limits_{j} x_j P(j, i) &= 0 \\\\\nx_i(-1 + P(i, i)) + \\sum\\limits_{j \\neq i} x_j P(j, i) &= 0 \\\\\n\\end{aligned}\n$$\n\n $ 1 $ \n\n$$\n\\begin{aligned}\nx_i &= \\sum\\limits_{j} x_j P(j, i) + 1 \\\\\n-x_i + \\sum\\limits_{j} x_j P(j, i) &= -1 \\\\\nx_i(-1 + P(i, i)) + \\sum\\limits_{j \\neq i} x_j P(j, i) &= -1 \\\\\n\\end{aligned}\n$$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int CHARSET_SIZE = 'Z' - 'A' + 1;\nconst int BASE_CHAR = 'A';\nconst double EPS = 0.005;\n\nint charsetSize, n;\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord, visited;\n\t\tint id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < charsetSize; i++) c[i] = NULL;\n\t\t\tthis->id = n++;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < charsetSize; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\t// c = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tc = v == root ? root : v->fail->c[i];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\ndouble p[MAXN], matrix[MAXN + 1][MAXN + 1 + 1];\n\ninline void buildMatrix() {\n\tfor (int i = 1; i < n; i++) matrix[i][i] = -1;\n\tmatrix[0][0] = -1, matrix[0][n] = -1;\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->isWord || v->next) continue;\n\n\t\tfor (int i = 0; i < charsetSize; i++) {\n\t\t\t// printf(\"%d -> %d\\n\", v->id, v->c[i]->id);\n\t\t\tmatrix[v->c[i]->id][v->id] += p[i];\n\t\t\tif (!v->c[i]->visited) {\n\t\t\t\tv->c[i]->visited = true;\n\t\t\t\tq.push(v->c[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void gauss() {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (fabs(matrix[i][i]) < EPS) {\n\t\t\tfor (int j = i + 1; j < n; j++) if (matrix[j][i] >= EPS) {\n\t\t\t\tstd::swap(matrix[i], matrix[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// for (int j = i + 1; j < n; j++) if (max == -1 || fabs(matrix[j][i]) > fabs(matrix[max][i])) max = j;\n\t\t// if (max != i) std::swap(matrix[max], matrix[i]);\n\n\t\tdouble t = matrix[i][i];\n\t\tfor (int j = 0; j < n + 1; j++) matrix[i][j] /= t;\n\n\t\tfor (int j = 0; j < n; j++) if (j != i) {\n\t\t\tdouble t = matrix[j][i];\n\t\t\tfor (int k = i; k < n + 1; k++) matrix[j][k] -= t * matrix[i][k];\n\t\t}\n\t}\n}\n\nbool gauss_jordan() {\n    for (int i = 0; i < n; ++i) {\n        int idx = i;\n        for (int j = 0; j < n; ++j) if (fabs(matrix[j][i]) > fabs(matrix[idx][i])) idx = j;\n        // if (fabs(matrix[idx][i]) <= eps) return false;\n        if (idx != i) std::swap(matrix[i], matrix[idx]); // for (int j = i; j <= n; ++j) std::swap(matrix[i][j], matrix[idx][j]);\n        for (int j = 0; j < n; ++j) if (i != j) {\n            double tmp = matrix[j][i] / matrix[i][i];\n            for (int k = n; k >= i; --k) matrix[j][k] -= matrix[i][k] * tmp;\n        }\n    }\n    return true;\n}\n\nint main() {\n\tint m, l;\n\tscanf(\"%d %d %d\", &m, &l, &charsetSize);\n\tfor (int i = 0; i < charsetSize; i++) {\n\t\tdouble a, b;\n\t\tscanf(\"%lf %lf\", &a, &b);\n\t\tp[i] = a / b;\n\t}\n\n\tstatic Trie::Node *a[MAXN];\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tchar s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tfor (int i = 0; i < l; i++) {\n\t\t\ts[i] -= BASE_CHAR;\n\t\t\tif (p[s[i]] == 0) cnt++;\n\t\t}\n\t\ta[i] = t.insert(s, s + l);\n\t}\n\n\t/*\n\tif (cnt == m) {\n\t\tfor (int i = 0; i < m; i++) puts(\"0.00\");\n\t\treturn 0;\n\t}\n\t*/\n\n\tt.build();\n\n\tbuildMatrix();\n\t// for (int i = 0; i <= n; i++) matrix[0][i] = -matrix[0][i];\n\tgauss();\n\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= n; j++) printf(\"%.2lf%c\", matrix[i][j], j == n ? '\\n' : ' ');\n\t}\n\t*/\n\n\tfor (int i = 0; i < m; i++) printf(\"%.2lf\\n\", matrix[a[i]->id][n] < EPS ? 0.0f : matrix[a[i]->id][n]);\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2009-game2.md","raw":"title: JSOI2009 - AC  + \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \n  - AC \n  - \n  - \n  - \npermalink: jsoi2009-game2\ndate: 2016-09-18 17:29:00\n---\n\n $ n $  $ m $  $ i $  $ {p_i \\over q_i} (0 \\leq p_i \\leq q_i) $$ T $  $ T $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1444](http://www.lydsy.com/JudgeOnline/problem.php?id=1444)\n\n### \n AC  AC  AC \n\n $ p(i) = \\frac{p_i}{q_i} $ $ u $  $ v $  $ \\{ c_i \\} $ $ u $  $ v $  $ P(u, v) = \\sum p(c_i) $\n\n AC **** $ i $  $ x_i $\n\n$$\n\\begin{aligned}\nx_i &= \\sum\\limits_{j} x_j P(j, i) \\\\\n-x_i + \\sum\\limits_{j} x_j P(j, i) &= 0 \\\\\nx_i(-1 + P(i, i)) + \\sum\\limits_{j \\neq i} x_j P(j, i) &= 0 \\\\\n\\end{aligned}\n$$\n\n $ 1 $ \n\n$$\n\\begin{aligned}\nx_i &= \\sum\\limits_{j} x_j P(j, i) + 1 \\\\\n-x_i + \\sum\\limits_{j} x_j P(j, i) &= -1 \\\\\nx_i(-1 + P(i, i)) + \\sum\\limits_{j \\neq i} x_j P(j, i) &= -1 \\\\\n\\end{aligned}\n$$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int CHARSET_SIZE = 'Z' - 'A' + 1;\nconst int BASE_CHAR = 'A';\nconst double EPS = 0.005;\n\nint charsetSize, n;\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord, visited;\n\t\tint id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < charsetSize; i++) c[i] = NULL;\n\t\t\tthis->id = n++;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < charsetSize; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\t// c = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tc = v == root ? root : v->fail->c[i];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\ndouble p[MAXN], matrix[MAXN + 1][MAXN + 1 + 1];\n\ninline void buildMatrix() {\n\tfor (int i = 1; i < n; i++) matrix[i][i] = -1;\n\tmatrix[0][0] = -1, matrix[0][n] = -1;\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->isWord || v->next) continue;\n\n\t\tfor (int i = 0; i < charsetSize; i++) {\n\t\t\t// printf(\"%d -> %d\\n\", v->id, v->c[i]->id);\n\t\t\tmatrix[v->c[i]->id][v->id] += p[i];\n\t\t\tif (!v->c[i]->visited) {\n\t\t\t\tv->c[i]->visited = true;\n\t\t\t\tq.push(v->c[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void gauss() {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (fabs(matrix[i][i]) < EPS) {\n\t\t\tfor (int j = i + 1; j < n; j++) if (matrix[j][i] >= EPS) {\n\t\t\t\tstd::swap(matrix[i], matrix[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// for (int j = i + 1; j < n; j++) if (max == -1 || fabs(matrix[j][i]) > fabs(matrix[max][i])) max = j;\n\t\t// if (max != i) std::swap(matrix[max], matrix[i]);\n\n\t\tdouble t = matrix[i][i];\n\t\tfor (int j = 0; j < n + 1; j++) matrix[i][j] /= t;\n\n\t\tfor (int j = 0; j < n; j++) if (j != i) {\n\t\t\tdouble t = matrix[j][i];\n\t\t\tfor (int k = i; k < n + 1; k++) matrix[j][k] -= t * matrix[i][k];\n\t\t}\n\t}\n}\n\nbool gauss_jordan() {\n    for (int i = 0; i < n; ++i) {\n        int idx = i;\n        for (int j = 0; j < n; ++j) if (fabs(matrix[j][i]) > fabs(matrix[idx][i])) idx = j;\n        // if (fabs(matrix[idx][i]) <= eps) return false;\n        if (idx != i) std::swap(matrix[i], matrix[idx]); // for (int j = i; j <= n; ++j) std::swap(matrix[i][j], matrix[idx][j]);\n        for (int j = 0; j < n; ++j) if (i != j) {\n            double tmp = matrix[j][i] / matrix[i][i];\n            for (int k = n; k >= i; --k) matrix[j][k] -= matrix[i][k] * tmp;\n        }\n    }\n    return true;\n}\n\nint main() {\n\tint m, l;\n\tscanf(\"%d %d %d\", &m, &l, &charsetSize);\n\tfor (int i = 0; i < charsetSize; i++) {\n\t\tdouble a, b;\n\t\tscanf(\"%lf %lf\", &a, &b);\n\t\tp[i] = a / b;\n\t}\n\n\tstatic Trie::Node *a[MAXN];\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tchar s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tfor (int i = 0; i < l; i++) {\n\t\t\ts[i] -= BASE_CHAR;\n\t\t\tif (p[s[i]] == 0) cnt++;\n\t\t}\n\t\ta[i] = t.insert(s, s + l);\n\t}\n\n\t/*\n\tif (cnt == m) {\n\t\tfor (int i = 0; i < m; i++) puts(\"0.00\");\n\t\treturn 0;\n\t}\n\t*/\n\n\tt.build();\n\n\tbuildMatrix();\n\t// for (int i = 0; i <= n; i++) matrix[0][i] = -matrix[0][i];\n\tgauss();\n\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j <= n; j++) printf(\"%.2lf%c\", matrix[i][j], j == n ? '\\n' : ' ');\n\t}\n\t*/\n\n\tfor (int i = 0; i < m; i++) printf(\"%.2lf\\n\", matrix[a[i]->id][n] < EPS ? 0.0f : matrix[a[i]->id][n]);\n\n\treturn 0;\n}\n```","slug":"jsoi2009-game2","published":1,"updated":"2016-09-18T09:30:31.290Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cgs00uhc2xlltiuxm68"},{"title":"JSOI2009 -  + ","date":"2016-04-28T14:10:42.000Z","_content":"\n $ N \\times M $ AA YY  AA \n\n\n\n AA \n\n<!-- more -->\n\n### \n[BZOJ 1443](http://www.lydsy.com/JudgeOnline/problem.php?id=1443)\n\n### \n AA  AA  AA \n\n\n\n YY  YY ******** AA  YY \n\n\n\n -  -  -   \n\n****\n\n Dinic  BFS********\n\n************ -  -  -   \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\nconst int DX[4] = { 1, 0, -1, 0 };\nconst int DY[4] = { 0, 1, 0, -1 };\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e, *c;\n    int l;\n    bool fs, ft;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n    Node *s, *t;\n    int f, c;\n    Edge *next, *r;\n\n    Edge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c) {\n    N[s].e = new Edge(&N[s], &N[t], c);\n    N[t].e = new Edge(&N[t], &N[s], 0);\n    (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nstruct Dinic {\n    bool makeLevelGraph(Node *const s, Node *const t, const int n) {\n        for (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n        std::queue<Node *> q;\n        q.push(s);\n        s->l = 1;\n\n        while (!q.empty()) {\n            Node *v = q.front();\n            q.pop();\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n                e->t->l = v->l + 1;\n                if (e->t == t) return true;\n                else q.push(e->t);\n            }\n        }\n\n        return false;\n    }\n\n    int findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n        if (s == t) return limit;\n\n        for (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n            int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n            if (f > 0) {\n                e->f += f, e->r->f -= f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n\n    int operator()(const int s, const int t, const int n) {\n        int ans = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            int f;\n            while ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n        }\n        \n        return ans;\n    }\n} dinic;\n\nint n, m;\nchar invalid[MAXN][MAXN];\n\nstruct Point {\n    int i, j;\n\n    Point(const int i, const int j) : i(i), j(j) {}\n\n    operator int() const { return i * m + j + 1; }\n    bool valid() const { return i >= 0 && i < n && j >= 0 && j < m && !invalid[i][j]; }\n    Point offset(const int dx, const int dy) const { return Point(i + dx, j + dy); }\n};\n\ninline void bfs(const int s, const int t) {\n    std::queue<Node *> q;\n    q.push(&N[s]);\n    N[s].fs = true;\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) if (e->f < e->c && !e->t->fs) {\n            e->t->fs = true;\n            q.push(e->t);\n        }\n    }\n\n    q.push(&N[t]);\n    N[t].ft = true;\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) if (e->r->f < e->r->c && !e->t->ft) {\n            // printf(\"%ld to %ld\\n\", v - N + 1, e->t - N + 1);\n            e->t->ft = true;\n            q.push(e->t);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) {\n        char s[MAXN + 1];\n        scanf(\"%s\", s);\n        for (int j = 0; j < m; j++) {\n            invalid[i][j] = (s[j] == '#');\n        }\n    }\n\n    const int s = 0, t = n * m + 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            Point p(i, j);\n            if (!p.valid()) continue;\n            if ((i + j) % 2 == 0) {\n                for (int k = 0; k < 4; k++) {\n                    Point p2 = p.offset(DX[k], DY[k]);\n                    if (p2.valid()) {\n                        addEdge(p, p2, 1);\n                    }\n                }\n\n                if (!invalid[i][j]) addEdge(s, p, 1);\n            } else if (!invalid[i][j]) addEdge(p, t, 1);\n        }\n    }\n\n    int maxFlow = dinic(s, t, n * m + 2);\n\n    if (maxFlow == 0) puts(\"LOSE\");\n    else {\n        puts(\"WIN\");\n\n        bfs(s, t);\n        for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) {\n            if ((i + j) % 2 == 0) {\n                if (N[Point(i, j)].fs) printf(\"%d %d\\n\", i + 1, j + 1);\n            } else {\n                if (N[Point(i, j)].ft) printf(\"%d %d\\n\", i + 1, j + 1);\n            }\n        }\n    }\n    // printf(\"%d\\n\", maxFlow);\n\n    /*\n    for (int i = 0; i < n * m + 2; i++) {\n        for (Edge *e = N[i].e; e; e = e->next) {\n            if (e->c > 0) printf(\"E(%ld, %ld, %d, [%d])\\n\", e->s - N, e->t - N, e->c, e->f);\n        }\n    }\n    */\n\n    return 0;\n}\n```\n","source":"_posts/jsoi2009-game.md","raw":"title: JSOI2009 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \n  - \n  - \n  - Dinic\npermalink: jsoi2009-game\ndate: 2016-04-28 22:10:42\n---\n\n $ N \\times M $ AA YY  AA \n\n\n\n AA \n\n<!-- more -->\n\n### \n[BZOJ 1443](http://www.lydsy.com/JudgeOnline/problem.php?id=1443)\n\n### \n AA  AA  AA \n\n\n\n YY  YY ******** AA  YY \n\n\n\n -  -  -   \n\n****\n\n Dinic  BFS********\n\n************ -  -  -   \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\nconst int DX[4] = { 1, 0, -1, 0 };\nconst int DY[4] = { 0, 1, 0, -1 };\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e, *c;\n    int l;\n    bool fs, ft;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n    Node *s, *t;\n    int f, c;\n    Edge *next, *r;\n\n    Edge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c) {\n    N[s].e = new Edge(&N[s], &N[t], c);\n    N[t].e = new Edge(&N[t], &N[s], 0);\n    (N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nstruct Dinic {\n    bool makeLevelGraph(Node *const s, Node *const t, const int n) {\n        for (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n        std::queue<Node *> q;\n        q.push(s);\n        s->l = 1;\n\n        while (!q.empty()) {\n            Node *v = q.front();\n            q.pop();\n\n            for (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n                e->t->l = v->l + 1;\n                if (e->t == t) return true;\n                else q.push(e->t);\n            }\n        }\n\n        return false;\n    }\n\n    int findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n        if (s == t) return limit;\n\n        for (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n            int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n            if (f > 0) {\n                e->f += f, e->r->f -= f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n\n    int operator()(const int s, const int t, const int n) {\n        int ans = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            int f;\n            while ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n        }\n        \n        return ans;\n    }\n} dinic;\n\nint n, m;\nchar invalid[MAXN][MAXN];\n\nstruct Point {\n    int i, j;\n\n    Point(const int i, const int j) : i(i), j(j) {}\n\n    operator int() const { return i * m + j + 1; }\n    bool valid() const { return i >= 0 && i < n && j >= 0 && j < m && !invalid[i][j]; }\n    Point offset(const int dx, const int dy) const { return Point(i + dx, j + dy); }\n};\n\ninline void bfs(const int s, const int t) {\n    std::queue<Node *> q;\n    q.push(&N[s]);\n    N[s].fs = true;\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) if (e->f < e->c && !e->t->fs) {\n            e->t->fs = true;\n            q.push(e->t);\n        }\n    }\n\n    q.push(&N[t]);\n    N[t].ft = true;\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) if (e->r->f < e->r->c && !e->t->ft) {\n            // printf(\"%ld to %ld\\n\", v - N + 1, e->t - N + 1);\n            e->t->ft = true;\n            q.push(e->t);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) {\n        char s[MAXN + 1];\n        scanf(\"%s\", s);\n        for (int j = 0; j < m; j++) {\n            invalid[i][j] = (s[j] == '#');\n        }\n    }\n\n    const int s = 0, t = n * m + 1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            Point p(i, j);\n            if (!p.valid()) continue;\n            if ((i + j) % 2 == 0) {\n                for (int k = 0; k < 4; k++) {\n                    Point p2 = p.offset(DX[k], DY[k]);\n                    if (p2.valid()) {\n                        addEdge(p, p2, 1);\n                    }\n                }\n\n                if (!invalid[i][j]) addEdge(s, p, 1);\n            } else if (!invalid[i][j]) addEdge(p, t, 1);\n        }\n    }\n\n    int maxFlow = dinic(s, t, n * m + 2);\n\n    if (maxFlow == 0) puts(\"LOSE\");\n    else {\n        puts(\"WIN\");\n\n        bfs(s, t);\n        for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) {\n            if ((i + j) % 2 == 0) {\n                if (N[Point(i, j)].fs) printf(\"%d %d\\n\", i + 1, j + 1);\n            } else {\n                if (N[Point(i, j)].ft) printf(\"%d %d\\n\", i + 1, j + 1);\n            }\n        }\n    }\n    // printf(\"%d\\n\", maxFlow);\n\n    /*\n    for (int i = 0; i < n * m + 2; i++) {\n        for (Edge *e = N[i].e; e; e = e->next) {\n            if (e->c > 0) printf(\"E(%ld, %ld, %d, [%d])\\n\", e->s - N, e->t - N, e->c, e->f);\n        }\n    }\n    */\n\n    return 0;\n}\n```\n","slug":"jsoi2009-game","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6ch100urc2xlvr7fw9x4"},{"title":"JSOI2008 -  + ","date":"2016-10-18T13:14:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1015](http://www.lydsy.com/JudgeOnline/problem.php?id=1015)\n\n### \n\n\n### \n```c++\n#include <cstdio>\n#include <vector>\n\nconst int MAXM = 200000;\nconst int MAXN = 2 * MAXM;\n\nstruct UnionFindSet {\n\tint a[MAXN], rk[MAXN];\n\n\tvoid init(const int n) { for (int i = 0; i < n; i++) a[i] = i, rk[i] = 1; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tbool test(const int x, const int y) { return find(x) == find(y); }\n\n\tvoid merge(const int x, const int y) {\n\t\tconst int p = find(x), q = find(y);\n\t\tif (p == q) return;\n\t\tif (rk[p] > rk[q]) a[q] = p;\n\t\telse if (rk[q] > rk[p]) a[p] = q;\n\t\telse a[p] = q, rk[q]++;\n\t}\n} ufs;\n\nstruct Edge {\n\tbool added;\n\tint u, v;\n} E[MAXM];\n\nstruct Node {\n\tstd::vector<Edge *> e;\n\tbool added;\n\tbool willDelete;\n} N[MAXN];\n\ninline void addAllEdge(Node *v, int &ans) {\n\tans++;\n\tfor (std::vector<Edge *>::const_iterator it = v->e.begin(); it != v->e.end(); it++) {\n\t\tEdge *const &e = *it;\n\t\tif (!e->added && N[e->u].added && N[e->v].added && !ufs.test(e->u, e->v)) {\n\t\t\tufs.merge(e->u, e->v);\n\t\t\t// printf(\"merge(%d, %d)\\n\", e->u, e->v);\n\t\t\tans--;\n\t\t\te->added = true;\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, m, k, ans;\n\tstatic int a[MAXN];\n\tscanf(\"%d %d\", &n, &m), ans = 0;\n\n\tufs.init(n);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d\", &E[i].u, &E[i].v), N[E[i].u].e.push_back(&E[i]), N[E[i].v].e.push_back(&E[i]);\n\n\tscanf(\"%d\", &k);\n\tfor (int i = k - 1; i >= 0; i--) scanf(\"%d\", &a[i]), N[a[i]].willDelete = true;\n\n\tfor (int i = 0; i < n; i++) if (!N[i].willDelete) N[i].added = true, addAllEdge(&N[i], ans);\n\n\tstd::vector<int> anses;\n\tanses.push_back(ans);\n\t\n\tfor (int i = 0; i < k; i++) {\n\t\t// printf(\"before %d\\n\", a[i]);\n\t\tNode *v = &N[a[i]];\n\t\tv->added = true;\n\t\taddAllEdge(v, ans);\n\t\tanses.push_back(ans);\n\t}\n\n\tfor (std::vector<int>::const_reverse_iterator it = anses.rbegin(); it != anses.rend(); it++) printf(\"%d\\n\", *it);\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2008-starwar.md","raw":"title: JSOI2008 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \n  - \npermalink: jsoi2008-starwar\ndate: 2016-10-18 21:14:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1015](http://www.lydsy.com/JudgeOnline/problem.php?id=1015)\n\n### \n\n\n### \n```c++\n#include <cstdio>\n#include <vector>\n\nconst int MAXM = 200000;\nconst int MAXN = 2 * MAXM;\n\nstruct UnionFindSet {\n\tint a[MAXN], rk[MAXN];\n\n\tvoid init(const int n) { for (int i = 0; i < n; i++) a[i] = i, rk[i] = 1; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tbool test(const int x, const int y) { return find(x) == find(y); }\n\n\tvoid merge(const int x, const int y) {\n\t\tconst int p = find(x), q = find(y);\n\t\tif (p == q) return;\n\t\tif (rk[p] > rk[q]) a[q] = p;\n\t\telse if (rk[q] > rk[p]) a[p] = q;\n\t\telse a[p] = q, rk[q]++;\n\t}\n} ufs;\n\nstruct Edge {\n\tbool added;\n\tint u, v;\n} E[MAXM];\n\nstruct Node {\n\tstd::vector<Edge *> e;\n\tbool added;\n\tbool willDelete;\n} N[MAXN];\n\ninline void addAllEdge(Node *v, int &ans) {\n\tans++;\n\tfor (std::vector<Edge *>::const_iterator it = v->e.begin(); it != v->e.end(); it++) {\n\t\tEdge *const &e = *it;\n\t\tif (!e->added && N[e->u].added && N[e->v].added && !ufs.test(e->u, e->v)) {\n\t\t\tufs.merge(e->u, e->v);\n\t\t\t// printf(\"merge(%d, %d)\\n\", e->u, e->v);\n\t\t\tans--;\n\t\t\te->added = true;\n\t\t}\n\t}\n}\n\nint main() {\n\tint n, m, k, ans;\n\tstatic int a[MAXN];\n\tscanf(\"%d %d\", &n, &m), ans = 0;\n\n\tufs.init(n);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d\", &E[i].u, &E[i].v), N[E[i].u].e.push_back(&E[i]), N[E[i].v].e.push_back(&E[i]);\n\n\tscanf(\"%d\", &k);\n\tfor (int i = k - 1; i >= 0; i--) scanf(\"%d\", &a[i]), N[a[i]].willDelete = true;\n\n\tfor (int i = 0; i < n; i++) if (!N[i].willDelete) N[i].added = true, addAllEdge(&N[i], ans);\n\n\tstd::vector<int> anses;\n\tanses.push_back(ans);\n\t\n\tfor (int i = 0; i < k; i++) {\n\t\t// printf(\"before %d\\n\", a[i]);\n\t\tNode *v = &N[a[i]];\n\t\tv->added = true;\n\t\taddAllEdge(v, ans);\n\t\tanses.push_back(ans);\n\t}\n\n\tfor (std::vector<int>::const_reverse_iterator it = anses.rbegin(); it != anses.rend(); it++) printf(\"%d\\n\", *it);\n\n\treturn 0;\n}\n```","slug":"jsoi2008-starwar","published":1,"updated":"2016-10-18T13:20:00.814Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6chb00v0c2xl0ekuj2ko"},{"title":"JSOI2008 - Splay + Hash","date":"2016-10-18T12:16:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1014](http://www.lydsy.com/JudgeOnline/problem.php?id=1014)\n\n### \n Splay  Hash Hash  Hash  Hash \n\n LCP \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 150000;\nconst unsigned long long BASE = 233;\n\nunsigned long long base[MAXN + 1];\n\nstruct Splay {\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tint size;\n\t\tchar val;\n\t\tunsigned long long hash;\n\n\t\tNode(Node *p, Node **r, const char val) : p(p), r(r), size(1), val(val), hash(val) {\n\t\t\tc[0] = c[1] = NULL;\n\t\t}\n\n\t\tint relation() { return this == p->c[0] ? 0 : 1; }\n\n\t\tvoid rotate() {\n\t\t\tNode *o = p;\n\t\t\tint x = relation();\n\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tNode *splay(Node *targetParent = NULL) {\n\t\t\twhile (p != targetParent) {\n\t\t\t\tif (p->p == targetParent) rotate();\n\t\t\t\telse if (relation() == p->relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = 1;\n\t\t\tif (c[0]) size += c[0]->size;\n\t\t\tif (c[1]) size += c[1]->size;\n\n\t\t\thash = val;\n\t\t\tif (c[1]) hash += c[1]->hash * BASE;\n\t\t\tif (c[0]) hash = hash * base[c[0]->size] + c[0]->hash;\n\t\t}\n\n\t\tint lsize() { return c[0] ? c[0]->size : 0; }\n\n\t\tvoid print(const int depth = 0) {\n\t\t\tif (c[1]) c[1]->print(depth + 1);\n\t\t\tfor (int i = 0; i < depth; i++) putchar(' ');\n\t\t\tprintf(\"%c\\n\", val == 0 ? ' ' : val);\n\t\t\tif (c[0]) c[0]->print(depth + 1);\n\t\t}\n\t} *r;\n\n\tSplay() : r(NULL) {}\n\n\tNode *build(const char *first, const char *last, Node *p) {\n\t\tif (first > last) return NULL;\n\t\tif (first == last) return new Node(p, &r, *first);\n\t\telse {\n\t\t\tconst char *mid = first + (last - first) / 2;\n\t\t\tNode *v = new Node(p, &r, *mid);\n\t\t\tv->c[0] = build(first, mid - 1, v);\n\t\t\tv->c[1] = build(mid + 1, last, v);\n\t\t\tv->maintain();\n\t\t\treturn v;\n\t\t}\n\t}\n\n\tvoid buildBounds(const int x) {\n\t\tNode *v = r;\n\t\twhile (v->c[x]) v = v->c[x];\n\t\tv->c[x] = new Node(v, &r, 0);\n\t\tNode *u = v;\n\t\tdo {\n\t\t\tu->maintain();\n\t\t\tu = u->p;\n\t\t} while (u);\n\t\tv->c[x]->splay();\n\t}\n\n\tvoid build(const char *first, const char *last) {\n\t\tr = build(first, last, NULL);\n\t\tbuildBounds(0);\n\t\tbuildBounds(1);\n\t}\n\n\tNode *select(const int k) {\n\t\tint x = k + 1;\n\t\tNode *v = r;\n\t\twhile (x != v->lsize() + 1) {\n\t\t\tif (x < v->lsize() + 1) v = v->c[0];\n\t\t\telse x -= v->lsize() + 1, v = v->c[1];\n\t\t}\n\t\treturn v->splay();\n\t}\n\n\tNode *select(const int l, const int r) {\n\t\tNode *a = select(l - 1), *b = select(r + 1);\n\t\ta->splay();\n\t\tb->splay(a);\n\t\treturn b->c[0];\n\t}\n\n\tNode *insert(const int pos, const char ch) {\n\t\tNode *a = select(pos), *b = select(pos + 1);\n\t\ta->splay();\n\t\tb->splay(a);\n\t\tb->c[0] = new Node(b, &r, ch);\n\t\tNode *v = b->c[0];\n\t\tdo {\n\t\t\tv->maintain();\n\t\t\tv = v->p;\n\t\t} while (v);\n\t\treturn b->c[0]->splay();\n\t}\n\n\tvoid update(const int pos, const char ch) {\n\t\tNode *v = select(pos);\n\t\tv->val = ch;\n\t\tv->maintain();\n\t}\n\n\tunsigned long long query(const int l, const int r) {\n\t\treturn select(l, r)->hash;\n\t}\n\n\tint size() { return r->size - 2; }\n} splay;\n\ninline void print() {\n\tsplay.r->print();\n\tputs(\"------------------------\");\n}\n\ninline int lcp(const int a, const int b) {\n\tint l = 0, r = std::min(splay.size() - a + 1, splay.size() - b + 1);\n\twhile (l != r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tif (splay.query(a, a + mid - 1) == splay.query(b, b + mid - 1)) {\n\t\t\tl = mid;\n\t\t} else {\n\t\t\tr = mid - 1;\n\t\t}\n\t}\n\treturn l;\n}\n\nint main() {\n\tbase[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) base[i] = base[i - 1] * BASE;\n\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tint n = strlen(s);\n\tsplay.build(s, s + n - 1);\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tchar cmd[2];\n\t\tscanf(\"%s\", cmd);\n\t\tif (cmd[0] == 'Q') {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tprintf(\"%d\\n\", lcp(a, b));\n\t\t} else if (cmd[0] == 'R') {\n\t\t\tint pos;\n\t\t\tchar ch[2];\n\t\t\tscanf(\"%d %s\", &pos, ch);\n\t\t\tsplay.update(pos, ch[0]);\n\t\t} else if (cmd[0] == 'I') {\n\t\t\tint pos;\n\t\t\tchar ch[2];\n\t\t\tscanf(\"%d %s\", &pos, ch);\n\t\t\tsplay.insert(pos, ch[0]);\n\t\t}\n\n\t\t// print();\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2008-prefix.md","raw":"title: JSOI2008 - Splay + Hash\ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - Splay\n  - Hash\n  - \npermalink: jsoi2008-prefix\ndate: 2016-10-18 20:16:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1014](http://www.lydsy.com/JudgeOnline/problem.php?id=1014)\n\n### \n Splay  Hash Hash  Hash  Hash \n\n LCP \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 150000;\nconst unsigned long long BASE = 233;\n\nunsigned long long base[MAXN + 1];\n\nstruct Splay {\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tint size;\n\t\tchar val;\n\t\tunsigned long long hash;\n\n\t\tNode(Node *p, Node **r, const char val) : p(p), r(r), size(1), val(val), hash(val) {\n\t\t\tc[0] = c[1] = NULL;\n\t\t}\n\n\t\tint relation() { return this == p->c[0] ? 0 : 1; }\n\n\t\tvoid rotate() {\n\t\t\tNode *o = p;\n\t\t\tint x = relation();\n\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relation()] = this;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tNode *splay(Node *targetParent = NULL) {\n\t\t\twhile (p != targetParent) {\n\t\t\t\tif (p->p == targetParent) rotate();\n\t\t\t\telse if (relation() == p->relation()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = 1;\n\t\t\tif (c[0]) size += c[0]->size;\n\t\t\tif (c[1]) size += c[1]->size;\n\n\t\t\thash = val;\n\t\t\tif (c[1]) hash += c[1]->hash * BASE;\n\t\t\tif (c[0]) hash = hash * base[c[0]->size] + c[0]->hash;\n\t\t}\n\n\t\tint lsize() { return c[0] ? c[0]->size : 0; }\n\n\t\tvoid print(const int depth = 0) {\n\t\t\tif (c[1]) c[1]->print(depth + 1);\n\t\t\tfor (int i = 0; i < depth; i++) putchar(' ');\n\t\t\tprintf(\"%c\\n\", val == 0 ? ' ' : val);\n\t\t\tif (c[0]) c[0]->print(depth + 1);\n\t\t}\n\t} *r;\n\n\tSplay() : r(NULL) {}\n\n\tNode *build(const char *first, const char *last, Node *p) {\n\t\tif (first > last) return NULL;\n\t\tif (first == last) return new Node(p, &r, *first);\n\t\telse {\n\t\t\tconst char *mid = first + (last - first) / 2;\n\t\t\tNode *v = new Node(p, &r, *mid);\n\t\t\tv->c[0] = build(first, mid - 1, v);\n\t\t\tv->c[1] = build(mid + 1, last, v);\n\t\t\tv->maintain();\n\t\t\treturn v;\n\t\t}\n\t}\n\n\tvoid buildBounds(const int x) {\n\t\tNode *v = r;\n\t\twhile (v->c[x]) v = v->c[x];\n\t\tv->c[x] = new Node(v, &r, 0);\n\t\tNode *u = v;\n\t\tdo {\n\t\t\tu->maintain();\n\t\t\tu = u->p;\n\t\t} while (u);\n\t\tv->c[x]->splay();\n\t}\n\n\tvoid build(const char *first, const char *last) {\n\t\tr = build(first, last, NULL);\n\t\tbuildBounds(0);\n\t\tbuildBounds(1);\n\t}\n\n\tNode *select(const int k) {\n\t\tint x = k + 1;\n\t\tNode *v = r;\n\t\twhile (x != v->lsize() + 1) {\n\t\t\tif (x < v->lsize() + 1) v = v->c[0];\n\t\t\telse x -= v->lsize() + 1, v = v->c[1];\n\t\t}\n\t\treturn v->splay();\n\t}\n\n\tNode *select(const int l, const int r) {\n\t\tNode *a = select(l - 1), *b = select(r + 1);\n\t\ta->splay();\n\t\tb->splay(a);\n\t\treturn b->c[0];\n\t}\n\n\tNode *insert(const int pos, const char ch) {\n\t\tNode *a = select(pos), *b = select(pos + 1);\n\t\ta->splay();\n\t\tb->splay(a);\n\t\tb->c[0] = new Node(b, &r, ch);\n\t\tNode *v = b->c[0];\n\t\tdo {\n\t\t\tv->maintain();\n\t\t\tv = v->p;\n\t\t} while (v);\n\t\treturn b->c[0]->splay();\n\t}\n\n\tvoid update(const int pos, const char ch) {\n\t\tNode *v = select(pos);\n\t\tv->val = ch;\n\t\tv->maintain();\n\t}\n\n\tunsigned long long query(const int l, const int r) {\n\t\treturn select(l, r)->hash;\n\t}\n\n\tint size() { return r->size - 2; }\n} splay;\n\ninline void print() {\n\tsplay.r->print();\n\tputs(\"------------------------\");\n}\n\ninline int lcp(const int a, const int b) {\n\tint l = 0, r = std::min(splay.size() - a + 1, splay.size() - b + 1);\n\twhile (l != r) {\n\t\tconst int mid = l + (r - l) / 2 + 1;\n\t\tif (splay.query(a, a + mid - 1) == splay.query(b, b + mid - 1)) {\n\t\t\tl = mid;\n\t\t} else {\n\t\t\tr = mid - 1;\n\t\t}\n\t}\n\treturn l;\n}\n\nint main() {\n\tbase[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) base[i] = base[i - 1] * BASE;\n\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tint n = strlen(s);\n\tsplay.build(s, s + n - 1);\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tchar cmd[2];\n\t\tscanf(\"%s\", cmd);\n\t\tif (cmd[0] == 'Q') {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tprintf(\"%d\\n\", lcp(a, b));\n\t\t} else if (cmd[0] == 'R') {\n\t\t\tint pos;\n\t\t\tchar ch[2];\n\t\t\tscanf(\"%d %s\", &pos, ch);\n\t\t\tsplay.update(pos, ch[0]);\n\t\t} else if (cmd[0] == 'I') {\n\t\t\tint pos;\n\t\t\tchar ch[2];\n\t\t\tscanf(\"%d %s\", &pos, ch);\n\t\t\tsplay.insert(pos, ch[0]);\n\t\t}\n\n\t\t// print();\n\t}\n\n\treturn 0;\n}\n```","slug":"jsoi2008-prefix","published":1,"updated":"2016-10-18T13:10:35.311Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6chj00v6c2xlqpdg3ocj"},{"title":"JSOI2008 - Splay","id":"56","updated":"2016-02-20T02:13:55.000Z","date":"2016-02-20T02:11:00.000Z","_content":"\n\n\n1.   \n   `Q L`  \n    `L`   \n   `L` \n2. \n   `A n`  \n    `n`  `t` `t`  `t = 0`) `D`   \n   `n` \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1012](http://www.lydsy.com/JudgeOnline/problem.php?id=1012)\n\n### \nSplay  \n\n\n\n Splay qwq\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXM = 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *parent, *child[2], **root;\n\t\tint value, max;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), bound(bound), size(1) {}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t\tmax = value;\n\t\t\tif (child[L] && !child[L]->bound) max = std::max(max, child[L]->max);\n\t\t\tif (child[R] && !child[R]->bound) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation r = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[r] = child[r ^ 1];\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\n\t\t\tchild[r ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid print(int depth = 0) {\n\t\t\tif (child[L]) child[L]->print(depth + 1);\n\t\t\tfor (int i = 0; i < depth; i++) putchar(' ');\n\t\t\t//printf(\"%d\\n\", value);\n\t\t\tif (child[R]) child[R]->print(depth + 1);\n\t\t}\n\t} *root;\n\n\tSplay() {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tvoid print() {\n\t\troot->print();\n\t\tputs(\"---------------------------\");\n\t}\n\n\tvoid buildBound(Relation r) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[r];\n\t\t}\n\n\t\t*v = new Node(parent, r == L ? -1 : 1, &root, true);\n\t}\n\n\tvoid append(const T &value) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tif (parent->bound && parent->value == 1) v = &parent->child[L];\n\t\t\telse v = &parent->child[R];\n\t\t}\n\n\t\t*v = new Node(parent, value, &root);\n\t\t//print();\n\t\t(*v)->splay();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (k != v->rank() + 1) {\n\t\t\t//printf(\"select(k = %d) in [%d] - { size = %d, rank = %d }\\n\", k, v->value, v->size, v->rank());\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *pred = select(l)->pred();\n\t\tNode *succ = select(r)->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(root);\n\t\treturn succ->child[L];\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\treturn select(l, r)->max;\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint m, p, lastAns;\nSplay<int> splay;\n\ninline char isVaild(char ch) {\n\treturn ch == 'A' || ch == 'Q';\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &p);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar cmd;\n\t\twhile (!isVaild(cmd = getchar()));\n\t\t//printf(\"cmd('%c')\\n\", cmd);\n\n\t\tif (cmd == 'A') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tsplay.append((n + lastAns) % p);\n\t\t} else {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n\n\t\t\tprintf(\"%d\\n\", lastAns = splay.queryMax(splay.size() - l + 1, splay.size()));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2008-maxnumber.md","raw":"title: JSOI2008 - Splay\ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - Splay\n  - \n  - \npermalink: jsoi2008-maxnumber\nid: 56\nupdated: '2016-02-20 10:13:55'\ndate: 2016-02-20 10:11:00\n---\n\n\n\n1.   \n   `Q L`  \n    `L`   \n   `L` \n2. \n   `A n`  \n    `n`  `t` `t`  `t = 0`) `D`   \n   `n` \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1012](http://www.lydsy.com/JudgeOnline/problem.php?id=1012)\n\n### \nSplay  \n\n\n\n Splay qwq\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXM = 200000;\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *parent, *child[2], **root;\n\t\tint value, max;\n\t\tint size;\n\t\tbool bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), root(root), bound(bound), size(1) {}\n\n\t\tvoid maintain() {\n\t\t\tsize = (child[L] ? child[L]->size : 0) + (child[R] ? child[R]->size : 0) + 1;\n\t\t\tmax = value;\n\t\t\tif (child[L] && !child[L]->bound) max = std::max(max, child[L]->max);\n\t\t\tif (child[R] && !child[R]->bound) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation r = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[r] = child[r ^ 1];\n\t\t\tif (child[r ^ 1]) child[r ^ 1]->parent = oldParent;\n\n\t\t\tchild[r ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse if (relation() == parent->relation()) parent->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn child[L] ? child[L]->size : 0;\n\t\t}\n\n\t\tNode *pred() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[L];\n\t\t\twhile (v->child[R]) v = v->child[R];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = this->child[R];\n\t\t\twhile (v->child[L]) v = v->child[L];\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid print(int depth = 0) {\n\t\t\tif (child[L]) child[L]->print(depth + 1);\n\t\t\tfor (int i = 0; i < depth; i++) putchar(' ');\n\t\t\t//printf(\"%d\\n\", value);\n\t\t\tif (child[R]) child[R]->print(depth + 1);\n\t\t}\n\t} *root;\n\n\tSplay() {\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tvoid print() {\n\t\troot->print();\n\t\tputs(\"---------------------------\");\n\t}\n\n\tvoid buildBound(Relation r) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[r];\n\t\t}\n\n\t\t*v = new Node(parent, r == L ? -1 : 1, &root, true);\n\t}\n\n\tvoid append(const T &value) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tif (parent->bound && parent->value == 1) v = &parent->child[L];\n\t\t\telse v = &parent->child[R];\n\t\t}\n\n\t\t*v = new Node(parent, value, &root);\n\t\t//print();\n\t\t(*v)->splay();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\twhile (k != v->rank() + 1) {\n\t\t\t//printf(\"select(k = %d) in [%d] - { size = %d, rank = %d }\\n\", k, v->value, v->size, v->rank());\n\t\t\tif (k < v->rank() + 1) v = v->child[L];\n\t\t\telse k -= v->rank() + 1, v = v->child[R];\n\t\t}\n\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *pred = select(l)->pred();\n\t\tNode *succ = select(r)->succ();\n\n\t\tpred->splay();\n\t\tsucc->splay(root);\n\t\treturn succ->child[L];\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\treturn select(l, r)->max;\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nint m, p, lastAns;\nSplay<int> splay;\n\ninline char isVaild(char ch) {\n\treturn ch == 'A' || ch == 'Q';\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &p);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tchar cmd;\n\t\twhile (!isVaild(cmd = getchar()));\n\t\t//printf(\"cmd('%c')\\n\", cmd);\n\n\t\tif (cmd == 'A') {\n\t\t\tint n;\n\t\t\tscanf(\"%d\", &n);\n\n\t\t\tsplay.append((n + lastAns) % p);\n\t\t} else {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n\n\t\t\tprintf(\"%d\\n\", lastAns = splay.queryMax(splay.size() - l + 1, splay.size()));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"jsoi2008-maxnumber","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6chs00vdc2xlb6u1m4b9"},{"title":"JSOI2008 -  DP","date":"2016-07-11T15:10:00.000Z","_content":"\n $ M $ \n\n<!-- more -->\n\n### \n[BZOJ 1017](http://www.lydsy.com/JudgeOnline/problem.php?id=1017)\n\n### \n$ f(i, j) $  $ i $  $ j $ \n\n $ g(i, j) $  $ i $  $ j $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <queue>\n\nconst int MAXN = 51;\nconst int MAXM = 2000;\nconst int MAXK = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint cnt, cost, val, ind;\n\tbool basic; // , visited;\n\tint f[MAXK + 1][MAXM + 1];\n} N[MAXN], *seq[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\t// printf(\"E(%d, %d, %d)\\n\", s, t, w);\n\tN[t].ind++;\n\tN[s].e = new Edge(&N[s], &N[t], w);\n}\n\nint n, m, ans;\n\ninline void bfs() {\n\tint pos = n;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].ind) continue;\n\t\t// printf(\"%d\\n\", i);\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\t// N[i].visited = true;\n\n\t\twhile (!q.empty()) {\n\t\t\tfor (Edge *e = (seq[--pos] = q.front())->e; e; e = e->next) q.push(e->t); // , e->t->visited = true;\n\t\t\tq.pop();\n\t\t}\n\t}\n}\n\ninline void dp1() {\n\tfor (int i = 0; i < n; i++) {\n\t\tNode *&v = seq[i];\n\t\tif (!v->basic) {\n\t\t\tv->cnt = INT_MAX;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tv->cnt = std::min(v->cnt, e->t->cnt / e->w);\n\t\t\t\tv->cost += e->t->cost * e->w;\n\t\t\t}\n\t\t\tv->cnt = std::min(v->cnt, m / v->cost);\n\t\t}\n\t}\n}\n\ninline void dp2() {\n\tfor (int i = 0; i < n; i++) {\n\t\tNode *&v = seq[i];\n\t\tint (&f)[MAXK + 1][MAXM + 1] = v->f;\n\t\tstatic int g[MAXN + 1][MAXM + 1];\n\n\t\tif (v->basic) {\n\t\t\tfor (int i = 0; i <= v->cnt; i++) {\n\t\t\t\tfor (int j = v->cost * i; j <= m; j++) {\n\t\t\t\t\tf[i][j] = std::max(f[i][j], std::min(v->cnt - i, (j - v->cost * i) / v->cost) * v->val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i <= v->cnt; i++) {\n\t\t\t\t// memset(g, 0, sizeof(g));\n\t\t\t\tfor (int i = 0; i <= MAXN; i++) for (int j = 0; j <= MAXM; j++) g[i][j] = i == 0 ? 0 : INT_MIN;\n\t\t\t\t// if (!v->e) {\n\t\t\t\t\t/*\n\t\t\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\t\t\tfor (int k = v->cost * i; k <= m; k++) {\n\t\t\t\t\t\t\tf[j][k] = std::max(f[j][k], v->val * (i - j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t// } else {\n\t\t\t\t\t// for (int j = v->cost * i; j <= m; j++) g[j] = v->val * i;\n\n\t\t\t\tint id = 0;\n\t\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\t\tid++;\n\t\t\t\t\tfor (int j = m; j >= 0; j--) {\n\t\t\t\t\t\tfor (int k = i * e->w * e->t->cost; k <= j; k++) {\n\t\t\t\t\t\t\tg[id][j] = std::max(g[id][j], g[id - 1][j - k] + e->t->f[e->w * i][k]);\n\t\t\t\t\t\t\t// if (j - k * e->t->cost >= v->cost * i) g[i][j] = std::max(g[i][j], g[i][j - k * e->t->cost]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// printf(\"g[%d][%d] = %d\\n\", i, j, g[i][j]);\n\t\t\t\t}\n\n\t\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\t\tfor (int k = v->cost * i; k <= m; k++) {\n\t\t\t\t\t\tf[j][k] = std::max(f[j][k], g[id][k] + (i - j) * v->val);\n\t\t\t\t\t\tans = std::max(ans, f[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &N[i].val);\n\t\tchar s[2];\n\t\tscanf(\"%s\", s);\n\n\t\tif (s[0] == 'B') {\n\t\t\tscanf(\"%d %d\", &N[i].cost, &N[i].cnt);\n\t\t\tN[i].basic = true;\n\t\t} else {\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\twhile (t--) {\n\t\t\t\tint u, w;\n\t\t\t\tscanf(\"%d %d\", &u, &w), u--;\n\t\t\t\taddEdge(i, u, w);\n\t\t\t}\n\t\t}\n\t}\n\n\tbfs();\n\tdp1();\n\tdp2();\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/jsoi2008-dotr.md","raw":"title: JSOI2008 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - DP\n  -  DP\npermalink: jsoi2008-dotr\ndate: 2016-07-11 23:10:00\n---\n\n $ M $ \n\n<!-- more -->\n\n### \n[BZOJ 1017](http://www.lydsy.com/JudgeOnline/problem.php?id=1017)\n\n### \n$ f(i, j) $  $ i $  $ j $ \n\n $ g(i, j) $  $ i $  $ j $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <queue>\n\nconst int MAXN = 51;\nconst int MAXM = 2000;\nconst int MAXK = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint cnt, cost, val, ind;\n\tbool basic; // , visited;\n\tint f[MAXK + 1][MAXM + 1];\n} N[MAXN], *seq[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\t// printf(\"E(%d, %d, %d)\\n\", s, t, w);\n\tN[t].ind++;\n\tN[s].e = new Edge(&N[s], &N[t], w);\n}\n\nint n, m, ans;\n\ninline void bfs() {\n\tint pos = n;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].ind) continue;\n\t\t// printf(\"%d\\n\", i);\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\t// N[i].visited = true;\n\n\t\twhile (!q.empty()) {\n\t\t\tfor (Edge *e = (seq[--pos] = q.front())->e; e; e = e->next) q.push(e->t); // , e->t->visited = true;\n\t\t\tq.pop();\n\t\t}\n\t}\n}\n\ninline void dp1() {\n\tfor (int i = 0; i < n; i++) {\n\t\tNode *&v = seq[i];\n\t\tif (!v->basic) {\n\t\t\tv->cnt = INT_MAX;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tv->cnt = std::min(v->cnt, e->t->cnt / e->w);\n\t\t\t\tv->cost += e->t->cost * e->w;\n\t\t\t}\n\t\t\tv->cnt = std::min(v->cnt, m / v->cost);\n\t\t}\n\t}\n}\n\ninline void dp2() {\n\tfor (int i = 0; i < n; i++) {\n\t\tNode *&v = seq[i];\n\t\tint (&f)[MAXK + 1][MAXM + 1] = v->f;\n\t\tstatic int g[MAXN + 1][MAXM + 1];\n\n\t\tif (v->basic) {\n\t\t\tfor (int i = 0; i <= v->cnt; i++) {\n\t\t\t\tfor (int j = v->cost * i; j <= m; j++) {\n\t\t\t\t\tf[i][j] = std::max(f[i][j], std::min(v->cnt - i, (j - v->cost * i) / v->cost) * v->val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i <= v->cnt; i++) {\n\t\t\t\t// memset(g, 0, sizeof(g));\n\t\t\t\tfor (int i = 0; i <= MAXN; i++) for (int j = 0; j <= MAXM; j++) g[i][j] = i == 0 ? 0 : INT_MIN;\n\t\t\t\t// if (!v->e) {\n\t\t\t\t\t/*\n\t\t\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\t\t\tfor (int k = v->cost * i; k <= m; k++) {\n\t\t\t\t\t\t\tf[j][k] = std::max(f[j][k], v->val * (i - j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t// } else {\n\t\t\t\t\t// for (int j = v->cost * i; j <= m; j++) g[j] = v->val * i;\n\n\t\t\t\tint id = 0;\n\t\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\t\tid++;\n\t\t\t\t\tfor (int j = m; j >= 0; j--) {\n\t\t\t\t\t\tfor (int k = i * e->w * e->t->cost; k <= j; k++) {\n\t\t\t\t\t\t\tg[id][j] = std::max(g[id][j], g[id - 1][j - k] + e->t->f[e->w * i][k]);\n\t\t\t\t\t\t\t// if (j - k * e->t->cost >= v->cost * i) g[i][j] = std::max(g[i][j], g[i][j - k * e->t->cost]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// printf(\"g[%d][%d] = %d\\n\", i, j, g[i][j]);\n\t\t\t\t}\n\n\t\t\t\tfor (int j = 0; j <= i; j++) {\n\t\t\t\t\tfor (int k = v->cost * i; k <= m; k++) {\n\t\t\t\t\t\tf[j][k] = std::max(f[j][k], g[id][k] + (i - j) * v->val);\n\t\t\t\t\t\tans = std::max(ans, f[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &N[i].val);\n\t\tchar s[2];\n\t\tscanf(\"%s\", s);\n\n\t\tif (s[0] == 'B') {\n\t\t\tscanf(\"%d %d\", &N[i].cost, &N[i].cnt);\n\t\t\tN[i].basic = true;\n\t\t} else {\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\twhile (t--) {\n\t\t\t\tint u, w;\n\t\t\t\tscanf(\"%d %d\", &u, &w), u--;\n\t\t\t\taddEdge(i, u, w);\n\t\t\t}\n\t\t}\n\t}\n\n\tbfs();\n\tdp1();\n\tdp2();\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"jsoi2008-dotr","published":1,"updated":"2016-10-24T23:37:01.646Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6chz00vkc2xlhma496vk"},{"title":"JSOI2008 - ","date":"2016-10-18T13:34:00.000Z","_content":"\n $ \\leq 10 $\n\n<!-- more -->\n\n### \n[BZOJ 1016](http://www.lydsy.com/JudgeOnline/problem.php?id=1016)\n\n### \n> \n\nhttps://blog.sengxian.com/solutions/bzoj-1016\n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nconst int MAXN = 100;\nconst int MAXM = 1000;\nconst int MAXC = 1000000000;\nconst int MOD = 31011;\n\nstruct Edge {\n\tint u, v, w;\n\tbool used;\n\n\tbool operator<(const Edge &other) const { return w < other.w; }\n} E[MAXM];\n\nstruct UnionFindSet {\n\tint a[MAXN];\n\n\tvoid init(const int n) { for (int i = 0; i < n; i++) a[i] = i; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tvoid merge(const int x, const int y) {\n\t\ta[find(x)] = find(y);\n\t}\n\n\tbool test(const int x, const int y) { return find(x) == find(y); }\n} ufs;\n\nstruct EdgeGroup {\n\tint used;\n\tstd::vector<Edge> edges;\n};\n\nint n, m, graph[MAXN][MAXN];\nstd::map<int, EdgeGroup> groups;\n\ninline bool kruskal() {\n\tstd::sort(E, E + m);\n\tufs.init(n);\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!ufs.test(E[i].u, E[i].v)) {\n\t\t\tufs.merge(E[i].u, E[i].v);\n\t\t\tE[i].used = true;\n\t\t\tgroups[E[i].w].used++;\n\t\t\tcnt++;\n\t\t}\n\t\tgroups[E[i].w].edges.push_back(E[i]);\n\t}\n\treturn cnt == n - 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d\", &E[i].u, &E[i].v, &E[i].w), E[i].u--, E[i].v--;\n\t}\n\n\tif (!kruskal()) {\n\t\tputs(\"0\");\n\t} else {\n\t\tlong long ans = 1;\n\t\tfor (int i = 0; i < m; i++) if (E[i].used) graph[E[i].u][E[i].v] = graph[E[i].v][E[i].u] = true;\n\t\tfor (std::map<int, EdgeGroup>::const_iterator it = groups.begin(); it != groups.end(); it++) {\n\t\t\tif (it->second.used == 0) continue;\n\t\t\tint t = 0;\n\t\t\tfor (unsigned int s = 1; s < (1 << it->second.edges.size()); s++) {\n\t\t\t\tint popcount = 0;\n\t\t\t\tfor (unsigned int i = 0; i < it->second.edges.size(); i++) if (s & (1 << i)) popcount++;\n\t\t\t\tif (popcount != it->second.used) continue;\n\n\t\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = false;\n\t\t\t\t}\n\n\t\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\t\tif (!(s & (1 << (e - it->second.edges.begin())))) continue;\n\n\t\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = true;\n\t\t\t\t}\n\n\t\t\t\tufs.init(n);\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\t\tif (graph[i][j]) {\n\t\t\t\t\t\t\tif (ufs.test(i, j)) {\n\t\t\t\t\t\t\t\tgoto nextLoop;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tufs.merge(i, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tt++;\nnextLoop:;\n\t\t\t}\n\t\t\t// printf(\"t = %d\\n\", t);\n\t\t\t(ans *= t) %= MOD;\n\n\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = e->used;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2008-award.md","raw":"title: JSOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \n  - \npermalink: jsoi2008-award\ndate: 2016-10-18 21:34:00\n---\n\n $ \\leq 10 $\n\n<!-- more -->\n\n### \n[BZOJ 1016](http://www.lydsy.com/JudgeOnline/problem.php?id=1016)\n\n### \n> \n\nhttps://blog.sengxian.com/solutions/bzoj-1016\n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nconst int MAXN = 100;\nconst int MAXM = 1000;\nconst int MAXC = 1000000000;\nconst int MOD = 31011;\n\nstruct Edge {\n\tint u, v, w;\n\tbool used;\n\n\tbool operator<(const Edge &other) const { return w < other.w; }\n} E[MAXM];\n\nstruct UnionFindSet {\n\tint a[MAXN];\n\n\tvoid init(const int n) { for (int i = 0; i < n; i++) a[i] = i; }\n\n\tint find(const int x) { return x == a[x] ? x : a[x] = find(a[x]); }\n\n\tvoid merge(const int x, const int y) {\n\t\ta[find(x)] = find(y);\n\t}\n\n\tbool test(const int x, const int y) { return find(x) == find(y); }\n} ufs;\n\nstruct EdgeGroup {\n\tint used;\n\tstd::vector<Edge> edges;\n};\n\nint n, m, graph[MAXN][MAXN];\nstd::map<int, EdgeGroup> groups;\n\ninline bool kruskal() {\n\tstd::sort(E, E + m);\n\tufs.init(n);\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!ufs.test(E[i].u, E[i].v)) {\n\t\t\tufs.merge(E[i].u, E[i].v);\n\t\t\tE[i].used = true;\n\t\t\tgroups[E[i].w].used++;\n\t\t\tcnt++;\n\t\t}\n\t\tgroups[E[i].w].edges.push_back(E[i]);\n\t}\n\treturn cnt == n - 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d\", &E[i].u, &E[i].v, &E[i].w), E[i].u--, E[i].v--;\n\t}\n\n\tif (!kruskal()) {\n\t\tputs(\"0\");\n\t} else {\n\t\tlong long ans = 1;\n\t\tfor (int i = 0; i < m; i++) if (E[i].used) graph[E[i].u][E[i].v] = graph[E[i].v][E[i].u] = true;\n\t\tfor (std::map<int, EdgeGroup>::const_iterator it = groups.begin(); it != groups.end(); it++) {\n\t\t\tif (it->second.used == 0) continue;\n\t\t\tint t = 0;\n\t\t\tfor (unsigned int s = 1; s < (1 << it->second.edges.size()); s++) {\n\t\t\t\tint popcount = 0;\n\t\t\t\tfor (unsigned int i = 0; i < it->second.edges.size(); i++) if (s & (1 << i)) popcount++;\n\t\t\t\tif (popcount != it->second.used) continue;\n\n\t\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = false;\n\t\t\t\t}\n\n\t\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\t\tif (!(s & (1 << (e - it->second.edges.begin())))) continue;\n\n\t\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = true;\n\t\t\t\t}\n\n\t\t\t\tufs.init(n);\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\t\tif (graph[i][j]) {\n\t\t\t\t\t\t\tif (ufs.test(i, j)) {\n\t\t\t\t\t\t\t\tgoto nextLoop;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tufs.merge(i, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tt++;\nnextLoop:;\n\t\t\t}\n\t\t\t// printf(\"t = %d\\n\", t);\n\t\t\t(ans *= t) %= MOD;\n\n\t\t\tfor (std::vector<Edge>::const_iterator e = it->second.edges.begin(); e != it->second.edges.end(); e++) {\n\t\t\t\tgraph[e->u][e->v] = graph[e->v][e->u] = e->used;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"jsoi2008-award","published":1,"updated":"2016-10-18T13:41:02.436Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6ci600vqc2xlsfb6onqi"},{"title":"JSOI2007 - ","date":"2016-11-13T01:11:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1029](http://www.lydsy.com/JudgeOnline/problem.php?id=1029)\n\n### \n****\n\n\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nconst int MAXN = 150000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic std::pair<int, int> a[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[i].second, &a[i].first);\n\n\tstd::sort(a, a + n);\n\n\tstd::priority_queue<int> q;\n\tlong long t = 0;\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (t + a[i].second <= a[i].first) {\n\t\t\tt += a[i].second;\n\t\t\tq.push(a[i].second);\n\t\t\tans++;\n\t\t} else if (!q.empty() && q.top() > a[i].second) {\n\t\t\tt -= q.top();\n\t\t\tt += a[i].second;\n\t\t\tq.pop();\n\t\t\tq.push(a[i].second);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2007-repair.md","raw":"title: JSOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \npermalink: jsoi2007-repair\ndate: 2016-11-13 09:11:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1029](http://www.lydsy.com/JudgeOnline/problem.php?id=1029)\n\n### \n****\n\n\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nconst int MAXN = 150000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic std::pair<int, int> a[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[i].second, &a[i].first);\n\n\tstd::sort(a, a + n);\n\n\tstd::priority_queue<int> q;\n\tlong long t = 0;\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (t + a[i].second <= a[i].first) {\n\t\t\tt += a[i].second;\n\t\t\tq.push(a[i].second);\n\t\t\tans++;\n\t\t} else if (!q.empty() && q.top() > a[i].second) {\n\t\t\tt -= q.top();\n\t\t\tt += a[i].second;\n\t\t\tq.pop();\n\t\t\tq.push(a[i].second);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"jsoi2007-repair","published":1,"updated":"2016-11-13T01:25:57.614Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cid00vwc2xllxfci3g6"},{"title":"JSOI2007 -  + ","date":"2016-11-13T00:27:00.000Z","_content":"\n\n $ 1 $  $ n $  $ 3m + 2 $  $ 3m $  $ m $  $ 3m + 1 $ \n\n<!-- more -->\n\n### \n[BZOJ 1028](http://www.lydsy.com/JudgeOnline/problem.php?id=1028)\n\n### \n $ +1 $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 400;\nconst int MAXM = 1000;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN];\n\tfor (int i = 0; i < m * 3 + 1; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\ta[x - 1]++;\n\t}\n\n\tstatic int ans[MAXN];\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic int b[MAXN];\n\t\tstd::copy(a, a + n, b);\n\t\tb[i]++;\n\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (b[j] >= 2) {\n\t\t\t\tstatic int c[MAXN + 2];\n\t\t\t\tstd::copy(b, b + n, c);\n\t\t\t\tc[j] -= 2;\n\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (c[k] == 0) continue;\n\t\t\t\t\tc[k] %= 3;\n\t\t\t\t\tint x = std::min(std::min(c[k], c[k + 1]), c[k + 2]);\n\t\t\t\t\tif (x < c[k]) goto fail;\n\t\t\t\t\tc[k] -= x, c[k + 1] -= x, c[k + 2] -= x;\n\t\t\t\t}\n\n\t\t\t\tgoto success;\n\nfail:;\n\t\t\t}\n\t\t}\n\n\t\tcontinue;\n\nsuccess:\n\t\tans[cnt++] = i + 1;\n\t}\n\n\tif (cnt) {\n\t\tfor (int i = 0; i < cnt; i++) printf(\"%d%c\", ans[i], i == cnt - 1 ? '\\n' : ' ');\n\t} else puts(\"NO\");\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2007-mahjong.md","raw":"title: JSOI2007 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \n  - \npermalink: jsoi2007-mahjong\ndate: 2016-11-13 08:27:00\n---\n\n\n $ 1 $  $ n $  $ 3m + 2 $  $ 3m $  $ m $  $ 3m + 1 $ \n\n<!-- more -->\n\n### \n[BZOJ 1028](http://www.lydsy.com/JudgeOnline/problem.php?id=1028)\n\n### \n $ +1 $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 400;\nconst int MAXM = 1000;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN];\n\tfor (int i = 0; i < m * 3 + 1; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\ta[x - 1]++;\n\t}\n\n\tstatic int ans[MAXN];\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic int b[MAXN];\n\t\tstd::copy(a, a + n, b);\n\t\tb[i]++;\n\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (b[j] >= 2) {\n\t\t\t\tstatic int c[MAXN + 2];\n\t\t\t\tstd::copy(b, b + n, c);\n\t\t\t\tc[j] -= 2;\n\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (c[k] == 0) continue;\n\t\t\t\t\tc[k] %= 3;\n\t\t\t\t\tint x = std::min(std::min(c[k], c[k + 1]), c[k + 2]);\n\t\t\t\t\tif (x < c[k]) goto fail;\n\t\t\t\t\tc[k] -= x, c[k + 1] -= x, c[k + 2] -= x;\n\t\t\t\t}\n\n\t\t\t\tgoto success;\n\nfail:;\n\t\t\t}\n\t\t}\n\n\t\tcontinue;\n\nsuccess:\n\t\tans[cnt++] = i + 1;\n\t}\n\n\tif (cnt) {\n\t\tfor (int i = 0; i < cnt; i++) printf(\"%d%c\", ans[i], i == cnt - 1 ? '\\n' : ' ');\n\t} else puts(\"NO\");\n\n\treturn 0;\n}\n```","slug":"jsoi2007-mahjong","published":1,"updated":"2016-11-13T00:32:35.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cij00w1c2xldyt70jjs"},{"title":"JSOI2007 - AC ","date":"2016-09-11T23:19:00.000Z","_content":"\n    \n\n $ a $  $ b $ $ b $  $ a $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1030](http://www.lydsy.com/JudgeOnline/problem.php?id=1030)\n\n### \n\n\n DP    $ i $  $ j $  KMP \n\n KMP  AC  $ j $  AC  $ j $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 60;\nconst int MAXM = 100;\nconst int CHARSET_SIZE = 'Z' - 'A' + 1;\nconst char BASE_CHAR = 'A';\nconst int MOD = 10007;\n\nstruct Trie {\n\tstruct Node {\n\t\tint id;\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node(false);\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tbool next(Node *v, const char ch, Node *&next) {\n\t\twhile (v != root && !v->c[ch]) v = v->fail;\n\t\tnext = v->c[ch] ? v->c[ch] : root;\n\t\tif (!v->c[ch]) return false;\n\t\telse if (v->c[ch]->isWord) return true;\n\t\telse if (v->c[ch]->next) return true;\n\t\telse return false;\n\t}\n\n\tvoid getNodeList(std::vector<Node *> &vec) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tvec.push_back(v);\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) if (v->c[i]) q.push(v->c[i]);\n\t\t}\n\t}\n} t;\n\ninline int pow(int x, int n) {\n\tint ans = 1;\n\tfor (; n; n >>= 1, x = x * x % MOD) if (n & 1) ans = ans * x % MOD;\n\treturn ans;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (n--) {\n\t\tchar s[MAXM + 1];\n\t\tscanf(\"%s\", s);\n\t\tint len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\n\tstd::vector<Trie::Node *> vec;\n\tt.getNodeList(vec);\n\n\t// std::tr1::unordered_map<Trie::Node *, int> f[MAXM + 1];\n\tstatic int f[MAXM + 1][MAXM * MAXN + 1];\n\t// for (size_t i = 0; i < vec.size(); i++) for (int j = 0; j < CHARSET_SIZE; j++) if (!vec[i]->c[j] || !vec[i]->c[j]->isWord) f[1][vec[i]]++;\n\tfor (size_t i = 0; i < vec.size(); i++) vec[i]->id = i, f[0][i] = 1;\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) {\n\t\t\tfor (int k = 0; k < CHARSET_SIZE; k++) {\n\t\t\t\tTrie::Node *next;\n\t\t\t\tif (!t.next(vec[j], k, next)) {\n\t\t\t\t\t(f[i][j] += f[i - 1][next->id]) %= MOD;\n\t\t\t\t\t// if (k <= 5) printf(\"(%d, %lu) => %d (%d)\\n\", i, j, k, f[i - 1][next]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) printf(\"f(%d, %lu) = %d\\n\", i, j, f[i][vec[j]]);\n\t\tputchar('\\n');\n\t}\n\t// */\n\n\t// printf(\"%d\\n\", f[m][t.root]);\n\tprintf(\"%d\\n\", ((pow(CHARSET_SIZE, m) - f[m][t.root->id]) % MOD + MOD) % MOD);\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2007-generator.md","raw":"title: JSOI2007 - AC \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \n  - AC \n  - DP\npermalink: jsoi2007-generator\ndate: 2016-09-12 07:19:00\n---\n\n    \n\n $ a $  $ b $ $ b $  $ a $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1030](http://www.lydsy.com/JudgeOnline/problem.php?id=1030)\n\n### \n\n\n DP    $ i $  $ j $  KMP \n\n KMP  AC  $ j $  AC  $ j $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 60;\nconst int MAXM = 100;\nconst int CHARSET_SIZE = 'Z' - 'A' + 1;\nconst char BASE_CHAR = 'A';\nconst int MOD = 10007;\n\nstruct Trie {\n\tstruct Node {\n\t\tint id;\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node(false);\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tbool next(Node *v, const char ch, Node *&next) {\n\t\twhile (v != root && !v->c[ch]) v = v->fail;\n\t\tnext = v->c[ch] ? v->c[ch] : root;\n\t\tif (!v->c[ch]) return false;\n\t\telse if (v->c[ch]->isWord) return true;\n\t\telse if (v->c[ch]->next) return true;\n\t\telse return false;\n\t}\n\n\tvoid getNodeList(std::vector<Node *> &vec) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tvec.push_back(v);\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) if (v->c[i]) q.push(v->c[i]);\n\t\t}\n\t}\n} t;\n\ninline int pow(int x, int n) {\n\tint ans = 1;\n\tfor (; n; n >>= 1, x = x * x % MOD) if (n & 1) ans = ans * x % MOD;\n\treturn ans;\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (n--) {\n\t\tchar s[MAXM + 1];\n\t\tscanf(\"%s\", s);\n\t\tint len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\n\tstd::vector<Trie::Node *> vec;\n\tt.getNodeList(vec);\n\n\t// std::tr1::unordered_map<Trie::Node *, int> f[MAXM + 1];\n\tstatic int f[MAXM + 1][MAXM * MAXN + 1];\n\t// for (size_t i = 0; i < vec.size(); i++) for (int j = 0; j < CHARSET_SIZE; j++) if (!vec[i]->c[j] || !vec[i]->c[j]->isWord) f[1][vec[i]]++;\n\tfor (size_t i = 0; i < vec.size(); i++) vec[i]->id = i, f[0][i] = 1;\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) {\n\t\t\tfor (int k = 0; k < CHARSET_SIZE; k++) {\n\t\t\t\tTrie::Node *next;\n\t\t\t\tif (!t.next(vec[j], k, next)) {\n\t\t\t\t\t(f[i][j] += f[i - 1][next->id]) %= MOD;\n\t\t\t\t\t// if (k <= 5) printf(\"(%d, %lu) => %d (%d)\\n\", i, j, k, f[i - 1][next]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) printf(\"f(%d, %lu) = %d\\n\", i, j, f[i][vec[j]]);\n\t\tputchar('\\n');\n\t}\n\t// */\n\n\t// printf(\"%d\\n\", f[m][t.root]);\n\tprintf(\"%d\\n\", ((pow(CHARSET_SIZE, m) - f[m][t.root->id]) % MOD + MOD) % MOD);\n\n\treturn 0;\n}\n```","slug":"jsoi2007-generator","published":1,"updated":"2016-09-11T23:28:09.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cit00w8c2xlh1zqq49r"},{"title":"JSOI2007 - ","date":"2016-09-29T13:00:00.000Z","_content":"\n $ S $ \n\n<!-- more -->\n\n### \n[BZOJ 1031](http://www.lydsy.com/JudgeOnline/problem.php?id=1031)\n\n### \n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1e5 * 2;\n\nchar s[MAXN];\nint n, sa[MAXN], rk[MAXN], ht[MAXN];\n\ninline void print(const int *a) {\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n}\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t >= n ? -1 : rk[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t// print(fir);\n\t\t// print(sec);\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\t\t// print(tmp);\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t// print(buc);\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\t\t// print(sa);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t\t// print(rk);\n\n\t\t// return;\n\t}\n\t// puts(\"----------------\");\n\t// print(sa);\n\t// print(rk);\n\t// for (int i = 0; i < n; i++) printf(\"%s\\n\", s + sa[i]);\n\t\n\t/*\n\tfor (int i = 0, j, k = 0; i < n; i++) {\n\t\tif (!rk[i]) continue;\n\t\tj = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\t// k = 0;\n\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\t*/\n\t// print(ht);\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tfor (int i = 0; i < n; i++) s[i + n] = s[i];\n\tn *= 2;\n\tsuffixArray();\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", sa[i] + 1, i == n - 1 ? '\\n' : ' ');\n\t// for (int i = 1; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (sa[i] < n / 2) {\n\t\t\tputchar(s[sa[i] + n / 2 - 1]);\n\t\t}\n\t}\n\tputchar('\\n');\n\n\treturn 0;\n}\n```","source":"_posts/jsoi2007-cipher.md","raw":"title: JSOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - JSOI\n  - \n  - \npermalink: jsoi2007-cipher\ndate: 2016-09-29 21:00:00\n---\n\n $ S $ \n\n<!-- more -->\n\n### \n[BZOJ 1031](http://www.lydsy.com/JudgeOnline/problem.php?id=1031)\n\n### \n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1e5 * 2;\n\nchar s[MAXN];\nint n, sa[MAXN], rk[MAXN], ht[MAXN];\n\ninline void print(const int *a) {\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n}\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t >= n ? -1 : rk[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t// print(fir);\n\t\t// print(sec);\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\t\t// print(tmp);\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t// print(buc);\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\t\t// print(sa);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t\t// print(rk);\n\n\t\t// return;\n\t}\n\t// puts(\"----------------\");\n\t// print(sa);\n\t// print(rk);\n\t// for (int i = 0; i < n; i++) printf(\"%s\\n\", s + sa[i]);\n\t\n\t/*\n\tfor (int i = 0, j, k = 0; i < n; i++) {\n\t\tif (!rk[i]) continue;\n\t\tj = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\t// k = 0;\n\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\t*/\n\t// print(ht);\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tfor (int i = 0; i < n; i++) s[i + n] = s[i];\n\tn *= 2;\n\tsuffixArray();\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", sa[i] + 1, i == n - 1 ? '\\n' : ' ');\n\t// for (int i = 1; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (sa[i] < n / 2) {\n\t\t\tputchar(s[sa[i] + n / 2 - 1]);\n\t\t}\n\t}\n\tputchar('\\n');\n\n\treturn 0;\n}\n```","slug":"jsoi2007-cipher","published":1,"updated":"2016-09-29T13:06:01.131Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cj100wfc2xlu4w1h8ti"},{"title":"IOI2011Race - ","date":"2016-06-16T12:01:00.000Z","_content":"\n**** $ K $\n\n<!-- more -->\n\n### \n[BZOJ 2599](http://www.lydsy.com/JudgeOnline/problem.php?id=2599)\n\n### \n $ K $ \n\n $ {\\rm depth}(v) $  $ {\\rm dist}(v) $\n\n $ f(i) $ **** $ i $ \n\n $ {\\rm depth}(i) + f(K - {\\rm dist}(i)) $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n// #include \"rand.h\"\n#include <queue>\n#include <stack>\n\nconst int MAXN = 200000;\nconst int MAXK = 1000000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint dist, depth, size, max;\n\tbool visited, solved;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\nint f[MAXK + 1];\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->parent = NULL;\n\tstart->visited = false;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\ta[cnt++] = v;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\t// return a[rand(0, cnt - 1)];\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\t// printf(\"%d %d\\n\", cnt, start->size);\n\t\tassert(cnt == start->size);\n\t\ta[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\treturn res;\n}\n\ninline int calc(Node *root) {\n\tstatic int A[MAXN];\n\tint tot = 0, res = INT_MAX;\n\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(e->t);\n\t\te->t->parent = root;\n\t\te->t->dist = e->w;\n\t\te->t->depth = 1;\n\n\t\tstatic Node *a[MAXN];\n\t\tint cnt = 0;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tif (v->dist > k) continue;\n\n\t\t\tA[tot++] = v->dist;\n\t\t\ta[cnt++] = v;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->dist = v->dist + e->w;\n\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\t// assert(k - a[i]->dist >= 0 && k - a[i]->dist <= k);\n\t\t\tif (f[k - a[i]->dist] != INT_MAX) res = std::min(res, f[k - a[i]->dist] + a[i]->depth);\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tf[a[i]->dist] = std::min(f[a[i]->dist], a[i]->depth);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) {\n\t\t// assert(A[i] >= 0 && A[i] <= k);\n\t\tf[A[i]] = INT_MAX;\n\t}\n\n\t// printf(\"calc(%ld) = %d\\n\", root - N + 1, res);\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = INT_MAX;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans = std::min(ans, calc(root));\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\t// assert(n <= MAXN);\n\t// assert(k <= MAXK);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\taddEdge(u, v, w);\n\t}\n\n\tfor (int i = 1; i <= k; i++) f[i] = INT_MAX;\n\n\tint ans = solve();\n\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/ioi2011-race.md","raw":"title: IOI2011Race - \ncategories: OI\ntags: \n  - IOI\n  - BZOJ\n  - \n  - \npermalink: ioi2011-race\ndate: 2016-06-16 20:01:00\n---\n\n**** $ K $\n\n<!-- more -->\n\n### \n[BZOJ 2599](http://www.lydsy.com/JudgeOnline/problem.php?id=2599)\n\n### \n $ K $ \n\n $ {\\rm depth}(v) $  $ {\\rm dist}(v) $\n\n $ f(i) $ **** $ i $ \n\n $ {\\rm depth}(i) + f(K - {\\rm dist}(i)) $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n// #include \"rand.h\"\n#include <queue>\n#include <stack>\n\nconst int MAXN = 200000;\nconst int MAXK = 1000000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint dist, depth, size, max;\n\tbool visited, solved;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\nint f[MAXK + 1];\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->parent = NULL;\n\tstart->visited = false;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\ta[cnt++] = v;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\t// return a[rand(0, cnt - 1)];\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\t// printf(\"%d %d\\n\", cnt, start->size);\n\t\tassert(cnt == start->size);\n\t\ta[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\treturn res;\n}\n\ninline int calc(Node *root) {\n\tstatic int A[MAXN];\n\tint tot = 0, res = INT_MAX;\n\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(e->t);\n\t\te->t->parent = root;\n\t\te->t->dist = e->w;\n\t\te->t->depth = 1;\n\n\t\tstatic Node *a[MAXN];\n\t\tint cnt = 0;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tif (v->dist > k) continue;\n\n\t\t\tA[tot++] = v->dist;\n\t\t\ta[cnt++] = v;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->dist = v->dist + e->w;\n\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\t// assert(k - a[i]->dist >= 0 && k - a[i]->dist <= k);\n\t\t\tif (f[k - a[i]->dist] != INT_MAX) res = std::min(res, f[k - a[i]->dist] + a[i]->depth);\n\t\t}\n\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tf[a[i]->dist] = std::min(f[a[i]->dist], a[i]->depth);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) {\n\t\t// assert(A[i] >= 0 && A[i] <= k);\n\t\tf[A[i]] = INT_MAX;\n\t}\n\n\t// printf(\"calc(%ld) = %d\\n\", root - N + 1, res);\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = INT_MAX;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans = std::min(ans, calc(root));\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\t// assert(n <= MAXN);\n\t// assert(k <= MAXK);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\taddEdge(u, v, w);\n\t}\n\n\tfor (int i = 1; i <= k; i++) f[i] = INT_MAX;\n\n\tint ans = solve();\n\tprintf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n\n\treturn 0;\n}\n```\n","slug":"ioi2011-race","published":1,"updated":"2016-06-16T12:01:55.927Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cj900wlc2xl1sj7zor5"},{"title":"IOI2008 -  DP","date":"2016-10-24T13:39:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1791](http://www.lydsy.com/JudgeOnline/problem.php?id=1791)\n\n### \n\n\n $ f(i) $  $ i $  $ i $  $ j $$ f(i) = \\max\\{ f(j) + d(i, j) \\} $\n\n $ u $$ v $  $ f(u) + d(i, u) + f(v) + d(i, v) $ \n\n DP\n\n $ f'(i) $  $ i $  $ f $ $ s(i) $  $ i $ \n\n $ i $  $ i $  $ j $ $ i $ \n\n$$\n\\begin{aligned}\n& f'(i) + f'(j) + s(i) - s(j) \\pod {i > j} \\\\\n= & f'(j) - s(j) + f'(i) + s(i)\n\\end{aligned}\n$$\n\n $ i $  $ j $$ S $ \n\n$$\n\\begin{aligned}\n& f'(i) + f'(j) + S - (s(i) - s(j)) \\pod {i > j} \\\\\n= & f'(i) + f'(j) + S - s(i) + s(j) \\\\\n= & f'(j) + s(j) + S + f'(i) - s(i)\n\\end{aligned}\n$$\n\n $ f'(j) + s(j) + S $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <vector>\n\nconst int MAXN = 1000000;\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tNode *parent;\n\tbool inCircle, solved, visited, pushed;\n\tint depth, inDegree;\n\tlong long len;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tlong long w;\n\tEdge *next, *r;\n\tbool disabled;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nint n;\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline std::vector<Node *> getBlock(Node *start) {\n\tstd::queue<Node *> q;\n\tq.push(start);\n\tstart->inDegree = 0;\n\tstart->visited = true;\n\n\tstd::vector<Node *> block;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tblock.push_back(v);\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e == v->in || e->t->solved) continue;\n\t\t\tif (!e->t->visited) {\n\t\t\t\te->t->visited = true;\n\t\t\t\te->t->inDegree = 1;\n\t\t\t\te->t->in = e;\n\t\t\t\tq.push(e->t);\n\t\t\t} else e->t->inDegree++;\n\t\t}\n\t}\n\n\treturn block;\n}\n\ninline void toposort(std::vector<Node *> &v) {\n\tstd::queue<Node *> q;\n\tfor (size_t i = 0; i < v.size(); i++) {\n#ifdef DBG\n\t\tprintf(\"toposort(): inDegree[%lu] = %d\\n\", v[i] - N + 1, v[i]->inDegree);\n#endif\n\t\tif (v[i]->inDegree == 1) q.push(v[i]);\n\t\telse v[i]->inCircle = true;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tv->inCircle = false;\n#ifdef CHECK\n\t\tprintf(\"%lu\\n\", v - N);\n#endif\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->solved) continue;\n\t\t\tif (--e->t->inDegree == 1) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long calcTree(std::vector<Node *> &v) {\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tv[i]->visited = false;\n\t\tv[i]->inDegree = 0;\n\t\tv[i]->depth = 0;\n\t}\n\n\tstd::stack<Node *> s;\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tif (v[i]->inCircle) {\n\t\t\tv[i]->depth = 1;\n\t\t\ts.push(v[i]);\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t}\n\t\t\n\t\twhile (v->c && (v->c->t->inCircle || v->c->t->pushed || v->c->t->solved)) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tEdge *&e = v->c;\n\t\t\te->t->pushed = true;\n\t\t\te->t->parent = v;\n\t\t\ts.push(e->t);\n\t\t\te = e->next;\n\t\t} else {\n\t\t\tv->len = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->inCircle || e->t->parent != v) continue;\n\n\t\t\t\tans = std::max(ans, v->len + e->t->len + e->w);\n\t\t\t\tv->len = std::max(v->len, e->t->len + e->w);\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n#ifdef DBG\n\tprintf(\"calcTree(size = %lu) = %lld\\n\", v.size(), ans);\n#endif\n\treturn ans;\n}\n\ninline long long calcCircle(std::vector<Node *> &v) {\n\tNode *start;\n\tfor (size_t i = 0; i < v.size(); i++) v[i]->visited = false;\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tif (v[i]->inCircle) {\n\t\t\tv[i]->visited = true;\n\t\t\tstart = v[i];\n\t\t\tbreak;\n\t\t}\n\t\tfor (Edge *e = v[i]->e; e; e = e->next) e->disabled = false;\n\t}\n\n\tstatic Node *c[MAXN];\n\tstatic long long s[MAXN];\n\tint cnt = 0;\n\tlong long sum = 0;\n\n#ifdef DBG\n\tfor (int i = 0; i < MAXN; i++) c[i] = NULL, s[i] = 0;\n#endif\n\n\tNode *u = start;\n\tc[cnt++] = u;\n\twhile (1) {\n\t\tNode *next = NULL;\n\t\tfor (Edge *e = u->e; e; e = e->next) {\n\t\t\tif (e->disabled || e->t->solved) continue;\n\t\t\tif (!e->t->visited && e->t->inCircle) {\n\t\t\t\tc[cnt] = e->t;\n\t\t\t\ts[cnt] = e->w;\n\t\t\t\tsum += e->w;\n\t\t\t\tcnt++;\n\t\t\t\te->t->visited = true;\n\t\t\t\te->r->disabled = true;\n\t\t\t\tnext = e->t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (next) {\n\t\t\tu = next;\n\t\t} else {\n\t\t\tfor (Edge *e = u->e; e; e = e->next) {\n\t\t\t\tif (e->disabled || e->t->solved) continue;\n\t\t\t\tif (e->t == start) {\n\t\t\t\t\tsum += e->w;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (n == 0) return 0;\n\t/*\n\tif (cnt == 2) {\n\t\tlong long ans = c[0]->len + c[1]->len + std::max(s[1], sum - s[1]);\n#ifdef DBG\n\t\tprintf(\"%lld %lld\\n\", s[1], sum);\n\t\tprintf(\"calcCircle(size = 2) = %lld\\n\", ans);\n#endif\n\t\treturn ans;\n\t}\n\t*/\n\n\tfor (int i = 1; i < cnt; i++) s[i] += s[i - 1];\n\n\t// ans1 = f[a] + f[b] + s[a] - s[b]\n\t// ans2 = f[a] + f[b] + sum - (s[a] - s[b]) = sum + f[a] + f[b] - s[a] + s[b]\n\t// maintain the max of f[b] - s[b] and f[b] + s[b]\n\tlong long ans = 0, max1 = LLONG_MIN, max2 = LLONG_MIN;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tans = std::max(ans, c[i]->len + s[i] + max1);\n\t\tans = std::max(ans, sum + c[i]->len - s[i] + max2);\n\n\t\tmax1 = std::max(max1, c[i]->len - s[i]);\n\t\tmax2 = std::max(max2, c[i]->len + s[i]);\n\n#ifdef DBG\n\t\tprintf(\"ans = %lld, max1 = %lld, max2 = %lld\\n\", ans, max1, max2);\n#endif\n\t}\n\n#ifdef DBG\n\tprintf(\"calcCircle(size = %lu, cnt = %d) = %lld\\n\", v.size(), cnt, ans);\n#endif\n\treturn ans;\n}\n\ninline long long solve() {\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].solved) continue;\n\n\t\tstd::vector<Node *> block = getBlock(&N[i]);\n\t\ttoposort(block);\n\n\t\tlong long tmp = calcTree(block);\n\t\ttmp = std::max(tmp, calcCircle(block));\n\t\tans += tmp;\n\n\t\tfor (size_t i = 0; i < block.size(); i++) block[i]->solved = true;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint u, w;\n\t\tscanf(\"%d %d\", &u, &w), u--;\n\t\taddEdge(i, u, w);\n\t}\n\n\tprintf(\"%lld\\n\", solve());\n\n#ifdef CHECK\n\tfor (int i = 0; i < n; i++) printf(\"f[%d] = %lld\\n\", i, N[i].len);\n#endif\n\n\treturn 0;\n}\n```\n","source":"_posts/ioi2008-island.md","raw":"title: IOI2008 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - SHOI\n  - DP\n  - \n  - Tarjan\npermalink: ioi2008-island\ndate: 2016-10-24 21:39:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1791](http://www.lydsy.com/JudgeOnline/problem.php?id=1791)\n\n### \n\n\n $ f(i) $  $ i $  $ i $  $ j $$ f(i) = \\max\\{ f(j) + d(i, j) \\} $\n\n $ u $$ v $  $ f(u) + d(i, u) + f(v) + d(i, v) $ \n\n DP\n\n $ f'(i) $  $ i $  $ f $ $ s(i) $  $ i $ \n\n $ i $  $ i $  $ j $ $ i $ \n\n$$\n\\begin{aligned}\n& f'(i) + f'(j) + s(i) - s(j) \\pod {i > j} \\\\\n= & f'(j) - s(j) + f'(i) + s(i)\n\\end{aligned}\n$$\n\n $ i $  $ j $$ S $ \n\n$$\n\\begin{aligned}\n& f'(i) + f'(j) + S - (s(i) - s(j)) \\pod {i > j} \\\\\n= & f'(i) + f'(j) + S - s(i) + s(j) \\\\\n= & f'(j) + s(j) + S + f'(i) - s(i)\n\\end{aligned}\n$$\n\n $ f'(j) + s(j) + S $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <vector>\n\nconst int MAXN = 1000000;\n\nstruct Node {\n\tstruct Edge *e, *c, *in;\n\tNode *parent;\n\tbool inCircle, solved, visited, pushed;\n\tint depth, inDegree;\n\tlong long len;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tlong long w;\n\tEdge *next, *r;\n\tbool disabled;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nint n;\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline std::vector<Node *> getBlock(Node *start) {\n\tstd::queue<Node *> q;\n\tq.push(start);\n\tstart->inDegree = 0;\n\tstart->visited = true;\n\n\tstd::vector<Node *> block;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tblock.push_back(v);\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e == v->in || e->t->solved) continue;\n\t\t\tif (!e->t->visited) {\n\t\t\t\te->t->visited = true;\n\t\t\t\te->t->inDegree = 1;\n\t\t\t\te->t->in = e;\n\t\t\t\tq.push(e->t);\n\t\t\t} else e->t->inDegree++;\n\t\t}\n\t}\n\n\treturn block;\n}\n\ninline void toposort(std::vector<Node *> &v) {\n\tstd::queue<Node *> q;\n\tfor (size_t i = 0; i < v.size(); i++) {\n#ifdef DBG\n\t\tprintf(\"toposort(): inDegree[%lu] = %d\\n\", v[i] - N + 1, v[i]->inDegree);\n#endif\n\t\tif (v[i]->inDegree == 1) q.push(v[i]);\n\t\telse v[i]->inCircle = true;\n\t}\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tv->inCircle = false;\n#ifdef CHECK\n\t\tprintf(\"%lu\\n\", v - N);\n#endif\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (e->t->solved) continue;\n\t\t\tif (--e->t->inDegree == 1) {\n\t\t\t\tq.push(e->t);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline long long calcTree(std::vector<Node *> &v) {\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tv[i]->visited = false;\n\t\tv[i]->inDegree = 0;\n\t\tv[i]->depth = 0;\n\t}\n\n\tstd::stack<Node *> s;\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tif (v[i]->inCircle) {\n\t\t\tv[i]->depth = 1;\n\t\t\ts.push(v[i]);\n\t\t}\n\t}\n\n\tlong long ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->c = v->e;\n\t\t}\n\t\t\n\t\twhile (v->c && (v->c->t->inCircle || v->c->t->pushed || v->c->t->solved)) v->c = v->c->next;\n\t\tif (v->c) {\n\t\t\tEdge *&e = v->c;\n\t\t\te->t->pushed = true;\n\t\t\te->t->parent = v;\n\t\t\ts.push(e->t);\n\t\t\te = e->next;\n\t\t} else {\n\t\t\tv->len = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->inCircle || e->t->parent != v) continue;\n\n\t\t\t\tans = std::max(ans, v->len + e->t->len + e->w);\n\t\t\t\tv->len = std::max(v->len, e->t->len + e->w);\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n#ifdef DBG\n\tprintf(\"calcTree(size = %lu) = %lld\\n\", v.size(), ans);\n#endif\n\treturn ans;\n}\n\ninline long long calcCircle(std::vector<Node *> &v) {\n\tNode *start;\n\tfor (size_t i = 0; i < v.size(); i++) v[i]->visited = false;\n\tfor (size_t i = 0; i < v.size(); i++) {\n\t\tif (v[i]->inCircle) {\n\t\t\tv[i]->visited = true;\n\t\t\tstart = v[i];\n\t\t\tbreak;\n\t\t}\n\t\tfor (Edge *e = v[i]->e; e; e = e->next) e->disabled = false;\n\t}\n\n\tstatic Node *c[MAXN];\n\tstatic long long s[MAXN];\n\tint cnt = 0;\n\tlong long sum = 0;\n\n#ifdef DBG\n\tfor (int i = 0; i < MAXN; i++) c[i] = NULL, s[i] = 0;\n#endif\n\n\tNode *u = start;\n\tc[cnt++] = u;\n\twhile (1) {\n\t\tNode *next = NULL;\n\t\tfor (Edge *e = u->e; e; e = e->next) {\n\t\t\tif (e->disabled || e->t->solved) continue;\n\t\t\tif (!e->t->visited && e->t->inCircle) {\n\t\t\t\tc[cnt] = e->t;\n\t\t\t\ts[cnt] = e->w;\n\t\t\t\tsum += e->w;\n\t\t\t\tcnt++;\n\t\t\t\te->t->visited = true;\n\t\t\t\te->r->disabled = true;\n\t\t\t\tnext = e->t;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (next) {\n\t\t\tu = next;\n\t\t} else {\n\t\t\tfor (Edge *e = u->e; e; e = e->next) {\n\t\t\t\tif (e->disabled || e->t->solved) continue;\n\t\t\t\tif (e->t == start) {\n\t\t\t\t\tsum += e->w;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (n == 0) return 0;\n\t/*\n\tif (cnt == 2) {\n\t\tlong long ans = c[0]->len + c[1]->len + std::max(s[1], sum - s[1]);\n#ifdef DBG\n\t\tprintf(\"%lld %lld\\n\", s[1], sum);\n\t\tprintf(\"calcCircle(size = 2) = %lld\\n\", ans);\n#endif\n\t\treturn ans;\n\t}\n\t*/\n\n\tfor (int i = 1; i < cnt; i++) s[i] += s[i - 1];\n\n\t// ans1 = f[a] + f[b] + s[a] - s[b]\n\t// ans2 = f[a] + f[b] + sum - (s[a] - s[b]) = sum + f[a] + f[b] - s[a] + s[b]\n\t// maintain the max of f[b] - s[b] and f[b] + s[b]\n\tlong long ans = 0, max1 = LLONG_MIN, max2 = LLONG_MIN;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tans = std::max(ans, c[i]->len + s[i] + max1);\n\t\tans = std::max(ans, sum + c[i]->len - s[i] + max2);\n\n\t\tmax1 = std::max(max1, c[i]->len - s[i]);\n\t\tmax2 = std::max(max2, c[i]->len + s[i]);\n\n#ifdef DBG\n\t\tprintf(\"ans = %lld, max1 = %lld, max2 = %lld\\n\", ans, max1, max2);\n#endif\n\t}\n\n#ifdef DBG\n\tprintf(\"calcCircle(size = %lu, cnt = %d) = %lld\\n\", v.size(), cnt, ans);\n#endif\n\treturn ans;\n}\n\ninline long long solve() {\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].solved) continue;\n\n\t\tstd::vector<Node *> block = getBlock(&N[i]);\n\t\ttoposort(block);\n\n\t\tlong long tmp = calcTree(block);\n\t\ttmp = std::max(tmp, calcCircle(block));\n\t\tans += tmp;\n\n\t\tfor (size_t i = 0; i < block.size(); i++) block[i]->solved = true;\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint u, w;\n\t\tscanf(\"%d %d\", &u, &w), u--;\n\t\taddEdge(i, u, w);\n\t}\n\n\tprintf(\"%lld\\n\", solve());\n\n#ifdef CHECK\n\tfor (int i = 0; i < n; i++) printf(\"f[%d] = %lld\\n\", i, N[i].len);\n#endif\n\n\treturn 0;\n}\n```\n","slug":"ioi2008-island","published":1,"updated":"2016-10-25T13:32:29.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cji00wsc2xlwhl44dm1"},{"title":"HNOI2016 -  + ","date":"2016-05-11T09:28:00.000Z","_content":"\n A  A  $ N $  $ 1,\\ 2,\\ \\dots,\\ N $ $ 1 $  A \n\n1. \n2.  345  $ M $ \n3.  $ a,\\ b $ $ 1 \\leq a \\leq N $$ 1 \\leq b \\leq $ \n4.  $ a $  $ b $  $ a $  $ b $ )\n5.  4  $ L $  $ a $  $ C $  $ C $  $ L + 1,\\ L + 2,\\ \\dots,\\ L + C $ $ C $  $ C $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 4539](http://www.lydsy.com/JudgeOnline/problem.php?id=4539)  \n[COGS 2052](http://cogs.top/cogs/problem/problem.php?pid=2052)\n\n### \n\n\n $ k $ \n\n\n\n1. \n2. \n3.  2 \n\n $ O((m + q) \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nconst int MAXQ = 100000;\n\nstruct Range {\n    long long l, r;\n\n    Range(const long long l = 0, const long long r = 0) : l(l), r(r) {}\n};\n\nstruct Node;\nstruct TemplateTreeNode;\nstruct TargetTreeNode;\n\nstruct Node {\n    int id, depth, size, pos, posEnd;\n    long long dist;\n    Node *parent, *child, *top;\n    bool visited;\n};\n\ntemplate <typename T>\nstruct Edge {\n    T *s, *t;\n    long long w;\n    Edge<T> *next;\n\n    Edge(T *const s, T *const t, const long long w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nstruct TemplateTreeNode : public Node {\n    Edge<TemplateTreeNode> *e;\n} templateTree[MAXN];\n\nstruct TargetTreeNode : public Node {\n    Edge<TargetTreeNode> *e;\n    TemplateTreeNode *rootInTemplateTree, *parentInTemplateTree;\n    Range idRange;\n\n    friend bool operator<(const TargetTreeNode &v, const long long x) {\n        return v.idRange.r < x;\n    }\n} targetTree[MAXM + 1];\n\nstruct ChairmanTree {\n    struct SegmentTree {\n        int l, r, mid;\n        SegmentTree *lc, *rc;\n        int cnt;\n\n        SegmentTree(const int l, const int r, SegmentTree *const lc = NULL, SegmentTree *const rc = NULL) : l(l), r(r), mid(l + ((r - l) >> 1)), lc(lc), rc(rc), cnt((lc ? lc->cnt : 0) + (rc ? rc->cnt : 0)) {}\n        SegmentTree(const int l, const int r, const int cnt) : l(l), r(r), lc(NULL), rc(NULL), cnt(cnt) {}\n\n        void pushDown() {\n            if (!lc) lc = new SegmentTree(l, mid);\n            if (!rc) rc = new SegmentTree(mid + 1, r);\n        }\n\n        SegmentTree *insert(const int num) {\n            if (num < l || num > r) return this;\n            else if (num == l && num == r) return new SegmentTree(l, r, cnt + 1);\n            else {\n                pushDown();\n                if (num <= mid) return new SegmentTree(l, r, lc->insert(num), rc);\n                else return new SegmentTree(l, r, lc, rc->insert(num));\n            }\n        }\n\n        int rank() const {\n            return lc ? lc->cnt : 0;\n        }\n    } *root[MAXN + 1];\n    int n;\n\n    void build(const int *a, const int n) {\n        this->n = n;\n        root[0] = new SegmentTree(0, n - 1);\n        for (int i = 1; i <= n; i++) root[i] = root[i - 1]->insert(a[i - 1]);\n    }\n\n    int query(const int l, const int r, int k) {\n        SegmentTree *L = root[l - 1], *R = root[r];\n        int min = 0, max = n - 1;\n        while (min != max) {\n            L->pushDown(), R->pushDown();\n            int mid = min + ((max - min) >> 1), t = R->rank() - L->rank();\n            if (k <= t) L = L->lc, R = R->lc, max = mid;\n            else k -= t, L = L->rc, R = R->rc, min = mid + 1;\n        }\n        return min;\n    }\n} chairmanTree;\n\nint n, m, q, dfsSequence[MAXN];\nint cnt;\n\ntemplate <typename T>\ninline void addEdge(T *const N, const int u, const int v, const long long w) {\n    N[u].e = new Edge<T>(&N[u], &N[v], w);\n    N[v].e = new Edge<T>(&N[v], &N[u], w);\n}\n\ntemplate <typename T>\ninline void cut(T *const N, const int n) {\n    std::stack<T *> s;\n    s.push(&N[0]);\n    N[0].depth = 1;\n    N[0].dist = 0;\n\n    while (!s.empty()) {\n        T *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (!e->t->depth) {\n                    e->t->depth = v->depth + 1;\n                    e->t->dist = v->dist + e->w;\n                    e->t->parent = v;\n                    s.push(e->t);\n                }\n            }\n        } else {\n            v->size = 1;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (static_cast<T *>(e->t->parent) == v) {\n                    v->size += e->t->size;\n                    if (!v->child || v->child->size < e->t->size) v->child = e->t;\n                }\n            }\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].visited = false;\n\n    int time = -1;\n    s.push(&N[0]);\n    N[0].depth = 1;\n    while (!s.empty()) {\n        T *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            if (v->parent == NULL || v != static_cast<T *>(v->parent->child)) v->top = v;\n            else v->top = v->parent->top;\n            v->pos = ++time;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (static_cast<T *>(e->t->parent) == v) {\n                    if (e->t != v->child) s.push(e->t);\n                }\n            }\n            if (v->child) s.push(static_cast<T *>(v->child));\n        } else {\n            v->posEnd = time;\n            s.pop();\n        }\n    }\n}\n\ntemplate <typename T>\ninline T *lca(T *const u, T *const v) {\n    Node *a = u, *b = v;\n    while (a->top != b->top) {\n        if (a->top->depth < b->top->depth) std::swap(a, b);\n        a = a->top->parent;\n    }\n    if (a->depth > b->depth) std::swap(a, b);\n    return static_cast<T *>(a);\n}\n\ntemplate <typename T>\ninline T *lcaDown(T *const u, T *const v, T *&uDown, T *&vDown) {\n    T *p = lca(u, v);\n\n    struct {\n        T *operator()(Node *const p, Node *const v) {\n            Node *tmp = v;\n            while (tmp->top->parent != p) {\n                if (p->top == tmp->top) return static_cast<T *>(p->child);\n                tmp = tmp->top->parent;\n            }\n            return static_cast<T *>(tmp->top);\n        }\n    } down;\n\n    uDown = down(p, u), vDown = down(p, v);\n\n    return p;\n}\n\ntemplate <typename T>\ninline long long calcDist(T *const u, T *const v) {\n    const T *p = lca(u, v);\n    return (u->dist - p->dist) + (v->dist - p->dist);\n}\n\ntemplate <typename T>\ninline long long getDist(T *const u, T *const v) {\n    return llabs(u->dist - v->dist);\n}\n\ninline void getNode(const long long id, TargetTreeNode *&targetTreeNode, TemplateTreeNode *&templateTreeNode) {\n    targetTreeNode = NULL;\n    templateTreeNode = NULL;\n    targetTreeNode = std::lower_bound(targetTree, targetTree + cnt, id);\n    /*for (int i = 0; i <= cnt; i++) {\n        if (id >= targetTree[i].idRange.l && id <= targetTree[i].idRange.r) {\n            targetTreeNode = &targetTree[i];\n            break;\n        }\n    }*/\n\n    // printf(\"%ld\\n\", targetTreeNode - targetTree);\n    if (targetTreeNode == NULL) throw;\n    if (targetTreeNode == &targetTree[0]) templateTreeNode = &templateTree[id];\n    else {\n        const int k = id - targetTreeNode->idRange.l;\n\n        TemplateTreeNode *root = targetTreeNode->rootInTemplateTree;\n\n        const int x = chairmanTree.query(root->pos + 1, root->posEnd + 1, k + 1);\n        templateTreeNode = &templateTree[x];\n        return;\n\n        // static int tmp[MAXN];\n        // std::copy(dfsSequence + root->pos, dfsSequence + root->pos + root->size, tmp);\n        // // std::nth_element(tmp, tmp + root->size, tmp + k);\n        // std::sort(tmp, tmp + root->size);\n        // templateTreeNode = &templateTree[tmp[k]];\n    }\n}\n\ninline long long query(const long long u, const long long v) {\n    TargetTreeNode *aTarget, *bTarget;\n    TemplateTreeNode *aTemplate, *bTemplate;\n    getNode(u, aTarget, aTemplate), getNode(v, bTarget, bTemplate);\n    if (aTarget == bTarget) {\n        return calcDist(aTemplate, bTemplate);\n    } else {\n        TargetTreeNode *aDown, *bDown;\n        TemplateTreeNode *aUp, *bUp;\n\n        TargetTreeNode *pTarget = lcaDown(aTarget, bTarget, aDown, bDown);\n        if (aTarget->depth > bTarget->depth) std::swap(aTarget, bTarget), std::swap(aTemplate, bTemplate), std::swap(aDown, bDown);\n\n        aUp = static_cast<TemplateTreeNode *>(aDown->parentInTemplateTree);\n        bUp = static_cast<TemplateTreeNode *>(bDown->parentInTemplateTree);\n\n        long long d = 0;\n        if (aTarget == pTarget) {\n            d += getDist(bTarget, pTarget);\n            d -= getDist(bUp, pTarget->rootInTemplateTree);\n            d += calcDist(bUp, aTemplate);\n            d += getDist(bTemplate, bTarget->rootInTemplateTree);\n        } else {\n            d += getDist(aTarget, pTarget) + getDist(bTarget, pTarget);\n            d -= getDist(bUp, pTarget->rootInTemplateTree);\n            d -= getDist(aUp, pTarget->rootInTemplateTree);\n            d += calcDist(aUp, bUp);\n            d += getDist(bTemplate, bTarget->rootInTemplateTree);\n            d += getDist(aTemplate, aTarget->rootInTemplateTree);\n        }\n        return d;\n    }\n}\n\nint main() {\n    // freopen(\"tree_tenderRun.in\", \"r\", stdin);\n    // freopen(\"tree_tenderRun.out\", \"w\", stdout);\n\n    scanf(\"%d %d %d\", &n, &m, &q);\n    for (int i = 0; i < n - 1; i++) {\n        templateTree[i].id = i;\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n        addEdge(templateTree, u, v, 1);\n    }\n\n    cut<TemplateTreeNode>(templateTree, n);\n\n    for (int i = 0; i < n; i++) dfsSequence[templateTree[i].pos] = i;\n    chairmanTree.build(dfsSequence, n);\n\n    targetTree[0].id = 0;\n    targetTree[0].rootInTemplateTree = &templateTree[0];\n    targetTree[0].idRange = Range(0, n - 1);\n    long long lastEnd = n - 1;\n    for (int i = 1; i <= m; i++) {\n        cnt = i;\n\n        targetTree[i].id = i;\n        long long a, b;\n        scanf(\"%lld %lld\", &a, &b), a--, b--;\n        targetTree[i].idRange = Range(lastEnd + 1, lastEnd + templateTree[a].size);\n        lastEnd = targetTree[i].idRange.r;\n\n        TargetTreeNode *V;\n        TemplateTreeNode *v;\n        getNode(b, V, v);\n\n        addEdge(targetTree, V->id, i, getDist(v, V->rootInTemplateTree) + 1);\n\n        targetTree[i].rootInTemplateTree = &templateTree[a];\n        targetTree[i].parentInTemplateTree = v;\n    }\n\n    cut<TargetTreeNode>(targetTree, m + 1);\n\n    for (int i = 0; i < q; i++) {\n        long long u, v;\n        scanf(\"%lld %lld\", &u, &v), u--, v--;\n        printf(\"%lld\\n\", query(u, v));\n    }\n\n    // fclose(stdin);\n    // fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/hnoi2016-tree.md","raw":"title: HNOI2016 -  + \ncategories: OI\ntags:\n  - BZOJ\n  - COGS\n  - HNOI\n  - \n  - \n  - \npermalink: hnoi2016-tree\ndate: 2016-05-11 17:28:00\n---\n\n A  A  $ N $  $ 1,\\ 2,\\ \\dots,\\ N $ $ 1 $  A \n\n1. \n2.  345  $ M $ \n3.  $ a,\\ b $ $ 1 \\leq a \\leq N $$ 1 \\leq b \\leq $ \n4.  $ a $  $ b $  $ a $  $ b $ )\n5.  4  $ L $  $ a $  $ C $  $ C $  $ L + 1,\\ L + 2,\\ \\dots,\\ L + C $ $ C $  $ C $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 4539](http://www.lydsy.com/JudgeOnline/problem.php?id=4539)  \n[COGS 2052](http://cogs.top/cogs/problem/problem.php?pid=2052)\n\n### \n\n\n $ k $ \n\n\n\n1. \n2. \n3.  2 \n\n $ O((m + q) \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\nconst int MAXQ = 100000;\n\nstruct Range {\n    long long l, r;\n\n    Range(const long long l = 0, const long long r = 0) : l(l), r(r) {}\n};\n\nstruct Node;\nstruct TemplateTreeNode;\nstruct TargetTreeNode;\n\nstruct Node {\n    int id, depth, size, pos, posEnd;\n    long long dist;\n    Node *parent, *child, *top;\n    bool visited;\n};\n\ntemplate <typename T>\nstruct Edge {\n    T *s, *t;\n    long long w;\n    Edge<T> *next;\n\n    Edge(T *const s, T *const t, const long long w) : s(s), t(t), w(w), next(s->e) {}\n};\n\nstruct TemplateTreeNode : public Node {\n    Edge<TemplateTreeNode> *e;\n} templateTree[MAXN];\n\nstruct TargetTreeNode : public Node {\n    Edge<TargetTreeNode> *e;\n    TemplateTreeNode *rootInTemplateTree, *parentInTemplateTree;\n    Range idRange;\n\n    friend bool operator<(const TargetTreeNode &v, const long long x) {\n        return v.idRange.r < x;\n    }\n} targetTree[MAXM + 1];\n\nstruct ChairmanTree {\n    struct SegmentTree {\n        int l, r, mid;\n        SegmentTree *lc, *rc;\n        int cnt;\n\n        SegmentTree(const int l, const int r, SegmentTree *const lc = NULL, SegmentTree *const rc = NULL) : l(l), r(r), mid(l + ((r - l) >> 1)), lc(lc), rc(rc), cnt((lc ? lc->cnt : 0) + (rc ? rc->cnt : 0)) {}\n        SegmentTree(const int l, const int r, const int cnt) : l(l), r(r), lc(NULL), rc(NULL), cnt(cnt) {}\n\n        void pushDown() {\n            if (!lc) lc = new SegmentTree(l, mid);\n            if (!rc) rc = new SegmentTree(mid + 1, r);\n        }\n\n        SegmentTree *insert(const int num) {\n            if (num < l || num > r) return this;\n            else if (num == l && num == r) return new SegmentTree(l, r, cnt + 1);\n            else {\n                pushDown();\n                if (num <= mid) return new SegmentTree(l, r, lc->insert(num), rc);\n                else return new SegmentTree(l, r, lc, rc->insert(num));\n            }\n        }\n\n        int rank() const {\n            return lc ? lc->cnt : 0;\n        }\n    } *root[MAXN + 1];\n    int n;\n\n    void build(const int *a, const int n) {\n        this->n = n;\n        root[0] = new SegmentTree(0, n - 1);\n        for (int i = 1; i <= n; i++) root[i] = root[i - 1]->insert(a[i - 1]);\n    }\n\n    int query(const int l, const int r, int k) {\n        SegmentTree *L = root[l - 1], *R = root[r];\n        int min = 0, max = n - 1;\n        while (min != max) {\n            L->pushDown(), R->pushDown();\n            int mid = min + ((max - min) >> 1), t = R->rank() - L->rank();\n            if (k <= t) L = L->lc, R = R->lc, max = mid;\n            else k -= t, L = L->rc, R = R->rc, min = mid + 1;\n        }\n        return min;\n    }\n} chairmanTree;\n\nint n, m, q, dfsSequence[MAXN];\nint cnt;\n\ntemplate <typename T>\ninline void addEdge(T *const N, const int u, const int v, const long long w) {\n    N[u].e = new Edge<T>(&N[u], &N[v], w);\n    N[v].e = new Edge<T>(&N[v], &N[u], w);\n}\n\ntemplate <typename T>\ninline void cut(T *const N, const int n) {\n    std::stack<T *> s;\n    s.push(&N[0]);\n    N[0].depth = 1;\n    N[0].dist = 0;\n\n    while (!s.empty()) {\n        T *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (!e->t->depth) {\n                    e->t->depth = v->depth + 1;\n                    e->t->dist = v->dist + e->w;\n                    e->t->parent = v;\n                    s.push(e->t);\n                }\n            }\n        } else {\n            v->size = 1;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (static_cast<T *>(e->t->parent) == v) {\n                    v->size += e->t->size;\n                    if (!v->child || v->child->size < e->t->size) v->child = e->t;\n                }\n            }\n            s.pop();\n        }\n    }\n\n    for (int i = 0; i < n; i++) N[i].visited = false;\n\n    int time = -1;\n    s.push(&N[0]);\n    N[0].depth = 1;\n    while (!s.empty()) {\n        T *v = s.top();\n        if (!v->visited) {\n            v->visited = true;\n            if (v->parent == NULL || v != static_cast<T *>(v->parent->child)) v->top = v;\n            else v->top = v->parent->top;\n            v->pos = ++time;\n            for (Edge<T> *e = v->e; e; e = e->next) {\n                if (static_cast<T *>(e->t->parent) == v) {\n                    if (e->t != v->child) s.push(e->t);\n                }\n            }\n            if (v->child) s.push(static_cast<T *>(v->child));\n        } else {\n            v->posEnd = time;\n            s.pop();\n        }\n    }\n}\n\ntemplate <typename T>\ninline T *lca(T *const u, T *const v) {\n    Node *a = u, *b = v;\n    while (a->top != b->top) {\n        if (a->top->depth < b->top->depth) std::swap(a, b);\n        a = a->top->parent;\n    }\n    if (a->depth > b->depth) std::swap(a, b);\n    return static_cast<T *>(a);\n}\n\ntemplate <typename T>\ninline T *lcaDown(T *const u, T *const v, T *&uDown, T *&vDown) {\n    T *p = lca(u, v);\n\n    struct {\n        T *operator()(Node *const p, Node *const v) {\n            Node *tmp = v;\n            while (tmp->top->parent != p) {\n                if (p->top == tmp->top) return static_cast<T *>(p->child);\n                tmp = tmp->top->parent;\n            }\n            return static_cast<T *>(tmp->top);\n        }\n    } down;\n\n    uDown = down(p, u), vDown = down(p, v);\n\n    return p;\n}\n\ntemplate <typename T>\ninline long long calcDist(T *const u, T *const v) {\n    const T *p = lca(u, v);\n    return (u->dist - p->dist) + (v->dist - p->dist);\n}\n\ntemplate <typename T>\ninline long long getDist(T *const u, T *const v) {\n    return llabs(u->dist - v->dist);\n}\n\ninline void getNode(const long long id, TargetTreeNode *&targetTreeNode, TemplateTreeNode *&templateTreeNode) {\n    targetTreeNode = NULL;\n    templateTreeNode = NULL;\n    targetTreeNode = std::lower_bound(targetTree, targetTree + cnt, id);\n    /*for (int i = 0; i <= cnt; i++) {\n        if (id >= targetTree[i].idRange.l && id <= targetTree[i].idRange.r) {\n            targetTreeNode = &targetTree[i];\n            break;\n        }\n    }*/\n\n    // printf(\"%ld\\n\", targetTreeNode - targetTree);\n    if (targetTreeNode == NULL) throw;\n    if (targetTreeNode == &targetTree[0]) templateTreeNode = &templateTree[id];\n    else {\n        const int k = id - targetTreeNode->idRange.l;\n\n        TemplateTreeNode *root = targetTreeNode->rootInTemplateTree;\n\n        const int x = chairmanTree.query(root->pos + 1, root->posEnd + 1, k + 1);\n        templateTreeNode = &templateTree[x];\n        return;\n\n        // static int tmp[MAXN];\n        // std::copy(dfsSequence + root->pos, dfsSequence + root->pos + root->size, tmp);\n        // // std::nth_element(tmp, tmp + root->size, tmp + k);\n        // std::sort(tmp, tmp + root->size);\n        // templateTreeNode = &templateTree[tmp[k]];\n    }\n}\n\ninline long long query(const long long u, const long long v) {\n    TargetTreeNode *aTarget, *bTarget;\n    TemplateTreeNode *aTemplate, *bTemplate;\n    getNode(u, aTarget, aTemplate), getNode(v, bTarget, bTemplate);\n    if (aTarget == bTarget) {\n        return calcDist(aTemplate, bTemplate);\n    } else {\n        TargetTreeNode *aDown, *bDown;\n        TemplateTreeNode *aUp, *bUp;\n\n        TargetTreeNode *pTarget = lcaDown(aTarget, bTarget, aDown, bDown);\n        if (aTarget->depth > bTarget->depth) std::swap(aTarget, bTarget), std::swap(aTemplate, bTemplate), std::swap(aDown, bDown);\n\n        aUp = static_cast<TemplateTreeNode *>(aDown->parentInTemplateTree);\n        bUp = static_cast<TemplateTreeNode *>(bDown->parentInTemplateTree);\n\n        long long d = 0;\n        if (aTarget == pTarget) {\n            d += getDist(bTarget, pTarget);\n            d -= getDist(bUp, pTarget->rootInTemplateTree);\n            d += calcDist(bUp, aTemplate);\n            d += getDist(bTemplate, bTarget->rootInTemplateTree);\n        } else {\n            d += getDist(aTarget, pTarget) + getDist(bTarget, pTarget);\n            d -= getDist(bUp, pTarget->rootInTemplateTree);\n            d -= getDist(aUp, pTarget->rootInTemplateTree);\n            d += calcDist(aUp, bUp);\n            d += getDist(bTemplate, bTarget->rootInTemplateTree);\n            d += getDist(aTemplate, aTarget->rootInTemplateTree);\n        }\n        return d;\n    }\n}\n\nint main() {\n    // freopen(\"tree_tenderRun.in\", \"r\", stdin);\n    // freopen(\"tree_tenderRun.out\", \"w\", stdout);\n\n    scanf(\"%d %d %d\", &n, &m, &q);\n    for (int i = 0; i < n - 1; i++) {\n        templateTree[i].id = i;\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n        addEdge(templateTree, u, v, 1);\n    }\n\n    cut<TemplateTreeNode>(templateTree, n);\n\n    for (int i = 0; i < n; i++) dfsSequence[templateTree[i].pos] = i;\n    chairmanTree.build(dfsSequence, n);\n\n    targetTree[0].id = 0;\n    targetTree[0].rootInTemplateTree = &templateTree[0];\n    targetTree[0].idRange = Range(0, n - 1);\n    long long lastEnd = n - 1;\n    for (int i = 1; i <= m; i++) {\n        cnt = i;\n\n        targetTree[i].id = i;\n        long long a, b;\n        scanf(\"%lld %lld\", &a, &b), a--, b--;\n        targetTree[i].idRange = Range(lastEnd + 1, lastEnd + templateTree[a].size);\n        lastEnd = targetTree[i].idRange.r;\n\n        TargetTreeNode *V;\n        TemplateTreeNode *v;\n        getNode(b, V, v);\n\n        addEdge(targetTree, V->id, i, getDist(v, V->rootInTemplateTree) + 1);\n\n        targetTree[i].rootInTemplateTree = &templateTree[a];\n        targetTree[i].parentInTemplateTree = v;\n    }\n\n    cut<TargetTreeNode>(targetTree, m + 1);\n\n    for (int i = 0; i < q; i++) {\n        long long u, v;\n        scanf(\"%lld %lld\", &u, &v), u--, v--;\n        printf(\"%lld\\n\", query(u, v));\n    }\n\n    // fclose(stdin);\n    // fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"hnoi2016-tree","published":1,"updated":"2016-09-10T05:51:35.350Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cjt00x0c2xly13ge6ou"},{"title":"HNOI2016 -  + RMQ","date":"2016-04-30T13:23:18.000Z","_content":"\n $ n $ $ a_1,\\ a_2,\\ \\dots,\\ a_n $ $ a[1:n] $$ a[l:r] $$ 1 \\leq l \\leq r \\leq n $$ a_l,\\ a_{l + 1},\\ \\dots,\\ a_{r - 1},\\ a_r $ $ 1 \\leq l \\leq s \\leq t \\leq r \\leq n $ $ a[s:t] $  $ a[l:r] $ \n\n $ q $  $ l $  $ r $$ 1 \\leq l \\leq r \\leq n $ $ a[l:r] $ \n\n<!-- more -->\n\n### \n[BZOJ 4540](http://www.lydsy.com/JudgeOnline/problem.php?id=4540)\n\n### \n[Sengxian ](https://blog.sengxian.com/solutions/bzoj-4540)\n\n\n\n $ [i] $  $ i $  $ a_i $$ [ \\ [l,\\ r],\\ R \\ ] $  $ [l,\\ r] $ $ R $ \n\n $ [l,\\ r - 1] $  $ [r] $  $ r - l + 1 $  $ [ \\ [l,\\ r] \\ ,\\ r \\ ] $\n\n$ [l, r] $  $ [m] $ $ [ \\ [l,\\ m],\\ r \\ ] $  $ [m] $\n\n|  | *1* | 2 | 3 | *4* | 5 | 6 | 7 | 8 | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|    | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n|  | $ l $ |   |   | $ m $ |   |   |   |   |   |  $ r $ |\n\n $ [ \\ [1,\\ 4],\\ 6 \\ ] $  $ [4] $ $ 1 $\n\n $ r - m $  $ r $  $ [r] $ ****$ r $  $ [r] $ $ [r] $  $ [8] = 3 $ $ {\\rm left}(r) = p $\n\n|  | *1* | 2 | 3 | *4* | 5 | 6 | 7 | *8* | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|    | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n|  | $ l $ |   |   | $ m $ |   |   |   | $ p $ |   |  $ r $ |\n\n$ p $  $ r - p = 10 - 8 = 2 $  $ [10] = 4 $ $ (r - p) \\times [r] $\n\n $ [p] = 3 $  $ [6] = 2 $ $ {\\rm left}(p) = p' = 6 $\n\n|  | *1* | 2 | 3 | *4* | 5 | *6* | 7 | *8* | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|    | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n|  | $ l $ |   |   | $ m $ |   | $ p' $  |   | $ p $ |   |  $ r $ |\n\n$ p' $  $ p - p' = 8 - 6 = 2 $  $ [8] = 3 $ $ (p - p') \\times [p] $\n\n $ p' $  $ 1 $ $ {\\rm left}(p') = m = 4 $ $ m $  $ p' - m = 6 - 4 = 2 $  $ [p'] = 2 $ $ (p' - m) \\times [p'] $\n\n $ O(n) $\n\n $ m = \\min[l,\\ r] $  $ [l,\\ r] $  $ f(l, r) $  $ [l,\\ r] $ \n\n$$\nf(l, r) = \n\\begin{cases}\n0 & r = m \\\\\n[r] \\times (r - {\\rm left}(r)) + f(l, {\\rm left}(r)) & {\\rm otherwise} \\\\\n\\end{cases}\n$$\n\n $ m $  $ l $ \n\n $ s(i) $  $ i $ \n\n$$\ns(i) = \n\\begin{cases}\n0 & i = \\min[1,\\ n] \\\\\n[i] \\times (i - {\\rm left}(i)) + s({\\rm left}(i)) & {\\rm otherwise} \\\\\n\\end{cases}\n$$\n\n$ {\\rm left}(p') = {\\rm left}(m + 1) = m $********\n\n$$ f(l, r) = s(r) - s(\\min[l,\\ r]) $$\n\n $ {\\rm left}(i) $ $ O(n) $  $ s(i) $\n\n RMQ $ O(n \\log n) $  $ O(1) $  $ O(1) $ $ O(q \\log q + n \\sqrt n) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n// #include <cassert>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\nconst int MAXM = 100000;\n\nstruct Element {\n    int val;\n    Element *left, *right;\n    long long sumLeft, sumRight;\n\n    bool operator<(const Element &x) const { return val < x.val; }\n    bool operator<=(const Element &x) const { return val <= x.val; }\n} a[MAXN];\n\nint n, m, logTable[MAXN + 1];\nElement *st[MAXN][MAXLOGN + 1];\nlong long ans[MAXN];\n\nstruct Query {\n    int l, r;\n    long long *ans;\n\n    bool operator<(const Query &x) const {\n        static int blockSize = floor(sqrt(n));\n        if (l / blockSize == x.l / blockSize) return r < x.r;\n        else return l / blockSize < x.l / blockSize;\n    }\n} Q[MAXM];\n\ninline Element *min(Element *const a, Element *const b) {\n    if (!a) return b;\n    if (!b) return a;\n    return *a < *b ? a : b;\n}\n\ninline void sparseTable() {\n    for (int i = 0; i < n - 1; i++) st[i][0] = min(&a[i], &a[i + 1]);\n    st[n - 1][0] = &a[n - 1];\n\n    for (int j = 1; (1 << j) <= n; j++) {\n        for (int i = 0; i < n; i++) {\n            if (i + (1 << (j - 1)) < n) {\n                st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n            }\n        }\n    }\n\n    for (int i = 0; i <= n; i++) {\n        logTable[i] = floor(log2(i));\n    }\n}\n\ninline Element *rmq(const int l, const int r) {\n    if (l == r) return &a[l];\n    else {\n        int t = logTable[r - l];\n        return min(st[l][t], st[r - (1 << t)][t]);\n    }\n}\n\ninline void prepare() {\n    std::stack<Element *> s;\n    s.push(&a[0]);\n\n    for (int i = 1; i < n; i++) {\n        while (!s.empty() && a[i] <= *s.top()) s.pop();\n        if (!s.empty()) a[i].left = s.top();\n        else a[i].left = NULL;\n        s.push(&a[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        Element *x = &a[i];\n        if (x->left == NULL) {\n            x->sumLeft = 0;\n        } else {\n            x->sumLeft = x->left->sumLeft + (x - x->left) * static_cast<long long>(x->val);\n        }\n    }\n\n    s.push(&a[n - 1]);\n    for (int i = n - 2; i >= 0; i--) {\n        while (!s.empty() && a[i] <= *s.top()) s.pop();\n        if (!s.empty()) a[i].right = s.top();\n        else a[i].right = NULL;\n        s.push(&a[i]);\n    }\n\n    for (int i = n - 1; i >= 0; i--) {\n        Element *x = &a[i];\n        if (x->right == NULL) {\n            x->sumRight = 0;\n        } else {\n            x->sumRight = x->right->sumRight + (x->right - x) * static_cast<long long>(x->val);\n        }\n    }\n\n    sparseTable();\n    std::sort(Q, Q + m);\n\n    for (int i = 0; i < n; i++) {\n        // printf(\"%lld %lld\\n\", a[i].sumLeft, a[i].sumRight);\n        // printf(\"%d: sumLeft = %lld, sumRight = %lld, \", a[i].val, a[i].sumLeft, a[i].sumRight);\n        // if (a[i].left == NULL) printf(\"left = NULL, \");\n        // else printf(\"left = %ld[%d], \", a[i].left - a, a[i].left->val);\n        // if (a[i].right == NULL) printf(\"right = NULL\\n\");\n        // else printf(\"right = %ld[%d]\\n\", a[i].right - a, a[i].right->val);\n    }\n}\n\ninline long long expandRight(const int l, const int r) {\n    // printf(\"[%d, %d]\\n\", l, r);\n    Element *pos = rmq(l, r);\n    return (pos - &a[l] + 1) * static_cast<long long>(pos->val)\n          + a[r].sumLeft - pos->sumLeft;\n}\n\ninline long long expandLeft(const int l, const int r) {\n    // printf(\"[%d, %d]\\n\", l, r);\n    Element *pos = rmq(l, r);\n    return (&a[r] - pos + 1) * static_cast<long long>(pos->val)\n          + a[l].sumRight - pos->sumRight;\n}\n\ninline void mo() {\n    int l = 0, r = 0;\n    long long ans = a[0].val;\n    for (int i = 0; i < m; i++) {\n        const Query &q = Q[i];\n        // assert(l <= r);\n        while (r < q.r) r++, ans += expandRight(l, r);\n        while (l > q.l) l--, ans += expandLeft(l, r);\n        while (r > q.r) ans -= expandRight(l, r), r--;\n        while (l < q.l) ans -= expandLeft(l, r), l++;\n        *q.ans = ans;\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i].val);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &Q[i].l, &Q[i].r);\n        Q[i].l--, Q[i].r--;\n        Q[i].ans = &ans[i];\n    }\n\n    prepare();\n    mo();\n\n    for (int i = 0; i < m; i++) printf(\"%lld\\n\", ans[i]);\n\n    return 0;\n}\n```\n","source":"_posts/hnoi2016-sequence.md","raw":"title: HNOI2016 -  + RMQ\ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - \n  - RMQ\npermalink: hnoi2016-sequence\ndate: 2016-04-30 21:23:18\n---\n\n $ n $ $ a_1,\\ a_2,\\ \\dots,\\ a_n $ $ a[1:n] $$ a[l:r] $$ 1 \\leq l \\leq r \\leq n $$ a_l,\\ a_{l + 1},\\ \\dots,\\ a_{r - 1},\\ a_r $ $ 1 \\leq l \\leq s \\leq t \\leq r \\leq n $ $ a[s:t] $  $ a[l:r] $ \n\n $ q $  $ l $  $ r $$ 1 \\leq l \\leq r \\leq n $ $ a[l:r] $ \n\n<!-- more -->\n\n### \n[BZOJ 4540](http://www.lydsy.com/JudgeOnline/problem.php?id=4540)\n\n### \n[Sengxian ](https://blog.sengxian.com/solutions/bzoj-4540)\n\n\n\n $ [i] $  $ i $  $ a_i $$ [ \\ [l,\\ r],\\ R \\ ] $  $ [l,\\ r] $ $ R $ \n\n $ [l,\\ r - 1] $  $ [r] $  $ r - l + 1 $  $ [ \\ [l,\\ r] \\ ,\\ r \\ ] $\n\n$ [l, r] $  $ [m] $ $ [ \\ [l,\\ m],\\ r \\ ] $  $ [m] $\n\n|  | *1* | 2 | 3 | *4* | 5 | 6 | 7 | 8 | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|    | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n|  | $ l $ |   |   | $ m $ |   |   |   |   |   |  $ r $ |\n\n $ [ \\ [1,\\ 4],\\ 6 \\ ] $  $ [4] $ $ 1 $\n\n $ r - m $  $ r $  $ [r] $ ****$ r $  $ [r] $ $ [r] $  $ [8] = 3 $ $ {\\rm left}(r) = p $\n\n|  | *1* | 2 | 3 | *4* | 5 | 6 | 7 | *8* | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|    | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n|  | $ l $ |   |   | $ m $ |   |   |   | $ p $ |   |  $ r $ |\n\n$ p $  $ r - p = 10 - 8 = 2 $  $ [10] = 4 $ $ (r - p) \\times [r] $\n\n $ [p] = 3 $  $ [6] = 2 $ $ {\\rm left}(p) = p' = 6 $\n\n|  | *1* | 2 | 3 | *4* | 5 | *6* | 7 | *8* | 9 | *10* |\n|:---:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:--:|\n|    | 5 | 7 | 3 | 1 | 5 | 2 | 8 | 3 | 6 |  4 |\n|  | $ l $ |   |   | $ m $ |   | $ p' $  |   | $ p $ |   |  $ r $ |\n\n$ p' $  $ p - p' = 8 - 6 = 2 $  $ [8] = 3 $ $ (p - p') \\times [p] $\n\n $ p' $  $ 1 $ $ {\\rm left}(p') = m = 4 $ $ m $  $ p' - m = 6 - 4 = 2 $  $ [p'] = 2 $ $ (p' - m) \\times [p'] $\n\n $ O(n) $\n\n $ m = \\min[l,\\ r] $  $ [l,\\ r] $  $ f(l, r) $  $ [l,\\ r] $ \n\n$$\nf(l, r) = \n\\begin{cases}\n0 & r = m \\\\\n[r] \\times (r - {\\rm left}(r)) + f(l, {\\rm left}(r)) & {\\rm otherwise} \\\\\n\\end{cases}\n$$\n\n $ m $  $ l $ \n\n $ s(i) $  $ i $ \n\n$$\ns(i) = \n\\begin{cases}\n0 & i = \\min[1,\\ n] \\\\\n[i] \\times (i - {\\rm left}(i)) + s({\\rm left}(i)) & {\\rm otherwise} \\\\\n\\end{cases}\n$$\n\n$ {\\rm left}(p') = {\\rm left}(m + 1) = m $********\n\n$$ f(l, r) = s(r) - s(\\min[l,\\ r]) $$\n\n $ {\\rm left}(i) $ $ O(n) $  $ s(i) $\n\n RMQ $ O(n \\log n) $  $ O(1) $  $ O(1) $ $ O(q \\log q + n \\sqrt n) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n// #include <cassert>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXLOGN = 17; // log(100000, 2) = 16.609640474436812\nconst int MAXM = 100000;\n\nstruct Element {\n    int val;\n    Element *left, *right;\n    long long sumLeft, sumRight;\n\n    bool operator<(const Element &x) const { return val < x.val; }\n    bool operator<=(const Element &x) const { return val <= x.val; }\n} a[MAXN];\n\nint n, m, logTable[MAXN + 1];\nElement *st[MAXN][MAXLOGN + 1];\nlong long ans[MAXN];\n\nstruct Query {\n    int l, r;\n    long long *ans;\n\n    bool operator<(const Query &x) const {\n        static int blockSize = floor(sqrt(n));\n        if (l / blockSize == x.l / blockSize) return r < x.r;\n        else return l / blockSize < x.l / blockSize;\n    }\n} Q[MAXM];\n\ninline Element *min(Element *const a, Element *const b) {\n    if (!a) return b;\n    if (!b) return a;\n    return *a < *b ? a : b;\n}\n\ninline void sparseTable() {\n    for (int i = 0; i < n - 1; i++) st[i][0] = min(&a[i], &a[i + 1]);\n    st[n - 1][0] = &a[n - 1];\n\n    for (int j = 1; (1 << j) <= n; j++) {\n        for (int i = 0; i < n; i++) {\n            if (i + (1 << (j - 1)) < n) {\n                st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n            }\n        }\n    }\n\n    for (int i = 0; i <= n; i++) {\n        logTable[i] = floor(log2(i));\n    }\n}\n\ninline Element *rmq(const int l, const int r) {\n    if (l == r) return &a[l];\n    else {\n        int t = logTable[r - l];\n        return min(st[l][t], st[r - (1 << t)][t]);\n    }\n}\n\ninline void prepare() {\n    std::stack<Element *> s;\n    s.push(&a[0]);\n\n    for (int i = 1; i < n; i++) {\n        while (!s.empty() && a[i] <= *s.top()) s.pop();\n        if (!s.empty()) a[i].left = s.top();\n        else a[i].left = NULL;\n        s.push(&a[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        Element *x = &a[i];\n        if (x->left == NULL) {\n            x->sumLeft = 0;\n        } else {\n            x->sumLeft = x->left->sumLeft + (x - x->left) * static_cast<long long>(x->val);\n        }\n    }\n\n    s.push(&a[n - 1]);\n    for (int i = n - 2; i >= 0; i--) {\n        while (!s.empty() && a[i] <= *s.top()) s.pop();\n        if (!s.empty()) a[i].right = s.top();\n        else a[i].right = NULL;\n        s.push(&a[i]);\n    }\n\n    for (int i = n - 1; i >= 0; i--) {\n        Element *x = &a[i];\n        if (x->right == NULL) {\n            x->sumRight = 0;\n        } else {\n            x->sumRight = x->right->sumRight + (x->right - x) * static_cast<long long>(x->val);\n        }\n    }\n\n    sparseTable();\n    std::sort(Q, Q + m);\n\n    for (int i = 0; i < n; i++) {\n        // printf(\"%lld %lld\\n\", a[i].sumLeft, a[i].sumRight);\n        // printf(\"%d: sumLeft = %lld, sumRight = %lld, \", a[i].val, a[i].sumLeft, a[i].sumRight);\n        // if (a[i].left == NULL) printf(\"left = NULL, \");\n        // else printf(\"left = %ld[%d], \", a[i].left - a, a[i].left->val);\n        // if (a[i].right == NULL) printf(\"right = NULL\\n\");\n        // else printf(\"right = %ld[%d]\\n\", a[i].right - a, a[i].right->val);\n    }\n}\n\ninline long long expandRight(const int l, const int r) {\n    // printf(\"[%d, %d]\\n\", l, r);\n    Element *pos = rmq(l, r);\n    return (pos - &a[l] + 1) * static_cast<long long>(pos->val)\n          + a[r].sumLeft - pos->sumLeft;\n}\n\ninline long long expandLeft(const int l, const int r) {\n    // printf(\"[%d, %d]\\n\", l, r);\n    Element *pos = rmq(l, r);\n    return (&a[r] - pos + 1) * static_cast<long long>(pos->val)\n          + a[l].sumRight - pos->sumRight;\n}\n\ninline void mo() {\n    int l = 0, r = 0;\n    long long ans = a[0].val;\n    for (int i = 0; i < m; i++) {\n        const Query &q = Q[i];\n        // assert(l <= r);\n        while (r < q.r) r++, ans += expandRight(l, r);\n        while (l > q.l) l--, ans += expandLeft(l, r);\n        while (r > q.r) ans -= expandRight(l, r), r--;\n        while (l < q.l) ans -= expandLeft(l, r), l++;\n        *q.ans = ans;\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i].val);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &Q[i].l, &Q[i].r);\n        Q[i].l--, Q[i].r--;\n        Q[i].ans = &ans[i];\n    }\n\n    prepare();\n    mo();\n\n    for (int i = 0; i < m; i++) printf(\"%lld\\n\", ans[i]);\n\n    return 0;\n}\n```\n","slug":"hnoi2016-sequence","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6ck400x9c2xlitwh7tcv"},{"title":"HNOI2016 -  + DFS ","date":"2016-05-11T09:08:00.000Z","_content":"\n\n\n1. \n2. \n3. \n\n\n\n<!-- more -->\n\n### \n[BZOJ 4538](http://www.lydsy.com/JudgeOnline/problem.php?id=4538)  \n[COGS 2215](http://cogs.top/cogs/problem/problem.php?pid=2215)\n\n### \n DFS  DFS  $ O(\\log n) $ \n\n******** DFS  $ O(\\log n) $  $ O(\\log n) $ \n\n\n\n $ O(n \\log ^ 3 n) $\n\n### \n```c++\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n \nconst int MAXN = 100000;\nconst int MAXM = 200000;\n \nstruct Node;\nstruct Edge;\n \nstruct Node {\n    Edge *e;\n    Node *p, *c, *t;\n    int d, i, s;\n    bool v;\n} N[MAXN];\n \nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n \n    Edge(Node *const s, Node *const t) : s(s), t(t), next(s->e) {}\n};\n \nstruct SegmentTree {\n    int l, r;\n    SegmentTree *lc, *rc;\n    std::priority_queue< std::pair<int, bool *> > q;\n \n    SegmentTree(const int l, const int r, SegmentTree *const lc, SegmentTree *const rc) : l(l), r(r), lc(lc), rc(rc) {}\n    ~SegmentTree() {\n        if (lc) delete lc;\n        if (rc) delete rc;\n    }\n \n    void update(const int l, const int r, const std::pair<int, bool *> &p) {\n        if (l > this->r || r < this->l) return;\n        else if (l <= this->l && r >= this->r) /* printf(\"> [%d, %d]\\n\", this->l, this->r), */ q.push(p);\n        else lc->update(l, r, p), rc->update(l, r, p);\n    }\n \n    int query(const int i) {\n        if (i < this->l || i > this->r) return -1;\n        else {\n            int ans = -1;\n            if (i >= this->l && i <= this->r) {\n                while (!q.empty() && *q.top().second) q.pop();\n                if (!q.empty()) ans = std::max(ans, q.top().first);\n            }\n            if (lc) ans = std::max(ans, lc->query(i));\n            if (rc) ans = std::max(ans, rc->query(i));\n            return ans;\n        }\n    }\n} *seg;\n \ninline void addEdge(const int u, const int v) {\n    N[u].e = new Edge(&N[u], &N[v]);\n    N[v].e = new Edge(&N[v], &N[u]);\n}\n \nint n, m;\nbool del[MAXM];\n \ninline SegmentTree *buildSegment(const int l, const int r) {\n    if (l > r) return NULL;\n    else if (l == r) return new SegmentTree(l, r, NULL, NULL);\n    else return new SegmentTree(l, r, buildSegment(l, l + ((r - l) >> 1)), buildSegment(l + ((r - l) >> 1) + 1, r));\n}\n \ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n    N[0].d = 1;\n \n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n                e->t->d = v->d + 1;\n                e->t->p = v;\n                s.push(e->t);\n            }\n        } else {\n            v->s = 1;\n            for (Edge *e = v->e; e; e = e->next) {\n                v->s += e->t->s;\n                if (!v->c || v->c->s < e->t->s) v->c = e->t;\n            }\n            s.pop();\n        }\n    }\n \n    for (int i = 0; i < n; i++) N[i].v = false;\n    s.push(&N[0]);\n \n    int time = -1;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            if (!v->p || v != v->p->c) v->t = v;\n            else v->t = v->p->t;\n            v->i = ++time;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else s.pop();\n    }\n \n    seg = buildSegment(0, n - 1);\n}\n \ninline void update(const int u, const int v, const std::pair<int, bool *> &p) {\n    Node *a = &N[u], *b = &N[v];\n    std::vector< std::pair<int, int> > vec;\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        vec.push_back(std::make_pair(a->t->i, a->i));\n        a = a->t->p;\n    }\n \n    if (a->i > b->i) std::swap(a, b);\n    vec.push_back(std::make_pair(a->i, b->i));\n \n    if (vec.empty()) return;\n \n    std::sort(vec.begin(), vec.end());\n    std::pair<int, int> last = std::make_pair(-1, -1);\n    for (std::vector< std::pair<int, int> >::const_iterator it = vec.begin(); it != vec.end(); it++) {\n        seg->update(last.second + 1, it->first - 1, p);\n        // printf(\"[%d, %d]\\n\", last.second + 1, it->first - 1);\n        last = *it;\n    }\n    seg->update(last.second + 1, n - 1, p);\n    // printf(\"[%d, %d]\\n\", last.second + 1, n - 1);\n}\n \ninline int query(const int x) {\n    // printf(\"query(%d)\\n\", x);\n    return seg->query(N[x].i);\n}\n \nint main() {\n    freopen(\"network_tenderRun.in\", \"r\", stdin);\n    freopen(\"network_tenderRun.out\", \"w\", stdout);\n \n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n        addEdge(u, v);\n    }\n \n    cut();\n \n    // for (int i = 0; i < n; i++) printf(\"#%d: i = %d\\n\", i + 1, N[i].i);\n \n    for (int i = 0; i < m; i++) {\n        int c;\n        scanf(\"%d\", &c);\n        if (c == 0) {\n            int u, v, w;\n            scanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n            update(u, v, std::make_pair(w, &del[i]));\n        } else if (c == 1) {\n            int t;\n            scanf(\"%d\", &t), t--;\n            del[t] = true;\n        } else if (c == 2) {\n            int x;\n            scanf(\"%d\", &x), x--;\n            printf(\"%d\\n\", query(x));\n        }\n    }\n \n    fclose(stdin);\n    fclose(stdout);\n \n    return 0;\n}\n```\n","source":"_posts/hnoi2016-network.md","raw":"title: HNOI2016 -  + DFS \ncategories: OI\ntags:\n  - BZOJ\n  - COGS\n  - HNOI\n  - \n  - DFS \npermalink: hnoi2016-network\ndate: 2016-05-11 17:08:00\n---\n\n\n\n1. \n2. \n3. \n\n\n\n<!-- more -->\n\n### \n[BZOJ 4538](http://www.lydsy.com/JudgeOnline/problem.php?id=4538)  \n[COGS 2215](http://cogs.top/cogs/problem/problem.php?pid=2215)\n\n### \n DFS  DFS  $ O(\\log n) $ \n\n******** DFS  $ O(\\log n) $  $ O(\\log n) $ \n\n\n\n $ O(n \\log ^ 3 n) $\n\n### \n```c++\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n \nconst int MAXN = 100000;\nconst int MAXM = 200000;\n \nstruct Node;\nstruct Edge;\n \nstruct Node {\n    Edge *e;\n    Node *p, *c, *t;\n    int d, i, s;\n    bool v;\n} N[MAXN];\n \nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n \n    Edge(Node *const s, Node *const t) : s(s), t(t), next(s->e) {}\n};\n \nstruct SegmentTree {\n    int l, r;\n    SegmentTree *lc, *rc;\n    std::priority_queue< std::pair<int, bool *> > q;\n \n    SegmentTree(const int l, const int r, SegmentTree *const lc, SegmentTree *const rc) : l(l), r(r), lc(lc), rc(rc) {}\n    ~SegmentTree() {\n        if (lc) delete lc;\n        if (rc) delete rc;\n    }\n \n    void update(const int l, const int r, const std::pair<int, bool *> &p) {\n        if (l > this->r || r < this->l) return;\n        else if (l <= this->l && r >= this->r) /* printf(\"> [%d, %d]\\n\", this->l, this->r), */ q.push(p);\n        else lc->update(l, r, p), rc->update(l, r, p);\n    }\n \n    int query(const int i) {\n        if (i < this->l || i > this->r) return -1;\n        else {\n            int ans = -1;\n            if (i >= this->l && i <= this->r) {\n                while (!q.empty() && *q.top().second) q.pop();\n                if (!q.empty()) ans = std::max(ans, q.top().first);\n            }\n            if (lc) ans = std::max(ans, lc->query(i));\n            if (rc) ans = std::max(ans, rc->query(i));\n            return ans;\n        }\n    }\n} *seg;\n \ninline void addEdge(const int u, const int v) {\n    N[u].e = new Edge(&N[u], &N[v]);\n    N[v].e = new Edge(&N[v], &N[u]);\n}\n \nint n, m;\nbool del[MAXM];\n \ninline SegmentTree *buildSegment(const int l, const int r) {\n    if (l > r) return NULL;\n    else if (l == r) return new SegmentTree(l, r, NULL, NULL);\n    else return new SegmentTree(l, r, buildSegment(l, l + ((r - l) >> 1)), buildSegment(l + ((r - l) >> 1) + 1, r));\n}\n \ninline void cut() {\n    std::stack<Node *> s;\n    s.push(&N[0]);\n    N[0].d = 1;\n \n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            for (Edge *e = v->e; e; e = e->next) if (!e->t->d) {\n                e->t->d = v->d + 1;\n                e->t->p = v;\n                s.push(e->t);\n            }\n        } else {\n            v->s = 1;\n            for (Edge *e = v->e; e; e = e->next) {\n                v->s += e->t->s;\n                if (!v->c || v->c->s < e->t->s) v->c = e->t;\n            }\n            s.pop();\n        }\n    }\n \n    for (int i = 0; i < n; i++) N[i].v = false;\n    s.push(&N[0]);\n \n    int time = -1;\n    while (!s.empty()) {\n        Node *v = s.top();\n        if (!v->v) {\n            v->v = true;\n            if (!v->p || v != v->p->c) v->t = v;\n            else v->t = v->p->t;\n            v->i = ++time;\n            for (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n            if (v->c) s.push(v->c);\n        } else s.pop();\n    }\n \n    seg = buildSegment(0, n - 1);\n}\n \ninline void update(const int u, const int v, const std::pair<int, bool *> &p) {\n    Node *a = &N[u], *b = &N[v];\n    std::vector< std::pair<int, int> > vec;\n    while (a->t != b->t) {\n        if (a->t->d < b->t->d) std::swap(a, b);\n        vec.push_back(std::make_pair(a->t->i, a->i));\n        a = a->t->p;\n    }\n \n    if (a->i > b->i) std::swap(a, b);\n    vec.push_back(std::make_pair(a->i, b->i));\n \n    if (vec.empty()) return;\n \n    std::sort(vec.begin(), vec.end());\n    std::pair<int, int> last = std::make_pair(-1, -1);\n    for (std::vector< std::pair<int, int> >::const_iterator it = vec.begin(); it != vec.end(); it++) {\n        seg->update(last.second + 1, it->first - 1, p);\n        // printf(\"[%d, %d]\\n\", last.second + 1, it->first - 1);\n        last = *it;\n    }\n    seg->update(last.second + 1, n - 1, p);\n    // printf(\"[%d, %d]\\n\", last.second + 1, n - 1);\n}\n \ninline int query(const int x) {\n    // printf(\"query(%d)\\n\", x);\n    return seg->query(N[x].i);\n}\n \nint main() {\n    freopen(\"network_tenderRun.in\", \"r\", stdin);\n    freopen(\"network_tenderRun.out\", \"w\", stdout);\n \n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n        addEdge(u, v);\n    }\n \n    cut();\n \n    // for (int i = 0; i < n; i++) printf(\"#%d: i = %d\\n\", i + 1, N[i].i);\n \n    for (int i = 0; i < m; i++) {\n        int c;\n        scanf(\"%d\", &c);\n        if (c == 0) {\n            int u, v, w;\n            scanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n            update(u, v, std::make_pair(w, &del[i]));\n        } else if (c == 1) {\n            int t;\n            scanf(\"%d\", &t), t--;\n            del[t] = true;\n        } else if (c == 2) {\n            int x;\n            scanf(\"%d\", &x), x--;\n            printf(\"%d\\n\", query(x));\n        }\n    }\n \n    fclose(stdin);\n    fclose(stdout);\n \n    return 0;\n}\n```\n","slug":"hnoi2016-network","published":1,"updated":"2016-05-11T09:39:49.490Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6ckd00xfc2xlcm2srjss"},{"title":"HNOI2016 -  + ","date":"2016-05-11T08:39:00.000Z","_content":"\n $ N $  $ M $  $ 1,\\ 2,\\ \\dots,\\ n $ $ 2 ^ a 3 ^ b $  $ q $  $ u $$ v $$ a $  $ b $ $ u $  $ v $  $ 2 ^ a 3 ^ b $\n\n<!-- more -->\n\n### \n[BZOJ 4537](http://www.lydsy.com/JudgeOnline/problem.php?id=4537)  \n[COGS 2241](http://cogs.top/cogs/problem/problem.php?pid=2241)  \n[CodeVS 4890](http://codevs.cn/problem/4890/)\n\n### \n******** $ 2 $  $ 3 $  $ 2 ^ {a_1} 3 ^ {b_1},\\ 2 ^ {a_2} 3 ^ {b_2},\\ \\dots,\\ 2 ^ {a_n} 3 ^ {b_n} $  $ 2 $  $ 3 $  $ 2 ^ {\\max\\{a_i\\}} 3 ^ {\\max\\{b_i\\}} $\n\n $ a $  $ b $ \n\n $ a $  $ b $  $ a $  $ b $  $ O(qm \\  \\alpha(m)) $\n\n $ a $  $ a $  $ b $ \n\n $ a $  $ T $  $ a $  $ a $ $ b $  $ a $  $ b $ ****\n\n********\n\n $ O(\\frac{n}{T}) $  $ O(\\frac{n}{T}) $  $ O(q \\frac{n}{T} \\log \\frac{n}{T}) $ $ T $  $ 1 $  $ O(T m \\log m + q \\log q) $ $ T = \\sqrt m $ $ O(q \\sqrt m \\log \\sqrt m + m \\sqrt m \\log m + q \\log q) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n// #include <cstring>\n// #include <cassert>\n#include <algorithm>\n#include <stack>\n#include <utility>\n#include <vector>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\nconst int MAXQ = 50000;\n\nstruct UnionFindSet {\n    int p[MAXN], rk[MAXN], a[MAXN], b[MAXN];\n    // int n;\n    std::stack< std::pair<int *, int> > s;\n\n    inline void init(const int n) {\n        // this->n = n;\n        for (int i = 0; i < n; i++) p[i] = i, rk[i] = 1, a[i] = -1, b[i] = -1;\n        while (!s.empty()) s.pop();\n    }\n\n    inline int find(const int x) {\n        // assert(x < n);\n        return p[x] == x ? x : find(p[x]);\n    }\n\n    inline int find(const int x, int &a, int &b) {\n        // assert(x < n);\n        if (p[x] == x) {\n            a = this->a[x], b = this->b[x];\n            return x;\n        }\n        return find(p[x], a, b);\n    }\n\n    inline void merge(const int x, const int y, const int a, const int b) {\n        int _x = find(x), _y = find(y);\n        if (_x != _y) {\n            if (rk[_x] == rk[_y]) {\n                s.push(std::make_pair(&rk[_y], rk[_y]));\n                rk[_y]++;\n            } else if (rk[_x] > rk[_y]) {\n                std::swap(_x, _y);\n            }\n\n            s.push(std::make_pair(&this->a[_y], this->a[_y]));\n            s.push(std::make_pair(&this->b[_y], this->b[_y]));\n            s.push(std::make_pair(&p[_x], p[_x]));\n\n            p[_x] = _y;\n            this->a[_y] = std::max(this->a[_y], this->a[_x]);\n            this->a[_y] = std::max(this->a[_y], a);\n            this->b[_y] = std::max(this->b[_y], this->b[_x]);\n            this->b[_y] = std::max(this->b[_y], b);\n        } else {\n            s.push(std::make_pair(&this->a[_y], this->a[_y]));\n            s.push(std::make_pair(&this->b[_y], this->b[_y]));\n\n            this->a[_x] = std::max(this->a[_x], a);\n            this->b[_x] = std::max(this->b[_x], b);\n        }\n    }\n\n    inline size_t status() { return s.size(); }\n\n    inline void restore(const size_t s) {\n        while (this->s.size() > s) {\n            const std::pair<int *, int> p = this->s.top();\n            *p.first = p.second;\n            this->s.pop();\n        }\n    }\n} ufs;\n\nstruct Edge {\n    int u, v, a, b;\n} E[MAXM];\n\nstruct Query {\n    int u, v, a, b; // , cnt;\n    bool ans; // , solved;\n} Q[MAXQ];\n\nint n, m, q;\n// bool ans[MAXQ];\n\ninline bool compareByA(const Edge &a, const Edge &b) {\n    return a.a < b.a;\n}\n\ninline bool compareByB(const Edge &a, const Edge &b) {\n    return a.b < b.b;\n}\n\ninline bool compareQueryByB(const Query *a, const Query *b) {\n    return a->b < b->b;\n}\n\n/*\ninline void forceSolve() {\n    for (int i = 0; i < q; i++) {\n        ufs.init(n);\n        for (int j = 0; j < m; j++) {\n            if (E[j].a <= Q[i].a && E[j].b <= Q[i].b) ufs.merge(E[j].u, E[j].v, E[j].a, E[j].b);\n        }\n        int a, b;\n        if (ufs.find(Q[i].u, a, b) == ufs.find(Q[i].v)) {\n            if (a == Q[i].a && b == Q[i].b) Q[i].ans = true;\n            else Q[i].ans = false;\n        } else Q[i].ans = false;\n    }\n}\n*/\n\ninline void solve() {\n    std::sort(E, E + m, &compareByA);\n    int blockSize = floor(sqrt(m) + 1);\n    // printf(\"blockSize = %d\\n\", blockSize);\n\n    for (int i = 0; i < m; i += blockSize) {\n        int curr = std::min(m - 1, i);\n        // printf(\"curr = %d, curr + blockSize = %d\\n\", curr, curr + blockSize);\n\n        std::sort(E, E + curr, &compareByB);\n        ufs.init(n);\n\n        std::vector<Query *> vec;\n        for (int j = 0; j < q; j++) {\n            if (Q[j].a >= E[curr].a && (curr + blockSize >= m || Q[j].a < E[curr + blockSize].a)) {\n                vec.push_back(&Q[j]);\n                // printf(\"getting queries ->  saved  { %d -> %d, [%d, %d] }\\n\", Q[j].u + 1, Q[j].v + 1, Q[j].a, Q[j].b);\n            } else {\n                // printf(\"getting queries -> ignored { %d -> %d, [%d, %d] }\\n\", Q[j].u + 1, Q[j].v + 1, Q[j].a, Q[j].b);\n            }\n        }\n        std::sort(vec.begin(), vec.end(), &compareQueryByB);\n\n        int j = 0;\n        for (std::vector<Query *>::const_iterator it = vec.begin(); it != vec.end(); it++) {\n            Query *p = *it;\n            while (j < curr && E[j].b <= p->b) {\n                Edge &e = E[j];\n                ufs.merge(e.u, e.v, e.a, e.b);\n                // printf(\"E(%d -> %d, [%d, %d])\\n\", e.u + 1, e.v + 1, e.a, e.b);\n                j++;\n            }\n\n            // static char restoreBuffers[sizeof(UnionFindSet)];\n            // memcpy(restoreBuffers, &ufs, sizeof(UnionFindSet));\n            size_t s = ufs.status();\n\n            for (int k = curr; k < std::min(curr + blockSize, m); k++) {\n            // for (int k = 0; k < m; k++) {\n                Edge &e = E[k];\n                if (e.a <= p->a && e.b <= p->b) {\n                    ufs.merge(e.u, e.v, e.a, e.b);\n                }\n            }\n\n            int a, b;\n            if (ufs.find(p->u, a, b) == ufs.find(p->v)) {\n                if (a == p->a && b == p->b) p->ans = true;\n                else p->ans = false;\n            } else p->ans = false;\n\n            // assert(p->ans == ans[&*p - Q]);\n\n            // if (p - Q + 1 >= 200 && p - Q + 1 <= 220) {\n            //     printf(\"Q(%d -> %d, [%d, %d]) = %s\\n\", p->u + 1, p->v + 1, p->a, p->b, p->ans ? \"Yes\" : \"No\");\n            // }\n\n            // p->cnt++;\n            // p->solved = true;\n\n            ufs.restore(s);\n            // memcpy(&ufs, restoreBuffers, sizeof(UnionFindSet));\n        }\n    }\n}\n\nint main() {\n    freopen(\"multiple.in\", \"r\", stdin);\n    freopen(\"multiple.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d %d\", &E[i].u, &E[i].v, &E[i].a, &E[i].b);\n        E[i].u--, E[i].v--;\n    }\n\n    scanf(\"%d\", &q);\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d %d %d %d\", &Q[i].u, &Q[i].v, &Q[i].a, &Q[i].b);\n        Q[i].u--, Q[i].v--;\n    }\n\n    // forceSolve();\n    solve();\n\n    for (int i = 0; i < q; i++) {\n        // assert(Q[i].solved);\n        // printf(\"%d \", Q[i].cnt);\n        puts(Q[i].ans ? \"Yes\" : \"No\");\n    }\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/hnoi2016-multiple.md","raw":"title: HNOI2016 -  + \ncategories: OI\ntags:\n  - BZOJ\n  - COGS\n  - CodeVS\n  - HNOI\n  - \n  - \npermalink: hnoi2016-multiple\ndate: 2016-05-11 16:39:00\n---\n\n $ N $  $ M $  $ 1,\\ 2,\\ \\dots,\\ n $ $ 2 ^ a 3 ^ b $  $ q $  $ u $$ v $$ a $  $ b $ $ u $  $ v $  $ 2 ^ a 3 ^ b $\n\n<!-- more -->\n\n### \n[BZOJ 4537](http://www.lydsy.com/JudgeOnline/problem.php?id=4537)  \n[COGS 2241](http://cogs.top/cogs/problem/problem.php?pid=2241)  \n[CodeVS 4890](http://codevs.cn/problem/4890/)\n\n### \n******** $ 2 $  $ 3 $  $ 2 ^ {a_1} 3 ^ {b_1},\\ 2 ^ {a_2} 3 ^ {b_2},\\ \\dots,\\ 2 ^ {a_n} 3 ^ {b_n} $  $ 2 $  $ 3 $  $ 2 ^ {\\max\\{a_i\\}} 3 ^ {\\max\\{b_i\\}} $\n\n $ a $  $ b $ \n\n $ a $  $ b $  $ a $  $ b $  $ O(qm \\  \\alpha(m)) $\n\n $ a $  $ a $  $ b $ \n\n $ a $  $ T $  $ a $  $ a $ $ b $  $ a $  $ b $ ****\n\n********\n\n $ O(\\frac{n}{T}) $  $ O(\\frac{n}{T}) $  $ O(q \\frac{n}{T} \\log \\frac{n}{T}) $ $ T $  $ 1 $  $ O(T m \\log m + q \\log q) $ $ T = \\sqrt m $ $ O(q \\sqrt m \\log \\sqrt m + m \\sqrt m \\log m + q \\log q) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n// #include <cstring>\n// #include <cassert>\n#include <algorithm>\n#include <stack>\n#include <utility>\n#include <vector>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\nconst int MAXQ = 50000;\n\nstruct UnionFindSet {\n    int p[MAXN], rk[MAXN], a[MAXN], b[MAXN];\n    // int n;\n    std::stack< std::pair<int *, int> > s;\n\n    inline void init(const int n) {\n        // this->n = n;\n        for (int i = 0; i < n; i++) p[i] = i, rk[i] = 1, a[i] = -1, b[i] = -1;\n        while (!s.empty()) s.pop();\n    }\n\n    inline int find(const int x) {\n        // assert(x < n);\n        return p[x] == x ? x : find(p[x]);\n    }\n\n    inline int find(const int x, int &a, int &b) {\n        // assert(x < n);\n        if (p[x] == x) {\n            a = this->a[x], b = this->b[x];\n            return x;\n        }\n        return find(p[x], a, b);\n    }\n\n    inline void merge(const int x, const int y, const int a, const int b) {\n        int _x = find(x), _y = find(y);\n        if (_x != _y) {\n            if (rk[_x] == rk[_y]) {\n                s.push(std::make_pair(&rk[_y], rk[_y]));\n                rk[_y]++;\n            } else if (rk[_x] > rk[_y]) {\n                std::swap(_x, _y);\n            }\n\n            s.push(std::make_pair(&this->a[_y], this->a[_y]));\n            s.push(std::make_pair(&this->b[_y], this->b[_y]));\n            s.push(std::make_pair(&p[_x], p[_x]));\n\n            p[_x] = _y;\n            this->a[_y] = std::max(this->a[_y], this->a[_x]);\n            this->a[_y] = std::max(this->a[_y], a);\n            this->b[_y] = std::max(this->b[_y], this->b[_x]);\n            this->b[_y] = std::max(this->b[_y], b);\n        } else {\n            s.push(std::make_pair(&this->a[_y], this->a[_y]));\n            s.push(std::make_pair(&this->b[_y], this->b[_y]));\n\n            this->a[_x] = std::max(this->a[_x], a);\n            this->b[_x] = std::max(this->b[_x], b);\n        }\n    }\n\n    inline size_t status() { return s.size(); }\n\n    inline void restore(const size_t s) {\n        while (this->s.size() > s) {\n            const std::pair<int *, int> p = this->s.top();\n            *p.first = p.second;\n            this->s.pop();\n        }\n    }\n} ufs;\n\nstruct Edge {\n    int u, v, a, b;\n} E[MAXM];\n\nstruct Query {\n    int u, v, a, b; // , cnt;\n    bool ans; // , solved;\n} Q[MAXQ];\n\nint n, m, q;\n// bool ans[MAXQ];\n\ninline bool compareByA(const Edge &a, const Edge &b) {\n    return a.a < b.a;\n}\n\ninline bool compareByB(const Edge &a, const Edge &b) {\n    return a.b < b.b;\n}\n\ninline bool compareQueryByB(const Query *a, const Query *b) {\n    return a->b < b->b;\n}\n\n/*\ninline void forceSolve() {\n    for (int i = 0; i < q; i++) {\n        ufs.init(n);\n        for (int j = 0; j < m; j++) {\n            if (E[j].a <= Q[i].a && E[j].b <= Q[i].b) ufs.merge(E[j].u, E[j].v, E[j].a, E[j].b);\n        }\n        int a, b;\n        if (ufs.find(Q[i].u, a, b) == ufs.find(Q[i].v)) {\n            if (a == Q[i].a && b == Q[i].b) Q[i].ans = true;\n            else Q[i].ans = false;\n        } else Q[i].ans = false;\n    }\n}\n*/\n\ninline void solve() {\n    std::sort(E, E + m, &compareByA);\n    int blockSize = floor(sqrt(m) + 1);\n    // printf(\"blockSize = %d\\n\", blockSize);\n\n    for (int i = 0; i < m; i += blockSize) {\n        int curr = std::min(m - 1, i);\n        // printf(\"curr = %d, curr + blockSize = %d\\n\", curr, curr + blockSize);\n\n        std::sort(E, E + curr, &compareByB);\n        ufs.init(n);\n\n        std::vector<Query *> vec;\n        for (int j = 0; j < q; j++) {\n            if (Q[j].a >= E[curr].a && (curr + blockSize >= m || Q[j].a < E[curr + blockSize].a)) {\n                vec.push_back(&Q[j]);\n                // printf(\"getting queries ->  saved  { %d -> %d, [%d, %d] }\\n\", Q[j].u + 1, Q[j].v + 1, Q[j].a, Q[j].b);\n            } else {\n                // printf(\"getting queries -> ignored { %d -> %d, [%d, %d] }\\n\", Q[j].u + 1, Q[j].v + 1, Q[j].a, Q[j].b);\n            }\n        }\n        std::sort(vec.begin(), vec.end(), &compareQueryByB);\n\n        int j = 0;\n        for (std::vector<Query *>::const_iterator it = vec.begin(); it != vec.end(); it++) {\n            Query *p = *it;\n            while (j < curr && E[j].b <= p->b) {\n                Edge &e = E[j];\n                ufs.merge(e.u, e.v, e.a, e.b);\n                // printf(\"E(%d -> %d, [%d, %d])\\n\", e.u + 1, e.v + 1, e.a, e.b);\n                j++;\n            }\n\n            // static char restoreBuffers[sizeof(UnionFindSet)];\n            // memcpy(restoreBuffers, &ufs, sizeof(UnionFindSet));\n            size_t s = ufs.status();\n\n            for (int k = curr; k < std::min(curr + blockSize, m); k++) {\n            // for (int k = 0; k < m; k++) {\n                Edge &e = E[k];\n                if (e.a <= p->a && e.b <= p->b) {\n                    ufs.merge(e.u, e.v, e.a, e.b);\n                }\n            }\n\n            int a, b;\n            if (ufs.find(p->u, a, b) == ufs.find(p->v)) {\n                if (a == p->a && b == p->b) p->ans = true;\n                else p->ans = false;\n            } else p->ans = false;\n\n            // assert(p->ans == ans[&*p - Q]);\n\n            // if (p - Q + 1 >= 200 && p - Q + 1 <= 220) {\n            //     printf(\"Q(%d -> %d, [%d, %d]) = %s\\n\", p->u + 1, p->v + 1, p->a, p->b, p->ans ? \"Yes\" : \"No\");\n            // }\n\n            // p->cnt++;\n            // p->solved = true;\n\n            ufs.restore(s);\n            // memcpy(&ufs, restoreBuffers, sizeof(UnionFindSet));\n        }\n    }\n}\n\nint main() {\n    freopen(\"multiple.in\", \"r\", stdin);\n    freopen(\"multiple.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d %d\", &E[i].u, &E[i].v, &E[i].a, &E[i].b);\n        E[i].u--, E[i].v--;\n    }\n\n    scanf(\"%d\", &q);\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d %d %d %d\", &Q[i].u, &Q[i].v, &Q[i].a, &Q[i].b);\n        Q[i].u--, Q[i].v--;\n    }\n\n    // forceSolve();\n    solve();\n\n    for (int i = 0; i < q; i++) {\n        // assert(Q[i].solved);\n        // printf(\"%d \", Q[i].cnt);\n        puts(Q[i].ans ? \"Yes\" : \"No\");\n    }\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"hnoi2016-multiple","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6ckm00xnc2xl09mej7dn"},{"title":"HNOI2012 - ","date":"2016-09-07T23:52:00.000Z","_content":"\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 2730](http://www.lydsy.com/JudgeOnline/problem.php?id=2730)\n\n### \n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <tr1/unordered_set>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low;\n\tbool v, pushed, flag;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint ts = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\t\tstd::stack<Node *> s;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->low = v->dfn = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, s.push(e->t), e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != &N[i]) for (Edge *e = v->e; e; e = e->next) if (e->t->low >= v->dfn && e->t->p == v) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// if (v->flag) printf(\"!!!: %lu\\n\", v - N + 1);\n\t\t\t\tif (v->flag) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t\t\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) cnt++;\n\t\tN[i].flag = cnt >= 2;\n\t}\n\n\treturn cnt;\n}\n\ninline void solve(int &min, long long &cnt) {\n\tmin = 0, cnt = 1;\n\tfor (int i = 0; i < n; i++) N[i].v = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v || N[i].flag) continue;\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].v = true;\n\n\t\tstd::tr1::unordered_set<unsigned long> s;\n\t\tint size = 0;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tsize++;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->flag) s.insert(e->t - N);\n\t\t\t\telse if (!e->t->v) q.push(e->t), e->t->v = true;\n\t\t\t}\n\t\t}\n\n\t\tif (s.size() == 1) min++, cnt *= size;\n\t}\n\n\tif (!min) min = 2, cnt = n * (n - 1) / 2;\n}\n\nint main() {\n\tfor (int i = 1, m; ~scanf(\"%d\", &m) && m; i++) {\n\t\tn = 0;\n\t\twhile (m--) {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tn = std::max(n, std::max(u, v));\n\t\t\tu--, v--;\n\t\t\taddEdge(u, v);\n\t\t}\n\n\t\ttarjan();\n\n\t\tint min;\n\t\tlong long cnt;\n\t\tsolve(min, cnt);\n\t\tprintf(\"Case %d: %d %lld\\n\", i, min, cnt);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].v = N[i].pushed = N[i].flag = false;\n\t\t\tN[i].dfn = N[i].low = 0;\n\t\t\tN[i].p = NULL;\n\t\t\tEdge *next;\n\t\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","source":"_posts/hnoi2012-mine.md","raw":"title: HNOI2012 - \ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - Tarjan\n  - \n  - \npermalink: hnoi2012-mine\ndate: 2016-09-08 07:52:00\n---\n\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 2730](http://www.lydsy.com/JudgeOnline/problem.php?id=2730)\n\n### \n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <tr1/unordered_set>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e, *c;\n\tNode *p;\n\tint dfn, low;\n\tbool v, pushed, flag;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint ts = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v) continue;\n\t\tstd::stack<Node *> s;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\t\t\tif (!v->v) {\n\t\t\t\tv->v = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->low = v->dfn = ++ts;\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tEdge *&e = v->c;\n\t\t\t\tif (e->t->v) v->low = std::min(v->low, e->t->dfn);\n\t\t\t\telse if (!e->t->pushed) e->t->pushed = true, s.push(e->t), e->t->p = v;\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v != &N[i]) for (Edge *e = v->e; e; e = e->next) if (e->t->low >= v->dfn && e->t->p == v) {\n\t\t\t\t\tv->flag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// if (v->flag) printf(\"!!!: %lu\\n\", v - N + 1);\n\t\t\t\tif (v->flag) cnt++;\n\n\t\t\t\tif (v->p) v->p->low = std::min(v->p->low, v->low);\n\t\t\t\t\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (Edge *e = N[i].e; e; e = e->next) if (e->t->p == &N[i]) cnt++;\n\t\tN[i].flag = cnt >= 2;\n\t}\n\n\treturn cnt;\n}\n\ninline void solve(int &min, long long &cnt) {\n\tmin = 0, cnt = 1;\n\tfor (int i = 0; i < n; i++) N[i].v = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].v || N[i].flag) continue;\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].v = true;\n\n\t\tstd::tr1::unordered_set<unsigned long> s;\n\t\tint size = 0;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tsize++;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->t->flag) s.insert(e->t - N);\n\t\t\t\telse if (!e->t->v) q.push(e->t), e->t->v = true;\n\t\t\t}\n\t\t}\n\n\t\tif (s.size() == 1) min++, cnt *= size;\n\t}\n\n\tif (!min) min = 2, cnt = n * (n - 1) / 2;\n}\n\nint main() {\n\tfor (int i = 1, m; ~scanf(\"%d\", &m) && m; i++) {\n\t\tn = 0;\n\t\twhile (m--) {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tn = std::max(n, std::max(u, v));\n\t\t\tu--, v--;\n\t\t\taddEdge(u, v);\n\t\t}\n\n\t\ttarjan();\n\n\t\tint min;\n\t\tlong long cnt;\n\t\tsolve(min, cnt);\n\t\tprintf(\"Case %d: %d %lld\\n\", i, min, cnt);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].v = N[i].pushed = N[i].flag = false;\n\t\t\tN[i].dfn = N[i].low = 0;\n\t\t\tN[i].p = NULL;\n\t\t\tEdge *next;\n\t\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","slug":"hnoi2012-mine","published":1,"updated":"2016-09-07T23:53:21.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6ckz00xvc2xl4owzq48v"},{"title":"HNOI2010 -  DP","date":"2016-07-06T04:08:00.000Z","_content":"\n\n\n1. \n2. \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1996](http://www.lydsy.com/JudgeOnline/problem.php?id=1996)\n\n### \n\n\n $ [l, r] $  $ A $  $ A $  $ [l, r - 1] $  $ [l, r - 1] $  $ A $ \n\n $ f(l, r, flag) $  $ [l, r] $  $ flag $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\nconst int MOD = 19650827;\n\nconst int DP_L = 0;\nconst int DP_R = 1;\nconst int DP_LR = 2;\n\nint n, a[MAXN];\n\ninline int dp(const int l, const int r, const int flag) {\n\tstatic int mem[MAXN][MAXN][3];\n\tstatic bool calced[MAXN][MAXN][3];\n\tint &ans = mem[l][r][flag];\n\tif (calced[l][r][flag]) return ans;\n\tcalced[l][r][flag] = true;\n\n\tif (r - l + 1 == 2) {\n\t\tif (a[l] > a[r]) return ans = 0;\n\t\telse if (flag == DP_LR) return ans = 2;\n\t\telse return ans = 1;\n\t}\n\n\tif (flag != DP_L) {\n\t\tconst int L = l, R = r - 1;\n\t\tif (a[r] > a[L] && a[r] > a[R]) ans += dp(L, R, DP_LR);\n\t\telse if (a[r] > a[L]) ans += dp(L, R, DP_L);\n\t\telse if (a[r] > a[R]) ans += dp(L, R, DP_R);\n\t}\n\n\tif (flag != DP_R) {\n\t\tconst int L = l + 1, R = r;\n\t\tif (a[l] < a[L] && a[l] < a[R]) ans += dp(L, R, DP_LR);\n\t\telse if (a[l] < a[L]) ans += dp(L, R, DP_L);\n\t\telse if (a[l] < a[R]) ans += dp(L, R, DP_R);\n\t}\n\n\treturn ans %= MOD;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tprintf(\"%d\\n\", dp(0, n - 1, DP_LR));\n\n\treturn 0;\n}\n```\n","source":"_posts/hnoi2010-chorus.md","raw":"title: HNOI2010 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - DP\n  -  DP\npermalink: hnoi2010-chorus\ndate: 2016-07-06 12:08:00\n---\n\n\n\n1. \n2. \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1996](http://www.lydsy.com/JudgeOnline/problem.php?id=1996)\n\n### \n\n\n $ [l, r] $  $ A $  $ A $  $ [l, r - 1] $  $ [l, r - 1] $  $ A $ \n\n $ f(l, r, flag) $  $ [l, r] $  $ flag $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\nconst int MOD = 19650827;\n\nconst int DP_L = 0;\nconst int DP_R = 1;\nconst int DP_LR = 2;\n\nint n, a[MAXN];\n\ninline int dp(const int l, const int r, const int flag) {\n\tstatic int mem[MAXN][MAXN][3];\n\tstatic bool calced[MAXN][MAXN][3];\n\tint &ans = mem[l][r][flag];\n\tif (calced[l][r][flag]) return ans;\n\tcalced[l][r][flag] = true;\n\n\tif (r - l + 1 == 2) {\n\t\tif (a[l] > a[r]) return ans = 0;\n\t\telse if (flag == DP_LR) return ans = 2;\n\t\telse return ans = 1;\n\t}\n\n\tif (flag != DP_L) {\n\t\tconst int L = l, R = r - 1;\n\t\tif (a[r] > a[L] && a[r] > a[R]) ans += dp(L, R, DP_LR);\n\t\telse if (a[r] > a[L]) ans += dp(L, R, DP_L);\n\t\telse if (a[r] > a[R]) ans += dp(L, R, DP_R);\n\t}\n\n\tif (flag != DP_R) {\n\t\tconst int L = l + 1, R = r;\n\t\tif (a[l] < a[L] && a[l] < a[R]) ans += dp(L, R, DP_LR);\n\t\telse if (a[l] < a[L]) ans += dp(L, R, DP_L);\n\t\telse if (a[l] < a[R]) ans += dp(L, R, DP_R);\n\t}\n\n\treturn ans %= MOD;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tprintf(\"%d\\n\", dp(0, n - 1, DP_LR));\n\n\treturn 0;\n}\n```\n","slug":"hnoi2010-chorus","published":1,"updated":"2016-10-24T23:36:49.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cl800y2c2xlfkyejj2n"},{"title":"HNOI2008 - Prfer ","date":"2016-10-11T10:51:00.000Z","_content":"\n $ 1 $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1005](http://www.lydsy.com/JudgeOnline/problem.php?id=1005)\n\n### \nPrufer \n\n>  $ n $  Prufer  $ n - 2 $ $ -1 $  Prufer \n\n $ k $ $ d_i $  $ i $ $ s = \\sum\\limits_{d_i \\neq -1} d_i - 1 $ $ s $ \n\n Prufer \n\n$$ C(n - 2, s) \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} $$\n\n $ n - k $  $ n - 2 - s $ \n\n$$ C(n - 2, s) \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} \\times (n - k) ^ {n - 2 - s} $$\n\n\n\n$$\n\\begin{aligned}\n&= \\frac{(n - 2)!}{s!(n - 2 - s)!} \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} \\times (n - k) ^ {n - 2 - s} \\\\\n&= \\frac{(n - 2)! (n - k) ^ {n - 2 - s}}{(n - 2 - s)! \\prod\\limits_{i = 1} ^ k (d_i - 1) !}\n\\end{aligned}\n$$\n\n### \n```java\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\n\t\tint d[] = new int[n], s = 0, k = 0;\n\t\tboolean invalid = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i] = sc.nextInt();\n\t\t\tif (d[i] != -1) {\n\t\t\t\tk++;\n\t\t\t\tif (d[i] <= 0 || d[i] >= n + 1) invalid = true;\n\t\t\t\ts += d[i] - 1;\n\t\t\t}\n\t\t}\n\n\t\tif (n == 1) {\n\t\t\tif (d[0] == 0 || d[0] == -1) System.out.println(1);\n\t\t\telse System.out.println(0);\n\t\t} else if (n == 2) {\n\t\t\tif ((d[0] == 1 || d[0] == -1) && (d[1] == 1 || d[1] == -1)) System.out.println(1);\n\t\t\telse System.out.println(0);\n\t\t} else if (invalid) {\n\t\t\tSystem.out.println(0);\n\t\t} else {\n\t\t\tBigInteger fac[] = new BigInteger[n - 1];\n\t\t\tfac[0] = BigInteger.ONE;\n\t\t\tfor (int i = 1; i <= n - 2; i++) fac[i] = fac[i - 1].multiply(BigInteger.valueOf(i));\n\n\t\t\tBigInteger ans = BigInteger.ONE;\n\t\t\tans = ans.multiply(fac[n - 2]).multiply(BigInteger.valueOf(n - k).pow(n - 2 - s)).divide(fac[n - 2 - s]);\n\t\t\tfor (int i = 0; i < n; i++) if (d[i] > 1) ans = ans.divide(fac[d[i] - 1]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\n```\n","source":"_posts/hnoi2008-tree.md","raw":"title: HNOI2008 - Prfer \ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - Prfer \n  - \n  - \npermalink: hnoi2008-tree\ndate: 2016-10-11 18:51:00\n---\n\n $ 1 $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1005](http://www.lydsy.com/JudgeOnline/problem.php?id=1005)\n\n### \nPrufer \n\n>  $ n $  Prufer  $ n - 2 $ $ -1 $  Prufer \n\n $ k $ $ d_i $  $ i $ $ s = \\sum\\limits_{d_i \\neq -1} d_i - 1 $ $ s $ \n\n Prufer \n\n$$ C(n - 2, s) \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} $$\n\n $ n - k $  $ n - 2 - s $ \n\n$$ C(n - 2, s) \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} \\times (n - k) ^ {n - 2 - s} $$\n\n\n\n$$\n\\begin{aligned}\n&= \\frac{(n - 2)!}{s!(n - 2 - s)!} \\times \\frac{s!}{\\prod\\limits_{i = 1} ^ k (d_i - 1) !} \\times (n - k) ^ {n - 2 - s} \\\\\n&= \\frac{(n - 2)! (n - k) ^ {n - 2 - s}}{(n - 2 - s)! \\prod\\limits_{i = 1} ^ k (d_i - 1) !}\n\\end{aligned}\n$$\n\n### \n```java\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\n\t\tint d[] = new int[n], s = 0, k = 0;\n\t\tboolean invalid = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i] = sc.nextInt();\n\t\t\tif (d[i] != -1) {\n\t\t\t\tk++;\n\t\t\t\tif (d[i] <= 0 || d[i] >= n + 1) invalid = true;\n\t\t\t\ts += d[i] - 1;\n\t\t\t}\n\t\t}\n\n\t\tif (n == 1) {\n\t\t\tif (d[0] == 0 || d[0] == -1) System.out.println(1);\n\t\t\telse System.out.println(0);\n\t\t} else if (n == 2) {\n\t\t\tif ((d[0] == 1 || d[0] == -1) && (d[1] == 1 || d[1] == -1)) System.out.println(1);\n\t\t\telse System.out.println(0);\n\t\t} else if (invalid) {\n\t\t\tSystem.out.println(0);\n\t\t} else {\n\t\t\tBigInteger fac[] = new BigInteger[n - 1];\n\t\t\tfac[0] = BigInteger.ONE;\n\t\t\tfor (int i = 1; i <= n - 2; i++) fac[i] = fac[i - 1].multiply(BigInteger.valueOf(i));\n\n\t\t\tBigInteger ans = BigInteger.ONE;\n\t\t\tans = ans.multiply(fac[n - 2]).multiply(BigInteger.valueOf(n - k).pow(n - 2 - s)).divide(fac[n - 2 - s]);\n\t\t\tfor (int i = 0; i < n; i++) if (d[i] > 1) ans = ans.divide(fac[d[i] - 1]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\n```\n","slug":"hnoi2008-tree","published":1,"updated":"2016-10-17T03:06:47.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6clh00y8c2xl0vbm2av4"},{"title":"HNOI2008 -  DP","date":"2016-04-24T03:23:41.000Z","_content":"\nP  $ 1 $ ~ $ N $  $ N $  $ i $  $ C_i $P  $ i $  $ j $  $ x = j - i + \\sum\\limits_{k = i} ^ j C_k $ $ x $ $ (x - L) ^ 2 $ $ L $ P \n $ L $\n\n<!-- more -->\n\n### \n[BZOJ 1010](http://www.lydsy.com/JudgeOnline/problem.php?id=1010)  \n[CodeVS 1319](http://codevs.cn/problem/1319/)  \n[COGS 1330](http://cogs.top/cogs/problem/problem.php?pid=1330)\n\n### \n $ f[i] $  i  $ s(n) = \\sum\\limits_{i = 1} ^ {n} C[i]  $\n\n $ j $ $ j + 1 $ ~ $ i $  $ i - j - 1 + s(i) - s(j) $\n\n$$ f[i] = \\min\\limits_{j = 0} ^ {i - 1} \\big \\{ f[j] + (i - j - 1 + s(i) - s(j) - L) ^ 2 \\big \\} $$\n\n $ O(n ^ 2) $\n\n $ g(i) = s(i) + i - L - 1 $$ h(j) = s(j) + j $\n\n$$ f[i] = \\min\\limits_{j = 0} ^ {i - 1} \\big \\{ f[j] + \\big [ g(i) - h(j) \\big ] ^ 2 \\big \\} $$\n\n $ j = a $  $ j = b $$ a > b $ a  b \n\n$$\n\\begin{align*}\nf[a] + \\big [ g(i) - h(a) \\big ] ^ 2 & < f[b] + \\big [ g(i) - h(b) \\big ] ^ 2 \\\\\nf[a] + g(i) ^ 2 + h(a) ^ 2 - 2g(i)h(a) & < f[b] + g(i) ^ 2 + h(b) ^ 2 - 2g(i)h(b) \\\\\nf[a] + h(a) ^ 2 - 2g(i)h(a) & < f[b] + h(b) ^ 2 - 2g(i)h(b) \\\\\n(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2) & < 2g(i)h(a) - 2g(i)h(b) \\\\\n(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2) & < 2g(i) \\big [h(a) - h(b) \\big ] \\\\\n\\frac{(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2)}{h(a) - h(b)} & < 2g(i) \\\\\n\\end{align*}\n$$\n\n $ O(1) $ $ O(n) $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 50000;\n\nint n, L, a[MAXN];\nlong long s[MAXN + 1], f[MAXN + 1];\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline long long g(const int i) { return s[i] + i - L - 1; }\ninline long long h(const int j) { return s[j] + j; }\n\ninline double slope(const int a, const int b) {\n    return double((f[a] + sqr(h(a))) - (f[b] + sqr(h(b)))) / double(h(a) - h(b));\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &L);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i - 1];\n\n    static long long q[MAXN];\n    long long *l = q, *r = q - 1;\n    *++r = 0;\n\n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) <= 2 * g(i)) l++;\n        f[i] = f[*l] + sqr(g(i) - h(*l));\n        while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n        *++r = i;\n    }\n\n    printf(\"%lld\\n\", f[n]);\n\n    return 0;\n}\n```\n","source":"_posts/hnoi2008-toy.md","raw":"title: HNOI2008 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - COGS\n  - HNOI\n  - \n  - \n  - DP\npermalink: hnoi2008-toy\ndate: 2016-04-24 11:23:41\n---\n\nP  $ 1 $ ~ $ N $  $ N $  $ i $  $ C_i $P  $ i $  $ j $  $ x = j - i + \\sum\\limits_{k = i} ^ j C_k $ $ x $ $ (x - L) ^ 2 $ $ L $ P \n $ L $\n\n<!-- more -->\n\n### \n[BZOJ 1010](http://www.lydsy.com/JudgeOnline/problem.php?id=1010)  \n[CodeVS 1319](http://codevs.cn/problem/1319/)  \n[COGS 1330](http://cogs.top/cogs/problem/problem.php?pid=1330)\n\n### \n $ f[i] $  i  $ s(n) = \\sum\\limits_{i = 1} ^ {n} C[i]  $\n\n $ j $ $ j + 1 $ ~ $ i $  $ i - j - 1 + s(i) - s(j) $\n\n$$ f[i] = \\min\\limits_{j = 0} ^ {i - 1} \\big \\{ f[j] + (i - j - 1 + s(i) - s(j) - L) ^ 2 \\big \\} $$\n\n $ O(n ^ 2) $\n\n $ g(i) = s(i) + i - L - 1 $$ h(j) = s(j) + j $\n\n$$ f[i] = \\min\\limits_{j = 0} ^ {i - 1} \\big \\{ f[j] + \\big [ g(i) - h(j) \\big ] ^ 2 \\big \\} $$\n\n $ j = a $  $ j = b $$ a > b $ a  b \n\n$$\n\\begin{align*}\nf[a] + \\big [ g(i) - h(a) \\big ] ^ 2 & < f[b] + \\big [ g(i) - h(b) \\big ] ^ 2 \\\\\nf[a] + g(i) ^ 2 + h(a) ^ 2 - 2g(i)h(a) & < f[b] + g(i) ^ 2 + h(b) ^ 2 - 2g(i)h(b) \\\\\nf[a] + h(a) ^ 2 - 2g(i)h(a) & < f[b] + h(b) ^ 2 - 2g(i)h(b) \\\\\n(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2) & < 2g(i)h(a) - 2g(i)h(b) \\\\\n(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2) & < 2g(i) \\big [h(a) - h(b) \\big ] \\\\\n\\frac{(f[a] + h(a) ^ 2)  - (f[b] + h(b) ^ 2)}{h(a) - h(b)} & < 2g(i) \\\\\n\\end{align*}\n$$\n\n $ O(1) $ $ O(n) $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 50000;\n\nint n, L, a[MAXN];\nlong long s[MAXN + 1], f[MAXN + 1];\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline long long g(const int i) { return s[i] + i - L - 1; }\ninline long long h(const int j) { return s[j] + j; }\n\ninline double slope(const int a, const int b) {\n    return double((f[a] + sqr(h(a))) - (f[b] + sqr(h(b)))) / double(h(a) - h(b));\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &L);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i - 1];\n\n    static long long q[MAXN];\n    long long *l = q, *r = q - 1;\n    *++r = 0;\n\n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) <= 2 * g(i)) l++;\n        f[i] = f[*l] + sqr(g(i) - h(*l));\n        while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n        *++r = i;\n    }\n\n    printf(\"%lld\\n\", f[n]);\n\n    return 0;\n}\n```\n","slug":"hnoi2008-toy","published":1,"updated":"2016-10-24T23:36:27.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cly00ygc2xlcboq51r6"},{"title":"HNOI2008 - ","date":"2016-10-17T03:07:00.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1006](http://www.lydsy.com/JudgeOnline/problem.php?id=1006)\n\n### \nMCS********\n\n\n\n1. \n2.  $ +1 $\n3. \n4.  (2)\n\n $ O(n ^ 2 + m) $  $ O(n + m) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <set>\n#include <list>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000000;\n\nstruct Node {\n\tstruct Edge *e;\n\tint d, color;\n\tbool visited;\n\tstd::list<Node *>::iterator iterator;\n} N[MAXN], *seq[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, m;\n\ninline void mcs() {\n\tstatic std::list<Node *> lists[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tN[i].d = 0;\n\t\tN[i].visited = false;\n\t\tlists[0].push_front(&N[i]);\n\t\tN[i].iterator = lists[0].begin();\n\t}\n\n\tint max = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\twhile (lists[max].empty()) max--;\n\t\tNode *v = lists[max].front();\n\t\tlists[max].pop_front();\n\t\tseq[i] = v;\n\t\t// printf(\"%lu\\n\", seq[i] - N + 1);\n\t\tv->visited = true;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (!e->t->visited) {\n\t\t\t\tlists[e->t->d].erase(e->t->iterator);\n\t\t\t\te->t->d++;\n\t\t\t\tlists[e->t->d].push_front(e->t);\n\t\t\t\te->t->iterator = lists[e->t->d].begin();\n\t\t\t\tmax = std::max(max, e->t->d);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tmcs();\n\n\tint ans = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tstd::set<int> s;\n\t\tfor (Edge *e = seq[i]->e; e; e = e->next) {\n\t\t\tif (e->t->color) s.insert(e->t->color);\n\t\t}\n\t\ts.insert(INT_MAX);\n\n\t\tint last = 0;\n\t\tfor (std::set<int>::const_iterator it = s.begin(); it != s.end(); it++) {\n\t\t\tif (last + 1 != *it) {\n\t\t\t\tseq[i]->color = last + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast = *it;\n\t\t}\n\n\t\tans = std::max(ans, seq[i]->color);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/hnoi2008-kingdom.md","raw":"title: HNOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - \n  - \npermalink: hnoi2008-kingdom\ndate: 2016-10-17 11:07:00\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1006](http://www.lydsy.com/JudgeOnline/problem.php?id=1006)\n\n### \nMCS********\n\n\n\n1. \n2.  $ +1 $\n3. \n4.  (2)\n\n $ O(n ^ 2 + m) $  $ O(n + m) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <set>\n#include <list>\n\nconst int MAXN = 10000;\nconst int MAXM = 1000000;\n\nstruct Node {\n\tstruct Edge *e;\n\tint d, color;\n\tbool visited;\n\tstd::list<Node *>::iterator iterator;\n} N[MAXN], *seq[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\nint n, m;\n\ninline void mcs() {\n\tstatic std::list<Node *> lists[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tN[i].d = 0;\n\t\tN[i].visited = false;\n\t\tlists[0].push_front(&N[i]);\n\t\tN[i].iterator = lists[0].begin();\n\t}\n\n\tint max = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\twhile (lists[max].empty()) max--;\n\t\tNode *v = lists[max].front();\n\t\tlists[max].pop_front();\n\t\tseq[i] = v;\n\t\t// printf(\"%lu\\n\", seq[i] - N + 1);\n\t\tv->visited = true;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\tif (!e->t->visited) {\n\t\t\t\tlists[e->t->d].erase(e->t->iterator);\n\t\t\t\te->t->d++;\n\t\t\t\tlists[e->t->d].push_front(e->t);\n\t\t\t\te->t->iterator = lists[e->t->d].begin();\n\t\t\t\tmax = std::max(max, e->t->d);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\taddEdge(u, v);\n\t}\n\n\tmcs();\n\n\tint ans = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tstd::set<int> s;\n\t\tfor (Edge *e = seq[i]->e; e; e = e->next) {\n\t\t\tif (e->t->color) s.insert(e->t->color);\n\t\t}\n\t\ts.insert(INT_MAX);\n\n\t\tint last = 0;\n\t\tfor (std::set<int>::const_iterator it = s.begin(); it != s.end(); it++) {\n\t\t\tif (last + 1 != *it) {\n\t\t\t\tseq[i]->color = last + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast = *it;\n\t\t}\n\n\t\tans = std::max(ans, seq[i]->color);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"hnoi2008-kingdom","published":1,"updated":"2016-10-17T09:25:23.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cm600ypc2xlixlhq2v8"},{"title":"HNOI2008GT - KMP + ","date":"2016-10-07T22:43:00.000Z","_content":"\n $ m $  $ T $ $ n $  $ T $ \n\n<!-- more -->\n\n### \n[BZOJ 1009](http://www.lydsy.com/JudgeOnline/problem.php?id=1009)\n\n### \n $ T $  KMP  $ f(i, j) $  $ i $  $ T $  $ j $ \n\n $ O(m ^ 3 \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 1e9;\nconst int MAXM = 20;\nconst int MAXK = 1000;\n\nstruct Matrix {\n\tint a[MAXM][MAXM];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) {\n\t\t\tfor (int i = 0; i < MAXM; i++) a[i][i] = 1;\n\t\t}\n\t}\n\n\tint &operator()(const int i, const int j) {\n\t\treturn a[i][j];\n\t}\n\n\tconst int &operator()(const int i, const int j) const {\n\t\treturn a[i][j];\n\t}\n};\n\nint mod;\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXM; i++) for (int j = 0; j < MAXM; j++) for (int k = 0; k < MAXM; k++) (res(i, j) += a(i, k) * b(k, j)) %= mod;\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tint n, m;\n\tchar s[MAXM + 2];\n\tscanf(\"%d %d %d\\n%s\", &n, &m, &mod, s + 1);\n\n\tint fail[MAXM + 1];\n\tfail[0] = fail[1] = 0;\n\tfor (int i = 2; i <= m; i++) {\n\t\tint k = fail[i - 1];\n\t\twhile (k && s[k + 1] != s[i]) k = fail[k];\n\t\tif (s[k + 1] == s[i]) fail[i] = k + 1;\n\t\telse fail[i] = 0;\n\t}\n\n\t// for (int i = 0; i <= m; i++) printf(\"%d%c\", fail[i], i == m ? '\\n' : ' ');\n\n\t/*\n\tint f[50][MAXM + 1];\n\tmemset(f, 0, sizeof(f));\n\n\tf[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (char c = '0'; c <= '9'; c++) {\n\t\t\t\tint k = j;\n\t\t\t\twhile (k && s[k + 1] != c) k = fail[k];\n\t\t\t\tif (s[k + 1] == c) k++;\n\n\t\t\t\tf[i + 1][k] += f[i][j];\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\tMatrix shift(false);\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (char c = '0'; c <= '9'; c++) {\n\t\t\tint k = i;\n\t\t\twhile (k && s[k + 1] != c) k = fail[k];\n\t\t\tif (s[k + 1] == c) k++;\n\t\t\tif (k < m) shift(i, k)++;\n\t\t}\n\t}\n\n\tMatrix init(false);\n\tinit(0, 0) = 1;\n\tMatrix res = init * pow(shift, n);\n\n\tint ans = 0;\n\tfor (int i = 0; i < m; i++) (ans += res(0, i)) %= mod;\n\n\tprintf(\"%d\\n\", ans);\n\n\t// for (int i = 0; i < MAXM; i++) for (int j = 0; j < MAXM; j++) printf(\"%d%c\", res(i, j), j == MAXM - 1 ? '\\n' : ' ');\n\n\t/*\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tprintf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\t*/\n\n\treturn 0;\n}\n```","source":"_posts/hnoi2008-gt.md","raw":"title: HNOI2008GT - KMP + \ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - DP\n  - KMP\n  - \n  - \n  - \npermalink: hnoi2008-gt\ndate: 2016-10-08 06:43:00\n---\n\n $ m $  $ T $ $ n $  $ T $ \n\n<!-- more -->\n\n### \n[BZOJ 1009](http://www.lydsy.com/JudgeOnline/problem.php?id=1009)\n\n### \n $ T $  KMP  $ f(i, j) $  $ i $  $ T $  $ j $ \n\n $ O(m ^ 3 \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 1e9;\nconst int MAXM = 20;\nconst int MAXK = 1000;\n\nstruct Matrix {\n\tint a[MAXM][MAXM];\n\n\tMatrix(const bool unit = false) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tif (unit) {\n\t\t\tfor (int i = 0; i < MAXM; i++) a[i][i] = 1;\n\t\t}\n\t}\n\n\tint &operator()(const int i, const int j) {\n\t\treturn a[i][j];\n\t}\n\n\tconst int &operator()(const int i, const int j) const {\n\t\treturn a[i][j];\n\t}\n};\n\nint mod;\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXM; i++) for (int j = 0; j < MAXM; j++) for (int k = 0; k < MAXM; k++) (res(i, j) += a(i, k) * b(k, j)) %= mod;\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tint n, m;\n\tchar s[MAXM + 2];\n\tscanf(\"%d %d %d\\n%s\", &n, &m, &mod, s + 1);\n\n\tint fail[MAXM + 1];\n\tfail[0] = fail[1] = 0;\n\tfor (int i = 2; i <= m; i++) {\n\t\tint k = fail[i - 1];\n\t\twhile (k && s[k + 1] != s[i]) k = fail[k];\n\t\tif (s[k + 1] == s[i]) fail[i] = k + 1;\n\t\telse fail[i] = 0;\n\t}\n\n\t// for (int i = 0; i <= m; i++) printf(\"%d%c\", fail[i], i == m ? '\\n' : ' ');\n\n\t/*\n\tint f[50][MAXM + 1];\n\tmemset(f, 0, sizeof(f));\n\n\tf[0][0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (char c = '0'; c <= '9'; c++) {\n\t\t\t\tint k = j;\n\t\t\t\twhile (k && s[k + 1] != c) k = fail[k];\n\t\t\t\tif (s[k + 1] == c) k++;\n\n\t\t\t\tf[i + 1][k] += f[i][j];\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\tMatrix shift(false);\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (char c = '0'; c <= '9'; c++) {\n\t\t\tint k = i;\n\t\t\twhile (k && s[k + 1] != c) k = fail[k];\n\t\t\tif (s[k + 1] == c) k++;\n\t\t\tif (k < m) shift(i, k)++;\n\t\t}\n\t}\n\n\tMatrix init(false);\n\tinit(0, 0) = 1;\n\tMatrix res = init * pow(shift, n);\n\n\tint ans = 0;\n\tfor (int i = 0; i < m; i++) (ans += res(0, i)) %= mod;\n\n\tprintf(\"%d\\n\", ans);\n\n\t// for (int i = 0; i < MAXM; i++) for (int j = 0; j < MAXM; j++) printf(\"%d%c\", res(i, j), j == MAXM - 1 ? '\\n' : ' ');\n\n\t/*\n\tfor (int i = 0; i <= n; i++) {\n\t\tfor (int j = 0; j <= m; j++) {\n\t\t\tprintf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\t*/\n\n\treturn 0;\n}\n```","slug":"hnoi2008-gt","published":1,"updated":"2016-10-07T22:52:45.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cmj00yxc2xlx6xxhlrm"},{"title":"HNOI2008Cards - Burnside ","date":"2016-10-17T02:57:00.000Z","_content":"\n $ n $ 3  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 1004](http://www.lydsy.com/JudgeOnline/problem.php?id=1004)\n\n### \nBurnside   \n\n $ m $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <vector>\n\nconst int MAXX = 20;\nconst int MAXN = 60;\nconst int MAXM = 60;\n\nint a, b, c, n, mod;\n\ninline int calc(const int *map) {\n\tbool flag[MAXM] = { false };\n\tstd::vector<int> v;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = 0;\n\t\tfor (int t = i; !flag[t]; t = map[t]) {\n\t\t\tflag[t] = true;\n\t\t\tx++;\n\t\t}\n\t\tif (x) v.push_back(x);\n\t}\n\n\tstatic int f[MAXX + 1][MAXX + 1][MAXX + 1];\n\tmemset(f, 0, sizeof(f));\n\tf[0][0][0] = 1;\n\tfor (std::vector<int>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tfor (int i = a; i >= 0; i--) {\n\t\t\tfor (int j = b; j >= 0; j--) {\n\t\t\t\tfor (int k = c; k >= 0; k--) {\n\t\t\t\t\tif (i >= *it) (f[i][j][k] += f[i - *it][j][k]) %= mod;\n\t\t\t\t\tif (j >= *it) (f[i][j][k] += f[i][j - *it][k]) %= mod;\n\t\t\t\t\tif (k >= *it) (f[i][j][k] += f[i][j][k - *it]) %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// printf(\"calc() = %d\\n\", f[a][b][c]);\n\n\treturn f[a][b][c];\n}\n\ninline void exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int x) {\n\tint tmp1, tmp2, res;\n\texgcd(x, mod, tmp1, res, tmp2);\n\treturn (res % mod + mod) % mod;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d %d %d %d\", &a, &b, &c, &m, &mod);\n\tn = a + b + c;\n\n\tint sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tint map[MAXN];\n\t\tfor (int j = 0; j < n; j++) scanf(\"%d\", &map[j]), map[j]--;\n\t\t(sum += calc(map)) %= mod;\n\t}\n\n\tint map[MAXN];\n\tfor (int i = 0; i < n; i++) map[i] = i;\n\t(sum += calc(map)) %= mod;\n\n\tint ans = sum * inv(m + 1) % mod;\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/hnoi2008-cards.md","raw":"title: HNOI2008Cards - Burnside \ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - Burnside \n  - \n  - \npermalink: hnoi2008-cards\ndate: 2016-10-17 10:57:00\n---\n\n $ n $ 3  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 1004](http://www.lydsy.com/JudgeOnline/problem.php?id=1004)\n\n### \nBurnside   \n\n $ m $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <vector>\n\nconst int MAXX = 20;\nconst int MAXN = 60;\nconst int MAXM = 60;\n\nint a, b, c, n, mod;\n\ninline int calc(const int *map) {\n\tbool flag[MAXM] = { false };\n\tstd::vector<int> v;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = 0;\n\t\tfor (int t = i; !flag[t]; t = map[t]) {\n\t\t\tflag[t] = true;\n\t\t\tx++;\n\t\t}\n\t\tif (x) v.push_back(x);\n\t}\n\n\tstatic int f[MAXX + 1][MAXX + 1][MAXX + 1];\n\tmemset(f, 0, sizeof(f));\n\tf[0][0][0] = 1;\n\tfor (std::vector<int>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tfor (int i = a; i >= 0; i--) {\n\t\t\tfor (int j = b; j >= 0; j--) {\n\t\t\t\tfor (int k = c; k >= 0; k--) {\n\t\t\t\t\tif (i >= *it) (f[i][j][k] += f[i - *it][j][k]) %= mod;\n\t\t\t\t\tif (j >= *it) (f[i][j][k] += f[i][j - *it][k]) %= mod;\n\t\t\t\t\tif (k >= *it) (f[i][j][k] += f[i][j][k - *it]) %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// printf(\"calc() = %d\\n\", f[a][b][c]);\n\n\treturn f[a][b][c];\n}\n\ninline void exgcd(const int a, const int b, int &g, int &x, int &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline int inv(const int x) {\n\tint tmp1, tmp2, res;\n\texgcd(x, mod, tmp1, res, tmp2);\n\treturn (res % mod + mod) % mod;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d %d %d %d\", &a, &b, &c, &m, &mod);\n\tn = a + b + c;\n\n\tint sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tint map[MAXN];\n\t\tfor (int j = 0; j < n; j++) scanf(\"%d\", &map[j]), map[j]--;\n\t\t(sum += calc(map)) %= mod;\n\t}\n\n\tint map[MAXN];\n\tfor (int i = 0; i < n; i++) map[i] = i;\n\t(sum += calc(map)) %= mod;\n\n\tint ans = sum * inv(m + 1) % mod;\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"hnoi2008-cards","published":1,"updated":"2016-10-17T03:03:37.128Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cmu00z6c2xls3xstv2v"},{"title":"HNOI2004 - set","id":"5","updated":"2016-01-19T13:08:01.000Z","date":"2015-12-15T21:14:20.000Z","_content":"\n `N`<= 80000 `a`\n\n<!-- more -->\n\n### \n[CodeVS 1285](http://codevs.cn/problem/1285/)  \n[BZOJ 1208](http://www.lydsy.com/JudgeOnline/problem.php?id=1208)  \n[Tyvj 1852](http://tyvj.cn/p/1852)\n\n### \n$O({\\log} n)$ STL  set\n\n set set  `lower_bound` ********\n\n### \n```cpp\n#include <cstdio>\n#include <set>\n#include <algorithm>\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nconst unsigned int MAXN = 80000;\nconst unsigned int p = 1000000;\n\nstd::set<unsigned int> pets, owners;\nunsigned int n, ans;\n\ninline unsigned int diff(unsigned int x, unsigned int y) {\n\treturn std::max(x, y) - std::min(x, y);\n}\n\ninline void add(unsigned int x, unsigned int y) {\n\tans = (ans + (diff(x, y) % p)) % p;\n}\n\ninline void solve(std::set<unsigned int> &set, unsigned int x) {\n\tif (set.size() == 1) {\n\t\tadd(x, *set.begin());\n\t\tset.clear();\n\t} else {\n\t\tstd::set<unsigned int>::const_iterator r = set.lower_bound(x);\n\n\t\tif (r == set.begin()) {\n\t\t\tadd(x, *r);\n\t\t\tset.erase(r);\n\t\t} else {\n\t\t\tstd::set<unsigned int>::const_iterator l = --set.lower_bound(x);\n\n\t\t\tif (r == set.end() || diff(x, *l) <= diff(x, *r)) {\n\t\t\t\tadd(x, *l);\n\t\t\t\tset.erase(l);\n\t\t\t} else {\n\t\t\t\tadd(x, *r);\n\t\t\t\tset.erase(r);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tread(n);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tregister unsigned int type, x;\n\t\tread(type), read(x);\n\n\t\tif (type == 0) { // pet\n\t\t\tif (owners.empty()) {\n\t\t\t\tpets.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(owners, x);\n\t\t\t}\n\t\t} else { // owner\n\t\t\tif (pets.empty()) {\n\t\t\t\towners.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(pets, x);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/hnoi2004-pet.md","raw":"title: HNOI2004 - set\ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - HNOI\n  - set\n  - STL\npermalink: hnoi2004-pet\nid: 5\nupdated: '2016-01-19 21:08:01'\ndate: 2015-12-16 05:14:20\n---\n\n `N`<= 80000 `a`\n\n<!-- more -->\n\n### \n[CodeVS 1285](http://codevs.cn/problem/1285/)  \n[BZOJ 1208](http://www.lydsy.com/JudgeOnline/problem.php?id=1208)  \n[Tyvj 1852](http://tyvj.cn/p/1852)\n\n### \n$O({\\log} n)$ STL  set\n\n set set  `lower_bound` ********\n\n### \n```cpp\n#include <cstdio>\n#include <set>\n#include <algorithm>\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tflag = true;\n\t\tch = getchar();\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nconst unsigned int MAXN = 80000;\nconst unsigned int p = 1000000;\n\nstd::set<unsigned int> pets, owners;\nunsigned int n, ans;\n\ninline unsigned int diff(unsigned int x, unsigned int y) {\n\treturn std::max(x, y) - std::min(x, y);\n}\n\ninline void add(unsigned int x, unsigned int y) {\n\tans = (ans + (diff(x, y) % p)) % p;\n}\n\ninline void solve(std::set<unsigned int> &set, unsigned int x) {\n\tif (set.size() == 1) {\n\t\tadd(x, *set.begin());\n\t\tset.clear();\n\t} else {\n\t\tstd::set<unsigned int>::const_iterator r = set.lower_bound(x);\n\n\t\tif (r == set.begin()) {\n\t\t\tadd(x, *r);\n\t\t\tset.erase(r);\n\t\t} else {\n\t\t\tstd::set<unsigned int>::const_iterator l = --set.lower_bound(x);\n\n\t\t\tif (r == set.end() || diff(x, *l) <= diff(x, *r)) {\n\t\t\t\tadd(x, *l);\n\t\t\t\tset.erase(l);\n\t\t\t} else {\n\t\t\t\tadd(x, *r);\n\t\t\t\tset.erase(r);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tread(n);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tregister unsigned int type, x;\n\t\tread(type), read(x);\n\n\t\tif (type == 0) { // pet\n\t\t\tif (owners.empty()) {\n\t\t\t\tpets.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(owners, x);\n\t\t\t}\n\t\t} else { // owner\n\t\t\tif (pets.empty()) {\n\t\t\t\towners.insert(x);\n\t\t\t} else {\n\t\t\t\tsolve(pets, x);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"hnoi2004-pet","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cn200zec2xlr7qp5cyz"},{"title":"HNOI2004L - Trie","date":"2016-09-12T23:40:00.000Z","_content":"\n $ T $  $ D $  $ T $  $ D $ \n\n $ D $ $ D $  $ D $ \n\n<!-- more -->\n\n### \n[BZOJ 1212](http://www.lydsy.com/JudgeOnline/problem.php?id=1212)\n\n### \n $ f_i $  $ i $  $ f_{i - 1} $  $ m $  $ i $  $ f_{i + m - 1} $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int MAXN = 1024 * 1024;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAT = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE]; //, *fail, *next;\n\t\tbool isWord;\n\n\t\tNode(const bool isWord) : /* fail(NULL), next(NULL), */ isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node(false);\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\t/*\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\t*/\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic char s[MAXN + 1];\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= 'a';\n\t\tt.insert(s, s + len);\n\t}\n\n\t// t.build();\n\n\twhile (m--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tstatic bool _f[MAXN + 1], *f = _f + 1;\n\t\tfor (int i = 0; i < len; i++) s[i] -= 'a', f[i] = false;\n\t\tint ans = -1;\n\t\tf[-1] = true;\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tif (!f[i - 1]) continue;\n\t\t\tTrie::Node *v = t.root;\n\t\t\tfor (int j = i; j < len; j++) {\n\t\t\t\t// while (v != t.root && !v->c[s[j]]) v = v->fail;\n\t\t\t\tif (!v->c[s[j]]) break;\n\t\t\t\tv = v->c[s[j]];\n\t\t\t\tif (v->isWord) f[j] = true, ans = std::max(ans, j);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans + 1);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/hnoi2004-language.md","raw":"title: HNOI2004L - Trie\ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - \n  - Trie\npermalink: hnoi2004-language\ndate: 2016-09-13 07:40:00\n---\n\n $ T $  $ D $  $ T $  $ D $ \n\n $ D $ $ D $  $ D $ \n\n<!-- more -->\n\n### \n[BZOJ 1212](http://www.lydsy.com/JudgeOnline/problem.php?id=1212)\n\n### \n $ f_i $  $ i $  $ f_{i - 1} $  $ m $  $ i $  $ f_{i + m - 1} $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int MAXN = 1024 * 1024;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAT = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE]; //, *fail, *next;\n\t\tbool isWord;\n\n\t\tNode(const bool isWord) : /* fail(NULL), next(NULL), */ isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node(false);\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\t/*\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\t*/\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic char s[MAXN + 1];\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= 'a';\n\t\tt.insert(s, s + len);\n\t}\n\n\t// t.build();\n\n\twhile (m--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tstatic bool _f[MAXN + 1], *f = _f + 1;\n\t\tfor (int i = 0; i < len; i++) s[i] -= 'a', f[i] = false;\n\t\tint ans = -1;\n\t\tf[-1] = true;\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tif (!f[i - 1]) continue;\n\t\t\tTrie::Node *v = t.root;\n\t\t\tfor (int j = i; j < len; j++) {\n\t\t\t\t// while (v != t.root && !v->c[s[j]]) v = v->fail;\n\t\t\t\tif (!v->c[s[j]]) break;\n\t\t\t\tv = v->c[s[j]];\n\t\t\t\tif (v->isWord) f[j] = true, ans = std::max(ans, j);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans + 1);\n\t}\n\n\treturn 0;\n}\n```","slug":"hnoi2004-language","published":1,"updated":"2016-09-12T23:45:11.171Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cn800zlc2xlepdlk3wo"},{"title":"HEOI2013Eden  -  DP","date":"2016-07-11T15:10:00.000Z","_content":"\n $ n $  $ m $  $ m $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 3163](http://www.lydsy.com/JudgeOnline/problem.php?id=3163)\n\n### \n $ f(i, j) $  $ i $ **** $ j $  $ g(i, j) $  $ i $ **** $ j $ \n\n $ a $  $ m $\n\n$$\n\\max\\limits_{i = 0} ^ {m} \\{ f(a - 1, i) + g(a + 1, m - i) \\}\n$$\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <utility>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\nconst int MAXLOGN = 10;\nconst int MAXQ = 300000;\n\nint main() {\n\tint n;\n\tstatic int w[MAXN], v[MAXN], cnt[MAXN];\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &w[i], &v[i], &cnt[i]);\n\n\tstatic std::pair<int, int> r[MAXN];\n\tstatic int W[MAXN * MAXLOGN], V[MAXN * MAXLOGN];\n\tint N = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tr[i].first = N + 1;\n\t\tfor (int j = 1; j <= cnt[i]; cnt[i] -= j, j *= 2) {\n\t\t// for (int j = 1; cnt[i]; cnt[i]--) {\n\t\t\tN++;\n\t\t\tW[N] = w[i] * j;\n\t\t\tV[N] = v[i] * j;\n\t\t}\n\t\tif (cnt[i]) {\n\t\t\tN++;\n\t\t\tW[N] = w[i] * cnt[i];\n\t\t\tV[N] = v[i] * cnt[i];\n\t\t}\n\t\tr[i].second = N;\n\t}\n\n\tstatic int f[MAXN * MAXLOGN + 1][MAXM + 1], g[MAXN * MAXLOGN + 2][MAXM + 1];\n\t// for (int i = 0; i <= N; i++) f[i][0] = 1;\n\t// for (int i = 1; i <= N + 1; i++) g[i][0] = 1;\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < W[i]) f[i][j] = f[i - 1][j];\n\t\t\telse f[i][j] = std::max(f[i - 1][j], f[i - 1][j - W[i]] + V[i]);\n\t\t}\n\t}\n\n\tfor (int i = N; i >= 1; i--) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < W[i]) g[i][j] = g[i + 1][j];\n\t\t\telse g[i][j] = std::max(g[i + 1][j], g[i + 1][j - W[i]] + V[i]);\n\t\t}\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tint id, m;\n\t\tscanf(\"%d %d\", &id, &m);\n\n\t\tint ans = 0, a = r[id].first - 1, b = r[id].second + 1;\n\t\tfor (int j = 0; j <= m; j++) ans = std::max(ans, f[a][j] + g[b][m - j]);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/heoi2013-bag.md","raw":"title: HEOI2013Eden  -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - HEOI\n  - DP\n  -  DP\npermalink: heoi2013-bag\ndate: 2016-07-11 23:10:00\n---\n\n $ n $  $ m $  $ m $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 3163](http://www.lydsy.com/JudgeOnline/problem.php?id=3163)\n\n### \n $ f(i, j) $  $ i $ **** $ j $  $ g(i, j) $  $ i $ **** $ j $ \n\n $ a $  $ m $\n\n$$\n\\max\\limits_{i = 0} ^ {m} \\{ f(a - 1, i) + g(a + 1, m - i) \\}\n$$\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <utility>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\nconst int MAXLOGN = 10;\nconst int MAXQ = 300000;\n\nint main() {\n\tint n;\n\tstatic int w[MAXN], v[MAXN], cnt[MAXN];\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &w[i], &v[i], &cnt[i]);\n\n\tstatic std::pair<int, int> r[MAXN];\n\tstatic int W[MAXN * MAXLOGN], V[MAXN * MAXLOGN];\n\tint N = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tr[i].first = N + 1;\n\t\tfor (int j = 1; j <= cnt[i]; cnt[i] -= j, j *= 2) {\n\t\t// for (int j = 1; cnt[i]; cnt[i]--) {\n\t\t\tN++;\n\t\t\tW[N] = w[i] * j;\n\t\t\tV[N] = v[i] * j;\n\t\t}\n\t\tif (cnt[i]) {\n\t\t\tN++;\n\t\t\tW[N] = w[i] * cnt[i];\n\t\t\tV[N] = v[i] * cnt[i];\n\t\t}\n\t\tr[i].second = N;\n\t}\n\n\tstatic int f[MAXN * MAXLOGN + 1][MAXM + 1], g[MAXN * MAXLOGN + 2][MAXM + 1];\n\t// for (int i = 0; i <= N; i++) f[i][0] = 1;\n\t// for (int i = 1; i <= N + 1; i++) g[i][0] = 1;\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < W[i]) f[i][j] = f[i - 1][j];\n\t\t\telse f[i][j] = std::max(f[i - 1][j], f[i - 1][j - W[i]] + V[i]);\n\t\t}\n\t}\n\n\tfor (int i = N; i >= 1; i--) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < W[i]) g[i][j] = g[i + 1][j];\n\t\t\telse g[i][j] = std::max(g[i + 1][j], g[i + 1][j - W[i]] + V[i]);\n\t\t}\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tint id, m;\n\t\tscanf(\"%d %d\", &id, &m);\n\n\t\tint ans = 0, a = r[id].first - 1, b = r[id].second + 1;\n\t\tfor (int j = 0; j <= m; j++) ans = std::max(ans, f[a][j] + g[b][m - j]);\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"heoi2013-bag","published":1,"updated":"2016-10-24T23:36:40.514Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cne00zsc2xlvj3qizzw"},{"title":"HDU 5906Square Revolution -  +  + ","date":"2016-09-30T10:00:00.000Z","_content":"\n $ S $ prefix-suffix-square free \n\n square `abab``aa`  square `aaa``abba`  prefix-suffix-square free  square\n\n<!-- more -->\n\n### \n[HDU 5906](http://acm.hdu.edu.cn/showproblem.php?pid=5906)\n\n### \n square $ i $  $ i $  square  $ f(i) $ $ i $  $ g(i) $ $ i $ $ j \\in [i, i + f(i) - 2] $  $ i \\geq g(j) $  $ j $ \n\n squareNOI2016  $ k $ $ k $  $ 2k $  square  $ [l, r] $ square $ [L, R] $  $ 2k $  square $ 2k $  $ f(i), i \\in[L, R] $\n\n $ k $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1e5;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1], log[MAXN + 1];\n\n\tinline void build(const char *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tbool unique = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t\tif (unique) break;\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n#ifdef DBG\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n#endif\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) >= n) st[i][j] = st[i][j - 1];\n\t\t\t\telse st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tint x = 0;\n\t\t\twhile ((1 << x) <= i) x++;\n\t\t\tlog[i] = x - 1;\n\t\t}\n\t}\n\n\tinline int rmq(const int l, const int r) {\n\t\tif (l == r) return st[l][0];\n\t\tint t = log[r - l];\n\t\treturn std::min(st[l][t], st[r - (1 << t) + 1][t]);\n\t}\n\n\tinline int lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn rmq(a + 1, b);\n\t}\n} sa1, sa2;\n\nint n, forward[MAXN], backward[MAXN];\n\ninline int lcp(const int i, const int j) { return sa1.lcp(i, j); }\ninline int lcs(const int i, const int j) { return sa2.lcp(n - i - 1, n - j - 1); }\n\ninline void prepare(const int n) {\n\t/*\n\tstruct SegmentTree {\n\t\tint l, r, mid;\n\t\tSegmentTree *lc, *rc;\n\t\tint val;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), val(INT_MAX) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid update(const int l, const int r, const int x) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) this->val = std::min(this->val, x);\n\t\t\telse lc->update(l, r, x), rc->update(l, r, x);\n\t\t}\n\n\t\tint query(const int pos) {\n\t\t\treturn (l == r) ? val : std::min(val, ((pos <= mid) ? lc : rc)->query(pos));\n\t\t}\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t\t}\n\t\t}\n\t} *sForawrd = SegmentTree::build(0, n - 1), *sBackward = SegmentTree::build(0, n - 1);\n\t*/\n\n\tstatic struct UnionFindSet {\n\t\tint a[MAXN], n;\n\n\t\tvoid init(const int n) {\n\t\t\tthis->n = n;\n\t\t\tfor (int i = 0; i < n; i++) a[i] = i;\n\t\t}\n\n\t\tint find(const int x) {\n\t\t\treturn x == a[x] ? x : a[x] = find(a[x]);\n\t\t}\n\n\t\tvoid merge(const int child, const int parent) {\n#ifdef DBG\n\t\t\tprintf(\"merge: %d => %d\\n\", child, parent);\n#endif\n\t\t\tconst int _child = find(child), _parent = find(parent);\n\t\t\ta[_child] = _parent;\n\t\t}\n\n\t\tvoid cover(const int l, const int r, const int x, int *val) {\n#ifdef DBG\n\t\t\tprintf(\"cover(%d, %d, %d)\\n\", l, r, x);\n#endif\n\t\t\tfor (int i = find(l); i <= r; i = find(i + 1)) {\n\t\t\t\tval[i] = std::min(val[i], x);\n\t\t\t\tif (i != n - 1) merge(i, i + 1);\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t} sForawrd, sBackward;\n\n\tsForawrd.init(n);\n\tsBackward.init(n);\n\n\tfor (int i = 0; i < n; i++) forward[i] = backward[i] = INT_MAX;\n\n\tfor (int len = 1; len < n; len++) {\n\t\tfor (int i = 0; i + len < n; i += len) {\n\t\t\tconst int j = i + len;\n\t\t\tconst int a = std::min(lcs(i, j), len), b = std::min(lcp(i, j), len), s = a + b - 1;\n\t\t\t// const int a = lcs(i, j), b = lcp(i, j), s = a + b - 1;\n#ifdef DBG\n\t\t\tprintf(\"s = %d, len = %d\\n\", s, len);\n#endif\n\t\t\tif (s >= len) {\n#ifdef DBG\n\t\t\t\tprintf(\"!FOUND! i = %d, j = %d, a = %d, b = %d, len = %d\\n\", i, j, a, b, len);\n#endif\n\t\t\t\tconst int l = i - a + 1, r = j + b - 1;\n\t\t\t\tsForawrd.cover(l, l + (r - (l + len * 2 - 1)), len * 2, forward);\n\t\t\t\tsBackward.cover(l + len * 2 - 1, r, len * 2, backward);\n\t\t\t\t// sForawrd->update(l, l + (r - (l + len * 2 - 1)), len * 2);\n\t\t\t\t// sBackward->update(l + len * 2 - 1, r, len * 2);\n\t\t\t\t/*\n\t\t\t\tfor (int i = l + len * 2 - 1; i <= r; i++) {\n\t\t\t\t\tprintf(\"[%d, %d]\\n\", i - len * 2 + 1, i);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t}\n\t}\n\n\t// for (int i = 0; i < n; i++) forward[i] = sForawrd->query(i);\n\t// for (int i = 0; i < n; i++) backward[i] = sBackward->query(i);\n\n#ifdef DBG\n\tputs(\"forward / backward\");\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", forward[i] == INT_MAX ? 0 : forward[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", backward[i] == INT_MAX ? 0 : backward[i], i == n - 1 ? '\\n' : ' ');\n#endif\n}\n\n/*\nstruct ChairmanTree {\n\tstruct SegmentTree {\n\t\tint l, r, mid;\n\t\tSegmentTree *lc, *rc;\n\t\tint cnt, refCnt;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, const int cnt = 0) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), cnt(cnt), refCnt(0) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc && lc->unRef()) delete lc;\n\t\t\tif (rc && rc->unRef()) delete rc;\n\t\t}\n\n\t\tSegmentTree *ref() {\n\t\t\trefCnt++;\n\t\t\treturn this;\n\t\t}\n\n\t\tbool unRef() {\n\t\t\treturn !refCnt--;\n\t\t}\n\n\t\tint query(const int l, const int r) {\n\t\t\tif (l > this->r || r < this->l) return 0;\n\t\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\t\telse return (lc ? lc->query(l, r) : 0) + (rc ? rc->query(l, r) : 0);\n\t\t}\n\n\t\tSegmentTree *insertSelf(const int x) {\n\t\t\tif (l == r) return this;\n\t\t\tif (x <= mid) {\n\t\t\t\tthis->lc = (new SegmentTree(l, mid, NULL, NULL, 1))->insertSelf(x);\n\t\t\t} else {\n\t\t\t\tthis->rc = (new SegmentTree(mid + 1, r, NULL, NULL, 1))->insertSelf(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tSegmentTree *insert(const int x) {\n\t\t\tif (x <= mid) {\n\t\t\t\treturn new SegmentTree(l, r, lc ? lc->insert(x) : (new SegmentTree(l, mid, NULL, NULL, 1))->insertSelf(x), rc ? rc->ref() : NULL, cnt + 1);\n\t\t\t} else {\n\t\t\t\treturn new SegmentTree(l, r, lc ? lc->ref() : NULL, rc ? rc->insert(x) : (new SegmentTree(mid + 1, r, NULL, NULL, 1))->insertSelf(x), cnt + 1);\n\t\t\t}\n\t\t}\n\n\t\tint lcount() {\n\t\t\treturn lc ? lc->cnt : 0;\n\t\t}\n\t} *root[MAXN + 1];\n\tint n, l, r;\n\n\tvoid clear() {\n\t\tfor (int i = n; i >= 0; i--) {\n\t\t\tdelete root[i];\n\t\t}\n\t}\n\n\t// Build tree with array a, whose elements are limited in [l, r]\n\tvoid build(const int *a, const int n, const int l, const int r) {\n\t\tthis->n = n, this->l = l, this->r = r;\n\t\troot[0] = new SegmentTree(0, n, NULL, NULL, 0);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\troot[i] = root[i - 1]->insert(a[i - 1]);\n\t\t}\n\t}\n\n\tint query(const int l, const int r, const int x) {\n\t\t// Adjust input [0, n - 1] to [1, n]\n\t\tSegmentTree *vr = root[r + 1], *vl = root[l];\n\t\tint ans = vr->query(this->l, x);\n\t\tif (vl) ans -= vl->query(this->l, x);\n\t\treturn ans;\n\n\t\t/ *\n\t\twhile (min != max) {\n\t\t\tconst int mid = mid + (max - min) / 2, t = vr->lcount() - (vl ? vl->lcount() : 0);\n\t\t\tif (t < k) {\n\t\t\t\tk -= t, vr = vr->rc;\n\t\t\t\tif (vl) vl = vl->rc;\n\t\t\t} else {\n\t\t\t\tvr = vr->lc;\n\t\t\t\tif (vl) vl = vl->lc;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t\t* /\n\t}\n} t;\n*/\n\ninline unsigned long long solve(const int *limit, const int *forward, const int n) {\n\tstatic struct Query {\n\t\tint type;\n\t\tint pos, val;\n\n\t\tbool operator<(const Query &other) const {\n\t\t\tif (pos < other.pos) return true;\n\t\t\telse if (pos == other.pos && !type && other.type) return true;\n\t\t\telse return false;\n\t\t}\n\t} Q[MAXN * 3];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tQ[i].pos = i;\n\t\tQ[i].type = 0;\n\t\tQ[i].val = limit[i];\n\n#ifdef DBG\n\t\tprintf(\"add(pos = %d, val = %d)\\n\", Q[i].pos, Q[i].val);\n#endif\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tQ[n + i].pos = i - 1;\n\t\tQ[n + i].val = i;\n\t\tQ[n + i].type = -1;\n\n#ifdef DBG\n\t\tprintf(\"query(pos = %d, val = %d, type = %d)\\n\", Q[n + i].pos, Q[n + i].val, Q[n + i].type);\n#endif\n\n\t\tQ[n + i + n].pos = (forward[i] == INT_MAX) ? (n - 1) : (i + forward[i] - 1);\n\t\tQ[n + i + n].val = i;\n\t\tQ[n + i + n].type = 1;\n\n#ifdef DBG\n\t\tprintf(\"query(pos = %d, val = %d, type = %d)\\n\", Q[n + i + n].pos, Q[n + i + n].val, Q[n + i + n].type);\n#endif\n\t}\n\n\tstd::sort(Q, Q + n * 3);\n\n\tstatic struct BinaryIndexedTree {\n\t\tint a[MAXN], n;\n\n\t\tstatic int lowbit(const int x) {\n\t\t\treturn x & -x;\n\t\t}\n\n\t\tvoid update(const int x, const int delta) {\n\t\t\t/*\n\t\t\ta[x - 1] += delta;\n\t\t\t*/\n\t\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t\t}\n\n\t\tint query(const int x) {\n\t\t\tint ans = 0;\n\t\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\t\t/*\n\t\t\tfor (int i = 1; i <= x; i++) ans += a[i - 1];\n\t\t\t*/\n\t\t\treturn ans;\n\t\t}\n\n\t\tvoid clear(const int x) {\n\t\t\t/*\n\t\t\ta[x - 1] = 0;\n\t\t\t*/\n\t\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\t\tif (!a[i - 1]) break;\n\t\t\t\ta[i - 1] = 0;\n\t\t\t}\n\t\t}\n\t} bit;\n\n\tbit.n = n;\n\n\tunsigned long long ans = 0;\n\tfor (int i = 0; i < n * 3; i++) {\n#ifdef DBG\n\t\tprintf(\"Query: %d %d %d\\n\", Q[i].type, Q[i].pos, Q[i].val);\n#endif\n\t\tif (Q[i].type) {\n\t\t\tint t = bit.query(Q[i].val + 1) * Q[i].type;\n\t\t\tans += t;\n#ifdef DBG\n\t\t\tprintf(\"t = %d\\n\", t);\n#endif\n\t\t} else bit.update(Q[i].val + 1, 1);\n\t\t/*\n#ifdef DBG\n\t\tprintf(\"Query: %d %d %d\\n\", Q[i].l, Q[i].r, Q[i].val);\n#endif\n\t\tif (Q[i].l == -1) bit.update(Q[i].val + 1, 1);\n\t\telse ans += bit.query(Q[i].r + 1) - bit.query(Q[i].l);\n#ifdef DBG\n\t\tprintf(\"ans = %d\\n\", ans);\n#endif\n\t\t*/\n\t}\n\n\tfor (int i = 0; i < n * 2; i++) if (!Q[i].type) bit.clear(Q[i].val + 1);\n\n\treturn ans;\n}\n\nint main() {\n\tint testcase;\n\tscanf(\"%d\", &testcase);\n\n\twhile (testcase--) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tsa1.build(s, n);\n\t\tstd::reverse(s, s + n);\n\t\tsa2.build(s, n);\n\n\t\tprepare(n);\n\t\tstatic int limit[MAXN];\n\t\tfor (int i = 0; i < n; i++) limit[i] = backward[i] == INT_MAX ? 0 : (i - backward[i] + 2);\n\n#ifdef DBG\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", limit[i], i == n - 1 ? '\\n' : ' ');\n#endif\n\n\t\t// t.clear();\n\t\t// t.build(limit, n, 0, n - 1);\n\n\t\t/*\n\t\tunsigned long long ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans += t.query(i, (forward[i] == INT_MAX) ? (n - 1) : (i + forward[i] - 1), i);\n\t\t}\n\t\t*/\n\n\t\tunsigned long long ans = solve(limit, forward, n);\n\t\tprintf(\"%llu\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/hdu-5906.md","raw":"title: HDU 5906Square Revolution -  +  + \ncategories: OI\ntags: \n  - HDU\n  - Bestcoder\n  - \n  - \n  - \n  - \n  - \npermalink: hdu-5906\ndate: 2016-09-30 18:00:00\n---\n\n $ S $ prefix-suffix-square free \n\n square `abab``aa`  square `aaa``abba`  prefix-suffix-square free  square\n\n<!-- more -->\n\n### \n[HDU 5906](http://acm.hdu.edu.cn/showproblem.php?pid=5906)\n\n### \n square $ i $  $ i $  square  $ f(i) $ $ i $  $ g(i) $ $ i $ $ j \\in [i, i + f(i) - 2] $  $ i \\geq g(j) $  $ j $ \n\n squareNOI2016  $ k $ $ k $  $ 2k $  square  $ [l, r] $ square $ [L, R] $  $ 2k $  square $ 2k $  $ f(i), i \\in[L, R] $\n\n $ k $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 1e5;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1], log[MAXN + 1];\n\n\tinline void build(const char *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tbool unique = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t\tif (unique) break;\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n#ifdef DBG\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n#endif\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) >= n) st[i][j] = st[i][j - 1];\n\t\t\t\telse st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tint x = 0;\n\t\t\twhile ((1 << x) <= i) x++;\n\t\t\tlog[i] = x - 1;\n\t\t}\n\t}\n\n\tinline int rmq(const int l, const int r) {\n\t\tif (l == r) return st[l][0];\n\t\tint t = log[r - l];\n\t\treturn std::min(st[l][t], st[r - (1 << t) + 1][t]);\n\t}\n\n\tinline int lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn rmq(a + 1, b);\n\t}\n} sa1, sa2;\n\nint n, forward[MAXN], backward[MAXN];\n\ninline int lcp(const int i, const int j) { return sa1.lcp(i, j); }\ninline int lcs(const int i, const int j) { return sa2.lcp(n - i - 1, n - j - 1); }\n\ninline void prepare(const int n) {\n\t/*\n\tstruct SegmentTree {\n\t\tint l, r, mid;\n\t\tSegmentTree *lc, *rc;\n\t\tint val;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), val(INT_MAX) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc) delete lc;\n\t\t\tif (rc) delete rc;\n\t\t}\n\n\t\tvoid update(const int l, const int r, const int x) {\n\t\t\tif (l > this->r || r < this->l) return;\n\t\t\telse if (l <= this->l && r >= this->r) this->val = std::min(this->val, x);\n\t\t\telse lc->update(l, r, x), rc->update(l, r, x);\n\t\t}\n\n\t\tint query(const int pos) {\n\t\t\treturn (l == r) ? val : std::min(val, ((pos <= mid) ? lc : rc)->query(pos));\n\t\t}\n\n\t\tstatic SegmentTree *build(const int l, const int r) {\n\t\t\tif (l > r) return NULL;\n\t\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\t\telse {\n\t\t\t\tconst int mid = l + (r - l) / 2;\n\t\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t\t}\n\t\t}\n\t} *sForawrd = SegmentTree::build(0, n - 1), *sBackward = SegmentTree::build(0, n - 1);\n\t*/\n\n\tstatic struct UnionFindSet {\n\t\tint a[MAXN], n;\n\n\t\tvoid init(const int n) {\n\t\t\tthis->n = n;\n\t\t\tfor (int i = 0; i < n; i++) a[i] = i;\n\t\t}\n\n\t\tint find(const int x) {\n\t\t\treturn x == a[x] ? x : a[x] = find(a[x]);\n\t\t}\n\n\t\tvoid merge(const int child, const int parent) {\n#ifdef DBG\n\t\t\tprintf(\"merge: %d => %d\\n\", child, parent);\n#endif\n\t\t\tconst int _child = find(child), _parent = find(parent);\n\t\t\ta[_child] = _parent;\n\t\t}\n\n\t\tvoid cover(const int l, const int r, const int x, int *val) {\n#ifdef DBG\n\t\t\tprintf(\"cover(%d, %d, %d)\\n\", l, r, x);\n#endif\n\t\t\tfor (int i = find(l); i <= r; i = find(i + 1)) {\n\t\t\t\tval[i] = std::min(val[i], x);\n\t\t\t\tif (i != n - 1) merge(i, i + 1);\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t} sForawrd, sBackward;\n\n\tsForawrd.init(n);\n\tsBackward.init(n);\n\n\tfor (int i = 0; i < n; i++) forward[i] = backward[i] = INT_MAX;\n\n\tfor (int len = 1; len < n; len++) {\n\t\tfor (int i = 0; i + len < n; i += len) {\n\t\t\tconst int j = i + len;\n\t\t\tconst int a = std::min(lcs(i, j), len), b = std::min(lcp(i, j), len), s = a + b - 1;\n\t\t\t// const int a = lcs(i, j), b = lcp(i, j), s = a + b - 1;\n#ifdef DBG\n\t\t\tprintf(\"s = %d, len = %d\\n\", s, len);\n#endif\n\t\t\tif (s >= len) {\n#ifdef DBG\n\t\t\t\tprintf(\"!FOUND! i = %d, j = %d, a = %d, b = %d, len = %d\\n\", i, j, a, b, len);\n#endif\n\t\t\t\tconst int l = i - a + 1, r = j + b - 1;\n\t\t\t\tsForawrd.cover(l, l + (r - (l + len * 2 - 1)), len * 2, forward);\n\t\t\t\tsBackward.cover(l + len * 2 - 1, r, len * 2, backward);\n\t\t\t\t// sForawrd->update(l, l + (r - (l + len * 2 - 1)), len * 2);\n\t\t\t\t// sBackward->update(l + len * 2 - 1, r, len * 2);\n\t\t\t\t/*\n\t\t\t\tfor (int i = l + len * 2 - 1; i <= r; i++) {\n\t\t\t\t\tprintf(\"[%d, %d]\\n\", i - len * 2 + 1, i);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t}\n\t}\n\n\t// for (int i = 0; i < n; i++) forward[i] = sForawrd->query(i);\n\t// for (int i = 0; i < n; i++) backward[i] = sBackward->query(i);\n\n#ifdef DBG\n\tputs(\"forward / backward\");\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", forward[i] == INT_MAX ? 0 : forward[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", backward[i] == INT_MAX ? 0 : backward[i], i == n - 1 ? '\\n' : ' ');\n#endif\n}\n\n/*\nstruct ChairmanTree {\n\tstruct SegmentTree {\n\t\tint l, r, mid;\n\t\tSegmentTree *lc, *rc;\n\t\tint cnt, refCnt;\n\n\t\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, const int cnt = 0) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), cnt(cnt), refCnt(0) {}\n\n\t\t~SegmentTree() {\n\t\t\tif (lc && lc->unRef()) delete lc;\n\t\t\tif (rc && rc->unRef()) delete rc;\n\t\t}\n\n\t\tSegmentTree *ref() {\n\t\t\trefCnt++;\n\t\t\treturn this;\n\t\t}\n\n\t\tbool unRef() {\n\t\t\treturn !refCnt--;\n\t\t}\n\n\t\tint query(const int l, const int r) {\n\t\t\tif (l > this->r || r < this->l) return 0;\n\t\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\t\telse return (lc ? lc->query(l, r) : 0) + (rc ? rc->query(l, r) : 0);\n\t\t}\n\n\t\tSegmentTree *insertSelf(const int x) {\n\t\t\tif (l == r) return this;\n\t\t\tif (x <= mid) {\n\t\t\t\tthis->lc = (new SegmentTree(l, mid, NULL, NULL, 1))->insertSelf(x);\n\t\t\t} else {\n\t\t\t\tthis->rc = (new SegmentTree(mid + 1, r, NULL, NULL, 1))->insertSelf(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tSegmentTree *insert(const int x) {\n\t\t\tif (x <= mid) {\n\t\t\t\treturn new SegmentTree(l, r, lc ? lc->insert(x) : (new SegmentTree(l, mid, NULL, NULL, 1))->insertSelf(x), rc ? rc->ref() : NULL, cnt + 1);\n\t\t\t} else {\n\t\t\t\treturn new SegmentTree(l, r, lc ? lc->ref() : NULL, rc ? rc->insert(x) : (new SegmentTree(mid + 1, r, NULL, NULL, 1))->insertSelf(x), cnt + 1);\n\t\t\t}\n\t\t}\n\n\t\tint lcount() {\n\t\t\treturn lc ? lc->cnt : 0;\n\t\t}\n\t} *root[MAXN + 1];\n\tint n, l, r;\n\n\tvoid clear() {\n\t\tfor (int i = n; i >= 0; i--) {\n\t\t\tdelete root[i];\n\t\t}\n\t}\n\n\t// Build tree with array a, whose elements are limited in [l, r]\n\tvoid build(const int *a, const int n, const int l, const int r) {\n\t\tthis->n = n, this->l = l, this->r = r;\n\t\troot[0] = new SegmentTree(0, n, NULL, NULL, 0);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\troot[i] = root[i - 1]->insert(a[i - 1]);\n\t\t}\n\t}\n\n\tint query(const int l, const int r, const int x) {\n\t\t// Adjust input [0, n - 1] to [1, n]\n\t\tSegmentTree *vr = root[r + 1], *vl = root[l];\n\t\tint ans = vr->query(this->l, x);\n\t\tif (vl) ans -= vl->query(this->l, x);\n\t\treturn ans;\n\n\t\t/ *\n\t\twhile (min != max) {\n\t\t\tconst int mid = mid + (max - min) / 2, t = vr->lcount() - (vl ? vl->lcount() : 0);\n\t\t\tif (t < k) {\n\t\t\t\tk -= t, vr = vr->rc;\n\t\t\t\tif (vl) vl = vl->rc;\n\t\t\t} else {\n\t\t\t\tvr = vr->lc;\n\t\t\t\tif (vl) vl = vl->lc;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t\t* /\n\t}\n} t;\n*/\n\ninline unsigned long long solve(const int *limit, const int *forward, const int n) {\n\tstatic struct Query {\n\t\tint type;\n\t\tint pos, val;\n\n\t\tbool operator<(const Query &other) const {\n\t\t\tif (pos < other.pos) return true;\n\t\t\telse if (pos == other.pos && !type && other.type) return true;\n\t\t\telse return false;\n\t\t}\n\t} Q[MAXN * 3];\n\n\tfor (int i = 0; i < n; i++) {\n\t\tQ[i].pos = i;\n\t\tQ[i].type = 0;\n\t\tQ[i].val = limit[i];\n\n#ifdef DBG\n\t\tprintf(\"add(pos = %d, val = %d)\\n\", Q[i].pos, Q[i].val);\n#endif\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tQ[n + i].pos = i - 1;\n\t\tQ[n + i].val = i;\n\t\tQ[n + i].type = -1;\n\n#ifdef DBG\n\t\tprintf(\"query(pos = %d, val = %d, type = %d)\\n\", Q[n + i].pos, Q[n + i].val, Q[n + i].type);\n#endif\n\n\t\tQ[n + i + n].pos = (forward[i] == INT_MAX) ? (n - 1) : (i + forward[i] - 1);\n\t\tQ[n + i + n].val = i;\n\t\tQ[n + i + n].type = 1;\n\n#ifdef DBG\n\t\tprintf(\"query(pos = %d, val = %d, type = %d)\\n\", Q[n + i + n].pos, Q[n + i + n].val, Q[n + i + n].type);\n#endif\n\t}\n\n\tstd::sort(Q, Q + n * 3);\n\n\tstatic struct BinaryIndexedTree {\n\t\tint a[MAXN], n;\n\n\t\tstatic int lowbit(const int x) {\n\t\t\treturn x & -x;\n\t\t}\n\n\t\tvoid update(const int x, const int delta) {\n\t\t\t/*\n\t\t\ta[x - 1] += delta;\n\t\t\t*/\n\t\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t\t}\n\n\t\tint query(const int x) {\n\t\t\tint ans = 0;\n\t\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\t\t/*\n\t\t\tfor (int i = 1; i <= x; i++) ans += a[i - 1];\n\t\t\t*/\n\t\t\treturn ans;\n\t\t}\n\n\t\tvoid clear(const int x) {\n\t\t\t/*\n\t\t\ta[x - 1] = 0;\n\t\t\t*/\n\t\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\t\tif (!a[i - 1]) break;\n\t\t\t\ta[i - 1] = 0;\n\t\t\t}\n\t\t}\n\t} bit;\n\n\tbit.n = n;\n\n\tunsigned long long ans = 0;\n\tfor (int i = 0; i < n * 3; i++) {\n#ifdef DBG\n\t\tprintf(\"Query: %d %d %d\\n\", Q[i].type, Q[i].pos, Q[i].val);\n#endif\n\t\tif (Q[i].type) {\n\t\t\tint t = bit.query(Q[i].val + 1) * Q[i].type;\n\t\t\tans += t;\n#ifdef DBG\n\t\t\tprintf(\"t = %d\\n\", t);\n#endif\n\t\t} else bit.update(Q[i].val + 1, 1);\n\t\t/*\n#ifdef DBG\n\t\tprintf(\"Query: %d %d %d\\n\", Q[i].l, Q[i].r, Q[i].val);\n#endif\n\t\tif (Q[i].l == -1) bit.update(Q[i].val + 1, 1);\n\t\telse ans += bit.query(Q[i].r + 1) - bit.query(Q[i].l);\n#ifdef DBG\n\t\tprintf(\"ans = %d\\n\", ans);\n#endif\n\t\t*/\n\t}\n\n\tfor (int i = 0; i < n * 2; i++) if (!Q[i].type) bit.clear(Q[i].val + 1);\n\n\treturn ans;\n}\n\nint main() {\n\tint testcase;\n\tscanf(\"%d\", &testcase);\n\n\twhile (testcase--) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tn = strlen(s);\n\t\tsa1.build(s, n);\n\t\tstd::reverse(s, s + n);\n\t\tsa2.build(s, n);\n\n\t\tprepare(n);\n\t\tstatic int limit[MAXN];\n\t\tfor (int i = 0; i < n; i++) limit[i] = backward[i] == INT_MAX ? 0 : (i - backward[i] + 2);\n\n#ifdef DBG\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", limit[i], i == n - 1 ? '\\n' : ' ');\n#endif\n\n\t\t// t.clear();\n\t\t// t.build(limit, n, 0, n - 1);\n\n\t\t/*\n\t\tunsigned long long ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans += t.query(i, (forward[i] == INT_MAX) ? (n - 1) : (i + forward[i] - 1), i);\n\t\t}\n\t\t*/\n\n\t\tunsigned long long ans = solve(limit, forward, n);\n\t\tprintf(\"%llu\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"hdu-5906","published":1,"updated":"2016-09-30T10:00:52.455Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cnk00zzc2xlnwjx8ega"},{"title":"HDU 5462King's Order -  DP","date":"2016-05-11T23:47:00.000Z","_content":"\n-- $ 3 $ . ---- \n\n $ n $ $ n $ \n\n<!-- more -->\n\n### \n[HDU 5642](http://acm.hdu.edu.cn/showproblem.php?pid=5642)\n\n### \n DP\n\n$$ f[n][f1][f2][f3][lastChar] $$\n\n $ n $  $ lastChar $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 10;\nconst int MAXN = 2000;\nconst int MOD = 1000000007;\nconst int CHARSET_SIZE = 26;\n\nint mem[MAXN + 1][2][2][2][CHARSET_SIZE + 1];\nbool calced[MAXN + 1][2][2][2][CHARSET_SIZE + 1];\n    \ninline int dp(const int n, const bool c2EqualToC1, const bool c3EqualToC2, const bool c4EqualToC3, const int c4) {\n    int &ans = mem[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4];\n    if (calced[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4]) return ans;\n    calced[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4] = true;\n    \n    if (c2EqualToC1 && c3EqualToC2 && c4EqualToC3) {\n        ans = 0;\n    } else if (n == 0) {\n        ans = 1;\n    } else {\n        ans = 0;\n        for (int i = 0; i < CHARSET_SIZE; i++) {\n            ans += dp(n - 1, c3EqualToC2, c4EqualToC3, i == c4, i);\n            ans %= MOD;\n        }\n    }\n    \n    return ans;\n}\n\n// inline void cleanUp() {\n//     memset(mem, 0, sizeof(mem));\n//     memset(calced, 0, sizeof(calced));\n// }\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    \n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n        \n        printf(\"%d\\n\", dp(n, false, false, false, CHARSET_SIZE));\n        \n        // cleanUp();\n    }\n    \n    return 0;\n}\n```\n","source":"_posts/hdu-5642.md","raw":"title: HDU 5462King's Order -  DP\ncategories: OI\ntags: \n  - HDU\n  - BestCoder\n  -  DP\n  - DP\npermalink: hdu-5642\ndate: 2016-05-12 07:47:00\n---\n\n-- $ 3 $ . ---- \n\n $ n $ $ n $ \n\n<!-- more -->\n\n### \n[HDU 5642](http://acm.hdu.edu.cn/showproblem.php?pid=5642)\n\n### \n DP\n\n$$ f[n][f1][f2][f3][lastChar] $$\n\n $ n $  $ lastChar $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXT = 10;\nconst int MAXN = 2000;\nconst int MOD = 1000000007;\nconst int CHARSET_SIZE = 26;\n\nint mem[MAXN + 1][2][2][2][CHARSET_SIZE + 1];\nbool calced[MAXN + 1][2][2][2][CHARSET_SIZE + 1];\n    \ninline int dp(const int n, const bool c2EqualToC1, const bool c3EqualToC2, const bool c4EqualToC3, const int c4) {\n    int &ans = mem[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4];\n    if (calced[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4]) return ans;\n    calced[n][c2EqualToC1][c3EqualToC2][c4EqualToC3][c4] = true;\n    \n    if (c2EqualToC1 && c3EqualToC2 && c4EqualToC3) {\n        ans = 0;\n    } else if (n == 0) {\n        ans = 1;\n    } else {\n        ans = 0;\n        for (int i = 0; i < CHARSET_SIZE; i++) {\n            ans += dp(n - 1, c3EqualToC2, c4EqualToC3, i == c4, i);\n            ans %= MOD;\n        }\n    }\n    \n    return ans;\n}\n\n// inline void cleanUp() {\n//     memset(mem, 0, sizeof(mem));\n//     memset(calced, 0, sizeof(calced));\n// }\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    \n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n        \n        printf(\"%d\\n\", dp(n, false, false, false, CHARSET_SIZE));\n        \n        // cleanUp();\n    }\n    \n    return 0;\n}\n```\n","slug":"hdu-5642","published":1,"updated":"2016-10-24T23:36:12.278Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cns010ac2xl973cjb8b"},{"title":"HDU 632Rikka with Array -  DP","date":"2016-05-12T14:11:00.000Z","_content":"\n $ A(x) $  $ x $  $ 1 $  $ 1 \\leq i \\lt j \\leq n,\\ A(i) \\gt A(j) $  $ [i, j] $ \n\n<!-- more -->\n\n### \n[HDU 5632](http://acm.hdu.edu.cn/showproblem.php?pid=5632)\n\n### \n DP\n\n$$ f[n][gap][iLessThanJ][lim1][lim2] $$\n\n $ n $ $ j - i $ $ gap $ $ i \\lt j $  $ i = j $$ i $$ j $ \n\n $ i $$ j $  $ 0 $  $ 1 $ \n\n $ i \\gt j $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXT = 10;\nconst int MAXN = 300;\nconst int MAXN_BIT = 997; // 996.5784284662087\nconst int MOD = 998244353;\n\nconst int FLAG = 2;\n\nint n;\nbool a[MAXN_BIT];\n\nint mem[MAXN_BIT][(MAXN_BIT + 1) * 2][FLAG][FLAG][FLAG];\n// bool calced[MAXN_BIT][(MAXN_BIT + 1) * 2][FLAG][FLAG][FLAG];\n\nbool i[MAXN_BIT], j[MAXN_BIT];\n\n/*\ninline void _set(const int n, const bool i, const bool j) {\n    ::i[::n - n] = i;\n    ::j[::n - n] = j;\n}\n\ninline void _print() {\n    for (int i = 0; i < n; i++) putchar(::i[i] ? '1' : '0');\n    putchar('\\n');\n    \n    for (int i = 0; i < n; i++) putchar(::j[i] ? '1' : '0');\n    putchar('\\n');\n    \n    putchar('\\n');\n}\n*/\n\ninline int dp(const int n, const int gap, const bool iLessThanJ, const bool limited1, const bool limited2) {\n    // gap : (A[i] - A[j])\n    \n    int &ans = mem[n][gap + MAXN_BIT][iLessThanJ][limited1][limited2];\n    if (ans != -1) return ans;\n    \n    if (n == 0) {\n        if (iLessThanJ && gap > 0) ans = 1; // , _print();\n        else ans = 0;\n    } else {\n        ans = 0;\n        \n        int limit1, limit2;\n        bool &next = a[::n - n];\n        \n        if (limited1) limit1 = next;\n        else limit1 = 1;\n        \n        if (limited2) limit2 = next;\n        else limit2 = 1;\n        \n        // printf(\"next = %d\\n\", next);\n        \n        // 0 0\n        // _set(n, 0, 0);\n        ans += dp(n - 1,\n                  gap,\n                  iLessThanJ,\n                  limited1 && next == 0,\n                  limited2 && next == 0\n        );\n        ans %= MOD;\n        \n        // 0 1\n        if (limit2 == 1) {\n            // _set(n, 0, 1);\n            ans += dp(n - 1,\n                      gap - 1,\n                      true,\n                      limited1 && next == 0,\n                      limited2 && next == 1\n            );\n            ans %= MOD;\n        }\n        \n        \n        // 1 0\n        if (limit1 == 1 && iLessThanJ) {\n            // _set(n, 1, 0);\n            ans += dp(n - 1,\n                      gap + 1,\n                      true,\n                      limited1 && next == 1,\n                      limited2 && next == 0\n            );\n            ans %= MOD;\n        }\n        \n        \n        // 1 1\n        if (limit1 == 1 && limit2 == 1) {\n            // _set(n, 1, 1);\n            ans += dp(n - 1,\n                      gap,\n                      iLessThanJ,\n                      limited1 && next == 1,\n                      limited2 && next == 1\n            );\n            ans %= MOD;\n        }\n    }\n    \n    // if (n == ::n - 1) printf(\"f[%d][%d][%s][%s][%s] = %d\\n\", n, gap, iLessThanJ ? \"<\" : \"=\", limited1 ? \"*\" : \" \", limited2 ? \"*\" : \" \", ans);\n    return ans;\n}\n\ninline int solve(const char *s) {\n    memset(mem, 0xff, sizeof(mem));\n    // memset(calced, 0, sizeof(calced));\n    n = 0;\n    \n    int len = strlen(s);\n    static int num[MAXN];\n    for (int i = 0; i < len; i++) num[i] = s[i] - '0';\n    \n    while (1) {\n        int r = 0;\n        bool allZero = true;\n        for (int i = 0; i < len; i++) {\n            if (num[i] != 0) allZero = false;\n            r = r * 10 + num[i];\n            num[i] = r / 2;\n            r %= 2;\n        }\n        \n        if (allZero) break;\n        \n        a[n++] = r;\n    }\n    \n    std::reverse(a, a + n);\n    \n    if (n == 0) return 0;\n    \n    int ans = 0;\n    \n    // 0 0\n    // _set(n, 0, 0);\n    ans += dp(\n        n - 1,\n        0,\n        false,\n        false,\n        false\n    );\n    ans %= MOD;\n    \n    // 0 1\n    // _set(n, 0, 1);\n    ans += dp(\n        n - 1,\n        -1,\n        true,\n        false,\n        true\n    );\n    ans %= MOD;\n    \n    // 1 1\n    // _set(n, 1, 1);\n    ans += dp(\n        n - 1,\n        0,\n        false,\n        true,\n        true\n    );\n    ans %= MOD;\n    \n    return ans;\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        static char s[MAXN + 1];\n        scanf(\"%s\", s);\n        printf(\"%d\\n\", solve(s));\n    }\n    \n    return 0;\n}\n```\n","source":"_posts/hdu-5632.md","raw":"title: HDU 632Rikka with Array -  DP\ncategories: OI\ntags: \n  - HDU\n  -  DP\n  - DP\npermalink: hdu-5632\ndate: 2016-05-12 22:11:00\n---\n\n $ A(x) $  $ x $  $ 1 $  $ 1 \\leq i \\lt j \\leq n,\\ A(i) \\gt A(j) $  $ [i, j] $ \n\n<!-- more -->\n\n### \n[HDU 5632](http://acm.hdu.edu.cn/showproblem.php?pid=5632)\n\n### \n DP\n\n$$ f[n][gap][iLessThanJ][lim1][lim2] $$\n\n $ n $ $ j - i $ $ gap $ $ i \\lt j $  $ i = j $$ i $$ j $ \n\n $ i $$ j $  $ 0 $  $ 1 $ \n\n $ i \\gt j $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXT = 10;\nconst int MAXN = 300;\nconst int MAXN_BIT = 997; // 996.5784284662087\nconst int MOD = 998244353;\n\nconst int FLAG = 2;\n\nint n;\nbool a[MAXN_BIT];\n\nint mem[MAXN_BIT][(MAXN_BIT + 1) * 2][FLAG][FLAG][FLAG];\n// bool calced[MAXN_BIT][(MAXN_BIT + 1) * 2][FLAG][FLAG][FLAG];\n\nbool i[MAXN_BIT], j[MAXN_BIT];\n\n/*\ninline void _set(const int n, const bool i, const bool j) {\n    ::i[::n - n] = i;\n    ::j[::n - n] = j;\n}\n\ninline void _print() {\n    for (int i = 0; i < n; i++) putchar(::i[i] ? '1' : '0');\n    putchar('\\n');\n    \n    for (int i = 0; i < n; i++) putchar(::j[i] ? '1' : '0');\n    putchar('\\n');\n    \n    putchar('\\n');\n}\n*/\n\ninline int dp(const int n, const int gap, const bool iLessThanJ, const bool limited1, const bool limited2) {\n    // gap : (A[i] - A[j])\n    \n    int &ans = mem[n][gap + MAXN_BIT][iLessThanJ][limited1][limited2];\n    if (ans != -1) return ans;\n    \n    if (n == 0) {\n        if (iLessThanJ && gap > 0) ans = 1; // , _print();\n        else ans = 0;\n    } else {\n        ans = 0;\n        \n        int limit1, limit2;\n        bool &next = a[::n - n];\n        \n        if (limited1) limit1 = next;\n        else limit1 = 1;\n        \n        if (limited2) limit2 = next;\n        else limit2 = 1;\n        \n        // printf(\"next = %d\\n\", next);\n        \n        // 0 0\n        // _set(n, 0, 0);\n        ans += dp(n - 1,\n                  gap,\n                  iLessThanJ,\n                  limited1 && next == 0,\n                  limited2 && next == 0\n        );\n        ans %= MOD;\n        \n        // 0 1\n        if (limit2 == 1) {\n            // _set(n, 0, 1);\n            ans += dp(n - 1,\n                      gap - 1,\n                      true,\n                      limited1 && next == 0,\n                      limited2 && next == 1\n            );\n            ans %= MOD;\n        }\n        \n        \n        // 1 0\n        if (limit1 == 1 && iLessThanJ) {\n            // _set(n, 1, 0);\n            ans += dp(n - 1,\n                      gap + 1,\n                      true,\n                      limited1 && next == 1,\n                      limited2 && next == 0\n            );\n            ans %= MOD;\n        }\n        \n        \n        // 1 1\n        if (limit1 == 1 && limit2 == 1) {\n            // _set(n, 1, 1);\n            ans += dp(n - 1,\n                      gap,\n                      iLessThanJ,\n                      limited1 && next == 1,\n                      limited2 && next == 1\n            );\n            ans %= MOD;\n        }\n    }\n    \n    // if (n == ::n - 1) printf(\"f[%d][%d][%s][%s][%s] = %d\\n\", n, gap, iLessThanJ ? \"<\" : \"=\", limited1 ? \"*\" : \" \", limited2 ? \"*\" : \" \", ans);\n    return ans;\n}\n\ninline int solve(const char *s) {\n    memset(mem, 0xff, sizeof(mem));\n    // memset(calced, 0, sizeof(calced));\n    n = 0;\n    \n    int len = strlen(s);\n    static int num[MAXN];\n    for (int i = 0; i < len; i++) num[i] = s[i] - '0';\n    \n    while (1) {\n        int r = 0;\n        bool allZero = true;\n        for (int i = 0; i < len; i++) {\n            if (num[i] != 0) allZero = false;\n            r = r * 10 + num[i];\n            num[i] = r / 2;\n            r %= 2;\n        }\n        \n        if (allZero) break;\n        \n        a[n++] = r;\n    }\n    \n    std::reverse(a, a + n);\n    \n    if (n == 0) return 0;\n    \n    int ans = 0;\n    \n    // 0 0\n    // _set(n, 0, 0);\n    ans += dp(\n        n - 1,\n        0,\n        false,\n        false,\n        false\n    );\n    ans %= MOD;\n    \n    // 0 1\n    // _set(n, 0, 1);\n    ans += dp(\n        n - 1,\n        -1,\n        true,\n        false,\n        true\n    );\n    ans %= MOD;\n    \n    // 1 1\n    // _set(n, 1, 1);\n    ans += dp(\n        n - 1,\n        0,\n        false,\n        true,\n        true\n    );\n    ans %= MOD;\n    \n    return ans;\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        static char s[MAXN + 1];\n        scanf(\"%s\", s);\n        printf(\"%d\\n\", solve(s));\n    }\n    \n    return 0;\n}\n```\n","slug":"hdu-5632","published":1,"updated":"2016-10-24T23:36:02.698Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cny010hc2xlcnsxg74l"},{"title":"HDU 2089 62 -  DP","date":"2016-05-12T03:56:00.000Z","_content":"\n $ 4 $  $ 62 $ $ 62315,\\ 73418,\\ 88914 $ $ 61152 $  $ 6 $  $ 2 $ $ 62 $ \n\n\n\n<!-- more -->\n\n### \n[HDU 2089](http://acm.hdu.edu.cn/showproblem.php?pid=2089)\n\n### \n DP\n\n$$ f[n][last][flag] $$\n\n $ n $  $ n $  $ last $\n\n $ n $  $ 4 $ $ 62 $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXX = 1000000;\nconst int MAXN = 7;\nconst int CHARSET_SIZE = 10;\nconst int FLAG = 2;\n\nint a[MAXN], n;\n\nint mem[MAXN + 1][CHARSET_SIZE][FLAG];\nbool calced[MAXN + 1][CHARSET_SIZE][FLAG];\n\ninline int dp(const int n, const int last, const bool flag) {\n    int &ans = mem[n][last][flag];\n    if (calced[n][last][flag]) return ans;\n    calced[n][last][flag] = true;\n    \n    if (n == 0) {\n        ans = 1;\n    } else {\n        int limit;\n        if (flag) limit = a[::n - n];\n        else limit = CHARSET_SIZE - 1;\n        \n        for (int i = 0; i <= limit; i++) {\n            if (last == 6 && i == 2 || i == 4) continue;\n            ans += dp(n - 1, i, flag && i == limit);\n        }\n    }\n    \n    // printf(\"dp(%d, %d) = %d\\n\", n, last, ans);\n    return ans;\n}\n\ninline int solve(const int x) {\n    char s[MAXN + 1];\n    sprintf(s, \"%d\", x);\n    n = strlen(s);\n    for (int i = 0; i < n; i++) a[i] = s[i] - '0';\n    \n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    int ans = 0;\n    for (int i = 0; i <= a[0]; i++) {\n        if (i == 4) continue;\n        ans += dp(n - 1, i, i == a[0]);\n        // printf(\"[%d, %d] -> %d\\n\", n - 1, i, dp(n - 1, i, i == a[0]));\n    }\n    \n    return ans;\n}\n\nint main() {\n    int l, r;\n    while (scanf(\"%d %d\", &l, &r), !(l == 0 && r == 0)) {\n        printf(\"%d\\n\", solve(r) - solve(l - 1));\n    }\n    \n    return 0;\n}\n```\n","source":"_posts/hdu-2089.md","raw":"title: HDU 2089 62 -  DP\ncategories: OI\ntags: \n  - HDU\n  -  DP\n  - DP\npermalink: hdu-2089\ndate: 2016-05-12 11:56:00\n---\n\n $ 4 $  $ 62 $ $ 62315,\\ 73418,\\ 88914 $ $ 61152 $  $ 6 $  $ 2 $ $ 62 $ \n\n\n\n<!-- more -->\n\n### \n[HDU 2089](http://acm.hdu.edu.cn/showproblem.php?pid=2089)\n\n### \n DP\n\n$$ f[n][last][flag] $$\n\n $ n $  $ n $  $ last $\n\n $ n $  $ 4 $ $ 62 $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXX = 1000000;\nconst int MAXN = 7;\nconst int CHARSET_SIZE = 10;\nconst int FLAG = 2;\n\nint a[MAXN], n;\n\nint mem[MAXN + 1][CHARSET_SIZE][FLAG];\nbool calced[MAXN + 1][CHARSET_SIZE][FLAG];\n\ninline int dp(const int n, const int last, const bool flag) {\n    int &ans = mem[n][last][flag];\n    if (calced[n][last][flag]) return ans;\n    calced[n][last][flag] = true;\n    \n    if (n == 0) {\n        ans = 1;\n    } else {\n        int limit;\n        if (flag) limit = a[::n - n];\n        else limit = CHARSET_SIZE - 1;\n        \n        for (int i = 0; i <= limit; i++) {\n            if (last == 6 && i == 2 || i == 4) continue;\n            ans += dp(n - 1, i, flag && i == limit);\n        }\n    }\n    \n    // printf(\"dp(%d, %d) = %d\\n\", n, last, ans);\n    return ans;\n}\n\ninline int solve(const int x) {\n    char s[MAXN + 1];\n    sprintf(s, \"%d\", x);\n    n = strlen(s);\n    for (int i = 0; i < n; i++) a[i] = s[i] - '0';\n    \n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    int ans = 0;\n    for (int i = 0; i <= a[0]; i++) {\n        if (i == 4) continue;\n        ans += dp(n - 1, i, i == a[0]);\n        // printf(\"[%d, %d] -> %d\\n\", n - 1, i, dp(n - 1, i, i == a[0]));\n    }\n    \n    return ans;\n}\n\nint main() {\n    int l, r;\n    while (scanf(\"%d %d\", &l, &r), !(l == 0 && r == 0)) {\n        printf(\"%d\\n\", solve(r) - solve(l - 1));\n    }\n    \n    return 0;\n}\n```\n","slug":"hdu-2089","published":1,"updated":"2016-10-24T23:35:53.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6co3010mc2xlaoa85tvp"},{"title":"HAOI2016 -  + DP","date":"2016-04-28T14:20:45.000Z","_content":"\n $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 4562](http://www.lydsy.com/JudgeOnline/problem.php?id=4562)  \n[COGS 2266](http://cogs.top/cogs/problem/problem.php?pid=2266)\n\n### \n****\n\n DP \n\n****\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXM = 200000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e;\n    int originInDegree, inDegree, outDegree;\n    int cnt;\n} N[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n\n    Edge(Node *const s, Node *const t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n    N[s].e = new Edge(&N[s], &N[t]);\n    N[s].outDegree++, N[t].inDegree++, N[t].originInDegree++;\n}\n\nint n, m;\n\ninline void toposort() {\n    std::queue<Node *> q;\n    for (int i = 0; i < n; i++) {\n        if (N[i].inDegree == 0) N[i].cnt = 1, q.push(&N[i]);\n    }\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) {\n            e->t->cnt += v->cnt;\n            if (!--e->t->inDegree) {\n                q.push(e->t);\n            }\n        }\n    }\n}\n\nint main() {\n    freopen(\"chain_2016.in\", \"r\", stdin);\n    freopen(\"chain_2016.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n\n        addEdge(u, v);\n    }\n\n    toposort();\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (N[i].outDegree == 0 && N[i].originInDegree != 0) ans += N[i].cnt;\n    }\n\n    printf(\"%d\\n\", ans);\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/haoi2016-chain.md","raw":"title: HAOI2016 -  + DP\ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - HAOI\n  - \n  - DP\npermalink: haoi2016-chain\ndate: 2016-04-28 22:20:45\n---\n\n $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 4562](http://www.lydsy.com/JudgeOnline/problem.php?id=4562)  \n[COGS 2266](http://cogs.top/cogs/problem/problem.php?pid=2266)\n\n### \n****\n\n DP \n\n****\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n\nconst int MAXN = 100000;\nconst int MAXM = 200000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e;\n    int originInDegree, inDegree, outDegree;\n    int cnt;\n} N[MAXN];\n\nstruct Edge {\n    Node *s, *t;\n    Edge *next;\n\n    Edge(Node *const s, Node *const t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n    N[s].e = new Edge(&N[s], &N[t]);\n    N[s].outDegree++, N[t].inDegree++, N[t].originInDegree++;\n}\n\nint n, m;\n\ninline void toposort() {\n    std::queue<Node *> q;\n    for (int i = 0; i < n; i++) {\n        if (N[i].inDegree == 0) N[i].cnt = 1, q.push(&N[i]);\n    }\n\n    while (!q.empty()) {\n        Node *v = q.front();\n        q.pop();\n\n        for (Edge *e = v->e; e; e = e->next) {\n            e->t->cnt += v->cnt;\n            if (!--e->t->inDegree) {\n                q.push(e->t);\n            }\n        }\n    }\n}\n\nint main() {\n    freopen(\"chain_2016.in\", \"r\", stdin);\n    freopen(\"chain_2016.out\", \"w\", stdout);\n\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v), u--, v--;\n\n        addEdge(u, v);\n    }\n\n    toposort();\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (N[i].outDegree == 0 && N[i].originInDegree != 0) ans += N[i].cnt;\n    }\n\n    printf(\"%d\\n\", ans);\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"haoi2016-chain","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6co7010rc2xlf2ck7v97"},{"title":"HAOI2015 -  + DFS","date":"2016-04-03T14:32:45.000Z","_content":"\n $ N $  $ 1 $  $ M $ \n\n1.  $ x $  $ a $\n2.  $ x $  $ a $\n3.  $ x $ \n\n<!-- more -->\n\n### \n[BZOJ 4034](http://www.lydsy.com/JudgeOnline/problem.php?id=4034)  \n[COGS 1963](http://cogs.top/cogs/problem/problem.php?pid=1963)\n\n### \n + DFS  `long long` \n\n### \n```c++\n#include <cstdio>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\n\nstruct Node;\nstruct Edge;\nstruct Path;\n\nstruct Node {\n\tEdge *e;\n\tNode *c, *p;\n\tint size, pos, posEnd;\n\tbool visited;\n\tPath *path;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v) {\n\tN[u].e = new Edge(&N[u], &N[v]);\n\tN[v].e = new Edge(&N[v], &N[u]);\n}\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tlong long value, lazy;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), lc(lc), rc(rc), value(0), lazy(0) {}\n\n\tvoid cover(const long long delta) { value += delta * (r - l + 1), lazy += delta; }\n\n\tvoid pushDown() {\n\t\tif (lazy) {\n\t\t\tif (lc) lc->cover(lazy);\n\t\t\tif (rc) rc->cover(lazy);\n\t\t\tlazy = 0;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const long long delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) cover(delta);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tvalue = 0;\n\t\t\tif (lc) lc->update(l, r, delta), value += lc->value;\n\t\t\tif (rc) rc->update(l, r, delta), value += rc->value;\n\t\t}\n\t}\n\n\tlong long query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return value;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlong long result = 0;\n\t\t\tif (lc) result += lc->query(l, r);\n\t\t\tif (rc) result += rc->query(l, r);\n\t\t\treturn result;\n\t\t}\n\t}\n} *segment;\n\nSegmentTree *buildSegmentTree(const int l, const int r) {\n\tif (l > r) return NULL;\n\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\telse return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) >> 1)), buildSegmentTree(l + ((r - l) >> 1) + 1, r));\n}\n\nstruct Path {\n\tNode *top;\n\n\tPath(Node *top) : top(top) {}\n};\n\nint n, m;\nlong long a[MAXN];\n\ninline void cut() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == NULL && e->t != v->p) e->t->p = v, s.push(e->t);\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (v->c == NULL || v->c->size < e->t->size) v->c = e->t;\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) N[i].visited = false;\n\n\ts.push(&N[0]);\n\tint time = -1;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->pos = ++time;\n\n\t\t\tif (!v->p || v != v->p->c) v->path = new Path(v);\n\t\t\telse v->path = v->p->path;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else v->posEnd = time, s.pop();\n\t}\n\n\tsegment = buildSegmentTree(0, n - 1);\n\tfor (int i = 0; i < n; i++) segment->update(N[i].pos, N[i].pos, a[i]);\n}\n\ninline long long queryToRoot(const int x) {\n\tNode *v = &N[x];\n\tlong long sum = 0;\n\twhile (v) {\n\t\tsum += segment->query(v->path->top->pos, v->pos);\n\t\tv = v->path->top->p;\n\t}\n\treturn sum;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n\tfor (int i = 0, u, v; i < n - 1; i++) scanf(\"%d %d\", &u, &v), u--, v--, addEdge(u, v);\n\n\tcut();\n\n\tfor (int i = 0, cmd; i < m; i++) {\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint x, a;\n\t\t\tscanf(\"%d %d\", &x, &a), x--;\n\t\t\tsegment->update(N[x].pos, N[x].pos, a);\n\t\t} else if (cmd == 2) {\n\t\t\tint x, a;\n\t\t\tscanf(\"%d %d\", &x, &a), x--;\n\t\t\tsegment->update(N[x].pos, N[x].posEnd, a);\n\t\t} else if (cmd == 3) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x), x--;\n\t\t\tprintf(\"%lld\\n\", queryToRoot(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2015-t2.md","raw":"title: HAOI2015 -  + DFS\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \n  - \n  - DFS \npermalink: haoi2015-t2\ndate: 2016-04-03 22:32:45\n---\n\n $ N $  $ 1 $  $ M $ \n\n1.  $ x $  $ a $\n2.  $ x $  $ a $\n3.  $ x $ \n\n<!-- more -->\n\n### \n[BZOJ 4034](http://www.lydsy.com/JudgeOnline/problem.php?id=4034)  \n[COGS 1963](http://cogs.top/cogs/problem/problem.php?pid=1963)\n\n### \n + DFS  `long long` \n\n### \n```c++\n#include <cstdio>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXM = 100000;\n\nstruct Node;\nstruct Edge;\nstruct Path;\n\nstruct Node {\n\tEdge *e;\n\tNode *c, *p;\n\tint size, pos, posEnd;\n\tbool visited;\n\tPath *path;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v) {\n\tN[u].e = new Edge(&N[u], &N[v]);\n\tN[v].e = new Edge(&N[v], &N[u]);\n}\n\nstruct SegmentTree {\n\tint l, r;\n\tSegmentTree *lc, *rc;\n\tlong long value, lazy;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), lc(lc), rc(rc), value(0), lazy(0) {}\n\n\tvoid cover(const long long delta) { value += delta * (r - l + 1), lazy += delta; }\n\n\tvoid pushDown() {\n\t\tif (lazy) {\n\t\t\tif (lc) lc->cover(lazy);\n\t\t\tif (rc) rc->cover(lazy);\n\t\t\tlazy = 0;\n\t\t}\n\t}\n\n\tvoid update(const int l, const int r, const long long delta) {\n\t\tif (l > this->r || r < this->l) return;\n\t\telse if (l <= this->l && r >= this->r) cover(delta);\n\t\telse {\n\t\t\tpushDown();\n\t\t\tvalue = 0;\n\t\t\tif (lc) lc->update(l, r, delta), value += lc->value;\n\t\t\tif (rc) rc->update(l, r, delta), value += rc->value;\n\t\t}\n\t}\n\n\tlong long query(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return value;\n\t\telse {\n\t\t\tpushDown();\n\t\t\tlong long result = 0;\n\t\t\tif (lc) result += lc->query(l, r);\n\t\t\tif (rc) result += rc->query(l, r);\n\t\t\treturn result;\n\t\t}\n\t}\n} *segment;\n\nSegmentTree *buildSegmentTree(const int l, const int r) {\n\tif (l > r) return NULL;\n\telse if (l == r) return new SegmentTree(l, r, NULL, NULL);\n\telse return new SegmentTree(l, r, buildSegmentTree(l, l + ((r - l) >> 1)), buildSegmentTree(l + ((r - l) >> 1) + 1, r));\n}\n\nstruct Path {\n\tNode *top;\n\n\tPath(Node *top) : top(top) {}\n};\n\nint n, m;\nlong long a[MAXN];\n\ninline void cut() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == NULL && e->t != v->p) e->t->p = v, s.push(e->t);\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (v->c == NULL || v->c->size < e->t->size) v->c = e->t;\n\t\t\t}\n\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) N[i].visited = false;\n\n\ts.push(&N[0]);\n\tint time = -1;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->pos = ++time;\n\n\t\t\tif (!v->p || v != v->p->c) v->path = new Path(v);\n\t\t\telse v->path = v->p->path;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) s.push(e->t);\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else v->posEnd = time, s.pop();\n\t}\n\n\tsegment = buildSegmentTree(0, n - 1);\n\tfor (int i = 0; i < n; i++) segment->update(N[i].pos, N[i].pos, a[i]);\n}\n\ninline long long queryToRoot(const int x) {\n\tNode *v = &N[x];\n\tlong long sum = 0;\n\twhile (v) {\n\t\tsum += segment->query(v->path->top->pos, v->pos);\n\t\tv = v->path->top->p;\n\t}\n\treturn sum;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n\tfor (int i = 0, u, v; i < n - 1; i++) scanf(\"%d %d\", &u, &v), u--, v--, addEdge(u, v);\n\n\tcut();\n\n\tfor (int i = 0, cmd; i < m; i++) {\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tint x, a;\n\t\t\tscanf(\"%d %d\", &x, &a), x--;\n\t\t\tsegment->update(N[x].pos, N[x].pos, a);\n\t\t} else if (cmd == 2) {\n\t\t\tint x, a;\n\t\t\tscanf(\"%d %d\", &x, &a), x--;\n\t\t\tsegment->update(N[x].pos, N[x].posEnd, a);\n\t\t} else if (cmd == 3) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x), x--;\n\t\t\tprintf(\"%lld\\n\", queryToRoot(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"haoi2015-t2","published":1,"updated":"2016-09-10T09:44:45.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6coe010zc2xlo3rb9c3n"},{"title":"HAOI2011Problem b - ","date":"2016-04-08T03:32:33.000Z","_content":"\n $ n $  $ (x, y) $ $ a \\leq x \\leq b $$ c \\leq y \\leq d $ $ \\gcd(x, y) = k $$ \\gcd(x, y) $ $ x $  $ y $ \n\n<!-- more -->\n\n### \n[BZOJ 2301](http://www.lydsy.com/JudgeOnline/problem.php?id=2301)  \n[COGS 548](http://cogs.top/cogs/problem/problem.php?pid=548)\n\n### \n\n\n$$ \\sum\\limits_{i = a} ^ {b} \\sum\\limits_{j = c} ^ {d} [\\gcd(i, j) = k] $$\n\n\n\n$$ F(n, m, k) = \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = k] $$\n\n\n\n$$ F(b, d, k) - F(a - 1, d, k) - F(b, c - 1, k) + F(a - 1, c - 1, k) $$\n\n $ F $ \n\n\n\n$$\n\\begin{align}\nf(k) &= \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = k] \\\\\n\\end{align}\n$$\n\n $ g(k) $\n\n$$\n\\begin{align}\ng(k) &= \\sum\\limits_{k \\mid d} f(d) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} f(t \\times k) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = t \\times k] \\\\\n&= \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [k \\mid \\gcd(i, j)] \\\\\n&= \\lfloor \\frac{n}{k} \\rfloor \\lfloor \\frac{m}{k} \\rfloor \\\\\n\\end{align}\n$$\n\n\n\n$$\n\\begin{align}\nf(k) &= \\sum\\limits_{k \\mid d} g(d) \\mu(\\frac{d}{k}) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} g(tk) \\mu(t) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} \\lfloor \\frac{n}{tk} \\rfloor \\lfloor \\frac{m}{tk} \\rfloor \\mu(t) \\\\\n\\end{align}\n$$\n\n $ F(n, m, k) $ \n\n```c++\nint ans = 0;\nfor (int d = 1; d <= (n / k); d++) {\n\tans += mu[d] * (n / (k * d)) * (m / (k * d));\n}\n```\n\n\n\n $ \\frac{n}{k} $  $ F'(n', m') $\n\n$$\n\\begin{align}\nn' &= \\lfloor \\frac{n}{k} \\rfloor \\\\\nm' &= \\lfloor \\frac{m}{k} \\rfloor \\\\\nF(n, m, k) &= F'(\\lfloor \\frac{n}{k} \\rfloor, \\lfloor \\frac{m}{k} \\rfloor) \\\\\nF'(n', m') &= \\sum\\limits_{T = 1} ^ {n'} \\lfloor \\frac{n'}{T} \\rfloor \\lfloor \\frac{m'}{T} \\rfloor \\mu(T) \\\\\n\\end{align}\n$$\n\n $ F' $  $ \\mu(T) $  $ O(\\sqrt{n}) $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 50000;\nconst int MAXN = 50000;\nconst int MAXK = 50000;\n\nbool isNotPrime[MAXN + 1];\nint mu[MAXN + 1], s[MAXN + 1], primes[MAXN + 1], cnt;\ninline void getPrimes() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tmu[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t\tmu[i] = -1;\n\t\t}\n\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tint t = i * primes[j];\n\t\t\tif (t > MAXN) break;\n\t\t\tisNotPrime[t] = true;\n\t\t\tif (i % primes[j] == 0) {\n\t\t\t\tmu[t] = 0;\n\t\t\t\tbreak;\n\t\t\t} else mu[t] = -mu[i];\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= MAXN; i++) s[i] = s[i - 1] + mu[i];\n}\n\ninline int gcd(const int a, const int b) { return !b ? a : gcd(b, a % b); }\n\ninline int solve(int n, int m, const int k) {\n\tif (n > m) std::swap(n, m);\n\tn /= k, m /= k;\n\tint ans = 0;\n\tfor (int l = 1, r; l <= n; l = r + 1) {\n\t\tr = std::min(n / (n / l), m / (m / l));\n\t\tans += (s[r] - s[l - 1]) * ((n / l) * (m / l));\n\t}\n\n\treturn ans;\n\n\t/*int ans = 0;\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) if (gcd(i, j) == k) ans++;\n\treturn ans;*/\n\n\t/*int ans = 0;\n\tfor (int d = 1; d <= (n / k); d++) {\n\t\tans += mu[d] * (n / (k * d)) * (m / (k * d));\n\t}*/\n\t// printf(\"solve(%d, %d, %d) = %d\\n\", n, m, k, ans);\n\treturn ans;\n}\n\ninline int solve(const int a, const int b, const int c, const int d, const int k) {\n\treturn solve(b, d, k) - solve(a - 1, d, k) - solve(b, c - 1, k) + solve(a - 1, c - 1, k);\n}\n\nint main() {\n\tgetPrimes();\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint a, b, c, d, k;\n\t\tscanf(\"%d %d %d %d %d\", &a, &b, &c, &d, &k);\n\t\tprintf(\"%d\\n\", solve(a, b, c, d, k));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2011-problemb.md","raw":"title: HAOI2011Problem b - \ncategories: OI\ntags: \n  - BZOJ\n  - COGS\n  - HAOI\n  - \n  - \n  - \n  - \npermalink: haoi2011-problemb\ndate: 2016-04-08 11:32:33\n---\n\n $ n $  $ (x, y) $ $ a \\leq x \\leq b $$ c \\leq y \\leq d $ $ \\gcd(x, y) = k $$ \\gcd(x, y) $ $ x $  $ y $ \n\n<!-- more -->\n\n### \n[BZOJ 2301](http://www.lydsy.com/JudgeOnline/problem.php?id=2301)  \n[COGS 548](http://cogs.top/cogs/problem/problem.php?pid=548)\n\n### \n\n\n$$ \\sum\\limits_{i = a} ^ {b} \\sum\\limits_{j = c} ^ {d} [\\gcd(i, j) = k] $$\n\n\n\n$$ F(n, m, k) = \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = k] $$\n\n\n\n$$ F(b, d, k) - F(a - 1, d, k) - F(b, c - 1, k) + F(a - 1, c - 1, k) $$\n\n $ F $ \n\n\n\n$$\n\\begin{align}\nf(k) &= \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = k] \\\\\n\\end{align}\n$$\n\n $ g(k) $\n\n$$\n\\begin{align}\ng(k) &= \\sum\\limits_{k \\mid d} f(d) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} f(t \\times k) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [\\gcd(i, j) = t \\times k] \\\\\n&= \\sum\\limits_{i = 1} ^ {n} \\sum\\limits_{j = 1} ^ {m} [k \\mid \\gcd(i, j)] \\\\\n&= \\lfloor \\frac{n}{k} \\rfloor \\lfloor \\frac{m}{k} \\rfloor \\\\\n\\end{align}\n$$\n\n\n\n$$\n\\begin{align}\nf(k) &= \\sum\\limits_{k \\mid d} g(d) \\mu(\\frac{d}{k}) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} g(tk) \\mu(t) \\\\\n&= \\sum\\limits_{t = 1} ^ {\\lfloor \\frac{n}{k} \\rfloor} \\lfloor \\frac{n}{tk} \\rfloor \\lfloor \\frac{m}{tk} \\rfloor \\mu(t) \\\\\n\\end{align}\n$$\n\n $ F(n, m, k) $ \n\n```c++\nint ans = 0;\nfor (int d = 1; d <= (n / k); d++) {\n\tans += mu[d] * (n / (k * d)) * (m / (k * d));\n}\n```\n\n\n\n $ \\frac{n}{k} $  $ F'(n', m') $\n\n$$\n\\begin{align}\nn' &= \\lfloor \\frac{n}{k} \\rfloor \\\\\nm' &= \\lfloor \\frac{m}{k} \\rfloor \\\\\nF(n, m, k) &= F'(\\lfloor \\frac{n}{k} \\rfloor, \\lfloor \\frac{m}{k} \\rfloor) \\\\\nF'(n', m') &= \\sum\\limits_{T = 1} ^ {n'} \\lfloor \\frac{n'}{T} \\rfloor \\lfloor \\frac{m'}{T} \\rfloor \\mu(T) \\\\\n\\end{align}\n$$\n\n $ F' $  $ \\mu(T) $  $ O(\\sqrt{n}) $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXT = 50000;\nconst int MAXN = 50000;\nconst int MAXK = 50000;\n\nbool isNotPrime[MAXN + 1];\nint mu[MAXN + 1], s[MAXN + 1], primes[MAXN + 1], cnt;\ninline void getPrimes() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tmu[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t\tmu[i] = -1;\n\t\t}\n\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tint t = i * primes[j];\n\t\t\tif (t > MAXN) break;\n\t\t\tisNotPrime[t] = true;\n\t\t\tif (i % primes[j] == 0) {\n\t\t\t\tmu[t] = 0;\n\t\t\t\tbreak;\n\t\t\t} else mu[t] = -mu[i];\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= MAXN; i++) s[i] = s[i - 1] + mu[i];\n}\n\ninline int gcd(const int a, const int b) { return !b ? a : gcd(b, a % b); }\n\ninline int solve(int n, int m, const int k) {\n\tif (n > m) std::swap(n, m);\n\tn /= k, m /= k;\n\tint ans = 0;\n\tfor (int l = 1, r; l <= n; l = r + 1) {\n\t\tr = std::min(n / (n / l), m / (m / l));\n\t\tans += (s[r] - s[l - 1]) * ((n / l) * (m / l));\n\t}\n\n\treturn ans;\n\n\t/*int ans = 0;\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) if (gcd(i, j) == k) ans++;\n\treturn ans;*/\n\n\t/*int ans = 0;\n\tfor (int d = 1; d <= (n / k); d++) {\n\t\tans += mu[d] * (n / (k * d)) * (m / (k * d));\n\t}*/\n\t// printf(\"solve(%d, %d, %d) = %d\\n\", n, m, k, ans);\n\treturn ans;\n}\n\ninline int solve(const int a, const int b, const int c, const int d, const int k) {\n\treturn solve(b, d, k) - solve(a - 1, d, k) - solve(b, c - 1, k) + solve(a - 1, c - 1, k);\n}\n\nint main() {\n\tgetPrimes();\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint a, b, c, d, k;\n\t\tscanf(\"%d %d %d %d %d\", &a, &b, &c, &d, &k);\n\t\tprintf(\"%d\\n\", solve(a, b, c, d, k));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"haoi2011-problemb","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cok0116c2xl16ozicb9"},{"title":"HAOI2008 -  + DP","date":"2016-11-13T03:31:00.000Z","_content":"\n $ n $  $ i $  $ L_i $$ n $  $ n - 1 $  $ m $  $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 1044](http://www.lydsy.com/JudgeOnline/problem.php?id=1044)\n\n### \n $ t $\n\n $ f(i, j) $  $ i $  $ j $  $ t $ \n\n $ s(i) $  $ i $ \n\n$$ f(i, j) = \\sum\\limits_{s(i) - s(k - 1) \\leq t} f(k - 1, j - 1)  $$\n\n $ k $  $ i $  $ j $ $ k $ \n\n $ f(i, j - 1) $  $ i $  $ k $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 1000;\nconst int MO = 10007;\n\nint n, m, a[MAXN + 1], s[MAXN + 1];\n\ninline bool check(int limit) {\n\tint k = m, s = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (s + a[i] > limit) k--, s = a[i];\n\t\telse s += a[i];\n\t}\n\treturn k >= 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m), m++;\n\n\tint max = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), max = std::max(max, a[i]);\n\tfor (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];\n\n\tint l = max, r = s[n];\n\twhile (r - l >= 5) {\n\t\tint mid = l + (r - l) / 2;\n\t\t// printf(\"[%d, %d, %d]\\n\", l, r, mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\n\tint ans;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (check(i)) {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%d \", ans);\n\n\tint tot = 0;\n\tstatic int f[MAXN + 1][2];\n\tfor (int i = 1; i <= n; i++) f[i][1] = s[i] <= ans ? 1 : 0;\n\tfor (int j = 2; j <= m; j++) {\n\t\tfor (int i = 1; i <= n; i++) (f[i][(j - 1) & 1] += f[i - 1][(j - 1) & 1]) %= MO;\n\t\tfor (int i = 1, k = j; i <= n; i++) {\n\t\t\tf[i][j & 1] = 0;\n\t\t\twhile (k <= i && s[i] - s[k - 1] > ans) k++;\n\t\t\tif (k <= i && s[i] - s[k - 1] <= ans) {\n\t\t\t\t// printf(\"f(%d, %d) += f([%d, %d], %d)\\n\", i, j, i - 1, k - 1, j - 1);\n\t\t\t\t(f[i][j & 1] += f[i - 1][(j - 1) & 1] - f[k - 2][(j - 1) & 1]) %= MO;\n\t\t\t}\n\n\t\t\t/*\n\t\t\tfor (int k = j; k <= i; k++) {\n\t\t\t\tif (s[i] - s[k - 1] <= ans) {\n\t\t\t\t\tf[i][j] += f[k - 1][j - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\n\t\t\t// printf(\"f(%d, %d) = %d\\n\", i, j, f[i][j]);\n\n\t\t\t// f[i][j] += f[i - 1][j];\n\t\t}\n\t\t(tot += f[n][j & 1]) %= MO;\n\t}\n\n\t// for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) printf(\"f(%d, %d) = %d\\n\", i, j, f[i][j]);\n\n\tprintf(\"%d\\n\", (tot + MO) % MO);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2008-stick.md","raw":"title: HAOI2008 -  + DP\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \n  - DP\npermalink: haoi2008-stick\ndate: 2016-11-13 11:31:00\n---\n\n $ n $  $ i $  $ L_i $$ n $  $ n - 1 $  $ m $  $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 1044](http://www.lydsy.com/JudgeOnline/problem.php?id=1044)\n\n### \n $ t $\n\n $ f(i, j) $  $ i $  $ j $  $ t $ \n\n $ s(i) $  $ i $ \n\n$$ f(i, j) = \\sum\\limits_{s(i) - s(k - 1) \\leq t} f(k - 1, j - 1)  $$\n\n $ k $  $ i $  $ j $ $ k $ \n\n $ f(i, j - 1) $  $ i $  $ k $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 1000;\nconst int MO = 10007;\n\nint n, m, a[MAXN + 1], s[MAXN + 1];\n\ninline bool check(int limit) {\n\tint k = m, s = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (s + a[i] > limit) k--, s = a[i];\n\t\telse s += a[i];\n\t}\n\treturn k >= 1;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m), m++;\n\n\tint max = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), max = std::max(max, a[i]);\n\tfor (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i];\n\n\tint l = max, r = s[n];\n\twhile (r - l >= 5) {\n\t\tint mid = l + (r - l) / 2;\n\t\t// printf(\"[%d, %d, %d]\\n\", l, r, mid);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid;\n\t}\n\n\tint ans;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (check(i)) {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%d \", ans);\n\n\tint tot = 0;\n\tstatic int f[MAXN + 1][2];\n\tfor (int i = 1; i <= n; i++) f[i][1] = s[i] <= ans ? 1 : 0;\n\tfor (int j = 2; j <= m; j++) {\n\t\tfor (int i = 1; i <= n; i++) (f[i][(j - 1) & 1] += f[i - 1][(j - 1) & 1]) %= MO;\n\t\tfor (int i = 1, k = j; i <= n; i++) {\n\t\t\tf[i][j & 1] = 0;\n\t\t\twhile (k <= i && s[i] - s[k - 1] > ans) k++;\n\t\t\tif (k <= i && s[i] - s[k - 1] <= ans) {\n\t\t\t\t// printf(\"f(%d, %d) += f([%d, %d], %d)\\n\", i, j, i - 1, k - 1, j - 1);\n\t\t\t\t(f[i][j & 1] += f[i - 1][(j - 1) & 1] - f[k - 2][(j - 1) & 1]) %= MO;\n\t\t\t}\n\n\t\t\t/*\n\t\t\tfor (int k = j; k <= i; k++) {\n\t\t\t\tif (s[i] - s[k - 1] <= ans) {\n\t\t\t\t\tf[i][j] += f[k - 1][j - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\n\t\t\t// printf(\"f(%d, %d) = %d\\n\", i, j, f[i][j]);\n\n\t\t\t// f[i][j] += f[i - 1][j];\n\t\t}\n\t\t(tot += f[n][j & 1]) %= MO;\n\t}\n\n\t// for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) printf(\"f(%d, %d) = %d\\n\", i, j, f[i][j]);\n\n\tprintf(\"%d\\n\", (tot + MO) % MO);\n\n\treturn 0;\n}\n```","slug":"haoi2008-stick","published":1,"updated":"2016-11-13T03:31:51.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cos011gc2xl4xw2ftu1"},{"title":"HAOI2008 - map + Splay","date":"2016-12-13T09:08:00.000Z","_content":"\n $ 10 $ \n\n<!-- more -->\n\n### \n[BZOJ 1056](http://www.lydsy.com/JudgeOnline/problem.php?id=1056)\n\n### \n Splay  `map`  Splay \n\n### \n```c++\n#include <cstdio>\n// #include <cassert>\n#include <climits>\n#include <vector>\n#include <map>\n#include <iostream>\n\nstruct Splay {\n\tstruct Node {\n\t\tNode *c[2], *fa, **root;\n\t\tconst std::map<std::string, Node *>::iterator it;\n\t\tstd::pair<int, int> x;\n\t\tint size;\n\n\t\tNode(Node **root, Node *fa, const std::pair<int, int> &x, const std::map<std::string, Node *>::iterator it) : fa(fa), root(root), it(it), x(x), size(0) {\n\t\t\tc[0] = c[1] = NULL;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = (c[0] ? c[0]->size : 0) + (c[1] ? c[1]->size : 0) + 1;\n\t\t}\n\n\t\tint relation() {\n\t\t\treturn this == fa->c[1];\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tNode *o = fa;\n\t\t\tint x = relation();\n\t\t\t\n\t\t\tif (o->fa) o->fa->c[o->relation()] = this;\n\t\t\tfa = o->fa;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->fa = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->fa = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!fa) *root = this;\n\t\t}\n\n\t\tNode *splay(Node *target = NULL) {\n\t\t\twhile (fa != target) {\n\t\t\t\tif (fa->fa == target) rotate();\n\t\t\t\telse if (relation() == fa->relation()) fa->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tNode *prev() {\n\t\t\tNode *v = splay()->c[0];\n\t\t\twhile (v->c[1]) v = v->c[1];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tNode *v = splay()->c[1];\n\t\t\twhile (v->c[0]) v = v->c[0];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn c[0] ? c[0]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay(const std::map<std::string, Node *>::iterator null) : root(NULL) {\n\t\tinsert(std::make_pair(INT_MIN, INT_MIN), null);\n\t\tinsert(std::make_pair(INT_MAX, INT_MAX), null);\n\t}\n\n\tNode *insert(const std::pair<int, int> &x, std::map<std::string, Node *>::iterator it) {\n\t\tNode **v = &root, *fa = NULL;\n\t\twhile (*v) {\n\t\t\tfa = *v;\n\t\t\tfa->size++;\n\t\t\tv = &fa->c[x > fa->x];\n\t\t}\n\t\t*v = new Node(&root, fa, x, it);\n\t\treturn (*v)->splay();\n\t}\n\n\tvoid erase(Node *v) {\n\t\tNode *l = v->prev(), *r = v->succ();\n\t\tr->splay();\n\t\tl->splay(r);\n\t\t// assert(v == l->c[1]);\n\t\tdelete v;\n\t\tl->c[1] = NULL;\n\t\tl->size--, r->size--;\n\t}\n\n\tNode *select(int k) {\n\t\tint x = k;\n\t\tNode *v = root;\n\t\twhile (v->rank() != x) {\n\t\t\tif (v->rank() > x) v = v->c[0];\n\t\t\telse x -= v->rank() + 1, v = v->c[1];\n\t\t}\n\t\treturn v->splay();\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *prev = select(l - 1), *succ = select(r + 1);\n\t\tsucc->splay();\n\t\tprev->splay(succ);\n\t\treturn prev->c[1];\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nstd::map<std::string, Splay::Node *> map;\nSplay splay(map.end());\n\nvoid dfs(Splay::Node *v, std::vector<const std::string *> &vec) {\n\tif (!v) return;\n\tdfs(v->c[0], vec);\n\tif (v->it != map.end()) vec.push_back(&v->it->first);\n\tdfs(v->c[1], vec);\n}\n\ninline int parseInt(std::string s) {\n\tint x = 0;\n\tfor (std::string::iterator it = s.begin(); it != s.end(); it++) x = x * 10 + (*it - '0');\n\treturn x;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\twhile (n--) {\n\t\tstd::string cmd;\n\t\tstd::cin >> cmd;\n\t\tif (cmd[0] == '+') {\n\t\t\tstd::string name = cmd.substr(1, cmd.length() - 1);\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tstd::map<std::string, Splay::Node *>::iterator it = map.find(name);\n\t\t\tif (it != map.end()) {\n\t\t\t\tsplay.erase(it->second);\n\t\t\t} else {\n\t\t\t\tit = map.insert(std::make_pair(name, static_cast<Splay::Node *>(NULL))).first;\n\t\t\t}\n\n\t\t\tit->second = splay.insert(std::make_pair(-x, -n), it);\n\t\t} else if (cmd[0] == '?') {\n\t\t\tstd::string arg = cmd.substr(1, cmd.length() - 1);\n\t\t\tif (arg[0] >= '0' && arg[0] <= '9') {\n\t\t\t\tint x = parseInt(arg);\n\t\t\t\tSplay::Node *v = splay.select(x, std::min(splay.size(), x + 10 - 1));\n\n\t\t\t\tstd::vector<const std::string *> vec;\n\t\t\t\tdfs(v, vec);\n\n\t\t\t\tfor (std::vector<const std::string *>::iterator it = vec.begin(); it != vec.end(); it++) std::cout << **it << (it == vec.end() - 1 ? '\\n' : ' ');\n\t\t\t} else {\n\t\t\t\tSplay::Node *v = map[arg];\n\t\t\t\tprintf(\"%d\\n\", v->splay()->rank());\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/haoi2008-rank.md","raw":"title: HAOI2008 - map + Splay\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - map\n  - Splay\n  - \npermalink: haoi2008-rank\ndate: 2016-12-13 17:08:00\n---\n\n $ 10 $ \n\n<!-- more -->\n\n### \n[BZOJ 1056](http://www.lydsy.com/JudgeOnline/problem.php?id=1056)\n\n### \n Splay  `map`  Splay \n\n### \n```c++\n#include <cstdio>\n// #include <cassert>\n#include <climits>\n#include <vector>\n#include <map>\n#include <iostream>\n\nstruct Splay {\n\tstruct Node {\n\t\tNode *c[2], *fa, **root;\n\t\tconst std::map<std::string, Node *>::iterator it;\n\t\tstd::pair<int, int> x;\n\t\tint size;\n\n\t\tNode(Node **root, Node *fa, const std::pair<int, int> &x, const std::map<std::string, Node *>::iterator it) : fa(fa), root(root), it(it), x(x), size(0) {\n\t\t\tc[0] = c[1] = NULL;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = (c[0] ? c[0]->size : 0) + (c[1] ? c[1]->size : 0) + 1;\n\t\t}\n\n\t\tint relation() {\n\t\t\treturn this == fa->c[1];\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tNode *o = fa;\n\t\t\tint x = relation();\n\t\t\t\n\t\t\tif (o->fa) o->fa->c[o->relation()] = this;\n\t\t\tfa = o->fa;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->fa = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->fa = this;\n\n\t\t\to->maintain(), maintain();\n\t\t\tif (!fa) *root = this;\n\t\t}\n\n\t\tNode *splay(Node *target = NULL) {\n\t\t\twhile (fa != target) {\n\t\t\t\tif (fa->fa == target) rotate();\n\t\t\t\telse if (relation() == fa->relation()) fa->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tNode *prev() {\n\t\t\tNode *v = splay()->c[0];\n\t\t\twhile (v->c[1]) v = v->c[1];\n\t\t\treturn v;\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tNode *v = splay()->c[1];\n\t\t\twhile (v->c[0]) v = v->c[0];\n\t\t\treturn v;\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn c[0] ? c[0]->size : 0;\n\t\t}\n\t} *root;\n\n\tSplay(const std::map<std::string, Node *>::iterator null) : root(NULL) {\n\t\tinsert(std::make_pair(INT_MIN, INT_MIN), null);\n\t\tinsert(std::make_pair(INT_MAX, INT_MAX), null);\n\t}\n\n\tNode *insert(const std::pair<int, int> &x, std::map<std::string, Node *>::iterator it) {\n\t\tNode **v = &root, *fa = NULL;\n\t\twhile (*v) {\n\t\t\tfa = *v;\n\t\t\tfa->size++;\n\t\t\tv = &fa->c[x > fa->x];\n\t\t}\n\t\t*v = new Node(&root, fa, x, it);\n\t\treturn (*v)->splay();\n\t}\n\n\tvoid erase(Node *v) {\n\t\tNode *l = v->prev(), *r = v->succ();\n\t\tr->splay();\n\t\tl->splay(r);\n\t\t// assert(v == l->c[1]);\n\t\tdelete v;\n\t\tl->c[1] = NULL;\n\t\tl->size--, r->size--;\n\t}\n\n\tNode *select(int k) {\n\t\tint x = k;\n\t\tNode *v = root;\n\t\twhile (v->rank() != x) {\n\t\t\tif (v->rank() > x) v = v->c[0];\n\t\t\telse x -= v->rank() + 1, v = v->c[1];\n\t\t}\n\t\treturn v->splay();\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *prev = select(l - 1), *succ = select(r + 1);\n\t\tsucc->splay();\n\t\tprev->splay(succ);\n\t\treturn prev->c[1];\n\t}\n\n\tint size() {\n\t\treturn root->size - 2;\n\t}\n};\n\nstd::map<std::string, Splay::Node *> map;\nSplay splay(map.end());\n\nvoid dfs(Splay::Node *v, std::vector<const std::string *> &vec) {\n\tif (!v) return;\n\tdfs(v->c[0], vec);\n\tif (v->it != map.end()) vec.push_back(&v->it->first);\n\tdfs(v->c[1], vec);\n}\n\ninline int parseInt(std::string s) {\n\tint x = 0;\n\tfor (std::string::iterator it = s.begin(); it != s.end(); it++) x = x * 10 + (*it - '0');\n\treturn x;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\twhile (n--) {\n\t\tstd::string cmd;\n\t\tstd::cin >> cmd;\n\t\tif (cmd[0] == '+') {\n\t\t\tstd::string name = cmd.substr(1, cmd.length() - 1);\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tstd::map<std::string, Splay::Node *>::iterator it = map.find(name);\n\t\t\tif (it != map.end()) {\n\t\t\t\tsplay.erase(it->second);\n\t\t\t} else {\n\t\t\t\tit = map.insert(std::make_pair(name, static_cast<Splay::Node *>(NULL))).first;\n\t\t\t}\n\n\t\t\tit->second = splay.insert(std::make_pair(-x, -n), it);\n\t\t} else if (cmd[0] == '?') {\n\t\t\tstd::string arg = cmd.substr(1, cmd.length() - 1);\n\t\t\tif (arg[0] >= '0' && arg[0] <= '9') {\n\t\t\t\tint x = parseInt(arg);\n\t\t\t\tSplay::Node *v = splay.select(x, std::min(splay.size(), x + 10 - 1));\n\n\t\t\t\tstd::vector<const std::string *> vec;\n\t\t\t\tdfs(v, vec);\n\n\t\t\t\tfor (std::vector<const std::string *>::iterator it = vec.begin(); it != vec.end(); it++) std::cout << **it << (it == vec.end() - 1 ? '\\n' : ' ');\n\t\t\t} else {\n\t\t\t\tSplay::Node *v = map[arg];\n\t\t\t\tprintf(\"%d\\n\", v->splay()->rank());\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n```","slug":"haoi2008-rank","published":1,"updated":"2016-12-13T09:08:05.081Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cox011mc2xlvejxcxpg"},{"title":"HAOI2008 -  DP","date":"2016-07-06T03:37:00.000Z","_content":"\n `WING`  `WING` \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1055](http://www.lydsy.com/JudgeOnline/problem.php?id=1055)\n\n### \n $ f(l, r) $  $ [l, r] $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 200;\nconst int K = 4;\n\nint n, a[MAXN];\nbool map[K][K][K];\n\ninline int id(const char ch) {\n\tswitch (ch) {\n\t\tcase 'W': return 0;\n\t\tcase 'I': return 1;\n\t\tcase 'N': return 2;\n\t\tcase 'G': return 3;\n\t\tdefault: return -1;\n\t}\n}\n\ninline char letter(const int x) {\n\treturn (\"WING\")[x];\n}\n\ninline void setMap(const int x, const int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tchar s[3];\n\t\tscanf(\"%s\", s);\n\t\tmap[id(s[0])][id(s[1])][x] = true;\n\t}\n}\n\ninline int dp(const int l, const int r) {\n\tstatic int mem[MAXN][MAXN];\n\tint &ans = mem[l][r];\n\tstatic bool calced[MAXN][MAXN];\n\tif (calced[l][r]) return ans;\n\tcalced[l][r] = true;\n\n\tif (l == r) return ans = 1 << a[l];\n\n\tfor (int i = l; i < r; i++) {\n\t\tconst int a = dp(l, i), b = dp(i + 1, r);\n\n\t\tfor (int i = 0; i < K; i++) if (a & (1 << i)) for (int j = 0; j < K; j++) if (b & (1 << j)) {\n\t\t\tfor (int k = 0; k < K; k++) if (map[i][j][k]) ans |= 1 << k;\n\t\t}\n\t}\n\n\t// printf(\"dp(%d, %d) = %d\\n\", l, r, ans);\n\treturn ans;\n}\n\nint main() {\n\tint cnt[K];\n\tfor (int i = 0; i < K; i++) scanf(\"%d\", &cnt[i]);\n\tfor (int i = 0; i < K; i++) setMap(i, cnt[i]);\n\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\n\tfor (int i = 0; i < n; i++) a[i] = id(s[i]);\n\n\tint res = dp(0, n - 1);\n\tbool flag = false;\n\tfor (int i = 0; i < K; i++) if (res & (1 << i)) putchar(letter(i)), flag = true;\n\n\tif (flag) putchar('\\n');\n\telse puts(\"The name is wrong!\");\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2008-name.md","raw":"title: HAOI2008 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - DP\n  -  DP\npermalink: haoi2008-name\ndate: 2016-07-06 11:37:00\n---\n\n `WING`  `WING` \n\n\n\n<!-- more -->\n\n### \n[BZOJ 1055](http://www.lydsy.com/JudgeOnline/problem.php?id=1055)\n\n### \n $ f(l, r) $  $ [l, r] $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 200;\nconst int K = 4;\n\nint n, a[MAXN];\nbool map[K][K][K];\n\ninline int id(const char ch) {\n\tswitch (ch) {\n\t\tcase 'W': return 0;\n\t\tcase 'I': return 1;\n\t\tcase 'N': return 2;\n\t\tcase 'G': return 3;\n\t\tdefault: return -1;\n\t}\n}\n\ninline char letter(const int x) {\n\treturn (\"WING\")[x];\n}\n\ninline void setMap(const int x, const int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tchar s[3];\n\t\tscanf(\"%s\", s);\n\t\tmap[id(s[0])][id(s[1])][x] = true;\n\t}\n}\n\ninline int dp(const int l, const int r) {\n\tstatic int mem[MAXN][MAXN];\n\tint &ans = mem[l][r];\n\tstatic bool calced[MAXN][MAXN];\n\tif (calced[l][r]) return ans;\n\tcalced[l][r] = true;\n\n\tif (l == r) return ans = 1 << a[l];\n\n\tfor (int i = l; i < r; i++) {\n\t\tconst int a = dp(l, i), b = dp(i + 1, r);\n\n\t\tfor (int i = 0; i < K; i++) if (a & (1 << i)) for (int j = 0; j < K; j++) if (b & (1 << j)) {\n\t\t\tfor (int k = 0; k < K; k++) if (map[i][j][k]) ans |= 1 << k;\n\t\t}\n\t}\n\n\t// printf(\"dp(%d, %d) = %d\\n\", l, r, ans);\n\treturn ans;\n}\n\nint main() {\n\tint cnt[K];\n\tfor (int i = 0; i < K; i++) scanf(\"%d\", &cnt[i]);\n\tfor (int i = 0; i < K; i++) setMap(i, cnt[i]);\n\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\n\tfor (int i = 0; i < n; i++) a[i] = id(s[i]);\n\n\tint res = dp(0, n - 1);\n\tbool flag = false;\n\tfor (int i = 0; i < K; i++) if (res & (1 << i)) putchar(letter(i)), flag = true;\n\n\tif (flag) putchar('\\n');\n\telse puts(\"The name is wrong!\");\n\n\treturn 0;\n}\n```\n","slug":"haoi2008-name","published":1,"updated":"2016-10-24T23:35:44.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cp3011tc2xlff8p9t24"},{"title":"HAOI2008 -  + BFS","date":"2016-12-13T09:01:00.000Z","_content":"\n $ 4 \\times 4 $ \n\n<!-- more -->\n\n### \n[BZOJ 1054](http://www.lydsy.com/JudgeOnline/problem.php?id=1054)\n\n### \n $ 16 $ BFS \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n\nconst int MAXN = 16;\n\ninline unsigned int read() {\n\tunsigned int res = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tchar s[4 + 1];\n\t\tscanf(\"%s\", s);\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tif (s[j] == '1') res |= (1 << (4 * i + j));\n\t\t}\n\t}\n\treturn res;\n}\n\ninline int bfs(unsigned int s, unsigned int t) {\n\tstatic int dist[1 << MAXN];\n\tfor (int i = 0; i < (1 << MAXN); i++) dist[i] = INT_MAX;\n\n\tstd::queue<unsigned int> q;\n\tdist[s] = 0;\n\tq.push(s);\n\n\twhile (!q.empty()) {\n\t\tunsigned int v = q.front();\n\t\tq.pop();\n\n\t\tif (v == t) return dist[v];\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tint a = 4 * i + j;\n\t\t\t\tunsigned int va = !!(v & (1 << a));\n\n\t\t\t\tif (i != 3) {\n\t\t\t\t\tint b = 4 * (i + 1) + j;\n\t\t\t\t\tunsigned int vb = !!(v & (1 << b));\n\t\t\t\t\tif (va != vb) {\n\t\t\t\t\t\tunsigned int u = v;\n\t\t\t\t\t\tif (vb) u |= (1 << a);\n\t\t\t\t\t\telse u &= ~(1 << a);\n\n\t\t\t\t\t\tif (va) u |= (1 << b);\n\t\t\t\t\t\telse u &= ~(1 << b);\n\n\t\t\t\t\t\tif (dist[u] > dist[v] + 1) {\n\t\t\t\t\t\t\tdist[u] = dist[v] + 1;\n\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j != 3) {\n\t\t\t\t\tint b = 4 * i + (j + 1);\n\t\t\t\t\tunsigned int vb = !!(v & (1 << b));\n\t\t\t\t\tif (va != vb) {\n\t\t\t\t\t\tunsigned int u = v;\n\t\t\t\t\t\tif (vb) u |= (1 << a);\n\t\t\t\t\t\telse u &= ~(1 << a);\n\n\t\t\t\t\t\tif (va) u |= (1 << b);\n\t\t\t\t\t\telse u &= ~(1 << b);\n\n\t\t\t\t\t\tif (dist[u] > dist[v] + 1) {\n\t\t\t\t\t\t\tdist[u] = dist[v] + 1;\n\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tunsigned int s = read(), t = read();\n\tprintf(\"%d\\n\", bfs(s, t));\n\treturn 0;\n}\n```\n","source":"_posts/haoi2008-move.md","raw":"title: HAOI2008 -  + BFS\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \n  - BFS\npermalink: haoi2008-move\ndate: 2016-12-13 17:01:00\n---\n\n $ 4 \\times 4 $ \n\n<!-- more -->\n\n### \n[BZOJ 1054](http://www.lydsy.com/JudgeOnline/problem.php?id=1054)\n\n### \n $ 16 $ BFS \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n\nconst int MAXN = 16;\n\ninline unsigned int read() {\n\tunsigned int res = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tchar s[4 + 1];\n\t\tscanf(\"%s\", s);\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tif (s[j] == '1') res |= (1 << (4 * i + j));\n\t\t}\n\t}\n\treturn res;\n}\n\ninline int bfs(unsigned int s, unsigned int t) {\n\tstatic int dist[1 << MAXN];\n\tfor (int i = 0; i < (1 << MAXN); i++) dist[i] = INT_MAX;\n\n\tstd::queue<unsigned int> q;\n\tdist[s] = 0;\n\tq.push(s);\n\n\twhile (!q.empty()) {\n\t\tunsigned int v = q.front();\n\t\tq.pop();\n\n\t\tif (v == t) return dist[v];\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tint a = 4 * i + j;\n\t\t\t\tunsigned int va = !!(v & (1 << a));\n\n\t\t\t\tif (i != 3) {\n\t\t\t\t\tint b = 4 * (i + 1) + j;\n\t\t\t\t\tunsigned int vb = !!(v & (1 << b));\n\t\t\t\t\tif (va != vb) {\n\t\t\t\t\t\tunsigned int u = v;\n\t\t\t\t\t\tif (vb) u |= (1 << a);\n\t\t\t\t\t\telse u &= ~(1 << a);\n\n\t\t\t\t\t\tif (va) u |= (1 << b);\n\t\t\t\t\t\telse u &= ~(1 << b);\n\n\t\t\t\t\t\tif (dist[u] > dist[v] + 1) {\n\t\t\t\t\t\t\tdist[u] = dist[v] + 1;\n\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j != 3) {\n\t\t\t\t\tint b = 4 * i + (j + 1);\n\t\t\t\t\tunsigned int vb = !!(v & (1 << b));\n\t\t\t\t\tif (va != vb) {\n\t\t\t\t\t\tunsigned int u = v;\n\t\t\t\t\t\tif (vb) u |= (1 << a);\n\t\t\t\t\t\telse u &= ~(1 << a);\n\n\t\t\t\t\t\tif (va) u |= (1 << b);\n\t\t\t\t\t\telse u &= ~(1 << b);\n\n\t\t\t\t\t\tif (dist[u] > dist[v] + 1) {\n\t\t\t\t\t\t\tdist[u] = dist[v] + 1;\n\t\t\t\t\t\t\tq.push(u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tunsigned int s = read(), t = read();\n\tprintf(\"%d\\n\", bfs(s, t));\n\treturn 0;\n}\n```\n","slug":"haoi2008-move","published":1,"updated":"2016-12-13T09:08:17.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cp8011zc2xlhd4h0stw"},{"title":"HAOI2008 -  DP + ","date":"2016-11-13T03:11:00.000Z","_content":"\n $ 4 $  $ c_1, c_2, c_3, c_4 $ $ n $  $ d_i $  $ c_i $  $ s_i $ \n\n<!-- more -->\n\n### \n[BZOJ 1042](http://www.lydsy.com/JudgeOnline/problem.php?id=1042)\n\n### \n $ c $  $ f(c) $\n\n $ s_i $    -  +  - \n\n $ i $    $ d_i + 1 $  $ i $  $ s - (d_i + 1) \\times c_i $  $ f(s - (d_i + 1) \\times c_i) $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\nconst int MAXM = 100000;\n\nint main() {\n\tint c[4 + 1], n;\n\tscanf(\"%d %d %d %d %d\", &c[1], &c[2], &c[3], &c[4], &n);\n\n\tstatic long long f[4 + 1][MAXM + 1];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= 4; i++) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < c[i]) f[i][j] = f[i - 1][j];\n\t\t\telse f[i][j] = f[i - 1][j] + f[i][j - c[i]];\n\t\t}\n\t}\n\n\twhile (n--) {\n\t\tint d[4 + 1], m;\n\t\tscanf(\"%d %d %d %d %d\", &d[1], &d[2], &d[3], &d[4], &m);\n\n\t\tlong long ans = f[4][m];\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tif (m - (d[i] + 1) * c[i] >= 0) ans -= f[4][m - (d[i] + 1) * c[i]];\n\t\t}\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tfor (int j = i + 1; j <= 4; j++) {\n\t\t\t\tif (m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] >= 0) ans += f[4][m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j]];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tfor (int j = i + 1; j <= 4; j++) {\n\t\t\t\tfor (int k = j + 1; k <= 4; k++) {\n\t\t\t\t\tif (m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] - (d[k] + 1) * c[k] >= 0) ans -= f[4][m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] - (d[k] + 1) * c[k]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (m - (d[1] + 1) * c[1] - (d[2] + 1) * c[2] - (d[3] + 1) * c[3] - (d[4] + 1) * c[4] >= 0) ans += f[4][m - (d[1] + 1) * c[1] - (d[2] + 1) * c[2] - (d[3] + 1) * c[3] - (d[4] + 1) * c[4]];\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/haoi2008-coins.md","raw":"title: HAOI2008 -  DP + \ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \n  - DP\n  -  DP\n  - \npermalink: haoi2008-coins\ndate: 2016-11-13 11:11:00\n---\n\n $ 4 $  $ c_1, c_2, c_3, c_4 $ $ n $  $ d_i $  $ c_i $  $ s_i $ \n\n<!-- more -->\n\n### \n[BZOJ 1042](http://www.lydsy.com/JudgeOnline/problem.php?id=1042)\n\n### \n $ c $  $ f(c) $\n\n $ s_i $    -  +  - \n\n $ i $    $ d_i + 1 $  $ i $  $ s - (d_i + 1) \\times c_i $  $ f(s - (d_i + 1) \\times c_i) $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000;\nconst int MAXM = 100000;\n\nint main() {\n\tint c[4 + 1], n;\n\tscanf(\"%d %d %d %d %d\", &c[1], &c[2], &c[3], &c[4], &n);\n\n\tstatic long long f[4 + 1][MAXM + 1];\n\tf[0][0] = 1;\n\tfor (int i = 1; i <= 4; i++) {\n\t\tfor (int j = 0; j <= MAXM; j++) {\n\t\t\tif (j < c[i]) f[i][j] = f[i - 1][j];\n\t\t\telse f[i][j] = f[i - 1][j] + f[i][j - c[i]];\n\t\t}\n\t}\n\n\twhile (n--) {\n\t\tint d[4 + 1], m;\n\t\tscanf(\"%d %d %d %d %d\", &d[1], &d[2], &d[3], &d[4], &m);\n\n\t\tlong long ans = f[4][m];\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tif (m - (d[i] + 1) * c[i] >= 0) ans -= f[4][m - (d[i] + 1) * c[i]];\n\t\t}\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tfor (int j = i + 1; j <= 4; j++) {\n\t\t\t\tif (m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] >= 0) ans += f[4][m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j]];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\tfor (int j = i + 1; j <= 4; j++) {\n\t\t\t\tfor (int k = j + 1; k <= 4; k++) {\n\t\t\t\t\tif (m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] - (d[k] + 1) * c[k] >= 0) ans -= f[4][m - (d[i] + 1) * c[i] - (d[j] + 1) * c[j] - (d[k] + 1) * c[k]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (m - (d[1] + 1) * c[1] - (d[2] + 1) * c[2] - (d[3] + 1) * c[3] - (d[4] + 1) * c[4] >= 0) ans += f[4][m - (d[1] + 1) * c[1] - (d[2] + 1) * c[2] - (d[3] + 1) * c[3] - (d[4] + 1) * c[4]];\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}\n```","slug":"haoi2008-coins","published":1,"updated":"2016-11-13T03:11:42.698Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cpe0125c2xl8n6yz5ql"},{"title":"HAOI2008 - ","date":"2016-11-13T02:56:00.000Z","_content":"\n $ x ^ 2 + y ^ 2 = r ^ 2 $\n\n<!-- more -->\n\n### \n[BZOJ 1041](http://www.lydsy.com/JudgeOnline/problem.php?id=1041)\n\n### \n$$\n\\begin{aligned}\nx ^ 2 + y ^ 2 &= r ^ 2 \\\\\ny ^ 2 &= r ^ 2 - x ^ 2 \\\\\ny ^ 2 &= (r + x) \\times (r - x)\n\\end{aligned}\n$$\n\n $ d = \\gcd(r + x, r - x) $$ a = \\frac{r - x}{d} $$ b = \\frac{r + x}{d} $ $ \\gcd(a, b) = 1 $\n\n$$\n\\begin{aligned}\ny ^ 2 &= (r + x) \\times (r - x) \\\\\n&= d ^ 2 \\times a \\times b\n\\end{aligned}\n$$\n\n$ d ^ 2 $  $ y ^ 2 $  $ a \\times b $  $ \\gcd(a, b) = 1 $ $ a $  $ b $ \n\n$$\n\\begin{aligned}\na + b &= \\frac{r - x}{d} + \\frac{r + x}{d} \\\\\na + b &= \\frac{2r}{d}\n\\end{aligned}\n$$\n\n $ \\{ a, b, d \\} $ $ a $  $ b $  $ d $  $ 2r $ \n\n $ d $ $ \\sqrt a $ $ b $ $ \\gcd(a, b) = 1 $ \n\n $ k $ $ 4k + 4 $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 2e9;\nconst double EPS = 1e-6;\n\nint main() {\n\tlong long r;\n\tscanf(\"%lld\", &r);\n\n\t// 2 * r = d * (a ^ 2 + b ^ 2)\n\tlong long cnt = 0;\n\tfor (long long i = 1; i * i <= r * 2; i++) {\n\t\tif (2 * r % i != 0) continue;\n\n\t\tlong long d = i;\n\t\tlong long t = 2 * r / i;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tfor (long long a = 1; a * a < t / 2; a++) {\n\t\t\t\tdouble b = sqrt(t - a * a);\n\t\t\t\tlong long _b = static_cast<long long>(b);\n\t\t\t\tif (fabs(b - _b) <= EPS && std::__gcd(a, _b) == 1) {\n\t\t\t\t\t// printf(\"d = %lld, a = %lld, b = %lld\\n\", d, a, _b);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (t != d) std::swap(t, d);\n\t\t\telse break;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", cnt * 4 + 4);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2008-cir.md","raw":"title: HAOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \npermalink: haoi2008-cir\ndate: 2016-11-13 10:56:00\n---\n\n $ x ^ 2 + y ^ 2 = r ^ 2 $\n\n<!-- more -->\n\n### \n[BZOJ 1041](http://www.lydsy.com/JudgeOnline/problem.php?id=1041)\n\n### \n$$\n\\begin{aligned}\nx ^ 2 + y ^ 2 &= r ^ 2 \\\\\ny ^ 2 &= r ^ 2 - x ^ 2 \\\\\ny ^ 2 &= (r + x) \\times (r - x)\n\\end{aligned}\n$$\n\n $ d = \\gcd(r + x, r - x) $$ a = \\frac{r - x}{d} $$ b = \\frac{r + x}{d} $ $ \\gcd(a, b) = 1 $\n\n$$\n\\begin{aligned}\ny ^ 2 &= (r + x) \\times (r - x) \\\\\n&= d ^ 2 \\times a \\times b\n\\end{aligned}\n$$\n\n$ d ^ 2 $  $ y ^ 2 $  $ a \\times b $  $ \\gcd(a, b) = 1 $ $ a $  $ b $ \n\n$$\n\\begin{aligned}\na + b &= \\frac{r - x}{d} + \\frac{r + x}{d} \\\\\na + b &= \\frac{2r}{d}\n\\end{aligned}\n$$\n\n $ \\{ a, b, d \\} $ $ a $  $ b $  $ d $  $ 2r $ \n\n $ d $ $ \\sqrt a $ $ b $ $ \\gcd(a, b) = 1 $ \n\n $ k $ $ 4k + 4 $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 2e9;\nconst double EPS = 1e-6;\n\nint main() {\n\tlong long r;\n\tscanf(\"%lld\", &r);\n\n\t// 2 * r = d * (a ^ 2 + b ^ 2)\n\tlong long cnt = 0;\n\tfor (long long i = 1; i * i <= r * 2; i++) {\n\t\tif (2 * r % i != 0) continue;\n\n\t\tlong long d = i;\n\t\tlong long t = 2 * r / i;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tfor (long long a = 1; a * a < t / 2; a++) {\n\t\t\t\tdouble b = sqrt(t - a * a);\n\t\t\t\tlong long _b = static_cast<long long>(b);\n\t\t\t\tif (fabs(b - _b) <= EPS && std::__gcd(a, _b) == 1) {\n\t\t\t\t\t// printf(\"d = %lld, a = %lld, b = %lld\\n\", d, a, _b);\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (t != d) std::swap(t, d);\n\t\t\telse break;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", cnt * 4 + 4);\n\n\treturn 0;\n}\n```","slug":"haoi2008-cir","published":1,"updated":"2016-11-13T02:56:51.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cpl012dc2xl1wt67ql5"},{"title":"HAOI2008 - ","date":"2016-11-13T03:45:00.000Z","_content":"\n $ n $  $ a_i $  $ 1 $\n\n<!-- more -->\n\n### \n[BZOJ 1045](http://www.lydsy.com/JudgeOnline/problem.php?id=1045)\n\n### \n $ v = \\frac{\\sum\\limits_{i = 1} ^ n a_i}{n} $$ x_1 $  $ i - 1 $  $ i $ \n\n$$\n\\begin{aligned}\nv &= a_i + x_i - x_{i - 1} \\\\\nx_{i + 1} &= x_i - v + a_i\n\\end{aligned}\n$$\n\n\n\n$$\n\\begin{aligned}\nx_2 &= x_1 - v + a_1 \\\\\nx_3 &= x_2 - v + a_2 \\\\\n    &= x_1 - v + a_1 - v + a_2 \\\\\nx_4 &= x_3 - v + a_3 \\\\\n    &= x_1 - v + a_1 - v + a_2 - v + a_3\n\\end{aligned}\n$$\n\n $ \\sum\\limits_{i = 1} ^ n | x_i | $\n\n $ c_0 = 0, c_i = c_{i - 1} + v - a_i $\n\n$$\n\\begin{aligned}\nx_1 &= x_1 - c_0 \\\\\nx_2 &= x_1 - c_1 \\\\\nx_3 &= x_1 - c_2 \\\\\nx_4 &= x_1 - c_3\n\\end{aligned}\n$$\n\n\n\n$$ \\sum\\limits_{i = 1} ^ n | x_1 - c_{i - 1} | $$\n\n $ c_i $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 1000000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic long long a[MAXN];\n\tlong long sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%lld\", &a[i]);\n\t\tsum += a[i];\n\t}\n\n\tlong long avg = sum / n;\n\tstatic long long c[MAXN];\n\tc[0] = 0;\n\tfor (int i = 1; i < n; i++) c[i] = c[i - 1] - a[i] + avg;\n\n\tstd::sort(c, c + n);\n\n\tlong long mid = c[n / 2], ans = 0;\n\tfor (int i = 0; i < n; i++) ans += llabs(c[i] - mid);\n\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2008-candy.md","raw":"title: HAOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \npermalink: haoi2008-candy\ndate: 2016-11-13 11:45:00\n---\n\n $ n $  $ a_i $  $ 1 $\n\n<!-- more -->\n\n### \n[BZOJ 1045](http://www.lydsy.com/JudgeOnline/problem.php?id=1045)\n\n### \n $ v = \\frac{\\sum\\limits_{i = 1} ^ n a_i}{n} $$ x_1 $  $ i - 1 $  $ i $ \n\n$$\n\\begin{aligned}\nv &= a_i + x_i - x_{i - 1} \\\\\nx_{i + 1} &= x_i - v + a_i\n\\end{aligned}\n$$\n\n\n\n$$\n\\begin{aligned}\nx_2 &= x_1 - v + a_1 \\\\\nx_3 &= x_2 - v + a_2 \\\\\n    &= x_1 - v + a_1 - v + a_2 \\\\\nx_4 &= x_3 - v + a_3 \\\\\n    &= x_1 - v + a_1 - v + a_2 - v + a_3\n\\end{aligned}\n$$\n\n $ \\sum\\limits_{i = 1} ^ n | x_i | $\n\n $ c_0 = 0, c_i = c_{i - 1} + v - a_i $\n\n$$\n\\begin{aligned}\nx_1 &= x_1 - c_0 \\\\\nx_2 &= x_1 - c_1 \\\\\nx_3 &= x_1 - c_2 \\\\\nx_4 &= x_1 - c_3\n\\end{aligned}\n$$\n\n\n\n$$ \\sum\\limits_{i = 1} ^ n | x_1 - c_{i - 1} | $$\n\n $ c_i $ \n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 1000000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic long long a[MAXN];\n\tlong long sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%lld\", &a[i]);\n\t\tsum += a[i];\n\t}\n\n\tlong long avg = sum / n;\n\tstatic long long c[MAXN];\n\tc[0] = 0;\n\tfor (int i = 1; i < n; i++) c[i] = c[i - 1] - a[i] + avg;\n\n\tstd::sort(c, c + n);\n\n\tlong long mid = c[n / 2], ans = 0;\n\tfor (int i = 0; i < n; i++) ans += llabs(c[i] - mid);\n\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"haoi2008-candy","published":1,"updated":"2016-11-13T07:24:37.454Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cpp012ic2xlrnikueyi"},{"title":"HAOI2007 - ","date":"2016-12-01T23:16:00.000Z","_content":"\n $ n \\times m $  $ k \\times k $ \n\n<!-- more -->\n\n### \n[BZOJ 1047](http://www.lydsy.com/JudgeOnline/problem.php?id=1047)\n\n### \n $ b(i, j) = \\max\\limits_{t = j - k + 1} ^ j a(i, t) $ $ k $  $ c(i, j) = \\max\\limits_{t = i - k + 1} ^ i b(t, j) $ $ k $  $ k $  $ k $  $ k \\times k $ \n\n $ k \\times k $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <functional>\n\nconst int MAXN = 1000;\n\nint n, m, k, a[MAXN + 1][MAXN + 1];\n\ntemplate <typename T>\ninline void workColumns(int a[MAXN + 1][MAXN + 1], int b[MAXN + 1][MAXN + 1], T comp) {\n\tstatic int q[MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tint *l = q, *r = q - 1;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\twhile (l <= r && j - *l >= k) l++;\n\t\t\twhile (l <= r && comp(a[i][j], a[i][*r])) r--;\n\t\t\t*++r = j;\n\t\t\tb[i][j] = a[i][*l];\n#ifdef DBG\n\t\t\tprintf(\"%d%c\", b[i][j], j == m ? '\\n' : ' ');\n#endif\n\t\t}\n\t}\n}\n\ntemplate <typename T>\ninline void workRows(int a[MAXN + 1][MAXN + 1], int b[MAXN + 1][MAXN + 1], T comp) {\n\tstatic int q[MAXN + 1];\n\tfor (int i = 1; i <= m; i++) {\n\t\tint *l = q, *r = q - 1;\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\twhile (l <= r && j - *l >= k) l++;\n\t\t\twhile (l <= r && comp(a[j][i], a[*r][i])) r--;\n\t\t\t*++r = j;\n\t\t\tb[j][i] = a[*l][i];\n\t\t}\n\t}\n#ifdef DBG\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) printf(\"%d%c\", b[i][j], j == m ? '\\n' : ' ');\n#endif\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tstatic int columnMax[MAXN + 1][MAXN + 1], rowMax[MAXN + 1][MAXN + 1];\n\tworkColumns(a, columnMax, std::greater<int>());\n\tworkRows(columnMax, rowMax, std::greater<int>());\n\n\tstatic int columnMin[MAXN + 1][MAXN + 1], rowMin[MAXN + 1][MAXN + 1];\n\tworkColumns(a, columnMin, std::less<int>());\n\tworkRows(columnMin, rowMin, std::less<int>());\n\n\tint ans = INT_MAX;\n\tfor (int i = k; i <= n; i++) for (int j = k; j <= m; j++) ans = std::min(ans, rowMax[i][j] - rowMin[i][j]);\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2007-square.md","raw":"title: HAOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \npermalink: haoi2007-square\ndate: 2016-12-02 07:16:00\n---\n\n $ n \\times m $  $ k \\times k $ \n\n<!-- more -->\n\n### \n[BZOJ 1047](http://www.lydsy.com/JudgeOnline/problem.php?id=1047)\n\n### \n $ b(i, j) = \\max\\limits_{t = j - k + 1} ^ j a(i, t) $ $ k $  $ c(i, j) = \\max\\limits_{t = i - k + 1} ^ i b(t, j) $ $ k $  $ k $  $ k $  $ k \\times k $ \n\n $ k \\times k $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <functional>\n\nconst int MAXN = 1000;\n\nint n, m, k, a[MAXN + 1][MAXN + 1];\n\ntemplate <typename T>\ninline void workColumns(int a[MAXN + 1][MAXN + 1], int b[MAXN + 1][MAXN + 1], T comp) {\n\tstatic int q[MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tint *l = q, *r = q - 1;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\twhile (l <= r && j - *l >= k) l++;\n\t\t\twhile (l <= r && comp(a[i][j], a[i][*r])) r--;\n\t\t\t*++r = j;\n\t\t\tb[i][j] = a[i][*l];\n#ifdef DBG\n\t\t\tprintf(\"%d%c\", b[i][j], j == m ? '\\n' : ' ');\n#endif\n\t\t}\n\t}\n}\n\ntemplate <typename T>\ninline void workRows(int a[MAXN + 1][MAXN + 1], int b[MAXN + 1][MAXN + 1], T comp) {\n\tstatic int q[MAXN + 1];\n\tfor (int i = 1; i <= m; i++) {\n\t\tint *l = q, *r = q - 1;\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\twhile (l <= r && j - *l >= k) l++;\n\t\t\twhile (l <= r && comp(a[j][i], a[*r][i])) r--;\n\t\t\t*++r = j;\n\t\t\tb[j][i] = a[*l][i];\n\t\t}\n\t}\n#ifdef DBG\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) printf(\"%d%c\", b[i][j], j == m ? '\\n' : ' ');\n#endif\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tstatic int columnMax[MAXN + 1][MAXN + 1], rowMax[MAXN + 1][MAXN + 1];\n\tworkColumns(a, columnMax, std::greater<int>());\n\tworkRows(columnMax, rowMax, std::greater<int>());\n\n\tstatic int columnMin[MAXN + 1][MAXN + 1], rowMin[MAXN + 1][MAXN + 1];\n\tworkColumns(a, columnMin, std::less<int>());\n\tworkRows(columnMin, rowMin, std::less<int>());\n\n\tint ans = INT_MAX;\n\tfor (int i = k; i <= n; i++) for (int j = k; j <= m; j++) ans = std::min(ans, rowMax[i][j] - rowMin[i][j]);\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"haoi2007-square","published":1,"updated":"2016-12-01T23:16:57.457Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cpw012nc2xltzkkizpe"},{"title":"HAOI2007 - ","date":"2016-12-04T23:52:00.000Z","_content":"\n $ n \\times m $  $ k - 1 $  $ k $  $ n $  $ n $\n\n<!-- more -->\n\n### \n[BZOJ 1048](http://www.lydsy.com/JudgeOnline/problem.php?id=1048)\n\n### \n $ s $ $ x_1 \\sim x_k $ $ S = \\sum\\limits_{i = 1} ^ k x_i $  $ x' = \\frac{S}{k} $\n\n$$\n\\begin{aligned}\ns ^ 2 &= \\frac{\\sum\\limits_{i = 1} ^ k (x_i - \\frac{S}{k}) ^ 2}{k} \\\\\n&= \\frac{\\sum\\limits_{i = 1} ^ k(x_i ^ 2 + (\\frac{S}{k}) ^ 2 + 2x_i\\frac{S}{k})}{k} \\\\\n&= \\sum\\limits_{i = 1} ^ k \\frac{x_i ^ 2}{k} + \\sum\\limits_{i = 1} ^ k \\frac{\\frac{S ^ 2}{k ^ 2}}{k} - 2(\\sum\\limits_{i = 1} ^ k x_i) \\frac{\\frac{S}{k}}{k} \\\\\n&= \\sum\\limits_{i = 1} ^ k \\frac{x_i ^ 2}{k} + \\frac{S ^ 2}{k^ 2} - 2 \\frac{(\\sum\\limits_{i = 1} ^ k x_i) S}{k ^ 2} \\\\\n&= \\sum\\limits_{i = 1} ^ k \\frac{x_i ^ 2}{k} - \\frac{S ^ 2}{k ^ 2} \\\\\n&= \\frac{k \\sum\\limits_{i = 1} ^ k x_i ^ 2 - S ^ 2}{k ^ 2}\n\\end{aligned}\n$$\n\n $ \\sum\\limits_{i = 1} ^ k x_i ^ 2 $\n\n$ f(i_1, j_1, i_2, j_2, k) $  $ (i_1, j_1) $ $ (i_2, j_2) $  $ k $ \n\n$ n $  $ m $  $ O(n ^ 4 k \\times nk) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10;\n\nint n, m, k, a[MAXN + 1][MAXN + 1], s[MAXN + 1][MAXN + 1];\n\ninline int sum(int i1, int j1, int i2, int j2) {\n\treturn s[i2][j2] - s[i1 - 1][j2] - s[i2][j1 - 1] + s[i1 - 1][j1 - 1];\n}\n\ninline void prepare() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tint sumLine = 0;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tsumLine += a[i][j];\n\t\t\ts[i][j] = s[i - 1][j] + sumLine;\n\t\t}\n\t}\n}\n\ntemplate <typename T> T sqr(T x) { return x * x; }\n\ninline int search(int i1, int j1, int i2, int j2, int cnt) {\n\tstatic int mem[MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1];\n\tstatic bool calced[MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1];\n\tint &ans = mem[i1][j1][i2][j2][cnt];\n\tif (calced[i1][j1][i2][j2][cnt]) return ans;\n\tcalced[i1][j1][i2][j2][cnt] = true;\n\n\tif (!cnt) {\n\t\treturn ans = sqr(sum(i1, j1, i2, j2));\n\t}\n\n\tans = INT_MAX;\n\n\tfor (int i = i1; i < i2; i++) {\n\t\tfor (int l = 0; l < cnt; l++) {\n\t\t\tint x1 = search(i + 1, j1, i2, j2, l);\n\t\t\tint x2 = search(i1, j1, i, j2, cnt - l - 1);\n\t\t\tif (x1 != INT_MAX && x2 != INT_MAX) ans = std::min(ans, x1 + x2);\n\t\t}\n\t}\n\n\tfor (int j = j1; j < j2; j++) {\n\t\tfor (int l = 0; l < cnt; l++) {\n\t\t\tint x1 = search(i1, j + 1, i2, j2, l);\n\t\t\tint x2 = search(i1, j1, i2, j, cnt - l - 1);\n\t\t\tif (x1 != INT_MAX && x2 != INT_MAX) ans = std::min(ans, x1 + x2);\n\t\t}\n\t}\n\n\t// printf(\"search(%d, %d, %d, %d, %d) = %d\\n\", i1, j1, i2, j2, cnt, ans);\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprepare();\n\n\tint ans = search(1, 1, n, m, k - 1);\n\n\t// printf(\"%d\\n\", ans);\n\tprintf(\"%.2lf\\n\", sqrt((ans * k - sqr(s[n][m])) / static_cast<double>(sqr(k))));\n\n\treturn 0;\n}\n```","source":"_posts/haoi2007-separation.md","raw":"title: HAOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - DP\n  - \n  - DFS\npermalink: haoi2007-separation\ndate: 2016-12-05 07:52:00\n---\n\n $ n \\times m $  $ k - 1 $  $ k $  $ n $  $ n $\n\n<!-- more -->\n\n### \n[BZOJ 1048](http://www.lydsy.com/JudgeOnline/problem.php?id=1048)\n\n### \n $ s $ $ x_1 \\sim x_k $ $ S = \\sum\\limits_{i = 1} ^ k x_i $  $ x' = \\frac{S}{k} $\n\n$$\n\\begin{aligned}\ns ^ 2 &= \\frac{\\sum\\limits_{i = 1} ^ k (x_i - \\frac{S}{k}) ^ 2}{k} \\\\\n&= \\frac{\\sum\\limits_{i = 1} ^ k(x_i ^ 2 + (\\frac{S}{k}) ^ 2 + 2x_i\\frac{S}{k})}{k} \\\\\n&= \\sum\\limits_{i = 1} ^ k \\frac{x_i ^ 2}{k} + \\sum\\limits_{i = 1} ^ k \\frac{\\frac{S ^ 2}{k ^ 2}}{k} - 2(\\sum\\limits_{i = 1} ^ k x_i) \\frac{\\frac{S}{k}}{k} \\\\\n&= \\sum\\limits_{i = 1} ^ k \\frac{x_i ^ 2}{k} + \\frac{S ^ 2}{k^ 2} - 2 \\frac{(\\sum\\limits_{i = 1} ^ k x_i) S}{k ^ 2} \\\\\n&= \\sum\\limits_{i = 1} ^ k \\frac{x_i ^ 2}{k} - \\frac{S ^ 2}{k ^ 2} \\\\\n&= \\frac{k \\sum\\limits_{i = 1} ^ k x_i ^ 2 - S ^ 2}{k ^ 2}\n\\end{aligned}\n$$\n\n $ \\sum\\limits_{i = 1} ^ k x_i ^ 2 $\n\n$ f(i_1, j_1, i_2, j_2, k) $  $ (i_1, j_1) $ $ (i_2, j_2) $  $ k $ \n\n$ n $  $ m $  $ O(n ^ 4 k \\times nk) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10;\n\nint n, m, k, a[MAXN + 1][MAXN + 1], s[MAXN + 1][MAXN + 1];\n\ninline int sum(int i1, int j1, int i2, int j2) {\n\treturn s[i2][j2] - s[i1 - 1][j2] - s[i2][j1 - 1] + s[i1 - 1][j1 - 1];\n}\n\ninline void prepare() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tint sumLine = 0;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tsumLine += a[i][j];\n\t\t\ts[i][j] = s[i - 1][j] + sumLine;\n\t\t}\n\t}\n}\n\ntemplate <typename T> T sqr(T x) { return x * x; }\n\ninline int search(int i1, int j1, int i2, int j2, int cnt) {\n\tstatic int mem[MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1];\n\tstatic bool calced[MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1][MAXN + 1];\n\tint &ans = mem[i1][j1][i2][j2][cnt];\n\tif (calced[i1][j1][i2][j2][cnt]) return ans;\n\tcalced[i1][j1][i2][j2][cnt] = true;\n\n\tif (!cnt) {\n\t\treturn ans = sqr(sum(i1, j1, i2, j2));\n\t}\n\n\tans = INT_MAX;\n\n\tfor (int i = i1; i < i2; i++) {\n\t\tfor (int l = 0; l < cnt; l++) {\n\t\t\tint x1 = search(i + 1, j1, i2, j2, l);\n\t\t\tint x2 = search(i1, j1, i, j2, cnt - l - 1);\n\t\t\tif (x1 != INT_MAX && x2 != INT_MAX) ans = std::min(ans, x1 + x2);\n\t\t}\n\t}\n\n\tfor (int j = j1; j < j2; j++) {\n\t\tfor (int l = 0; l < cnt; l++) {\n\t\t\tint x1 = search(i1, j + 1, i2, j2, l);\n\t\t\tint x2 = search(i1, j1, i2, j, cnt - l - 1);\n\t\t\tif (x1 != INT_MAX && x2 != INT_MAX) ans = std::min(ans, x1 + x2);\n\t\t}\n\t}\n\n\t// printf(\"search(%d, %d, %d, %d, %d) = %d\\n\", i1, j1, i2, j2, cnt, ans);\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprepare();\n\n\tint ans = search(1, 1, n, m, k - 1);\n\n\t// printf(\"%d\\n\", ans);\n\tprintf(\"%.2lf\\n\", sqrt((ans * k - sqr(s[n][m])) / static_cast<double>(sqr(k))));\n\n\treturn 0;\n}\n```","slug":"haoi2007-separation","published":1,"updated":"2016-12-04T23:52:39.695Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cq1012sc2xlrr6wbnho"},{"title":"HAOI2007 - DP + ","date":"2016-12-01T03:43:00.000Z","_content":"\n $ S = \\{ a_1, a_2, a_3, \\ldots , a_n \\} $ $ P = \\{ a_{x_1},a_{x_2}, a_{x_3}, \\ldots, a_{x_m} \\} $ $ x_1 < x_2 < \\ldots < x_m $  $ a_{x_1} < a_{x_2} < \\ldots < a_{x_m} $ $ P $  $ S $  $ P $ \n\n $ S $  $ i $  $ L_i $ ****\n\n<!-- more -->\n\n### \n[BZOJ 1046](http://www.lydsy.com/JudgeOnline/problem.php?id=1046)\n\n### \n $ f(i) $  $ i $ ****\n\n$$ f(i) = \\max\\limits_{j > i, a_j > a_i}\\{ f(j) \\} + 1 $$\n\n $ \\leq l $ $ l $  $ 1 $ $ l \\neq 0 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic int a[MAXN + 1];\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int f[MAXN + 1];\n\tfor (int i = n; i >= 1; i--) {\n\t\tf[i] = 1;\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (a[i] < a[j] && f[j] + 1 > f[i]) f[i] = f[j] + 1;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"f[%d] = %d\\n\", i, f[i]);\n#endif\n\t}\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\n\t\tstatic int tmp[MAXN + 1];\n\t\tint cnt = 0;\n\n\t\tint last = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (f[i] >= l && a[i] > last) {\n\t\t\t\tl--;\n\t\t\t\tlast = a[i];\n\t\t\t\ttmp[++cnt] = a[i];\n\t\t\t}\n\t\t\tif (!l) break;\n\t\t}\n\n\t\tif (l) puts(\"Impossible\");\n\t\telse for (int i = 1; i <= cnt; i++) printf(\"%d%c\", tmp[i], i == cnt ? '\\n' : ' ');\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2007-lis.md","raw":"title: HAOI2007 - DP + \ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - DP\n  - \npermalink: haoi2007-lis\ndate: 2016-12-01 11:43:00\n---\n\n $ S = \\{ a_1, a_2, a_3, \\ldots , a_n \\} $ $ P = \\{ a_{x_1},a_{x_2}, a_{x_3}, \\ldots, a_{x_m} \\} $ $ x_1 < x_2 < \\ldots < x_m $  $ a_{x_1} < a_{x_2} < \\ldots < a_{x_m} $ $ P $  $ S $  $ P $ \n\n $ S $  $ i $  $ L_i $ ****\n\n<!-- more -->\n\n### \n[BZOJ 1046](http://www.lydsy.com/JudgeOnline/problem.php?id=1046)\n\n### \n $ f(i) $  $ i $ ****\n\n$$ f(i) = \\max\\limits_{j > i, a_j > a_i}\\{ f(j) \\} + 1 $$\n\n $ \\leq l $ $ l $  $ 1 $ $ l \\neq 0 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 10000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tstatic int a[MAXN + 1];\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int f[MAXN + 1];\n\tfor (int i = n; i >= 1; i--) {\n\t\tf[i] = 1;\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (a[i] < a[j] && f[j] + 1 > f[i]) f[i] = f[j] + 1;\n\t\t}\n#ifdef DBG\n\t\tprintf(\"f[%d] = %d\\n\", i, f[i]);\n#endif\n\t}\n\n\tint m;\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\n\t\tstatic int tmp[MAXN + 1];\n\t\tint cnt = 0;\n\n\t\tint last = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (f[i] >= l && a[i] > last) {\n\t\t\t\tl--;\n\t\t\t\tlast = a[i];\n\t\t\t\ttmp[++cnt] = a[i];\n\t\t\t}\n\t\t\tif (!l) break;\n\t\t}\n\n\t\tif (l) puts(\"Impossible\");\n\t\telse for (int i = 1; i <= cnt; i++) printf(\"%d%c\", tmp[i], i == cnt ? '\\n' : ' ');\n\t}\n\n\treturn 0;\n}\n```\n","slug":"haoi2007-lis","published":1,"updated":"2016-12-01T08:25:25.224Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cq6012zc2xl9xz9zejh"},{"title":"HAOI2007 -  + ","date":"2016-12-13T08:37:00.000Z","_content":"\n $ L \\times L $ \n\n<!-- more -->\n\n### \n[BZOJ 1052](http://www.lydsy.com/JudgeOnline/problem.php?id=1052)\n\n### \n\n\n\n\n\n\n $ O(4 \\times 4 \\times n \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 20000;\n\nstruct Point {\n\tint x, y;\n\tbool covered[2];\n} a[MAXN + 1];\n\nstruct Rectangle {\n\tint x1, y1, x2, y2;\n};\n\nint n;\n\ninline Rectangle getBound() {\n\tRectangle rect;\n\trect.x1 = rect.y1 = INT_MAX, rect.x2 = rect.y2 = INT_MIN;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i].covered[0] || a[i].covered[1]) continue;\n\t\trect.x1 = std::min(rect.x1, a[i].x);\n\t\trect.y1 = std::min(rect.y1, a[i].y);\n\t\trect.x2 = std::max(rect.x2, a[i].x);\n\t\trect.y2 = std::max(rect.y2, a[i].y);\n\t}\n\treturn rect;\n}\n\ninline void cover(int x, int y, int len, int index, bool flag) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i].x >= x && a[i].x <= x + len && a[i].y >= y && a[i].y <= y + len) {\n\t\t\ta[i].covered[index] = flag;\n\t\t}\n\t}\n}\n\ninline void cover(Rectangle rect, int limit, int corner, int index, bool flag) {\n\tif (corner == 1) cover(rect.x1, rect.y1, limit, index, flag);\n\telse if (corner == 2) cover(rect.x2 - limit, rect.y1, limit, index, flag);\n\telse if (corner == 3) cover(rect.x2 - limit, rect.y2 - limit, limit, index, flag);\n\telse cover(rect.x1, rect.y2 - limit, limit, index, flag);\n}\n\ninline bool check(int limit) {\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].covered[0] = a[i].covered[1] = false;\n\t}\n\n\tRectangle rect1 = getBound();\n\tfor (int i = 1; i <= 4; i++) {\n\t\tcover(rect1, limit, i, 0, true);\n\n\t\tRectangle rect2 = getBound();\n\t\tfor (int j = 1; j <= 4; j++) {\n\t\t\tcover(rect2, limit, j, 1, true);\n\n\t\t\tRectangle rect3 = getBound();\n\t\t\tif (std::max(rect3.x2 - rect3.x1, rect3.y2 - rect3.y1) <= limit) return true;\n\n\t\t\tcover(rect2, limit, j, 1, false);\n\t\t}\n\n\t\tcover(rect1, limit, i, 0, false);\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d %d\", &a[i].x, &a[i].y);\n\t}\n\n\tRectangle rect = getBound();\n\n\tint l = 0, r = std::max(rect.x2 - rect.x1, rect.y2 - rect.y1);\n\twhile (l < r) {\n\t\tint mid = l + (r - l) / 2;\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\tprintf(\"%d\\n\", l);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2007-cover.md","raw":"title: HAOI2007 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \n  - \npermalink: haoi2007-cover\ndate: 2016-12-13 16:37:00\n---\n\n $ L \\times L $ \n\n<!-- more -->\n\n### \n[BZOJ 1052](http://www.lydsy.com/JudgeOnline/problem.php?id=1052)\n\n### \n\n\n\n\n\n\n $ O(4 \\times 4 \\times n \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 20000;\n\nstruct Point {\n\tint x, y;\n\tbool covered[2];\n} a[MAXN + 1];\n\nstruct Rectangle {\n\tint x1, y1, x2, y2;\n};\n\nint n;\n\ninline Rectangle getBound() {\n\tRectangle rect;\n\trect.x1 = rect.y1 = INT_MAX, rect.x2 = rect.y2 = INT_MIN;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i].covered[0] || a[i].covered[1]) continue;\n\t\trect.x1 = std::min(rect.x1, a[i].x);\n\t\trect.y1 = std::min(rect.y1, a[i].y);\n\t\trect.x2 = std::max(rect.x2, a[i].x);\n\t\trect.y2 = std::max(rect.y2, a[i].y);\n\t}\n\treturn rect;\n}\n\ninline void cover(int x, int y, int len, int index, bool flag) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i].x >= x && a[i].x <= x + len && a[i].y >= y && a[i].y <= y + len) {\n\t\t\ta[i].covered[index] = flag;\n\t\t}\n\t}\n}\n\ninline void cover(Rectangle rect, int limit, int corner, int index, bool flag) {\n\tif (corner == 1) cover(rect.x1, rect.y1, limit, index, flag);\n\telse if (corner == 2) cover(rect.x2 - limit, rect.y1, limit, index, flag);\n\telse if (corner == 3) cover(rect.x2 - limit, rect.y2 - limit, limit, index, flag);\n\telse cover(rect.x1, rect.y2 - limit, limit, index, flag);\n}\n\ninline bool check(int limit) {\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i].covered[0] = a[i].covered[1] = false;\n\t}\n\n\tRectangle rect1 = getBound();\n\tfor (int i = 1; i <= 4; i++) {\n\t\tcover(rect1, limit, i, 0, true);\n\n\t\tRectangle rect2 = getBound();\n\t\tfor (int j = 1; j <= 4; j++) {\n\t\t\tcover(rect2, limit, j, 1, true);\n\n\t\t\tRectangle rect3 = getBound();\n\t\t\tif (std::max(rect3.x2 - rect3.x1, rect3.y2 - rect3.y1) <= limit) return true;\n\n\t\t\tcover(rect2, limit, j, 1, false);\n\t\t}\n\n\t\tcover(rect1, limit, i, 0, false);\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d %d\", &a[i].x, &a[i].y);\n\t}\n\n\tRectangle rect = getBound();\n\n\tint l = 0, r = std::max(rect.x2 - rect.x1, rect.y2 - rect.y1);\n\twhile (l < r) {\n\t\tint mid = l + (r - l) / 2;\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\tprintf(\"%d\\n\", l);\n\n\treturn 0;\n}\n```","slug":"haoi2007-cover","published":1,"updated":"2016-12-13T08:37:24.905Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cqc0135c2xl7dqjqzy1"},{"title":"HAOI2007 - ","date":"2016-12-13T08:57:00.000Z","_content":"\n $ x $ $ g(x) $ $ g(1) = 1 $$ g(6) = 4 $ $ x $  $ i \\in (0, x) $  $ g(x) > g(i) $ $ x $ \n\n $ N $ $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1053](http://www.lydsy.com/JudgeOnline/problem.php?id=1053)\n\n### \n $ x $  $ [1, x] $  $ y < x $  $ y $  $ x $ \n\n $ 2 $ \n\n $ x $  $ x = 2 ^ {t_1} \\times 3 ^ {t_2} \\times \\ldots \\times p_k ^ {t_k} $ $ x $  $ g(x) = \\prod\\limits_{i = 1} ^ k t_i $ $ j $  $ p_j $  $ p_{j + 1} $  $ p_{j + 1} $  $ p_j $ $ p_{j + 2} \\sim p_k $ $ \\{ t_i \\} $  $ x $ \n\n $ 11 $ $ \\{ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 \\} $ $ 2 \\times 10 ^ 9 $\n\n\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 2e9;\n\nconst int PRIMES[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\nconst int PRIMES_CNT = 11;\n\nint n, cntAns;\nlong long ans;\n\ninline void search(int i, long long x, int cnt) {\n\tif (i == PRIMES_CNT) {\n\t\tif ((cnt == cntAns && x < ans) || (cnt > cntAns)) {\n\t\t\tans = x;\n\t\t\tcntAns = cnt;\n\t\t\t// printf(\"%lld\\n\", ans);\n\t\t}\n\t\treturn;\n\t}\n\n\tlong long t = 1;\n\tfor (int j = 0; x * t <= n; j++) {\n\t\tsearch(i + 1, x * t, cnt * (j + 1));\n\t\tt *= PRIMES[i];\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tsearch(0, 1, 1);\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2007-ant.md","raw":"title: HAOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \n  - \npermalink: haoi2007-ant\ndate: 2016-12-13 16:57:00\n---\n\n $ x $ $ g(x) $ $ g(1) = 1 $$ g(6) = 4 $ $ x $  $ i \\in (0, x) $  $ g(x) > g(i) $ $ x $ \n\n $ N $ $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1053](http://www.lydsy.com/JudgeOnline/problem.php?id=1053)\n\n### \n $ x $  $ [1, x] $  $ y < x $  $ y $  $ x $ \n\n $ 2 $ \n\n $ x $  $ x = 2 ^ {t_1} \\times 3 ^ {t_2} \\times \\ldots \\times p_k ^ {t_k} $ $ x $  $ g(x) = \\prod\\limits_{i = 1} ^ k t_i $ $ j $  $ p_j $  $ p_{j + 1} $  $ p_{j + 1} $  $ p_j $ $ p_{j + 2} \\sim p_k $ $ \\{ t_i \\} $  $ x $ \n\n $ 11 $ $ \\{ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 \\} $ $ 2 \\times 10 ^ 9 $\n\n\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 2e9;\n\nconst int PRIMES[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31 };\nconst int PRIMES_CNT = 11;\n\nint n, cntAns;\nlong long ans;\n\ninline void search(int i, long long x, int cnt) {\n\tif (i == PRIMES_CNT) {\n\t\tif ((cnt == cntAns && x < ans) || (cnt > cntAns)) {\n\t\t\tans = x;\n\t\t\tcntAns = cnt;\n\t\t\t// printf(\"%lld\\n\", ans);\n\t\t}\n\t\treturn;\n\t}\n\n\tlong long t = 1;\n\tfor (int j = 0; x * t <= n; j++) {\n\t\tsearch(i + 1, x * t, cnt * (j + 1));\n\t\tt *= PRIMES[i];\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tsearch(0, 1, 1);\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"haoi2007-ant","published":1,"updated":"2016-12-13T08:57:07.004Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cqi013bc2xl858kef5z"},{"title":"HAOI2006 - DP","date":"2016-12-07T00:35:00.000Z","_content":"\n $ n $  $ \\{ a_i \\} $\n\n<!-- more -->\n\n### \n[BZOJ 1049](http://www.lydsy.com/JudgeOnline/problem.php?id=1049)\n\n### \n $ a_0 = \\min\\limits_{i = 1} ^ n\\{ a_i \\} $ $ a_{n + 1} = \\max\\limits_{i = 1} ^ n\\{ a_i \\} $\n\n $ a_i $ $ k $  $ k $ $ a_i \\geq a_{i - k} + k $ $ f(i) $  $ i $  DP \n\n$$ f(i) = \\max\\limits_{j = 0} ^ {i - 1} \\{ f(j) + 1, a_i - a_j \\geq i - j \\} $$\n\n $ n - f(n + 1) + 1 $\n\n\n\n $ a_i $  $ i $ $ b_i = a_i - i $ $ \\{ b_i \\} $  $ \\{ a_i \\} $  $ b_i $  $ b_i $ \n\n $ \\mathrm{cost}(l, r) $ ** $ l $  $ r $ ** $ [l, r] $  $ g(i) $  $ i $  $ [1, i] $ \n\n$$ g(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ g(j) + \\mathrm{cost}(j, i), f(i) = f(j) + 1 \\} $$\n\n $ (i, j) $ $ k \\in (i, j) $  $ b_i \\leq b_k \\leq b_j $ $ k \\in (i, j) $ $ b_k > b_i $  $ b_k < b_j $\n\n![](haoi2006-sequence/1.svg)\n\n $ b_j $ $ b_i $\n\n![](haoi2006-sequence/2.svg)\n\n $ b_j $ $ b_i $  $ g(i) $\n\n $ O(n ^ 3) $\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <algorithm>\n\nconst int MAXN = 35000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN + 1];\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int b[MAXN + 2];\n\tfor (int i = 1; i <= n; i++) {\n\t\tb[i] = a[i] - i;\n\n\t\tb[0] = std::min(b[0], b[i]);\n\t\tb[n + 1] = std::max(b[n + 1], b[i]);\n\t}\n\n\tstatic int f[MAXN + 2];\n\tint maxLen = 1;\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (b[j] <= b[i] && f[j] + 1 > f[i]) {\n\t\t\t\tf[i] = f[j] + 1;\n\t\t\t\tmaxLen = std::max(maxLen, f[i]);\n\t\t\t}\n\t\t}\n#ifdef DBG\n\t\tprintf(\"b[%d] = %d, f[%d] = %d\\n\", i, b[i], i, f[i]);\n#endif\n\t}\n\n\tprintf(\"%d\\n\", n - f[n + 1] + 1);\n\n\tstatic int g[MAXN + 2];\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tg[i] = INT_MAX;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (b[j] <= b[i] && f[j] + 1 == f[i]) {\n\t\t\t\tint w = 0;\n\t\t\t\tfor (int k = i - 1; k > j; k--) w += abs(b[k] - b[j]);\n\t\t\t\tg[i] = std::min(g[i], g[j] + w);\n\t\t\t\tfor (int k = i - 1; k > j; k--) {\n\t\t\t\t\tw -= abs(b[k] - b[j]);\n\t\t\t\t\tw += abs(b[k] - b[i]);\n\t\t\t\t\tg[i] = std::min(g[i], g[j] + w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(g[i] != INT_MAX);\n#ifdef DBG\n\t\tprintf(\"g[%d] = %d\\n\", i, g[i]);\n#endif\n\t}\n\n\tprintf(\"%d\\n\", g[n + 1]);\n\n\treturn 0;\n}\n```","source":"_posts/haoi2006-sequence.md","raw":"title: HAOI2006 - DP\ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - DP\npermalink: haoi2006-sequence\ndate: 2016-12-07 08:35:00\n---\n\n $ n $  $ \\{ a_i \\} $\n\n<!-- more -->\n\n### \n[BZOJ 1049](http://www.lydsy.com/JudgeOnline/problem.php?id=1049)\n\n### \n $ a_0 = \\min\\limits_{i = 1} ^ n\\{ a_i \\} $ $ a_{n + 1} = \\max\\limits_{i = 1} ^ n\\{ a_i \\} $\n\n $ a_i $ $ k $  $ k $ $ a_i \\geq a_{i - k} + k $ $ f(i) $  $ i $  DP \n\n$$ f(i) = \\max\\limits_{j = 0} ^ {i - 1} \\{ f(j) + 1, a_i - a_j \\geq i - j \\} $$\n\n $ n - f(n + 1) + 1 $\n\n\n\n $ a_i $  $ i $ $ b_i = a_i - i $ $ \\{ b_i \\} $  $ \\{ a_i \\} $  $ b_i $  $ b_i $ \n\n $ \\mathrm{cost}(l, r) $ ** $ l $  $ r $ ** $ [l, r] $  $ g(i) $  $ i $  $ [1, i] $ \n\n$$ g(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ g(j) + \\mathrm{cost}(j, i), f(i) = f(j) + 1 \\} $$\n\n $ (i, j) $ $ k \\in (i, j) $  $ b_i \\leq b_k \\leq b_j $ $ k \\in (i, j) $ $ b_k > b_i $  $ b_k < b_j $\n\n![](haoi2006-sequence/1.svg)\n\n $ b_j $ $ b_i $\n\n![](haoi2006-sequence/2.svg)\n\n $ b_j $ $ b_i $  $ g(i) $\n\n $ O(n ^ 3) $\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <algorithm>\n\nconst int MAXN = 35000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN + 1];\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int b[MAXN + 2];\n\tfor (int i = 1; i <= n; i++) {\n\t\tb[i] = a[i] - i;\n\n\t\tb[0] = std::min(b[0], b[i]);\n\t\tb[n + 1] = std::max(b[n + 1], b[i]);\n\t}\n\n\tstatic int f[MAXN + 2];\n\tint maxLen = 1;\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (b[j] <= b[i] && f[j] + 1 > f[i]) {\n\t\t\t\tf[i] = f[j] + 1;\n\t\t\t\tmaxLen = std::max(maxLen, f[i]);\n\t\t\t}\n\t\t}\n#ifdef DBG\n\t\tprintf(\"b[%d] = %d, f[%d] = %d\\n\", i, b[i], i, f[i]);\n#endif\n\t}\n\n\tprintf(\"%d\\n\", n - f[n + 1] + 1);\n\n\tstatic int g[MAXN + 2];\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tg[i] = INT_MAX;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (b[j] <= b[i] && f[j] + 1 == f[i]) {\n\t\t\t\tint w = 0;\n\t\t\t\tfor (int k = i - 1; k > j; k--) w += abs(b[k] - b[j]);\n\t\t\t\tg[i] = std::min(g[i], g[j] + w);\n\t\t\t\tfor (int k = i - 1; k > j; k--) {\n\t\t\t\t\tw -= abs(b[k] - b[j]);\n\t\t\t\t\tw += abs(b[k] - b[i]);\n\t\t\t\t\tg[i] = std::min(g[i], g[j] + w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(g[i] != INT_MAX);\n#ifdef DBG\n\t\tprintf(\"g[%d] = %d\\n\", i, g[i]);\n#endif\n\t}\n\n\tprintf(\"%d\\n\", g[n + 1]);\n\n\treturn 0;\n}\n```","slug":"haoi2006-sequence","published":1,"updated":"2016-12-07T00:36:12.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cqn013hc2xlvdz4s7k4"},{"title":"HAOI2006 - ","date":"2016-03-04T13:28:17.000Z","_content":"\n $ N $  $ M $  $ (A,B) $ $ A $  $ B $   $ A $  $ B $ $ B $  $ C $  $ A $  $ C $ \n\n<!-- more -->\n\n### \n[BZOJ 1051](http://www.lydsy.com/JudgeOnline/problem.php?id=1051)\n\n### \n\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 10000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) {\n\t\t\t\t\ts.push(e->to);\n\t\t\t\t\te->to->pushed = true;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t} else if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\tConnected *popular = contract(count);\n\n\tif (!popular) puts(\"-1\");\n\telse printf(\"%d\\n\", popular->size);\n\n\treturn 0;\n}\n```\n","source":"_posts/haoi2006-cow.md","raw":"title: HAOI2006 - \ncategories: OI\ntags: \n  - BZOJ\n  - HAOI\n  - \n  - Tarjan\n  - \npermalink: haoi2006-cow\ndate: 2016-03-04 21:28:17\n---\n\n $ N $  $ M $  $ (A,B) $ $ A $  $ B $   $ A $  $ B $ $ B $  $ C $  $ A $  $ C $ \n\n<!-- more -->\n\n### \n[BZOJ 1051](http://www.lydsy.com/JudgeOnline/problem.php?id=1051)\n\n### \n\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 10000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) {\n\t\t\t\t\ts.push(e->to);\n\t\t\t\t\te->to->pushed = true;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t} else if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\tConnected *popular = contract(count);\n\n\tif (!popular) puts(\"-1\");\n\telse printf(\"%d\\n\", popular->size);\n\n\treturn 0;\n}\n```\n","slug":"haoi2006-cow","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cqx013mc2xlnvvv4hr8"},{"title":"GDB ","id":"41","updated":"2016-02-05T02:59:41.000Z","date":"2016-02-05T02:58:07.000Z","_content":"\nGDBGNU Debugger GNU  UNIXLinux  Windows  CC++Pascal \n\n<!-- more -->\n\n### \n#### Linux\n Ubuntu  `apt`  GDB\n```bash\nsudo apt-get install gdb\n```\nNOI Linux  GDB\n\n RHEL/Fedora/Archlinux  GDB\n```bash\nsudo yum install gdb  # RHEL\nsudo dnf install gdb  # Fedora\nsudo pacman -S gdb    # Archlinux\n```\n\n#### Windows\n Windows  Cygwin/MSYS2  GDB MinGW \n\nDev-C++  MinGW `bin`  `gdb.exe` `bin`  `PATH`  `cmd`  `gdb` \n\n### \n `gdb` Windows  GDB\n```bash\ngdb\n```\n GDB  `file` \n```bash\n(gdb) file test\n```\n GDB \n```bash\ngdb test\n```\n `test` \n\n GDB ** `-g` **\n```bash\ng++ test.cpp -o test -g\nfpc test.cpp -g\n```\nGDB \n```bash\nMenci@Menci-Laptop:~$ gdb\nGNU gdb (Ubuntu 7.10-1ubuntu2) 7.10\nCopyright (C) 2015 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\".\n(gdb) \n```\n\n### \n `run` `r`\n```bash\n(gdb) run\n```\n\n```bash\n[Inferior 1 (process 52800) exited with code 1]\n```\nRuntime ErrorRE\n```bash\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000000000400598 in main () at test.cpp:6\n6\t\taby[8999999999990] = 1;\n```\n `SIGSEGV` Segmentation fault `6` \n\n\n\n### \n `quit` `q`\n\n `q`  GDB\n```bash\n(gdb) q\nA debugging session is active.\n\n\tInferior 1 [process 52800] will be killed.\n\nQuit anyway? (y or n) \n```\n `y`  GDB\n\n### \n `break` `b`\n```bash\n(gdb) b 9\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n```bash\n(gdb) b main\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n`break` \n```cpp\n#include <cstdio>\n\nint main() {\n\tint a;\n\tscanf(\"%d\", &a);\n\tprintf(\"%dn\", a);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6 if a == 528\n```\n `r`  `528` \n\nPascal  `==`  `=`\n\n### \n `continue` `c`\n\n********   \n\n `step` `s`\n```cpp\nint foo() {\n\treturn 2333;\n}\n\nint main() {\n\tfoo();\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) s\nfoo () at test.cpp:2\n2\t\treturn 2333;\n```\n Pascal \n```pascal\nProgram Test;\nFunction Foo(): Longint;\nBegin\n        Exit(2333);\nEnd;\nBegin\n        Foo();\nEnd.\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) s\nFOO () at test.pas:4\n4\t\tExit(2333);\n```\n `next` `n`****\n\n\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) n\n7\t\treturn 0;\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) n\n8\tEnd.\n```\n\n### \n GDB \n\n `print` `p`\n\n A + B \n```cpp\n#include <cstdio>\n\nint main() {\n\tint a, b;\n\tscanf(\"%d %d\", &a, &b);\n\tprintf(\"%dn\", a + b);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x400642: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n233 2333\n\nBreakpoint 1, main () at test.cpp:6\n6\t\tprintf(\"%dn\", a + b);\n(gdb) p a\n$1 = 233\n(gdb) p b\n$2 = 2333\n```\n `display` `disp`\n```cpp\n#include <cstdio>\n\nint doSomething(int x) {\n\treturn x * 10;\n}\n\nint main() {\n\tint n = 10;\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"i = %dn\", i);\n\t}\n\treturn 0;\n}\n```\n```bash\n(gdb) b 10\nBreakpoint 1 at 0x400603: file test.cpp, line 10.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n(gdb) disp doSomething(i)\n1: doSomething(i) = 0\n(gdb) n\ni = 0\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 0\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 10\n(gdb) n\ni = 1\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 10\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 20\n(gdb) n\ni = 2\n```\n GDB 7.0  `p`  STL \n\n### \n `backtrace` `bt`\n\n\n```cpp\nint fac(int x) {\n\tif (x == 0) return 1;\n\telse return x * fac(x - 1);\n}\n\nint main() {\n\tint x = fac(1000000000);\n\treturn 0;\n}\n```\n```bash\n(gdb) r\nStarting program: /home/Menci/test \n\nProgram received signal SIGSEGV, Segmentation fault.\n0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n3\t\telse return x * fac(x - 1);\n(gdb) bt\n#0  0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n#1  0x00000000004005aa in fac (x=999737954) at test.cpp:3\n#2  0x00000000004005aa in fac (x=999737955) at test.cpp:3\n#3  0x00000000004005aa in fac (x=999737956) at test.cpp:3\n#4  0x00000000004005aa in fac (x=999737957) at test.cpp:3\n#5  0x00000000004005aa in fac (x=999737958) at test.cpp:3\n```\n 272043 \n\n`bt` \n\n `frame` \n```cpp\nint a(int x) {\n\treturn x - 4;\n}\n\nint b(int x) {\n\treturn a(x * 3);\n}\n\nint c(int x) {\n\treturn b(x + 10);\n}\n\nint d(int x) {\n\treturn c(x / 2);\n}\n\nint main() {\n\tint x = d(4);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 2\nBreakpoint 1 at 0x400577: file test.cpp, line 2.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, a (x=36) at test.cpp:2\n2\t\treturn x - 4;\n(gdb) bt\n#0  a (x=36) at test.cpp:2\n#1  0x00000000004005a7 in b (x=12) at test.cpp:6\n#2  0x00000000004005c9 in c (x=2) at test.cpp:10\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n#4  0x0000000000400619 in main () at test.cpp:18\n(gdb) frame 3\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n14\t\treturn c(x / 2);\n(gdb) p x\n$1 = 4\n```\n`frame 3`  `d(x)`  `p x`  `4`\n\n`frame`  STL  STL \n\n### \n `list` `l`\n\n```bash\n(gdb) l 1\n1\tint a(int x) {\n2\t\treturn x - 4;\n3\t}\n4\t\n5\tint b(int x) {\n6\t\treturn a(x * 3);\n7\t}\n8\t\n9\tint c(int x) {\n10\t\treturn b(x + 10);\n```\n","source":"_posts/gnu-debugger.md","raw":"title: GDB \ncategories: OI\ntags: \n  - GDB\n  - \n  - C++\npermalink: gnu-debugger\nid: 41\nupdated: '2016-02-05 10:59:41'\ndate: 2016-02-05 10:58:07\n---\n\nGDBGNU Debugger GNU  UNIXLinux  Windows  CC++Pascal \n\n<!-- more -->\n\n### \n#### Linux\n Ubuntu  `apt`  GDB\n```bash\nsudo apt-get install gdb\n```\nNOI Linux  GDB\n\n RHEL/Fedora/Archlinux  GDB\n```bash\nsudo yum install gdb  # RHEL\nsudo dnf install gdb  # Fedora\nsudo pacman -S gdb    # Archlinux\n```\n\n#### Windows\n Windows  Cygwin/MSYS2  GDB MinGW \n\nDev-C++  MinGW `bin`  `gdb.exe` `bin`  `PATH`  `cmd`  `gdb` \n\n### \n `gdb` Windows  GDB\n```bash\ngdb\n```\n GDB  `file` \n```bash\n(gdb) file test\n```\n GDB \n```bash\ngdb test\n```\n `test` \n\n GDB ** `-g` **\n```bash\ng++ test.cpp -o test -g\nfpc test.cpp -g\n```\nGDB \n```bash\nMenci@Menci-Laptop:~$ gdb\nGNU gdb (Ubuntu 7.10-1ubuntu2) 7.10\nCopyright (C) 2015 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\".\n(gdb) \n```\n\n### \n `run` `r`\n```bash\n(gdb) run\n```\n\n```bash\n[Inferior 1 (process 52800) exited with code 1]\n```\nRuntime ErrorRE\n```bash\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000000000400598 in main () at test.cpp:6\n6\t\taby[8999999999990] = 1;\n```\n `SIGSEGV` Segmentation fault `6` \n\n\n\n### \n `quit` `q`\n\n `q`  GDB\n```bash\n(gdb) q\nA debugging session is active.\n\n\tInferior 1 [process 52800] will be killed.\n\nQuit anyway? (y or n) \n```\n `y`  GDB\n\n### \n `break` `b`\n```bash\n(gdb) b 9\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n```bash\n(gdb) b main\nBreakpoint 1 at 0x4004fa: file test.cpp, line 9.\n```\n`break` \n```cpp\n#include <cstdio>\n\nint main() {\n\tint a;\n\tscanf(\"%d\", &a);\n\tprintf(\"%dn\", a);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6 if a == 528\n```\n `r`  `528` \n\nPascal  `==`  `=`\n\n### \n `continue` `c`\n\n********   \n\n `step` `s`\n```cpp\nint foo() {\n\treturn 2333;\n}\n\nint main() {\n\tfoo();\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) s\nfoo () at test.cpp:2\n2\t\treturn 2333;\n```\n Pascal \n```pascal\nProgram Test;\nFunction Foo(): Longint;\nBegin\n        Exit(2333);\nEnd;\nBegin\n        Foo();\nEnd.\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) s\nFOO () at test.pas:4\n4\t\tExit(2333);\n```\n `next` `n`****\n\n\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x40058f: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:6\n6\t\tfoo();\n(gdb) n\n7\t\treturn 0;\n```\n```bash\n(gdb) b 7\nBreakpoint 1 at 0x4001c1: file test.pas, line 7.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.pas:7\n7\t\tFoo();\n(gdb) n\n8\tEnd.\n```\n\n### \n GDB \n\n `print` `p`\n\n A + B \n```cpp\n#include <cstdio>\n\nint main() {\n\tint a, b;\n\tscanf(\"%d %d\", &a, &b);\n\tprintf(\"%dn\", a + b);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 6\nBreakpoint 1 at 0x400642: file test.cpp, line 6.\n(gdb) r\nStarting program: /home/Menci/test \n233 2333\n\nBreakpoint 1, main () at test.cpp:6\n6\t\tprintf(\"%dn\", a + b);\n(gdb) p a\n$1 = 233\n(gdb) p b\n$2 = 2333\n```\n `display` `disp`\n```cpp\n#include <cstdio>\n\nint doSomething(int x) {\n\treturn x * 10;\n}\n\nint main() {\n\tint n = 10;\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"i = %dn\", i);\n\t}\n\treturn 0;\n}\n```\n```bash\n(gdb) b 10\nBreakpoint 1 at 0x400603: file test.cpp, line 10.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n(gdb) disp doSomething(i)\n1: doSomething(i) = 0\n(gdb) n\ni = 0\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 0\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 10\n(gdb) n\ni = 1\n9\t\tfor (int i = 0; i < n; i++) {\n1: doSomething(i) = 10\n(gdb) n\n\nBreakpoint 1, main () at test.cpp:10\n10\t\t\tprintf(\"i = %dn\", i);\n1: doSomething(i) = 20\n(gdb) n\ni = 2\n```\n GDB 7.0  `p`  STL \n\n### \n `backtrace` `bt`\n\n\n```cpp\nint fac(int x) {\n\tif (x == 0) return 1;\n\telse return x * fac(x - 1);\n}\n\nint main() {\n\tint x = fac(1000000000);\n\treturn 0;\n}\n```\n```bash\n(gdb) r\nStarting program: /home/Menci/test \n\nProgram received signal SIGSEGV, Segmentation fault.\n0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n3\t\telse return x * fac(x - 1);\n(gdb) bt\n#0  0x00000000004005a5 in fac (x=999737953) at test.cpp:3\n#1  0x00000000004005aa in fac (x=999737954) at test.cpp:3\n#2  0x00000000004005aa in fac (x=999737955) at test.cpp:3\n#3  0x00000000004005aa in fac (x=999737956) at test.cpp:3\n#4  0x00000000004005aa in fac (x=999737957) at test.cpp:3\n#5  0x00000000004005aa in fac (x=999737958) at test.cpp:3\n```\n 272043 \n\n`bt` \n\n `frame` \n```cpp\nint a(int x) {\n\treturn x - 4;\n}\n\nint b(int x) {\n\treturn a(x * 3);\n}\n\nint c(int x) {\n\treturn b(x + 10);\n}\n\nint d(int x) {\n\treturn c(x / 2);\n}\n\nint main() {\n\tint x = d(4);\n\treturn 0;\n}\n```\n```bash\n(gdb) b 2\nBreakpoint 1 at 0x400577: file test.cpp, line 2.\n(gdb) r\nStarting program: /home/Menci/test \n\nBreakpoint 1, a (x=36) at test.cpp:2\n2\t\treturn x - 4;\n(gdb) bt\n#0  a (x=36) at test.cpp:2\n#1  0x00000000004005a7 in b (x=12) at test.cpp:6\n#2  0x00000000004005c9 in c (x=2) at test.cpp:10\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n#4  0x0000000000400619 in main () at test.cpp:18\n(gdb) frame 3\n#3  0x00000000004005f5 in d (x=4) at test.cpp:14\n14\t\treturn c(x / 2);\n(gdb) p x\n$1 = 4\n```\n`frame 3`  `d(x)`  `p x`  `4`\n\n`frame`  STL  STL \n\n### \n `list` `l`\n\n```bash\n(gdb) l 1\n1\tint a(int x) {\n2\t\treturn x - 4;\n3\t}\n4\t\n5\tint b(int x) {\n6\t\treturn a(x * 3);\n7\t}\n8\t\n9\tint c(int x) {\n10\t\treturn b(x + 10);\n```\n","slug":"gnu-debugger","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cr3013tc2xlgml7050a"},{"title":"FJOI2007 - ","date":"2016-10-17T02:54:00.000Z","_content":"\n $ N $  $ N $ 2  2  $ N $  $ N $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1002](http://www.lydsy.com/JudgeOnline/problem.php?id=1002)\n\n### \n$ f(i) = 3f(i - 1) - f(i - 2) + 2 $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n\nconst int MAXN = 100;\n\nstruct BigInt {\n\tstd::vector<int> v;\n\n\tBigInt(const int n = 0) { *this = n; }\n\tBigInt(const std::string &s) { *this = s; }\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t}\n\n\tBigInt &operator=(const std::string &s) {\n\t\tv.resize(s.length());\n\t\tfor (size_t i = 0; i < s.length(); i++) v[i] = s[s.length() - i - 1] - '0';\n\t}\n\n\tvoid print() {\n\t\tfor (int i = v.size() - 1; i >= 0; i--) printf(\"%d\", v[i]);\n\t\tputchar('\\n');\n\t}\n};\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.clear();\n\tbool flag = false;\n\tfor (size_t i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint t = 0;\n\t\tif (i < a.v.size()) t += a.v[i];\n\t\tif (i < b.v.size()) t += b.v[i];\n\t\tif (flag) t++, flag = false;\n\t\tif (t >= 10) t -= 10, flag = true;\n\t\tres.v.push_back(t);\n\t}\n\tif (flag) res.v.push_back(1);\n\treturn res;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.clear();\n\tbool flag = false;\n\tfor (size_t i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint t = 0;\n\t\tif (i < a.v.size()) t += a.v[i];\n\t\tif (i < b.v.size()) t -= b.v[i];\n\t\tif (flag) t--, flag = false;\n\t\tif (t < 0) t += 10, flag = true;\n\t\tres.v.push_back(t);\n\t}\n\treturn res;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.resize(a.v.size() + b.v.size() + 1);\n\tfor (size_t i = 0; i < a.v.size(); i++) {\n\t\tfor (size_t j = 0; j < b.v.size(); j++) {\n\t\t\tres.v[i + j] += a.v[i] * b.v[j];\n\t\t\tres.v[i + j + 1] += res.v[i + j] / 10;\n\t\t\tres.v[i + j] %= 10;\n\t\t}\n\t}\n\twhile (res.v.size() > 1 && res.v.back() == 0) res.v.pop_back();\n\treturn res;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tBigInt f[MAXN + 1];\n\tf[1] = 1, f[2] = 5;\n\tfor (int i = 3; i <= n; i++) f[i] = f[i - 1] * 3 - f[i - 2] + 2;\n\tf[n].print();\n\treturn 0;\n}\n```\n","source":"_posts/fjoi2007-wheel.md","raw":"title: FJOI2007 - \ncategories: OI\ntags: \n  - BZOJ\n  - FJOI\n  - \npermalink: fjoi2007-wheel\ndate: 2016-10-17 10:54:00\n---\n\n $ N $  $ N $ 2  2  $ N $  $ N $  $ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1002](http://www.lydsy.com/JudgeOnline/problem.php?id=1002)\n\n### \n$ f(i) = 3f(i - 1) - f(i - 2) + 2 $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n\nconst int MAXN = 100;\n\nstruct BigInt {\n\tstd::vector<int> v;\n\n\tBigInt(const int n = 0) { *this = n; }\n\tBigInt(const std::string &s) { *this = s; }\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t}\n\n\tBigInt &operator=(const std::string &s) {\n\t\tv.resize(s.length());\n\t\tfor (size_t i = 0; i < s.length(); i++) v[i] = s[s.length() - i - 1] - '0';\n\t}\n\n\tvoid print() {\n\t\tfor (int i = v.size() - 1; i >= 0; i--) printf(\"%d\", v[i]);\n\t\tputchar('\\n');\n\t}\n};\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.clear();\n\tbool flag = false;\n\tfor (size_t i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint t = 0;\n\t\tif (i < a.v.size()) t += a.v[i];\n\t\tif (i < b.v.size()) t += b.v[i];\n\t\tif (flag) t++, flag = false;\n\t\tif (t >= 10) t -= 10, flag = true;\n\t\tres.v.push_back(t);\n\t}\n\tif (flag) res.v.push_back(1);\n\treturn res;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.clear();\n\tbool flag = false;\n\tfor (size_t i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n\t\tint t = 0;\n\t\tif (i < a.v.size()) t += a.v[i];\n\t\tif (i < b.v.size()) t -= b.v[i];\n\t\tif (flag) t--, flag = false;\n\t\tif (t < 0) t += 10, flag = true;\n\t\tres.v.push_back(t);\n\t}\n\treturn res;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt res;\n\tres.v.resize(a.v.size() + b.v.size() + 1);\n\tfor (size_t i = 0; i < a.v.size(); i++) {\n\t\tfor (size_t j = 0; j < b.v.size(); j++) {\n\t\t\tres.v[i + j] += a.v[i] * b.v[j];\n\t\t\tres.v[i + j + 1] += res.v[i + j] / 10;\n\t\t\tres.v[i + j] %= 10;\n\t\t}\n\t}\n\twhile (res.v.size() > 1 && res.v.back() == 0) res.v.pop_back();\n\treturn res;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tBigInt f[MAXN + 1];\n\tf[1] = 1, f[2] = 5;\n\tfor (int i = 3; i <= n; i++) f[i] = f[i - 1] * 3 - f[i - 2] + 2;\n\tf[n].print();\n\treturn 0;\n}\n```\n","slug":"fjoi2007-wheel","published":1,"updated":"2016-10-17T09:26:27.229Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cr90140c2xl3gt869k0"},{"title":"","date":"2016-06-17T13:38:00.000Z","_content":"\nFFT Number-Theoretic Transform\n\n<!-- more -->\n\n### \nFFT  $ \\omega_n ^ k = \\cos \\frac{2 \\pi}{n}k + i \\sin\\frac{2 \\pi}{n}k $\n\n1. $ \\omega_n ^ t (0 \\leq t \\leq n - 1) $ \n2. $ \\omega_{2n} ^ {2k} = \\omega_n ^ k $\n3. $ \\omega_n ^ { k + \\frac{n}{2} } = -\\omega_n ^ k $\n3.  $ k \\neq 0 $ $ 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} = 0 $\n\n $ p = qn + 1 $ $ n $  $ 2 $ **** $ g $  $ g ^ i(0 \\leq i \\leq p - 1) $ \n\n#### \n\n $ \\omega_n = g ^ q $ $ 1,\\ g ^ q,\\ g ^ {2q},\\ \\dots,\\ g ^ {(n - 1)q} $ ****\n\n#### \n\n $ \\omega_n = g ^ q $  $ \\omega_{2n} = g ^ { \\frac{q}{2} } $$ p = \\frac{q}{2} \\times 2n + 1 $ $ \\omega_{2n} ^ {2k} = g ^ {2k \\frac{q}{2} } = g ^ {kq} = \\omega_n ^ k $****\n\n#### \n\n\n\n$$ \\omega_n ^ n = g ^ {nq} = g ^ {p - 1} \\equiv 1 \\pmod p $$\n\n $ (\\omega_{n} ^ { \\frac{n}{2} }) ^ 2 = \\omega_n ^ n $ $ \\omega_n ^ { \\frac{n}{2} } \\equiv \\pm 1 \\pmod p $ $ \\omega_n ^ { \\frac{n}{2} } \\neq \\omega_n ^ 0 \\ $ $ \\omega_n ^ { \\frac{n}{2} } \\equiv -1 \\pmod p $ $ \\omega_n ^ { k + \\frac{n}{2} } = \\omega_n ^ k \\times \\omega_n ^ { \\frac{n}{2} } \\equiv -\\omega_n ^ k \\pmod p $****\n\n#### \n $ k \\neq 0 $ \n\n$$\n\\begin{aligned}\nS(\\omega_n ^ k) &= 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} \\\\\n\\omega_n ^ k S(\\omega_n ^ k) &= \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + (\\omega_n ^ k) ^ 3 + \\dots + (\\omega_n ^ k) ^ n \\\\\n\\omega_n ^ k S(\\omega_n ^ k) - S(\\omega_n ^ k) &= (\\omega_n ^ k) ^ n - 1 \\\\\nS(\\omega_n ^ k) &= \\frac{(\\omega_n ^ k) ^ n - 1}{\\omega_n ^ k - 1}\n\\end{aligned}\n$$\n\n****$ (\\omega_n ^ k) ^ n - 1 \\equiv 0 \\pmod p $ $ S(\\omega_n ^ k) \\equiv 0  \\pmod p $****\n\n### \n   $ g $ $ g $  $ p $ \n\n>  $ g $ $ g ^ k \\equiv 1 \\pmod p $  $ k $  $ p - 1 $ \n\n $ k $  $ p - 1 $  $ x $  $ xk > p - 1 > (x - 1)k $\n\n$$ g ^ {xk} \\equiv g ^ {p - 1} \\equiv 1 \\equiv g ^ {xk - (p - 1)} \\pmod p $$\n\n$ xk - (p - 1) < k $\n\n $ p - 1 $  $ q $ $ g ^ q \\not\\equiv 1 \\pmod p $ \n\n```c++\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n```\n\n### \n\n\n $ \\div n $  $ \\times n ^ {-1} $\n\n```c++\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n\ninline void exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long a, const long long p) {\n\tlong long g, x, y;\n\texgcd(a, p, g, x, y);\n\treturn (x + p) % p;\n}\n\nstruct NumberTheoreticTransform {\n\tlong long omega[MAXM_EXTENDED], omegaInverse[MAXM_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tlong long g = root(MOD), x = pow(g, (MOD - 1) / n, MOD);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tomega[i] = (i == 0) ? 1 : omega[i - 1] * x % MOD;\n\t\t\tomegaInverse[i] = inv(omega[i], MOD);\n\t\t}\n\t}\n\n\tvoid transform(long long *a, const int n, const long long *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t}\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tint m = l / 2;\n\t\t\tfor (long long *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tlong long t = omega[n / l * i] * p[i + m] % MOD;\n\t\t\t\t\tp[i + m] = (p[i] - t + MOD) % MOD;\n\t\t\t\t\t(p[i] += t) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(long long *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(long long *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tlong long x = inv(n, MOD);\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * x % MOD;\n\t}\n} ntt;\n```\n","source":"_posts/fft-to-ntt.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - \n  - \npermalink: fft-to-ntt\ndate: 2016-06-17 21:38:00\n---\n\nFFT Number-Theoretic Transform\n\n<!-- more -->\n\n### \nFFT  $ \\omega_n ^ k = \\cos \\frac{2 \\pi}{n}k + i \\sin\\frac{2 \\pi}{n}k $\n\n1. $ \\omega_n ^ t (0 \\leq t \\leq n - 1) $ \n2. $ \\omega_{2n} ^ {2k} = \\omega_n ^ k $\n3. $ \\omega_n ^ { k + \\frac{n}{2} } = -\\omega_n ^ k $\n3.  $ k \\neq 0 $ $ 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} = 0 $\n\n $ p = qn + 1 $ $ n $  $ 2 $ **** $ g $  $ g ^ i(0 \\leq i \\leq p - 1) $ \n\n#### \n\n $ \\omega_n = g ^ q $ $ 1,\\ g ^ q,\\ g ^ {2q},\\ \\dots,\\ g ^ {(n - 1)q} $ ****\n\n#### \n\n $ \\omega_n = g ^ q $  $ \\omega_{2n} = g ^ { \\frac{q}{2} } $$ p = \\frac{q}{2} \\times 2n + 1 $ $ \\omega_{2n} ^ {2k} = g ^ {2k \\frac{q}{2} } = g ^ {kq} = \\omega_n ^ k $****\n\n#### \n\n\n\n$$ \\omega_n ^ n = g ^ {nq} = g ^ {p - 1} \\equiv 1 \\pmod p $$\n\n $ (\\omega_{n} ^ { \\frac{n}{2} }) ^ 2 = \\omega_n ^ n $ $ \\omega_n ^ { \\frac{n}{2} } \\equiv \\pm 1 \\pmod p $ $ \\omega_n ^ { \\frac{n}{2} } \\neq \\omega_n ^ 0 \\ $ $ \\omega_n ^ { \\frac{n}{2} } \\equiv -1 \\pmod p $ $ \\omega_n ^ { k + \\frac{n}{2} } = \\omega_n ^ k \\times \\omega_n ^ { \\frac{n}{2} } \\equiv -\\omega_n ^ k \\pmod p $****\n\n#### \n $ k \\neq 0 $ \n\n$$\n\\begin{aligned}\nS(\\omega_n ^ k) &= 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} \\\\\n\\omega_n ^ k S(\\omega_n ^ k) &= \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + (\\omega_n ^ k) ^ 3 + \\dots + (\\omega_n ^ k) ^ n \\\\\n\\omega_n ^ k S(\\omega_n ^ k) - S(\\omega_n ^ k) &= (\\omega_n ^ k) ^ n - 1 \\\\\nS(\\omega_n ^ k) &= \\frac{(\\omega_n ^ k) ^ n - 1}{\\omega_n ^ k - 1}\n\\end{aligned}\n$$\n\n****$ (\\omega_n ^ k) ^ n - 1 \\equiv 0 \\pmod p $ $ S(\\omega_n ^ k) \\equiv 0  \\pmod p $****\n\n### \n   $ g $ $ g $  $ p $ \n\n>  $ g $ $ g ^ k \\equiv 1 \\pmod p $  $ k $  $ p - 1 $ \n\n $ k $  $ p - 1 $  $ x $  $ xk > p - 1 > (x - 1)k $\n\n$$ g ^ {xk} \\equiv g ^ {p - 1} \\equiv 1 \\equiv g ^ {xk - (p - 1)} \\pmod p $$\n\n$ xk - (p - 1) < k $\n\n $ p - 1 $  $ q $ $ g ^ q \\not\\equiv 1 \\pmod p $ \n\n```c++\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n```\n\n### \n\n\n $ \\div n $  $ \\times n ^ {-1} $\n\n```c++\ninline long long pow(const long long x, const long long n, const long long p) {\n\tlong long ans = 1;\n\tfor (long long num = x, tmp = n; tmp; tmp >>= 1, num = num * num % p) if (tmp & 1) ans = ans * num % p;\n\treturn ans;\n}\n\ninline long long root(const long long p) {\n\tfor (int i = 2; i <= p; i++) {\n\t\tint x = p - 1;\n\t\tbool flag = false;\n\t\tfor (int k = 2; k * k <= p - 1; k++) if (x % k == 0) {\n\t\t\tif (pow(i, (p - 1) / k, p) == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (x % k == 0) x /= k;\n\t\t}\n\n\t\tif (!flag && (x == 1 || pow(i, (p - 1) / x, p) != 1)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\tthrow;\n}\n\ninline void exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long a, const long long p) {\n\tlong long g, x, y;\n\texgcd(a, p, g, x, y);\n\treturn (x + p) % p;\n}\n\nstruct NumberTheoreticTransform {\n\tlong long omega[MAXM_EXTENDED], omegaInverse[MAXM_EXTENDED];\n\n\tvoid init(const int n) {\n\t\tlong long g = root(MOD), x = pow(g, (MOD - 1) / n, MOD);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tassert(i < MAXM_EXTENDED);\n\t\t\tomega[i] = (i == 0) ? 1 : omega[i - 1] * x % MOD;\n\t\t\tomegaInverse[i] = inv(omega[i], MOD);\n\t\t}\n\t}\n\n\tvoid transform(long long *a, const int n, const long long *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t}\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tint m = l / 2;\n\t\t\tfor (long long *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tlong long t = omega[n / l * i] * p[i + m] % MOD;\n\t\t\t\t\tp[i + m] = (p[i] - t + MOD) % MOD;\n\t\t\t\t\t(p[i] += t) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(long long *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(long long *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tlong long x = inv(n, MOD);\n\t\tfor (int i = 0; i < n; i++) a[i] = a[i] * x % MOD;\n\t}\n} ntt;\n```\n","slug":"fft-to-ntt","published":1,"updated":"2016-06-17T13:38:12.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6crf0146c2xlscbb7cvw"},{"title":"FFT ","date":"2016-06-03T11:41:00.000Z","_content":"\nFast Fourier TransformFFT $ O(n \\log n) $ Discrete Fourier transformDFT OI \n\n<!-- more -->\n\n### \n#### \n##### \n $ A(x) $  $ n - 1 $  $ n $  $ ( a_0,\\ a_1,\\ a_2,\\ \\dots,\\ a_{n - 1} ) $ \n\n$$\n\\begin{align*}\nA(x) &= \\sum\\limits_{i = 0} ^ {n - 1} a_i x ^ i \\\\\n&= a_0 + a_1 x + a_2 x ^ 2 + \\dots + a_{n - 1} x ^ {n - 1}\n\\end{align*}\n$$\n\n**** $ n $  $ x $  $ n $  $ n $  $ ( x_0,\\ x_1,\\ x_2,\\ \\dots,\\ x_{n - 1} ) $$ ( y_0,\\ y_1,\\ y_2,\\ \\dots,\\ y_{n - 1} ) $\n\n$$\n\\begin{align*}\ny_i &= A(x_i) \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j x_i ^ j\n\\end{align*}\n$$\n\n##### \n>  $ n - 1 $  $ n $ \n\n $ n - 1 $  $ A(x) $$ B(x) $ $ i \\in [0,\\ n - 1] $ $ A(x_i) = B(x_i) $\n\n $ C(x) = A(x) - B(x) $ $ C(x) $  $ n - 1 $  $ i \\in [0,\\ n - 1] $ $ C(x_i) = 0 $\n\n $ C(x) $  $ n $  $ n - 1 $  $ n - 1 $  $ C(x) $  $ n - 1 $ \n\n $ O(n ^ 2) $\n\n**** $ O(n ^ 2) $\n\n##### \n $ A(x) = \\sum\\limits_{i = 0} ^ {n - 1} a_i x ^ i $  $ B(x) = \\sum\\limits_{i = 0} ^ {n - 1} b_i x ^ i $  $ C(x) $\n\n$$ C(x) = A(x) \\times B(x) = \\sum\\limits_{k = 0} ^ {2n - 2} (\\sum\\limits_{k = i + j} a_i b_j) x ^ k $$\n\n $ n - 1 $  $ 2n - 2 $  $ O(n ^ 2) $\n\n $ 2n - 1 $ \n\n$$ {y_3}_i = (\\sum\\limits_{j = 0} ^ {2n - 1} a_j x_i ^ j) \\times (\\sum\\limits_{j = 0} ^ {2n - 1} b_j x_i ^ j) = {y_1}_i \\times {y_2}_i $$\n\n $ O(n) $\n\n#### \n $ a $$ b $ $ i ^ 2 = -1 $ $ a + bi $ **** $ i $ ****\n\n##### \n$ x $ $ y $  $ a + bi $  $ (0,\\ 0) $  $ (a,\\ b) $ \n\n $ \\sqrt {a ^ 2 + b ^ 2} $  $ x $ \n\n\n\n\n\n### \n $ n $  $ 2 $ \n\n$ 1 $  $ n $  $ n $ **** $ \\omega_n $ $ n $ \n\n $ n - 1 $  $ \\omega_n ^ 2,\\ \\omega_n ^ 3,\\ \\dots,\\ \\omega_n ^ n $ $ \\omega_n ^ n = \\omega_n ^ 0 = 1 $\n\n $ 1 \\over n $\n\n$$ \\omega_n ^ k = \\cos k \\frac{2 \\pi}{n} + i\\sin k \\frac{2 \\pi}{n} $$\n\n#### \n\n> $ \\omega_{2n} ^ {2k} = \\omega_n ^ k $\n\n\n\n\n\n$$ \\cos 2k \\frac{2 \\pi}{2n} + i\\sin 2k \\frac{2 \\pi}{2n} = \\cos k \\frac{2 \\pi}{n} + i\\sin k \\frac{2 \\pi}{n} $$\n\n> $ \\omega_n ^ { k + \\frac{n}{2} } = -\\omega_n ^ k $\n\n $ \\omega_n ^ k $  $ \\omega_n ^ { \\frac{n}{2} } $\n\n$$\n\\begin{align*}\n\\omega_n ^ { \\frac{n}{2} } &= \\cos \\frac{n}{2} \\cdot \\frac{2 \\pi}{n} + i\\sin \\frac{n}{2} \\cdot \\frac{2 \\pi}{n} \\\\\n&= \\cos \\pi + i\\sin \\pi \\\\\n&= -1\n\\end{align*}\n$$\n\n### \n $ A(x) $  $ n $  $ 0 $  $ n - 1 $  $ (A(\\omega_n ^ 0),\\ A(\\omega_n ^ 1),\\ \\dots,\\ A(\\omega_n ^ {n - 1})) $  $ (a_0,\\ a_1,\\ \\dots,\\ a_{n - 1}) $ ****\n\n $ O(n ^ 2) $\n\n\n\n$$ A(x) = (a_0 + a_2 x ^ 2 + a_4 x ^ 4 + \\dots + a_{n - 2} x ^ {n - 2}) + (a_1 x + a_3 x ^ 3 + a_5 x ^ 5 + \\dots + a_{n - 1} x ^ {n - 1}) $$\n\n\n\n$$\n\\begin{align*}\nA_1(x) &= a_0 + a_2 x + a_4 x ^ 2 + \\dots + a_{n - 2} x ^ {\\frac{n}{2} - 1} \\\\\nA_2(x) &= a_1 + a_3 x + a_5 x ^ 2 + \\dots + a_{n - 1} x ^ {\\frac{n}{2} - 1}\n\\end{align*}\n$$\n\n\n\n$$ A(x) = A_1(x ^ 2) + x A_2(x ^ 2) $$\n\n $ k < \\frac{n}{2} $ $ A(\\omega_n ^ k) $\n\n$$\n\\begin{align*}\nA(\\omega_n ^ k) &= A_1(\\omega_n ^ {2k}) + \\omega_n ^ {k} A_2(\\omega_n ^ {2k}) \\\\\n&= A_1(\\omega_{\\frac{n}{2}} ^ {k}) + \\omega_n ^ {k} A_2(\\omega_{\\frac{n}{2}} ^ {k}) \\\\\n\\end{align*}\n$$\n\n\n\n $ A(\\omega_n ^ {k + \\frac{n}{2}}) $\n\n$$\n\\begin{align*}\nA(\\omega_n ^ {k + \\frac{n}{2}}) &= A_1(\\omega_n ^ {2k + n}) + \\omega_n ^ {k + \\frac{n}{2}} A_2(\\omega_n ^ {2k + n}) \\\\\n&= A_1(\\omega_n ^ {2k} \\times \\omega_n ^ n) - \\omega_n ^ {k} A_2(\\omega_n ^ {2k} \\times \\omega_n ^ n) \\\\\n&= A_1(\\omega_n ^ {2k}) - \\omega_n ^ {k} A_2(\\omega_n ^ {2k}) \\\\\n&= A_1(\\omega_{\\frac{n}{2}} ^ {k}) - \\omega_n ^ {k} A_2(\\omega_{\\frac{n}{2}} ^ {k}) \\\\\n\\end{align*}\n$$\n\n $ \\omega_n ^ n = 1 $ \n\n $ k $  $ [0,\\ \\frac{n}{2} - 1] $ $ k $  $ k + \\frac{n}{2} $  $ [0,\\ n - 1] $\n\n $ A_1(x) $  $ A_2(x) $  $ \\omega_{ \\frac{n}{2} } ^ 0,\\ \\omega_{ \\frac{n}{2} } ^ 1,\\ \\dots,\\ \\omega_{ \\frac{n}{2} } ^ { \\frac{n}{2} - 1 } $  $ O(n) $  $ A(x) $  $ \\omega_n ^ 0,\\ \\omega_n ^ 1,\\ \\dots,\\ \\omega_n ^ {n - 1} $  $ A_1(x) $  $ A_2(x) $  $ a_0 $\n\n\n\n$$ T(n) = 2T( \\frac{n}{2} ) + O(n) = O(n \\log n) $$\n\n FFT   Cooley-Tukey \n\n### \n****\n\n $ (y_0,\\ y_1,\\ y_2,\\ \\dots,\\ y_{n - 1}) $  $ (a_0,\\ a_1,\\ a_2,\\ \\dots,\\ a_{n - 1}) $  $ (c_0,\\ c_1,\\ c_2,\\ \\dots,\\ c_{n - 1}) $ \n\n$$\nc_k = \\sum\\limits_{i = 0} ^ {n - 1} y_i (\\omega_n ^ {-k}) ^ i\n$$\n\n $ B(x) = y_0 + y_1 x + y_2 x ^ 2 + \\dots + y_{n - 1} x ^ {n - 1} $  $ \\omega_n ^ 0,\\ \\omega_n ^ {-1},\\ \\omega_n ^ {-2},\\ \\dots,\\  \\omega_n ^ {-(n - 1)} $ \n\n\n\n$$\n\\begin{align*}\nc_k &= \\sum\\limits_{i = 0} ^ {n - 1} y_i (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ i) ^ j) (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ j) ^ i (\\omega_n ^ {-k}) ^ i) \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ j) ^ i) (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ {j - k}) ^ i \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\sum\\limits_{i = 0} ^ {n - 1} (\\omega_n ^ {j - k}) ^ i)\n\\end{align*}\n$$\n\n\n\n$$ S(\\omega_n ^ k) = 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} $$\n\n $ k \\neq 0 $  $ \\omega_n ^ k $ \n\n$$ \\omega_n ^ k S(\\omega_n ^ k) = \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + (\\omega_n ^ k) ^ 3 + \\dots + (\\omega_n ^ k) ^ n $$\n\n\n\n$$\n\\begin{align*}\n\\omega_n ^ k S(\\omega_n ^ k) - S(\\omega_n ^ k) &= (\\omega_n ^ k) ^ n - 1 \\\\\nS(\\omega_n ^ k) &= \\frac{(\\omega_n ^ k) ^ n - 1}{\\omega_n ^ k - 1}\n\\end{align*}\n$$\n\n\n\n$$ S(\\omega_n ^ k) = 0 $$\n\n $ k = 0 $  $ S(\\omega_n ^ k) = n $\n\n\n\n$$\n\\begin{align*}\nc_k &= \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\sum\\limits_{i = 0} ^ {n - 1} (\\omega_n ^ {j - k}) ^ i) \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j S(\\omega_n ^ {j - k})\n\\end{align*}\n$$\n\n $ j = k $ $ S(\\omega_n ^ {j - k}) = n $ $ S(\\omega_n ^ {j - k}) = 0 $\n\n$$\n\\begin{align*}\nc_i &= n a_i \\\\\na_i &= \\frac{1}{n} c_i\n\\end{align*}\n$$\n\n $ n $\n\n### \nC++  STL  `complex`  `std::complex<T>` `T`  `double` `long double`  `__float128`\n\n `std::conj()`  IDFT \n\n#### \n\n\n##### \n\n```c++\nconst double PI = acos(-1);\n\nbool inversed = false;\n\ninline std::complex<double> omega(const int n, const int k) {\n    if (!inversed) return std::complex<double>(cos(2 * PI / n * k), sin(2 * PI / n * k));\n    else return std::conj(std::complex<double>(cos(2 * PI / n * k), sin(2 * PI / n * k)));\n}\n\ninline void transform(std::complex<double> *a, const int n) {\n    if (n == 1) return;\n\n    static std::complex<double> buf[MAXN];\n    const int m = n / 2;\n    // \n    for (int i = 0; i < m; i++) {\n        buf[i] = a[i * 2];\n        buf[i + m] = a[i * 2 + 1];\n    }\n    std::copy(buf, buf + n, a);\n\n    // \n    std::complex<double> *a1 = a, *a2 = a + m;\n    fft(a1, m);\n    fft(a2, m);\n\n    // \n    for (int i = 0; i < m; i++) {\n        std::complex<double> x = omega(n, i);\n        buf[i] = a1[i] + x * a2[i];\n        buf[i + m] = a1[i] - x * a2[i];\n    }\n\n    std::copy(buf, buf + n, a);\n}\n```\n\n#### \n FFT \n\n##### \n FFT \n\n```plain\n000 001 010 011 100 101 110 111\n 0   1   2   3   4   5   6   7\n 0   2   4   6 - 1   3   5   7\n 0   4 - 2   6 - 1   5 - 3   7\n 0 - 4 - 2 - 6 - 1 - 5 - 3 - 7\n000 100 010 110 001 101 011 111\n```\n\n\n\n\n\n```c++\nint k = 0;\nwhile ((1 << k) < n) k++;\nfor (int i = 0; i < n; i++) {\n    int t = 0;\n    for (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n    if (i < t) std::swap(a[i], a[t]);\n}\n```\n\n##### \n $ A_1(\\omega_{ \\frac{n}{2} } ^ k) $  $ A_2(\\omega_{ \\frac{n}{2} } ^ k) $  $ a(k) $  $ a(\\frac{n}{2} + k) $ $ A(\\omega_n ^ {k}) $  $ A(\\omega_n ^ {k + \\frac{n}{2} }) $  $ b(k) $  $ b(\\frac{n}{2} + k) $ \n\n$$\n\\begin{align*}\nb(k) & \\leftarrow a(k) + \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\nb(\\frac{n}{2} + k) & \\leftarrow a(k) - \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\n\\end{align*}\n$$\n\n $ t $ $ b $ $ A(\\omega_n ^ {k}) $  $ A(\\omega_n ^ {k + \\frac{n}{2} }) $  $ a(k) $  $ a(\\frac{n}{2} + k) $ \n\n$$\n\\begin{align*}\nt & \\leftarrow \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\na(\\frac{n}{2} + k) & \\leftarrow a(k) - t \\\\\na(k) & \\leftarrow a(k) + t \\\\\n\\end{align*}\n$$\n\n****\n\n##### \n`omega[k]`  $ \\omega_n ^ k $IDFT  $ \\omega_n ^ {-k} $\n\n $ l $ $ \\frac{l}{2} $  $ l $  $ \\omega_l ^ k = \\omega_n ^ { \\frac{n}{l} k } $\n\n```c++\nvoid transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n    // \n    for (int l = 2; l <= n; l *= 2) {\n        int m = l / 2;\n        //  m  l \n        for (std::complex<double> *p = a; p != a + n; p += l) {\n            for (int i = 0; i < m; i++) {\n                // \n                std::complex<double> t = omega[n / l * i] * p[m + i];\n                p[m + i] = p[i] - t;\n                p[i] += t;\n            }\n        }\n    }\n}\n```\n\n### \n $ n_1 - 1 $  $ n_2 - 1 $ **** $ n_1 + n_2 - 1 $  $ n_1 + n_2 - 2 $ \n\n```c++\nstruct FastFourierTransform {\n    std::complex<double> omega[MAXN], omegaInverse[MAXN];\n\n    void init(const int n) {\n        for (int i = 0; i < n; i++) {\n            omega[i] = std::complex<double>(cos(2 * PI / n * i), sin(2 * PI / n * i));\n            omegaInverse[i] = std::conj(omega[i]);\n        }\n    }\n\n    void transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n        int k = 0;\n        while ((1 << k) < n) k++;\n        for (int i = 0; i < n; i++) {\n            int t = 0;\n            for (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n            if (i < t) std::swap(a[i], a[t]);\n        }\n\n        for (int l = 2; l <= n; l *= 2) {\n            int m = l / 2;\n            for (std::complex<double> *p = a; p != a + n; p += l) {\n                for (int i = 0; i < m; i++) {\n                    std::complex<double> t = omega[n / l * i] * p[m + i];\n                    p[m + i] = p[i] - t;\n                    p[i] += t;\n                }\n            }\n        }\n    }\n\n    void dft(std::complex<double> *a, const int n) {\n        transform(a, n, omega);\n    }\n\n    void idft(std::complex<double> *a, const int n) {\n        transform(a, n, omegaInverse);\n        for (int i = 0; i < n; i++) a[i] /= n;\n    }\n} fft;\n\ninline void multiply(const int *a1, const int n1, const int *a2, const int n2, int *res) {\n    int n = 1;\n    while (n < n1 + n2) n *= 2;\n    static std::complex<double> c1[MAXN], c2[MAXN];\n    for (int i = 0; i < n1; i++) c1[i].real(a1[i]);\n    for (int i = 0; i < n2; i++) c2[i].real(a2[i]);\n    fft.init(n);\n    fft.dft(c1, n), fft.dft(c2, n);\n    for (int i = 0; i < n; i++) c1[i] *= c2[i];\n    fft.idft(c1, n);\n    for (int i = 0; i < n1 + n2 - 1; i++) res[i] = static_cast<int>(floor(c1[i].real() + 0.5));\n}\n```\n\n### \n* [ - ](https://zh.wikipedia.org/zh/%E5%A4%9A%E9%A0%85%E5%BC%8F)Wikipedia\n* [ - ](https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%B9%B3%E9%9D%A2)Wikipedia\n* [ () - ](https://zh.wikipedia.org/wiki/%E5%A4%8D%E6%95%B0_(%E6%95%B0%E5%AD%A6))Wikipedia\n* [ - ](https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2)Wikipedia\n* [FFT & NTT | ZYK1997](http://zyk1997.github.io/2015/06/08/FFT/)ZYK1997\n* [BZOJ 3992 SDOI2015  - Fuxey -  - CSDN.NET](http://blog.csdn.net/fuxey/article/details/50840881)Fuxey\n* [ - Miskcoo's Space](http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform)Miskcoo\n* [OI  FFT - zball - ](http://www.cnblogs.com/tmzbot/p/4320955.html)zball\n* [Fourier transform](https://pan.baidu.com/wap/album/file?uk=3325080974&album_id=2474841267539644259&fsid=845742707277510&adapt=pc&fr=ftw)\n","source":"_posts/fft-notes.md","raw":"title: FFT \ncategories: OI\ntags: \n  - FFT\n  - \n  - \n  - \n  - \npermalink: fft-notes\ndate: 2016-06-03 19:41:00\n---\n\nFast Fourier TransformFFT $ O(n \\log n) $ Discrete Fourier transformDFT OI \n\n<!-- more -->\n\n### \n#### \n##### \n $ A(x) $  $ n - 1 $  $ n $  $ ( a_0,\\ a_1,\\ a_2,\\ \\dots,\\ a_{n - 1} ) $ \n\n$$\n\\begin{align*}\nA(x) &= \\sum\\limits_{i = 0} ^ {n - 1} a_i x ^ i \\\\\n&= a_0 + a_1 x + a_2 x ^ 2 + \\dots + a_{n - 1} x ^ {n - 1}\n\\end{align*}\n$$\n\n**** $ n $  $ x $  $ n $  $ n $  $ ( x_0,\\ x_1,\\ x_2,\\ \\dots,\\ x_{n - 1} ) $$ ( y_0,\\ y_1,\\ y_2,\\ \\dots,\\ y_{n - 1} ) $\n\n$$\n\\begin{align*}\ny_i &= A(x_i) \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j x_i ^ j\n\\end{align*}\n$$\n\n##### \n>  $ n - 1 $  $ n $ \n\n $ n - 1 $  $ A(x) $$ B(x) $ $ i \\in [0,\\ n - 1] $ $ A(x_i) = B(x_i) $\n\n $ C(x) = A(x) - B(x) $ $ C(x) $  $ n - 1 $  $ i \\in [0,\\ n - 1] $ $ C(x_i) = 0 $\n\n $ C(x) $  $ n $  $ n - 1 $  $ n - 1 $  $ C(x) $  $ n - 1 $ \n\n $ O(n ^ 2) $\n\n**** $ O(n ^ 2) $\n\n##### \n $ A(x) = \\sum\\limits_{i = 0} ^ {n - 1} a_i x ^ i $  $ B(x) = \\sum\\limits_{i = 0} ^ {n - 1} b_i x ^ i $  $ C(x) $\n\n$$ C(x) = A(x) \\times B(x) = \\sum\\limits_{k = 0} ^ {2n - 2} (\\sum\\limits_{k = i + j} a_i b_j) x ^ k $$\n\n $ n - 1 $  $ 2n - 2 $  $ O(n ^ 2) $\n\n $ 2n - 1 $ \n\n$$ {y_3}_i = (\\sum\\limits_{j = 0} ^ {2n - 1} a_j x_i ^ j) \\times (\\sum\\limits_{j = 0} ^ {2n - 1} b_j x_i ^ j) = {y_1}_i \\times {y_2}_i $$\n\n $ O(n) $\n\n#### \n $ a $$ b $ $ i ^ 2 = -1 $ $ a + bi $ **** $ i $ ****\n\n##### \n$ x $ $ y $  $ a + bi $  $ (0,\\ 0) $  $ (a,\\ b) $ \n\n $ \\sqrt {a ^ 2 + b ^ 2} $  $ x $ \n\n\n\n\n\n### \n $ n $  $ 2 $ \n\n$ 1 $  $ n $  $ n $ **** $ \\omega_n $ $ n $ \n\n $ n - 1 $  $ \\omega_n ^ 2,\\ \\omega_n ^ 3,\\ \\dots,\\ \\omega_n ^ n $ $ \\omega_n ^ n = \\omega_n ^ 0 = 1 $\n\n $ 1 \\over n $\n\n$$ \\omega_n ^ k = \\cos k \\frac{2 \\pi}{n} + i\\sin k \\frac{2 \\pi}{n} $$\n\n#### \n\n> $ \\omega_{2n} ^ {2k} = \\omega_n ^ k $\n\n\n\n\n\n$$ \\cos 2k \\frac{2 \\pi}{2n} + i\\sin 2k \\frac{2 \\pi}{2n} = \\cos k \\frac{2 \\pi}{n} + i\\sin k \\frac{2 \\pi}{n} $$\n\n> $ \\omega_n ^ { k + \\frac{n}{2} } = -\\omega_n ^ k $\n\n $ \\omega_n ^ k $  $ \\omega_n ^ { \\frac{n}{2} } $\n\n$$\n\\begin{align*}\n\\omega_n ^ { \\frac{n}{2} } &= \\cos \\frac{n}{2} \\cdot \\frac{2 \\pi}{n} + i\\sin \\frac{n}{2} \\cdot \\frac{2 \\pi}{n} \\\\\n&= \\cos \\pi + i\\sin \\pi \\\\\n&= -1\n\\end{align*}\n$$\n\n### \n $ A(x) $  $ n $  $ 0 $  $ n - 1 $  $ (A(\\omega_n ^ 0),\\ A(\\omega_n ^ 1),\\ \\dots,\\ A(\\omega_n ^ {n - 1})) $  $ (a_0,\\ a_1,\\ \\dots,\\ a_{n - 1}) $ ****\n\n $ O(n ^ 2) $\n\n\n\n$$ A(x) = (a_0 + a_2 x ^ 2 + a_4 x ^ 4 + \\dots + a_{n - 2} x ^ {n - 2}) + (a_1 x + a_3 x ^ 3 + a_5 x ^ 5 + \\dots + a_{n - 1} x ^ {n - 1}) $$\n\n\n\n$$\n\\begin{align*}\nA_1(x) &= a_0 + a_2 x + a_4 x ^ 2 + \\dots + a_{n - 2} x ^ {\\frac{n}{2} - 1} \\\\\nA_2(x) &= a_1 + a_3 x + a_5 x ^ 2 + \\dots + a_{n - 1} x ^ {\\frac{n}{2} - 1}\n\\end{align*}\n$$\n\n\n\n$$ A(x) = A_1(x ^ 2) + x A_2(x ^ 2) $$\n\n $ k < \\frac{n}{2} $ $ A(\\omega_n ^ k) $\n\n$$\n\\begin{align*}\nA(\\omega_n ^ k) &= A_1(\\omega_n ^ {2k}) + \\omega_n ^ {k} A_2(\\omega_n ^ {2k}) \\\\\n&= A_1(\\omega_{\\frac{n}{2}} ^ {k}) + \\omega_n ^ {k} A_2(\\omega_{\\frac{n}{2}} ^ {k}) \\\\\n\\end{align*}\n$$\n\n\n\n $ A(\\omega_n ^ {k + \\frac{n}{2}}) $\n\n$$\n\\begin{align*}\nA(\\omega_n ^ {k + \\frac{n}{2}}) &= A_1(\\omega_n ^ {2k + n}) + \\omega_n ^ {k + \\frac{n}{2}} A_2(\\omega_n ^ {2k + n}) \\\\\n&= A_1(\\omega_n ^ {2k} \\times \\omega_n ^ n) - \\omega_n ^ {k} A_2(\\omega_n ^ {2k} \\times \\omega_n ^ n) \\\\\n&= A_1(\\omega_n ^ {2k}) - \\omega_n ^ {k} A_2(\\omega_n ^ {2k}) \\\\\n&= A_1(\\omega_{\\frac{n}{2}} ^ {k}) - \\omega_n ^ {k} A_2(\\omega_{\\frac{n}{2}} ^ {k}) \\\\\n\\end{align*}\n$$\n\n $ \\omega_n ^ n = 1 $ \n\n $ k $  $ [0,\\ \\frac{n}{2} - 1] $ $ k $  $ k + \\frac{n}{2} $  $ [0,\\ n - 1] $\n\n $ A_1(x) $  $ A_2(x) $  $ \\omega_{ \\frac{n}{2} } ^ 0,\\ \\omega_{ \\frac{n}{2} } ^ 1,\\ \\dots,\\ \\omega_{ \\frac{n}{2} } ^ { \\frac{n}{2} - 1 } $  $ O(n) $  $ A(x) $  $ \\omega_n ^ 0,\\ \\omega_n ^ 1,\\ \\dots,\\ \\omega_n ^ {n - 1} $  $ A_1(x) $  $ A_2(x) $  $ a_0 $\n\n\n\n$$ T(n) = 2T( \\frac{n}{2} ) + O(n) = O(n \\log n) $$\n\n FFT   Cooley-Tukey \n\n### \n****\n\n $ (y_0,\\ y_1,\\ y_2,\\ \\dots,\\ y_{n - 1}) $  $ (a_0,\\ a_1,\\ a_2,\\ \\dots,\\ a_{n - 1}) $  $ (c_0,\\ c_1,\\ c_2,\\ \\dots,\\ c_{n - 1}) $ \n\n$$\nc_k = \\sum\\limits_{i = 0} ^ {n - 1} y_i (\\omega_n ^ {-k}) ^ i\n$$\n\n $ B(x) = y_0 + y_1 x + y_2 x ^ 2 + \\dots + y_{n - 1} x ^ {n - 1} $  $ \\omega_n ^ 0,\\ \\omega_n ^ {-1},\\ \\omega_n ^ {-2},\\ \\dots,\\  \\omega_n ^ {-(n - 1)} $ \n\n\n\n$$\n\\begin{align*}\nc_k &= \\sum\\limits_{i = 0} ^ {n - 1} y_i (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ i) ^ j) (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ j) ^ i (\\omega_n ^ {-k}) ^ i) \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} (\\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ j) ^ i) (\\omega_n ^ {-k}) ^ i \\\\\n&= \\sum\\limits_{i = 0} ^ {n - 1} \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\omega_n ^ {j - k}) ^ i \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\sum\\limits_{i = 0} ^ {n - 1} (\\omega_n ^ {j - k}) ^ i)\n\\end{align*}\n$$\n\n\n\n$$ S(\\omega_n ^ k) = 1 + \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + \\dots + (\\omega_n ^ k) ^ {n - 1} $$\n\n $ k \\neq 0 $  $ \\omega_n ^ k $ \n\n$$ \\omega_n ^ k S(\\omega_n ^ k) = \\omega_n ^ k + (\\omega_n ^ k) ^ 2 + (\\omega_n ^ k) ^ 3 + \\dots + (\\omega_n ^ k) ^ n $$\n\n\n\n$$\n\\begin{align*}\n\\omega_n ^ k S(\\omega_n ^ k) - S(\\omega_n ^ k) &= (\\omega_n ^ k) ^ n - 1 \\\\\nS(\\omega_n ^ k) &= \\frac{(\\omega_n ^ k) ^ n - 1}{\\omega_n ^ k - 1}\n\\end{align*}\n$$\n\n\n\n$$ S(\\omega_n ^ k) = 0 $$\n\n $ k = 0 $  $ S(\\omega_n ^ k) = n $\n\n\n\n$$\n\\begin{align*}\nc_k &= \\sum\\limits_{j = 0} ^ {n - 1} a_j (\\sum\\limits_{i = 0} ^ {n - 1} (\\omega_n ^ {j - k}) ^ i) \\\\\n&= \\sum\\limits_{j = 0} ^ {n - 1} a_j S(\\omega_n ^ {j - k})\n\\end{align*}\n$$\n\n $ j = k $ $ S(\\omega_n ^ {j - k}) = n $ $ S(\\omega_n ^ {j - k}) = 0 $\n\n$$\n\\begin{align*}\nc_i &= n a_i \\\\\na_i &= \\frac{1}{n} c_i\n\\end{align*}\n$$\n\n $ n $\n\n### \nC++  STL  `complex`  `std::complex<T>` `T`  `double` `long double`  `__float128`\n\n `std::conj()`  IDFT \n\n#### \n\n\n##### \n\n```c++\nconst double PI = acos(-1);\n\nbool inversed = false;\n\ninline std::complex<double> omega(const int n, const int k) {\n    if (!inversed) return std::complex<double>(cos(2 * PI / n * k), sin(2 * PI / n * k));\n    else return std::conj(std::complex<double>(cos(2 * PI / n * k), sin(2 * PI / n * k)));\n}\n\ninline void transform(std::complex<double> *a, const int n) {\n    if (n == 1) return;\n\n    static std::complex<double> buf[MAXN];\n    const int m = n / 2;\n    // \n    for (int i = 0; i < m; i++) {\n        buf[i] = a[i * 2];\n        buf[i + m] = a[i * 2 + 1];\n    }\n    std::copy(buf, buf + n, a);\n\n    // \n    std::complex<double> *a1 = a, *a2 = a + m;\n    fft(a1, m);\n    fft(a2, m);\n\n    // \n    for (int i = 0; i < m; i++) {\n        std::complex<double> x = omega(n, i);\n        buf[i] = a1[i] + x * a2[i];\n        buf[i + m] = a1[i] - x * a2[i];\n    }\n\n    std::copy(buf, buf + n, a);\n}\n```\n\n#### \n FFT \n\n##### \n FFT \n\n```plain\n000 001 010 011 100 101 110 111\n 0   1   2   3   4   5   6   7\n 0   2   4   6 - 1   3   5   7\n 0   4 - 2   6 - 1   5 - 3   7\n 0 - 4 - 2 - 6 - 1 - 5 - 3 - 7\n000 100 010 110 001 101 011 111\n```\n\n\n\n\n\n```c++\nint k = 0;\nwhile ((1 << k) < n) k++;\nfor (int i = 0; i < n; i++) {\n    int t = 0;\n    for (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n    if (i < t) std::swap(a[i], a[t]);\n}\n```\n\n##### \n $ A_1(\\omega_{ \\frac{n}{2} } ^ k) $  $ A_2(\\omega_{ \\frac{n}{2} } ^ k) $  $ a(k) $  $ a(\\frac{n}{2} + k) $ $ A(\\omega_n ^ {k}) $  $ A(\\omega_n ^ {k + \\frac{n}{2} }) $  $ b(k) $  $ b(\\frac{n}{2} + k) $ \n\n$$\n\\begin{align*}\nb(k) & \\leftarrow a(k) + \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\nb(\\frac{n}{2} + k) & \\leftarrow a(k) - \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\n\\end{align*}\n$$\n\n $ t $ $ b $ $ A(\\omega_n ^ {k}) $  $ A(\\omega_n ^ {k + \\frac{n}{2} }) $  $ a(k) $  $ a(\\frac{n}{2} + k) $ \n\n$$\n\\begin{align*}\nt & \\leftarrow \\omega_n ^ k \\times a(\\frac{n}{2} + k) \\\\\na(\\frac{n}{2} + k) & \\leftarrow a(k) - t \\\\\na(k) & \\leftarrow a(k) + t \\\\\n\\end{align*}\n$$\n\n****\n\n##### \n`omega[k]`  $ \\omega_n ^ k $IDFT  $ \\omega_n ^ {-k} $\n\n $ l $ $ \\frac{l}{2} $  $ l $  $ \\omega_l ^ k = \\omega_n ^ { \\frac{n}{l} k } $\n\n```c++\nvoid transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n    // \n    for (int l = 2; l <= n; l *= 2) {\n        int m = l / 2;\n        //  m  l \n        for (std::complex<double> *p = a; p != a + n; p += l) {\n            for (int i = 0; i < m; i++) {\n                // \n                std::complex<double> t = omega[n / l * i] * p[m + i];\n                p[m + i] = p[i] - t;\n                p[i] += t;\n            }\n        }\n    }\n}\n```\n\n### \n $ n_1 - 1 $  $ n_2 - 1 $ **** $ n_1 + n_2 - 1 $  $ n_1 + n_2 - 2 $ \n\n```c++\nstruct FastFourierTransform {\n    std::complex<double> omega[MAXN], omegaInverse[MAXN];\n\n    void init(const int n) {\n        for (int i = 0; i < n; i++) {\n            omega[i] = std::complex<double>(cos(2 * PI / n * i), sin(2 * PI / n * i));\n            omegaInverse[i] = std::conj(omega[i]);\n        }\n    }\n\n    void transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n        int k = 0;\n        while ((1 << k) < n) k++;\n        for (int i = 0; i < n; i++) {\n            int t = 0;\n            for (int j = 0; j < k; j++) if (i & (1 << j)) t |= (1 << (k - j - 1));\n            if (i < t) std::swap(a[i], a[t]);\n        }\n\n        for (int l = 2; l <= n; l *= 2) {\n            int m = l / 2;\n            for (std::complex<double> *p = a; p != a + n; p += l) {\n                for (int i = 0; i < m; i++) {\n                    std::complex<double> t = omega[n / l * i] * p[m + i];\n                    p[m + i] = p[i] - t;\n                    p[i] += t;\n                }\n            }\n        }\n    }\n\n    void dft(std::complex<double> *a, const int n) {\n        transform(a, n, omega);\n    }\n\n    void idft(std::complex<double> *a, const int n) {\n        transform(a, n, omegaInverse);\n        for (int i = 0; i < n; i++) a[i] /= n;\n    }\n} fft;\n\ninline void multiply(const int *a1, const int n1, const int *a2, const int n2, int *res) {\n    int n = 1;\n    while (n < n1 + n2) n *= 2;\n    static std::complex<double> c1[MAXN], c2[MAXN];\n    for (int i = 0; i < n1; i++) c1[i].real(a1[i]);\n    for (int i = 0; i < n2; i++) c2[i].real(a2[i]);\n    fft.init(n);\n    fft.dft(c1, n), fft.dft(c2, n);\n    for (int i = 0; i < n; i++) c1[i] *= c2[i];\n    fft.idft(c1, n);\n    for (int i = 0; i < n1 + n2 - 1; i++) res[i] = static_cast<int>(floor(c1[i].real() + 0.5));\n}\n```\n\n### \n* [ - ](https://zh.wikipedia.org/zh/%E5%A4%9A%E9%A0%85%E5%BC%8F)Wikipedia\n* [ - ](https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%B9%B3%E9%9D%A2)Wikipedia\n* [ () - ](https://zh.wikipedia.org/wiki/%E5%A4%8D%E6%95%B0_(%E6%95%B0%E5%AD%A6))Wikipedia\n* [ - ](https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2)Wikipedia\n* [FFT & NTT | ZYK1997](http://zyk1997.github.io/2015/06/08/FFT/)ZYK1997\n* [BZOJ 3992 SDOI2015  - Fuxey -  - CSDN.NET](http://blog.csdn.net/fuxey/article/details/50840881)Fuxey\n* [ - Miskcoo's Space](http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform)Miskcoo\n* [OI  FFT - zball - ](http://www.cnblogs.com/tmzbot/p/4320955.html)zball\n* [Fourier transform](https://pan.baidu.com/wap/album/file?uk=3325080974&album_id=2474841267539644259&fsid=845742707277510&adapt=pc&fr=ftw)\n","slug":"fft-notes","published":1,"updated":"2016-12-23T06:20:49.497Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6crn014fc2xl5q3vdtrh"},{"title":"","date":"2016-04-08T05:14:55.000Z","_content":"\n $ O(n) $  $ [1, n] $  $ O(n) $ \n\n<!-- more -->\n\n### \n $ \\phi(n) $  $ n $  $ n $ $ \\phi(1) = 1 $\n\n $ n $  $ \\phi(n) = n - 1 $\n\n $ n = p_1 ^ {k_1} \\times p_2 ^ {k_2} \\times  \\times p_N ^ {k_N} $ $ p_i $ \n\n$$ \\phi(n) = n \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} $$\n\n $ p_1 $  $ n $ $ n' = \\frac{n}{p_1} $$ n $  $ n' \\times p_1 $ \n\n $ n' \\ {\\rm mod} \\ p_1 = 0 $ $ k_1 \\gt 1 $ $ n' $  $ n $ \n\n$$\n\\begin{align}\n\\phi(n) &= n \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\\n&= p_1 \\times n' \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\\n&= p_1 \\times \\phi(n') \\\\\n\\end{align}\n$$\n\n $ n' \\ {\\rm mod} \\ p_1 \\neq 0 $ $ k_1 = 1 $ $ n' $  $ p_1 $ \n\n$$\n\\begin{align}\n\\phi(n) &= \\phi(n') \\times \\phi(p_1) \\\\\n&= (p_1 - 1) \\times \\phi(n')\n\\end{align}\n$$\n\n### \n $ \\mu(n) $ \n\n $ n = p_1 ^ {k_1} \\times p_2 ^ {k_2} \\times  \\times p_N ^ {k_N} $ $ p_i $ \n\n$$\n\\mu(n) = \n\\begin{cases}\n1 & n = 1 \\\\\n(-1) ^ N & \\prod\\limits_{i = 1} ^ {N} k_i = 1 \\\\\n0 & k_i \\gt 1 \\\\\n\\end{cases}\n$$\n\n $ n $  $ \\mu(n) = -1 $\n\n $ p_1 $  $ n $ $ n' = \\frac{n}{p_1} $$ n $  $ n' \\times p_1 $ \n\n $ n' \\ {\\rm mod} \\ p_1 = 0 $ $ k_1 \\gt 1 $ \n\n$$ \\mu(n) = 0 $$\n\n $ n' \\ {\\rm mod} \\ p_1 \\neq 0 $ $ k_1 = 1 $ $ n' $  $ N - 1 $  $ \\mu(n') \\neq 0 $ $ n' $  $ 1 $\n\n$$\n\\begin{align}\n\\mu(n) &= (-1) ^ N \\\\\n&= (-1) ^ {N - 1} \\times (-1) \\\\\n&= \\mu(n') \\times (-1) \\\\\n&= -\\mu(n')\n\\end{align}\n$$\n\n $ \\mu(n') = 0 $ $ \\prod\\limits_{i = 2} ^ {N} k_i \\gt 1 $\n\n$$ \\mu(n) = 0 $$\n\n $ \\mu(n) = -\\mu(n') $ \n\n\n### \n```c++\nbool isNotPrime[MAXN + 1];\nint mu[MAXN + 1], phi[MAXN + 1], primes[MAXN + 1], cnt;\ninline void euler() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tmu[1] = 1;\n\tphi[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t\tmu[i] = -1;\n\t\t\tphi[i] = i - 1;\n\t\t}\n\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tint t = i * primes[j];\n\t\t\tif (t > MAXN) break;\n\t\t\tisNotPrime[t] = true;\n\t\t\tif (i % primes[j] == 0) {\n\t\t\t\tmu[t] = 0;\n\t\t\t\tphi[t] = phi[i] * primes[j];\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmu[t] = -mu[i];\n\t\t\t\tphi[t] = phi[i] * (primes[j] - 1);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","source":"_posts/euler-sieve.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - \npermalink: euler-sieve\ndate: 2016-04-08 13:14:55\n---\n\n $ O(n) $  $ [1, n] $  $ O(n) $ \n\n<!-- more -->\n\n### \n $ \\phi(n) $  $ n $  $ n $ $ \\phi(1) = 1 $\n\n $ n $  $ \\phi(n) = n - 1 $\n\n $ n = p_1 ^ {k_1} \\times p_2 ^ {k_2} \\times  \\times p_N ^ {k_N} $ $ p_i $ \n\n$$ \\phi(n) = n \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} $$\n\n $ p_1 $  $ n $ $ n' = \\frac{n}{p_1} $$ n $  $ n' \\times p_1 $ \n\n $ n' \\ {\\rm mod} \\ p_1 = 0 $ $ k_1 \\gt 1 $ $ n' $  $ n $ \n\n$$\n\\begin{align}\n\\phi(n) &= n \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\\n&= p_1 \\times n' \\prod\\limits_{i = 1} ^ {n} \\frac{p_i - 1}{p_i} \\\\\n&= p_1 \\times \\phi(n') \\\\\n\\end{align}\n$$\n\n $ n' \\ {\\rm mod} \\ p_1 \\neq 0 $ $ k_1 = 1 $ $ n' $  $ p_1 $ \n\n$$\n\\begin{align}\n\\phi(n) &= \\phi(n') \\times \\phi(p_1) \\\\\n&= (p_1 - 1) \\times \\phi(n')\n\\end{align}\n$$\n\n### \n $ \\mu(n) $ \n\n $ n = p_1 ^ {k_1} \\times p_2 ^ {k_2} \\times  \\times p_N ^ {k_N} $ $ p_i $ \n\n$$\n\\mu(n) = \n\\begin{cases}\n1 & n = 1 \\\\\n(-1) ^ N & \\prod\\limits_{i = 1} ^ {N} k_i = 1 \\\\\n0 & k_i \\gt 1 \\\\\n\\end{cases}\n$$\n\n $ n $  $ \\mu(n) = -1 $\n\n $ p_1 $  $ n $ $ n' = \\frac{n}{p_1} $$ n $  $ n' \\times p_1 $ \n\n $ n' \\ {\\rm mod} \\ p_1 = 0 $ $ k_1 \\gt 1 $ \n\n$$ \\mu(n) = 0 $$\n\n $ n' \\ {\\rm mod} \\ p_1 \\neq 0 $ $ k_1 = 1 $ $ n' $  $ N - 1 $  $ \\mu(n') \\neq 0 $ $ n' $  $ 1 $\n\n$$\n\\begin{align}\n\\mu(n) &= (-1) ^ N \\\\\n&= (-1) ^ {N - 1} \\times (-1) \\\\\n&= \\mu(n') \\times (-1) \\\\\n&= -\\mu(n')\n\\end{align}\n$$\n\n $ \\mu(n') = 0 $ $ \\prod\\limits_{i = 2} ^ {N} k_i \\gt 1 $\n\n$$ \\mu(n) = 0 $$\n\n $ \\mu(n) = -\\mu(n') $ \n\n\n### \n```c++\nbool isNotPrime[MAXN + 1];\nint mu[MAXN + 1], phi[MAXN + 1], primes[MAXN + 1], cnt;\ninline void euler() {\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tmu[1] = 1;\n\tphi[1] = 1;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes[cnt++] = i;\n\t\t\tmu[i] = -1;\n\t\t\tphi[i] = i - 1;\n\t\t}\n\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tint t = i * primes[j];\n\t\t\tif (t > MAXN) break;\n\t\t\tisNotPrime[t] = true;\n\t\t\tif (i % primes[j] == 0) {\n\t\t\t\tmu[t] = 0;\n\t\t\t\tphi[t] = phi[i] * primes[j];\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmu[t] = -mu[i];\n\t\t\t\tphi[t] = phi[i] * (primes[j] - 1);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n","slug":"euler-sieve","published":1,"updated":"2016-05-11T09:33:24.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6crt014mc2xl4olmhzgw"},{"title":"Edmonds-Karp ","date":"2016-02-19T09:04:38.000Z","_content":"\n Edmonds-Karp  Dinic  Edmonds-Karp \n\n<!-- more -->\n\n### \n$ \\mathrm{cost} $\n\n Dinic  Edmonds-Karp \n\nEdmonds-Karp \n\n### \n1. \n2. **** $ \\times $ ****\n3. \n\n Bellman-Ford   \n\nEdmonds-Karp \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 400;\n\nstruct Node {\n\tstruct Edge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tN[from].firstEdge = new Edge(&N[from], &N[to], capacity, cost);\n\tN[to].firstEdge = new Edge(&N[to], &N[from], 0, -cost);\n\n\tN[from].firstEdge->reversedEdge = N[to].firstEdge;\n\tN[to].firstEdge->reversedEdge = N[from].firstEdge;\n}\n\ninline void edmondskarp(int s, int t, int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tN[i].inEdge = NULL;\n\t\t\tN[i].flow = 0;\n\t\t\tN[i].dist = INT_MAX;\n\t\t\tN[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\tN[s].flow = INT_MAX;\n\t\tN[s].dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].dist == INT_MAX) break;\n\n\t\tfor (Edge *e = N[t].inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += N[t].flow;\n\t\t\te->reversedEdge->flow -= N[t].flow;\n\t\t}\n\n\t\tflow += N[t].flow;\n\t\tcost += N[t].dist * N[t].flow;\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint u, v, cap, cost;\n\t\tscanf(\"%d %d %d %d\", &u, &v, &cap, &cost);\n\t\taddEdge(u, v, cap, cost);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(1, n, n, flow, cost);\n\n\tprintf(\"%d %d\\n\", flow, cost);\n\n\treturn 0;\n}\n```\n","source":"_posts/edmonds-karp-notes.md","raw":"title: Edmonds-Karp \ncategories: OI\ntags: \n  - \n  - \n  - \n  - Edmonds-Karp\n  - \n  - \npermalink: edmonds-karp-notes\ndate: 2016-02-19 17:04:38\n---\n\n Edmonds-Karp  Dinic  Edmonds-Karp \n\n<!-- more -->\n\n### \n$ \\mathrm{cost} $\n\n Dinic  Edmonds-Karp \n\nEdmonds-Karp \n\n### \n1. \n2. **** $ \\times $ ****\n3. \n\n Bellman-Ford   \n\nEdmonds-Karp \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 400;\n\nstruct Node {\n\tstruct Edge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} N[MAXN + 1];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tN[from].firstEdge = new Edge(&N[from], &N[to], capacity, cost);\n\tN[to].firstEdge = new Edge(&N[to], &N[from], 0, -cost);\n\n\tN[from].firstEdge->reversedEdge = N[to].firstEdge;\n\tN[to].firstEdge->reversedEdge = N[from].firstEdge;\n}\n\ninline void edmondskarp(int s, int t, int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tN[i].inEdge = NULL;\n\t\t\tN[i].flow = 0;\n\t\t\tN[i].dist = INT_MAX;\n\t\t\tN[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\tN[s].flow = INT_MAX;\n\t\tN[s].dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].dist == INT_MAX) break;\n\n\t\tfor (Edge *e = N[t].inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += N[t].flow;\n\t\t\te->reversedEdge->flow -= N[t].flow;\n\t\t}\n\n\t\tflow += N[t].flow;\n\t\tcost += N[t].dist * N[t].flow;\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\twhile (m--) {\n\t\tint u, v, cap, cost;\n\t\tscanf(\"%d %d %d %d\", &u, &v, &cap, &cost);\n\t\taddEdge(u, v, cap, cost);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(1, n, n, flow, cost);\n\n\tprintf(\"%d %d\\n\", flow, cost);\n\n\treturn 0;\n}\n```\n","slug":"edmonds-karp-notes","published":1,"updated":"2016-12-25T03:05:44.773Z","_id":"cix2l6cs0014tc2xlbdr5e22e","comments":1,"layout":"post","photos":[],"link":""},{"title":" Docker ","date":"2016-12-13T13:19:00.000Z","_content":"\nOnline JudgeSandbox\n\n<!-- more -->\n\n### \n `setrlimit()`Set Resource Limit\n\n`setrlimit()` Man Page`setrlimit()` `RLIMIT_RTTIME` CPU    `sleep()`  `scanf()` \n\n### \nSystem Call Web \n\n `ptrace()`  `seccamp` `ptrace()`  `seccamp` \n\n `ptrace()` [HustOJ](https://github.com/zhblue/hustoj)[UOJ](https://github.com/vfleaking/uoj)  \n `seccamp` [QDUOJ](https://github.com/QingdaoU/Judger)[TJudger](https://github.com/TimHsue/TJudger)\n\n###  Docker \nSandbox `chroot`  Docker \n\n Docker `fork()`  `setrlimit()`  `exec` \n\n .Net  Python   \n\nDocker \n\n `docker`  [`dockerode`](https://github.com/apocas/dockerode/)  Docker \n\n Docker  .Net  Python  C++   \n Docker Docker  32 \n\n### \n Web \n\n\n\n1.  Web \n2.  Web \n3. \n4. \n5. \n6.  Web \n\n\n\n![](docker-sandbox-judger/image.svg)\n","source":"_posts/docker-sandbox-judger.md","raw":"title:  Docker \ncategories: OI\ntags: \n  - Docker\n  - \npermalink: docker-sandbox-judger\ndate: 2016-12-13 21:19:00\n---\n\nOnline JudgeSandbox\n\n<!-- more -->\n\n### \n `setrlimit()`Set Resource Limit\n\n`setrlimit()` Man Page`setrlimit()` `RLIMIT_RTTIME` CPU    `sleep()`  `scanf()` \n\n### \nSystem Call Web \n\n `ptrace()`  `seccamp` `ptrace()`  `seccamp` \n\n `ptrace()` [HustOJ](https://github.com/zhblue/hustoj)[UOJ](https://github.com/vfleaking/uoj)  \n `seccamp` [QDUOJ](https://github.com/QingdaoU/Judger)[TJudger](https://github.com/TimHsue/TJudger)\n\n###  Docker \nSandbox `chroot`  Docker \n\n Docker `fork()`  `setrlimit()`  `exec` \n\n .Net  Python   \n\nDocker \n\n `docker`  [`dockerode`](https://github.com/apocas/dockerode/)  Docker \n\n Docker  .Net  Python  C++   \n Docker Docker  32 \n\n### \n Web \n\n\n\n1.  Web \n2.  Web \n3. \n4. \n5. \n6.  Web \n\n\n\n![](docker-sandbox-judger/image.svg)\n","slug":"docker-sandbox-judger","published":1,"updated":"2016-12-13T13:24:53.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cs70151c2xles9j0qa2"},{"title":"Dinic ","date":"2016-02-03T10:57:59.000Z","_content":"\nDinic  $ O(n ^ 2m) $ \n\n<!-- more -->\n\n### \n* $ \\mathrm{capacity}(e) $  $ e(u, v) $ \n\n* $ \\mathrm{flow}(e) $  $ e(u, v) $ \n\n*  $ \\mathrm{capacity}(e) - \\mathrm{flow}(e) $ $ \\mathrm{e}(u, v) $ \n\n*  $ 0 $\n\n* \n\n* augmenting path****\n\n* augmenting****\n\n*  $ \\mathrm{level}(u) $  $ u $ \n\n* ********\n\n### \n1. \n2. \n3.  2  1 \n4. \n\n\n\n### \nDinic \n\n DFS \n\n### \n```cpp\nstruct Node {\n\tstruct Edge *firstEdge, *currentEdge;\n\tint level;\n} N[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), next(from->firstEdge), flow(0) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) {\n        \tN[i].level = 0;\n            N[i].currentEdge = N[i].firstEdge;\n        }\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&N[s], &N[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tN[from].firstEdge = new Edge(&N[from], &N[to], capacity);\n\tN[to].firstEdge = new Edge(&N[to], &N[from], 0);\n\n\tN[from].firstEdge->reversedEdge = N[to].firstEdge, N[to].firstEdge->reversedEdge = N[from].firstEdge;\n}\n```\n","source":"_posts/dinic-notes.md","raw":"title: Dinic \ncategories: OI\ntags: \n  - \n  - \n  - \n  - Dinic\n  -   \npermalink: dinic-notes\ndate: 2016-02-03 18:57:59\n---\n\nDinic  $ O(n ^ 2m) $ \n\n<!-- more -->\n\n### \n* $ \\mathrm{capacity}(e) $  $ e(u, v) $ \n\n* $ \\mathrm{flow}(e) $  $ e(u, v) $ \n\n*  $ \\mathrm{capacity}(e) - \\mathrm{flow}(e) $ $ \\mathrm{e}(u, v) $ \n\n*  $ 0 $\n\n* \n\n* augmenting path****\n\n* augmenting****\n\n*  $ \\mathrm{level}(u) $  $ u $ \n\n* ********\n\n### \n1. \n2. \n3.  2  1 \n4. \n\n\n\n### \nDinic \n\n DFS \n\n### \n```cpp\nstruct Node {\n\tstruct Edge *firstEdge, *currentEdge;\n\tint level;\n} N[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), next(from->firstEdge), flow(0) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) {\n        \tN[i].level = 0;\n            N[i].currentEdge = N[i].firstEdge;\n        }\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&N[s], &N[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tN[from].firstEdge = new Edge(&N[from], &N[to], capacity);\n\tN[to].firstEdge = new Edge(&N[to], &N[from], 0);\n\n\tN[from].firstEdge->reversedEdge = N[to].firstEdge, N[to].firstEdge->reversedEdge = N[from].firstEdge;\n}\n```\n","slug":"dinic-notes","published":1,"updated":"2016-12-24T13:13:48.817Z","_id":"cix2l6cse0157c2xlubh2j54s","comments":1,"layout":"post","photos":[],"link":""},{"title":"","date":"2016-04-13T07:41:16.000Z","_content":"\n $ 1 $ ~ $ n $ \n\n<!-- more -->\n\n $ f(n) $\n\n $ n $  $ n - 1 $  $ 1 $\n\n $ n $  $ n $  $ 1 $  $ n $  $ 1 $ $ f(n - 1) $\n\n   $ n $  1  1  $ n $  1  $ f(n - 2) $\n\n\n\n$$ f(n) = (n - 1) \\times (f(n - 1) + f(n - 2)) $$\n","source":"_posts/derangement-number.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \npermalink: derangement-number\ndate: 2016-04-13 15:41:16\n---\n\n $ 1 $ ~ $ n $ \n\n<!-- more -->\n\n $ f(n) $\n\n $ n $  $ n - 1 $  $ 1 $\n\n $ n $  $ n $  $ 1 $  $ n $  $ 1 $ $ f(n - 1) $\n\n   $ n $  1  1  $ n $  1  $ f(n - 2) $\n\n\n\n$$ f(n) = (n - 1) \\times (f(n - 1) + f(n - 2)) $$\n","slug":"derangement-number","published":1,"updated":"2016-05-11T09:33:24.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6csk015ec2xlkjzbnick"},{"title":"CTSC1999 - ","id":"59","updated":"2016-02-24T13:42:46.000Z","date":"2016-02-24T13:41:36.000Z","_content":"\n `n`  `m`  `i`  `H[i]`  1\n\n<!-- more -->\n\n### \n[COGS 736](http://cogs.top/cogs/problem/problem.php?pid=736)\n\n### \n  qwq\n\n `t` `t + 1`  0 ********\n\n 1\n\n  qwq\n\n`n`  `m` \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 13;\nconst int MAXM = 20;\nconst int MAXK = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n\t//char info[256];\n} nodes[MAXN * (MAXN + 2) * (MAXM + 1) * MAXK * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, k, a[MAXM];\nstd::vector<int> v[MAXM];\nstd::vector<int>::const_iterator currentStation[MAXM];\n\ninline void print(Node *v) {\n\t//printf(\"%s\", v->info);\n\treturn;\n\t//int x = (int)(v - nodes);\n\t//if (x == 0) putchar('s');\n\t//else if (x == n * (n + 2) * (m + 1) * k * 2 + 1) putchar('t');\n\t//else {\n\t//\tprintf(\"{ day: %d, station: %d }\", x / (n + 2), x % (n + 2) - 2);\n\t//}\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\t//print(e->from);\n\t\t\t\t\t//printf(\" -> \");\n\t\t\t\t\t//print(e->to);\n\t\t\t\t\t//putchar('\\n');\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\t//printf(\"(%d)\\n\", (int)(s - nodes));\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\te->flow = 0;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"\\t\\t%d\\n\", capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int stationID(int station, int day) {\n\t//sprintf(nodes[day * (n + 2) + station].info, \"{ day: %d, station: %d }\", day, station - 2);\n\treturn day * (n + 2) + station;\n}\n\ninline int solve() {\n\tconst int s = 0, t = n * (n + 2) * (m + 1) * k * 2 + 1;\n\t//nodes[s].info[0] = 's';\n\t//nodes[t].info[0] = 't';\n\n\t//puts(\"s --> { day: 0, station: 0 }\");\n\taddEdge(s, stationID(2, 0), INT_MAX);\n\t//puts(\"s --> { day: 0, station: -1 }\");\n\taddEdge(stationID(1, 0), t, INT_MAX);\n\n\tfor (int i = 1; i <= (n + 2) * (m + 1) * k * 2; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint oldStation = *currentStation[j - 1];\n\n\t\t\tcurrentStation[j - 1]++;\n\t\t\tif (currentStation[j - 1] == v[j - 1].end()) currentStation[j - 1] = v[j - 1].begin();\n\n\t\t\tint newStation = *currentStation[j - 1];\n\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, oldStation - 2, i, newStation - 2);\n\t\t\taddEdge(stationID(oldStation, i - 1), stationID(newStation, i), a[j - 1]);\n\t\t}\n\t\t\n\t\t//printf(\"s --> { day: %d, station: 0 }\\n\", i);\n\t\t//printf(\"{ day: %d, station: -1 } --> t\\n\", i);\n\t\taddEdge(stationID(1, i), t, INT_MAX);\n\t\taddEdge(s, stationID(2, i), INT_MAX);\n\t\t\n\t\tfor (int j = 3; j <= n + 2; j++) {\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, j - 2, i, j - 2);\n\t\t\taddEdge(stationID(j, i - 1), stationID(j, i), INT_MAX);\n\t\t}\n\n\t\tint flow = dinic(s, t, n * (n + 2) * (m + 1) * k * 2 + 2);\n\t\t//printf(\"%d\\n\", flow);\n\t\tif (flow >= k) return i;\n\t}\n\n\treturn 0;\n}\n\nint main() {\n\t//printf(\"%d\\n\", sizeof(nodes));\n\tfreopen(\"home.in\", \"r\", stdin);\n\tfreopen(\"home.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\n\t\tfor (int j = 0; j < t; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tv[i].push_back(x + 2);\n\t\t}\n\n\t\tcurrentStation[i] = v[i].begin();\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/ctsc1999-home.md","raw":"title: CTSC1999 - \ncategories: OI\ntags: \n  - COGS\n  - CTSC\n  - \n  - \n  - Dinic\n  -  24 \n  - \npermalink: ctsc1999-home\nid: 59\nupdated: '2016-02-24 21:42:46'\ndate: 2016-02-24 21:41:36\n---\n\n `n`  `m`  `i`  `H[i]`  1\n\n<!-- more -->\n\n### \n[COGS 736](http://cogs.top/cogs/problem/problem.php?pid=736)\n\n### \n  qwq\n\n `t` `t + 1`  0 ********\n\n 1\n\n  qwq\n\n`n`  `m` \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 13;\nconst int MAXM = 20;\nconst int MAXK = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n\t//char info[256];\n} nodes[MAXN * (MAXN + 2) * (MAXM + 1) * MAXK * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, k, a[MAXM];\nstd::vector<int> v[MAXM];\nstd::vector<int>::const_iterator currentStation[MAXM];\n\ninline void print(Node *v) {\n\t//printf(\"%s\", v->info);\n\treturn;\n\t//int x = (int)(v - nodes);\n\t//if (x == 0) putchar('s');\n\t//else if (x == n * (n + 2) * (m + 1) * k * 2 + 1) putchar('t');\n\t//else {\n\t//\tprintf(\"{ day: %d, station: %d }\", x / (n + 2), x % (n + 2) - 2);\n\t//}\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\t//print(e->from);\n\t\t\t\t\t//printf(\" -> \");\n\t\t\t\t\t//print(e->to);\n\t\t\t\t\t//putchar('\\n');\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\t//printf(\"(%d)\\n\", (int)(s - nodes));\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\te->flow = 0;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) nodes[i].currentEdge = nodes[i].firstEdge;\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"\\t\\t%d\\n\", capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int stationID(int station, int day) {\n\t//sprintf(nodes[day * (n + 2) + station].info, \"{ day: %d, station: %d }\", day, station - 2);\n\treturn day * (n + 2) + station;\n}\n\ninline int solve() {\n\tconst int s = 0, t = n * (n + 2) * (m + 1) * k * 2 + 1;\n\t//nodes[s].info[0] = 's';\n\t//nodes[t].info[0] = 't';\n\n\t//puts(\"s --> { day: 0, station: 0 }\");\n\taddEdge(s, stationID(2, 0), INT_MAX);\n\t//puts(\"s --> { day: 0, station: -1 }\");\n\taddEdge(stationID(1, 0), t, INT_MAX);\n\n\tfor (int i = 1; i <= (n + 2) * (m + 1) * k * 2; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint oldStation = *currentStation[j - 1];\n\n\t\t\tcurrentStation[j - 1]++;\n\t\t\tif (currentStation[j - 1] == v[j - 1].end()) currentStation[j - 1] = v[j - 1].begin();\n\n\t\t\tint newStation = *currentStation[j - 1];\n\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, oldStation - 2, i, newStation - 2);\n\t\t\taddEdge(stationID(oldStation, i - 1), stationID(newStation, i), a[j - 1]);\n\t\t}\n\t\t\n\t\t//printf(\"s --> { day: %d, station: 0 }\\n\", i);\n\t\t//printf(\"{ day: %d, station: -1 } --> t\\n\", i);\n\t\taddEdge(stationID(1, i), t, INT_MAX);\n\t\taddEdge(s, stationID(2, i), INT_MAX);\n\t\t\n\t\tfor (int j = 3; j <= n + 2; j++) {\n\t\t\t//printf(\"{ day: %d, station: %d } --> { day: %d, station: %d }\\n\", i - 1, j - 2, i, j - 2);\n\t\t\taddEdge(stationID(j, i - 1), stationID(j, i), INT_MAX);\n\t\t}\n\n\t\tint flow = dinic(s, t, n * (n + 2) * (m + 1) * k * 2 + 2);\n\t\t//printf(\"%d\\n\", flow);\n\t\tif (flow >= k) return i;\n\t}\n\n\treturn 0;\n}\n\nint main() {\n\t//printf(\"%d\\n\", sizeof(nodes));\n\tfreopen(\"home.in\", \"r\", stdin);\n\tfreopen(\"home.out\", \"w\", stdout);\n\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\n\t\tfor (int j = 0; j < t; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tv[i].push_back(x + 2);\n\t\t}\n\n\t\tcurrentStation[i] = v[i].begin();\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"ctsc1999-home","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6csz015rc2xls7mzmm9b"},{"title":"CTSC1997 -  DP","id":"15","updated":"2016-01-19T13:05:52.000Z","date":"2016-01-06T21:12:01.000Z","_content":"\n N<= 300  M \n\n<!-- more -->\n\n### \n[CodeVS 1378](http://codevs.cn/problem/1378/)\n\n### \n $f[i][m]$  `i`  `m` \n\n1.  `i` **** `k` `m - k - 1` ****\n2.  `i`  `m` ****\n\n$$f[i][m]={\\max}( {\\max}\\{ f[i.children][k] + f[i.next][m-k-1],k{\\in}[0,m-1] \\},f[i.next][m] )$$\n\n\n\n```C++\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n```\n\n### \n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = 300;\n\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n\nint n, m;\n\ninline void addTree(int parent, int child, int w) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent], w);\n}\n\nint solve(Tree *t, int m) {\n\tif (!t || m < 0) return 0;\n\n\tif (!t->ans[m].solved) {\n\t\tt->ans[m].value = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->children, i) + solve(t->next, m - i - 1) + t->w);\n\t\t}\n\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->next, m));\n\n\t\tt->ans[m].solved = true;\n\t}\n\n\treturn t->ans[m].value;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint parent, w;\n\t\tscanf(\"%d %d\", &parent, &w);\n\t\taddTree(parent, i, w);\n\t}\n\n\tprintf(\"%d\\n\", solve(&trees[0], m + 1));\n\n\treturn 0;\n}\n```\n","source":"_posts/ctsc1997-course.md","raw":"title: CTSC1997 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - CTSC\n  - DP\n  -  DP\npermalink: ctsc1997-course\nid: 15\nupdated: '2016-01-19 21:05:52'\ndate: 2016-01-07 05:12:01\n---\n\n N<= 300  M \n\n<!-- more -->\n\n### \n[CodeVS 1378](http://codevs.cn/problem/1378/)\n\n### \n $f[i][m]$  `i`  `m` \n\n1.  `i` **** `k` `m - k - 1` ****\n2.  `i`  `m` ****\n\n$$f[i][m]={\\max}( {\\max}\\{ f[i.children][k] + f[i.next][m-k-1],k{\\in}[0,m-1] \\},f[i.next][m] )$$\n\n\n\n```C++\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n```\n\n### \n```C++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = 300;\n\nstruct Tree {\n\tTree *children, *next;\n\tint w;\n\n\tstruct Answer {\n\t\tbool solved;\n\t\tint value;\n\n\t\tinline Answer() : solved(false) {}\n\t} ans[MAXM + 1];\n\n\tinline Tree() {}\n\tinline Tree(Tree *parent, int w) : w(w), next(parent->children) {}\n} trees[MAXN + 1];\n\nint n, m;\n\ninline void addTree(int parent, int child, int w) {\n\ttrees[parent].children = new (&trees[child]) Tree(&trees[parent], w);\n}\n\nint solve(Tree *t, int m) {\n\tif (!t || m < 0) return 0;\n\n\tif (!t->ans[m].solved) {\n\t\tt->ans[m].value = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->children, i) + solve(t->next, m - i - 1) + t->w);\n\t\t}\n\t\tt->ans[m].value = std::max(t->ans[m].value, solve(t->next, m));\n\n\t\tt->ans[m].solved = true;\n\t}\n\n\treturn t->ans[m].value;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint parent, w;\n\t\tscanf(\"%d %d\", &parent, &w);\n\t\taddTree(parent, i, w);\n\t}\n\n\tprintf(\"%d\\n\", solve(&trees[0], m + 1));\n\n\treturn 0;\n}\n```\n","slug":"ctsc1997-course","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6ctb0162c2xlkgdjun96"},{"title":"CTSC2016 & APIO2016 ","date":"2016-05-09T10:18:13.000Z","_content":"\n CTSC & APIO\n\n<!-- more -->\n\n### 5.1\n   \n QAQ  \nqwq\n\nOxer  yts1999 RP++\n\n Teachk  ovo \n\n HA CXC   \n QwQ   \n\n~~sui  Fancy ~~  \nCOGS  QwQ ~~ID ~~  \n ovo  \n NOI LinuxUbuntu 14.04 LTS  \n~~ SDOI ~~\n\nFancy  vim   \n sui ~  \n~~ JSOI  vim ~~\n\n NOI   ~~~~  \n~~~~\n\n QQ smg   \n %fqk    \n QQ  DQS    \n~~~~\n\n COGS   \nsui Menci  \n%%%%%   \n~~Mencimdzz  &@!#@%~& ~~\n\n wmd  Chenyao    \n Chenyao   \n~~mdzz ~~\n~~Chenyao  Orz~~\n\n   \n   \n  qwq\n\n### 5.2\nCTSC2016 Day1\n\n  \n \n\n     \n   \n   \n\n dms    \n     \n   \n~~mdzz ~~\n\n \n\n   \n .jpg  \nSuffix Array 5    \n\n   \n   \n   \n  \n   \n `else`   \n~~mdzz ~~\n\n   \n   \n   \n   `n`    \n~~mdzz~~ \n\n   \n   \n   \n~~ 5 ~~\n\n   \n  \n~~mdzz ~~  \n\n 5  5  \n\n   \n T3 \n\n T3    \n\n Fancy    \nFancy  \nMenci&@!#@%~&   sui    \n~~mdzz  ~~\n\n  \n 01  X    \n  \n     \n  \n 0   \n  \n  \nmdzz   0  \n\n~~ ~~\n\n    XD  \n yts1999    \n  \n   \n\n`5 + 5 + 2 = 12`    \nFancy  0  15  \n\n Fe  \n\nsui  HNOI ~~~~\n\n### 5.3\n  QAQ\n\nfaebdc  \n\n     \n Fancy  \n\n   \n   \n\n   QAQ   mdzz   \n qwq   \nsui   0.0 ovoFancy  Kindle  ovo \n\n \n\nFancy    \nwoc   fqk   \nfqkFancy   \nMenci&@!#@%~&   \nfqkwori  .jpg HA    sb   \nfqk  shenben 2333\n\n### 5.4\nCTSC2016 Day2\n\n\n\n \n\n  \n  \n\n\n QAQ   XD\n\n   \n10   \n 3  \n\n   \n 2333  \n  mdzz   \n\n   SPFA  qwq   \n  md   \nmdzz  youdu\n\n APIO2009  atm    \n Tarjan \n\nTarjan    \n   \n \n\n   \n \n\n~~mdzz ~~    \n\n\n  \n  \n\n\n `O3`   \n n    3M+  \n`checker` 20  \n\n QAQ    \n  XD\n\n \n\n Dashgua SPFA 70    \n~~mdzz ~~  \n Cu    \ndms  A \n\n  ~~mdzz ~~\n\n qwq `O(E)`  SPFA   \n Fe  QAQ\n\nyts1999Oxerdmsheheda    \n 2333 \n\n qwq  \n abclzr lzr \n\nKZ  UbuntuWindows     \n \n\n### 5.5\n\n\n \n\n  \nKZ Menci    \nFancyMenci   \n~~Menci&@!#@%~&~~  \n~~.jpg~~\n\n qvq\n\nFancy    \n \n\n N  \n\n SDOI   &@!#@%~& 233333333\n\n### 5.6\n fqk \n\n XXXX  Orz fqk \n\n qwq \n\n HNOI  APIO  qwq  \nAPIO \n\n### 5.7\nAPIO2016 Day1\n\nAPIO  qwq  vim  \n\n Johann %%% \n\n PDF  qwq\n\n \n\n   \n   \n\n\n   DP    XD\n\n     \n\n 16  \n\n~~mdzz~~     \n30.38    46.38    \n\n 42    \n WA    \n\n CMS  ~~~~  \n~~~~\n\n  \n\nT3      \nT2  2  DP   QAQ\n\n Fe  XD\n\n THU  QwQ  \n Fuxey  Sengxian   qwq  \nSengxian ****46.38  23333\n\n### 5.8\n\n\n  smg   sui      \nmdzz   XD\n\n Fancy    \n   Fancy  XD\n\n  Cu 46  \n\nzdw1999  qvq  \n \n\n HA     ~~~~\n\n~~~~\n\n COGS WWTTTTTTTT \n\n Fancy  Ubuntu KZ   XD\n\n### 5.9\nget   23333\n\n \n\n  qwq\n\n \n\n \n","source":"_posts/ctsc-apio-2016.md","raw":"title: CTSC2016 & APIO2016 \ncategories: \n  - Diary\npermalink: ctsc-apio-2016\ndate: 2016-05-09 18:18:13\n---\n\n CTSC & APIO\n\n<!-- more -->\n\n### 5.1\n   \n QAQ  \nqwq\n\nOxer  yts1999 RP++\n\n Teachk  ovo \n\n HA CXC   \n QwQ   \n\n~~sui  Fancy ~~  \nCOGS  QwQ ~~ID ~~  \n ovo  \n NOI LinuxUbuntu 14.04 LTS  \n~~ SDOI ~~\n\nFancy  vim   \n sui ~  \n~~ JSOI  vim ~~\n\n NOI   ~~~~  \n~~~~\n\n QQ smg   \n %fqk    \n QQ  DQS    \n~~~~\n\n COGS   \nsui Menci  \n%%%%%   \n~~Mencimdzz  &@!#@%~& ~~\n\n wmd  Chenyao    \n Chenyao   \n~~mdzz ~~\n~~Chenyao  Orz~~\n\n   \n   \n  qwq\n\n### 5.2\nCTSC2016 Day1\n\n  \n \n\n     \n   \n   \n\n dms    \n     \n   \n~~mdzz ~~\n\n \n\n   \n .jpg  \nSuffix Array 5    \n\n   \n   \n   \n  \n   \n `else`   \n~~mdzz ~~\n\n   \n   \n   \n   `n`    \n~~mdzz~~ \n\n   \n   \n   \n~~ 5 ~~\n\n   \n  \n~~mdzz ~~  \n\n 5  5  \n\n   \n T3 \n\n T3    \n\n Fancy    \nFancy  \nMenci&@!#@%~&   sui    \n~~mdzz  ~~\n\n  \n 01  X    \n  \n     \n  \n 0   \n  \n  \nmdzz   0  \n\n~~ ~~\n\n    XD  \n yts1999    \n  \n   \n\n`5 + 5 + 2 = 12`    \nFancy  0  15  \n\n Fe  \n\nsui  HNOI ~~~~\n\n### 5.3\n  QAQ\n\nfaebdc  \n\n     \n Fancy  \n\n   \n   \n\n   QAQ   mdzz   \n qwq   \nsui   0.0 ovoFancy  Kindle  ovo \n\n \n\nFancy    \nwoc   fqk   \nfqkFancy   \nMenci&@!#@%~&   \nfqkwori  .jpg HA    sb   \nfqk  shenben 2333\n\n### 5.4\nCTSC2016 Day2\n\n\n\n \n\n  \n  \n\n\n QAQ   XD\n\n   \n10   \n 3  \n\n   \n 2333  \n  mdzz   \n\n   SPFA  qwq   \n  md   \nmdzz  youdu\n\n APIO2009  atm    \n Tarjan \n\nTarjan    \n   \n \n\n   \n \n\n~~mdzz ~~    \n\n\n  \n  \n\n\n `O3`   \n n    3M+  \n`checker` 20  \n\n QAQ    \n  XD\n\n \n\n Dashgua SPFA 70    \n~~mdzz ~~  \n Cu    \ndms  A \n\n  ~~mdzz ~~\n\n qwq `O(E)`  SPFA   \n Fe  QAQ\n\nyts1999Oxerdmsheheda    \n 2333 \n\n qwq  \n abclzr lzr \n\nKZ  UbuntuWindows     \n \n\n### 5.5\n\n\n \n\n  \nKZ Menci    \nFancyMenci   \n~~Menci&@!#@%~&~~  \n~~.jpg~~\n\n qvq\n\nFancy    \n \n\n N  \n\n SDOI   &@!#@%~& 233333333\n\n### 5.6\n fqk \n\n XXXX  Orz fqk \n\n qwq \n\n HNOI  APIO  qwq  \nAPIO \n\n### 5.7\nAPIO2016 Day1\n\nAPIO  qwq  vim  \n\n Johann %%% \n\n PDF  qwq\n\n \n\n   \n   \n\n\n   DP    XD\n\n     \n\n 16  \n\n~~mdzz~~     \n30.38    46.38    \n\n 42    \n WA    \n\n CMS  ~~~~  \n~~~~\n\n  \n\nT3      \nT2  2  DP   QAQ\n\n Fe  XD\n\n THU  QwQ  \n Fuxey  Sengxian   qwq  \nSengxian ****46.38  23333\n\n### 5.8\n\n\n  smg   sui      \nmdzz   XD\n\n Fancy    \n   Fancy  XD\n\n  Cu 46  \n\nzdw1999  qvq  \n \n\n HA     ~~~~\n\n~~~~\n\n COGS WWTTTTTTTT \n\n Fancy  Ubuntu KZ   XD\n\n### 5.9\nget   23333\n\n \n\n  qwq\n\n \n\n \n","slug":"ctsc-apio-2016","published":1,"updated":"2016-11-20T15:49:31.201Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cth0168c2xl4k26qh9t"},{"title":"CQOI2016 -  DP","date":"2016-04-21T15:31:24.000Z","_content":"\n $ 3 $  $ 8 $  $ 4 $$ 3000988721 $$ 23333333333 $$ 14444101000 $$ 1015400080 $$ 10010012022 $\n\n $ 11 $  $ 0 $ $ L $  $ R $ $ [L, R] $ $ L $  $ R $  $ 11 $ \n\n<!-- more -->\n\n### \n[BZOJ 4521](http://www.lydsy.com/JudgeOnline/problem.php?id=4521)\n\n### \n $ F(x) $  $ x $ $ F(R) - F(L - 1) $ \n\n $ F(x) $  DP\n\n$$ f[n][limit][last][equal][flag][four][eight] $$\n\n$ 10 $  $ 4 $ $ 8 $\n\n $ < limit $\n\n DP  $ O(10 ^ 4 * 2 ^ 4) $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst long long MINN = 1e10;\nconst long long MAXN = 1e11 - 1;\nconst int LEN = 11;\n\nint a[LEN];\n\nlong long mem[LEN][11][10][2][2][2][2];\nbool calced[LEN][11][10][2][2][2][2];\n\nlong long f(const int n, const int limit, const int last, const bool equal, const bool flag, const bool four, const bool eight) {\n\tlong long &ans = mem[n][limit][last][equal][flag][four][eight];\n\tif (calced[n][limit][last][equal][flag][four][eight]) return ans;\n\tcalced[n][limit][last][equal][flag][four][eight] = true;\n\n\t// printf(\"f(n = %d, limit = %d, last = %d, [%s], [%s], [%s], [%s])\\n\", n, limit, last, equal ? \"equal\" : \"\", flag ? \"flag\" : \"\", four ? \"four\" : \"\", eight ? \"eight\" : \"\");\n\n\tans = 0;\n\tif (n == 1) {\n\t\tfor (int i = 0; i <= std::min(limit, 9); i++) {\n\t\t\tif (i == 4 && eight) continue;\n\t\t\tif (i == 8 && four) continue;\n\n\t\t\tif (flag || (equal && i == last)) ans++;\n\t\t}\n\t} else {\n\t\tint &next = a[LEN - n + 1];\n\t\tfor (int i = 0; i <= std::min(limit, 9); i++) {\n\t\t\tif (i == 4 && eight) continue;\n\t\t\tif (i == 8 && four) continue;\n\n\t\t\tint t;\n\t\t\tif (i < limit || limit > 9) {\n\t\t\t\tt = 10;\n\t\t\t} else t = next;\n\n\t\t\tans += f(n - 1, t, i, i == last, flag || (equal && i == last), four || (i == 4), eight || (i == 8));\n\t\t}\n\t}\n\n\treturn ans;\n}\n\ninline long long solve(const long long num) {\n\tif (num < MINN) return 0;\n\n\tchar s[LEN + 1];\n\tsprintf(s, \"%lld\", num);\n\tfor (int i = 0; i < LEN; i++) a[i] = s[i] - '0';\n\n\tmemset(mem, 0, sizeof(mem));\n\tmemset(calced, 0, sizeof(calced));\n\n\tint &limit = a[0];\n\tlong long ans = 0;\n\tfor (int i = 1; i <= limit; i++) {\n\t\tint t;\n\t\tif (i < limit) t = 10;\n\t\telse t = a[1];\n\t\tans += f(LEN - 1, t, i, false, false, i == 4, i == 8);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"number.in\", \"r\", stdin);\n\t// freopen(\"number.out\", \"w\", stdout);\n\n\tlong long l, r;\n\tscanf(\"%lld %lld\", &l, &r);\n\n\tlong long L = solve(l - 1), R = solve(r);\n\n\t// printf(\"%lld\\n%lld\\n\", L, R);;\n\tprintf(\"%lld\\n\", R - L);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cqoi2016-number.md","raw":"title: CQOI2016 -  DP\ndate: 2016-04-21 23:31:24\ncategories: OI\ntags:\n  - CQOI\n  - BZOJ\n  -  DP\n  - DP\npermalink: cqoi2016-number\n---\n\n $ 3 $  $ 8 $  $ 4 $$ 3000988721 $$ 23333333333 $$ 14444101000 $$ 1015400080 $$ 10010012022 $\n\n $ 11 $  $ 0 $ $ L $  $ R $ $ [L, R] $ $ L $  $ R $  $ 11 $ \n\n<!-- more -->\n\n### \n[BZOJ 4521](http://www.lydsy.com/JudgeOnline/problem.php?id=4521)\n\n### \n $ F(x) $  $ x $ $ F(R) - F(L - 1) $ \n\n $ F(x) $  DP\n\n$$ f[n][limit][last][equal][flag][four][eight] $$\n\n$ 10 $  $ 4 $ $ 8 $\n\n $ < limit $\n\n DP  $ O(10 ^ 4 * 2 ^ 4) $\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst long long MINN = 1e10;\nconst long long MAXN = 1e11 - 1;\nconst int LEN = 11;\n\nint a[LEN];\n\nlong long mem[LEN][11][10][2][2][2][2];\nbool calced[LEN][11][10][2][2][2][2];\n\nlong long f(const int n, const int limit, const int last, const bool equal, const bool flag, const bool four, const bool eight) {\n\tlong long &ans = mem[n][limit][last][equal][flag][four][eight];\n\tif (calced[n][limit][last][equal][flag][four][eight]) return ans;\n\tcalced[n][limit][last][equal][flag][four][eight] = true;\n\n\t// printf(\"f(n = %d, limit = %d, last = %d, [%s], [%s], [%s], [%s])\\n\", n, limit, last, equal ? \"equal\" : \"\", flag ? \"flag\" : \"\", four ? \"four\" : \"\", eight ? \"eight\" : \"\");\n\n\tans = 0;\n\tif (n == 1) {\n\t\tfor (int i = 0; i <= std::min(limit, 9); i++) {\n\t\t\tif (i == 4 && eight) continue;\n\t\t\tif (i == 8 && four) continue;\n\n\t\t\tif (flag || (equal && i == last)) ans++;\n\t\t}\n\t} else {\n\t\tint &next = a[LEN - n + 1];\n\t\tfor (int i = 0; i <= std::min(limit, 9); i++) {\n\t\t\tif (i == 4 && eight) continue;\n\t\t\tif (i == 8 && four) continue;\n\n\t\t\tint t;\n\t\t\tif (i < limit || limit > 9) {\n\t\t\t\tt = 10;\n\t\t\t} else t = next;\n\n\t\t\tans += f(n - 1, t, i, i == last, flag || (equal && i == last), four || (i == 4), eight || (i == 8));\n\t\t}\n\t}\n\n\treturn ans;\n}\n\ninline long long solve(const long long num) {\n\tif (num < MINN) return 0;\n\n\tchar s[LEN + 1];\n\tsprintf(s, \"%lld\", num);\n\tfor (int i = 0; i < LEN; i++) a[i] = s[i] - '0';\n\n\tmemset(mem, 0, sizeof(mem));\n\tmemset(calced, 0, sizeof(calced));\n\n\tint &limit = a[0];\n\tlong long ans = 0;\n\tfor (int i = 1; i <= limit; i++) {\n\t\tint t;\n\t\tif (i < limit) t = 10;\n\t\telse t = a[1];\n\t\tans += f(LEN - 1, t, i, false, false, i == 4, i == 8);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"number.in\", \"r\", stdin);\n\t// freopen(\"number.out\", \"w\", stdout);\n\n\tlong long l, r;\n\tscanf(\"%lld %lld\", &l, &r);\n\n\tlong long L = solve(l - 1), R = solve(r);\n\n\t// printf(\"%lld\\n%lld\\n\", L, R);;\n\tprintf(\"%lld\\n\", R - L);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cqoi2016-number","published":1,"updated":"2016-10-24T23:35:36.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6ctk016ac2xlkmlipq5s"},{"title":"CQOI2016 -  + ","date":"2016-04-21T10:57:52.000Z","_content":"\n $ s $$ t $  $ s $$ t $  $ s $$ t $  $ s $$ t $ \n\n $ N $  $ \\frac{N(N  1)}{2} $\n\n<!-- more -->\n\n### \n[BZOJ 4519](http://www.lydsy.com/JudgeOnline/problem.php?id=4519)\n\n### \n $ s $$ t $  $ S $  $ T $ \n\n $ S $ $ T $  $ u $ $ s $  $ u $  $ S' $$ T' $ $ S $  $ S' $ \n\n $ N - 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <tr1/unordered_set>\n\nconst int MAXN = 7800;\nconst int MAXM = 78000;\n\nconst int S = 1;\nconst int T = -1;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l, set, lastSet, time;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *const s, Node *const t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->l == 0) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\tconst int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f > 0) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t// printf(\"[%ld => %ld] = %d\\n\", s - N + 1, t - N + 1, f);\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\t// puts(\"Leveled!\");\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\t// printf(\"dinic(%d, %d, %d) = %d\\n\", s + 1, t + 1, n, ans);\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int u, const int v, const int c) {\n\tN[u].e = new Edge(&N[u], &N[v], c);\n\tN[v].e = new Edge(&N[v], &N[u], c);\n\tN[u].e->r = N[v].e, N[v].e->r = N[u].e;\n}\n\nint n, m;\n\ninline void cleanUp() {\n\tfor (int i = 0; i < n; i++) for (Edge *e = N[i].e; e; e = e->next) e->f = 0;\n}\n\ninline void minCut(const int s, const int t) {\n\tfor (int i = 0; i < n; i++) N[i].set = T;\n\n\tstatic int time = 0;\n\ttime++;\n\n\tconst int S = 1, T = -1;\n\n\tstd::queue<Node *> q;\n\tq.push(&N[s]);\n\tN[s].set = S;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->time != time) {\n\t\t\te->t->time = time;\n\t\t\te->t->set = S;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n}\n\ninline void reMark(const std::vector<int> &vs, const std::vector<int> &vt) {\n\tfor (std::vector<int>::const_iterator p = vs.begin(); p != vs.end(); p++) N[*p].lastSet = S;\n\tfor (std::vector<int>::const_iterator p = vt.begin(); p != vt.end(); p++) N[*p].lastSet = T;\n}\n\nstd::tr1::unordered_set<int> set;\ninline void solve(const int s, const int t, const int lastSet) {\n\tcleanUp();\n\tint f = dinic(s, t, n);\n\tset.insert(f);\n\n\tminCut(s, t);\n\tstd::vector<int> vs, vt;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].set == S && (N[i].lastSet == lastSet || lastSet == 0)) vs.push_back(i);\n\t\telse if (N[i].set == T && (N[i].lastSet == lastSet || lastSet == 0)) vt.push_back(i);\n\t}\n\n\tfor (std::vector<int>::const_iterator p = vs.begin(); p != vs.end(); p++) if (*p != s) {\n\t\treMark(vs, vt);\n\t\tsolve(s, *p, S);\n\t\tbreak;\n\t}\n\t\n\tfor (std::vector<int>::const_iterator p = vt.begin(); p != vt.end(); p++) if (*p != t) {\n\t\treMark(vs, vt);\n\t\tsolve(*p, t, T);\n\t\tbreak;\n\t}\n}\n\ninline int solve() {\n\tif (n < 2) return 0;\n\telse {\n\t\tsolve(0, 1, 0);\n\t\treturn set.size();\n\t}\n}\n\nint main() {\n\t// freopen(\"cuts.in\", \"r\", stdin);\n\t// freopen(\"cuts.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cqoi2016-cuts.md","raw":"title: CQOI2016 -  + \ndate: 2016-04-21 18:57:52\ncategories: OI\ntags:\n  - CQOI\n  - BZOJ\n  - \n  - Dinic\n  - \npermalink: cqoi2016-cuts\n---\n\n $ s $$ t $  $ s $$ t $  $ s $$ t $  $ s $$ t $ \n\n $ N $  $ \\frac{N(N  1)}{2} $\n\n<!-- more -->\n\n### \n[BZOJ 4519](http://www.lydsy.com/JudgeOnline/problem.php?id=4519)\n\n### \n $ s $$ t $  $ S $  $ T $ \n\n $ S $ $ T $  $ u $ $ s $  $ u $  $ S' $$ T' $ $ S $  $ S' $ \n\n $ N - 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <tr1/unordered_set>\n\nconst int MAXN = 7800;\nconst int MAXM = 78000;\n\nconst int S = 1;\nconst int T = -1;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l, set, lastSet, time;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *const s, Node *const t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->l == 0) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *const s, Node *const t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\tconst int f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f > 0) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t// printf(\"[%ld => %ld] = %d\\n\", s - N + 1, t - N + 1, f);\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\t// puts(\"Leveled!\");\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\t// printf(\"dinic(%d, %d, %d) = %d\\n\", s + 1, t + 1, n, ans);\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int u, const int v, const int c) {\n\tN[u].e = new Edge(&N[u], &N[v], c);\n\tN[v].e = new Edge(&N[v], &N[u], c);\n\tN[u].e->r = N[v].e, N[v].e->r = N[u].e;\n}\n\nint n, m;\n\ninline void cleanUp() {\n\tfor (int i = 0; i < n; i++) for (Edge *e = N[i].e; e; e = e->next) e->f = 0;\n}\n\ninline void minCut(const int s, const int t) {\n\tfor (int i = 0; i < n; i++) N[i].set = T;\n\n\tstatic int time = 0;\n\ttime++;\n\n\tconst int S = 1, T = -1;\n\n\tstd::queue<Node *> q;\n\tq.push(&N[s]);\n\tN[s].set = S;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->time != time) {\n\t\t\te->t->time = time;\n\t\t\te->t->set = S;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n}\n\ninline void reMark(const std::vector<int> &vs, const std::vector<int> &vt) {\n\tfor (std::vector<int>::const_iterator p = vs.begin(); p != vs.end(); p++) N[*p].lastSet = S;\n\tfor (std::vector<int>::const_iterator p = vt.begin(); p != vt.end(); p++) N[*p].lastSet = T;\n}\n\nstd::tr1::unordered_set<int> set;\ninline void solve(const int s, const int t, const int lastSet) {\n\tcleanUp();\n\tint f = dinic(s, t, n);\n\tset.insert(f);\n\n\tminCut(s, t);\n\tstd::vector<int> vs, vt;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].set == S && (N[i].lastSet == lastSet || lastSet == 0)) vs.push_back(i);\n\t\telse if (N[i].set == T && (N[i].lastSet == lastSet || lastSet == 0)) vt.push_back(i);\n\t}\n\n\tfor (std::vector<int>::const_iterator p = vs.begin(); p != vs.end(); p++) if (*p != s) {\n\t\treMark(vs, vt);\n\t\tsolve(s, *p, S);\n\t\tbreak;\n\t}\n\t\n\tfor (std::vector<int>::const_iterator p = vt.begin(); p != vt.end(); p++) if (*p != t) {\n\t\treMark(vs, vt);\n\t\tsolve(*p, t, T);\n\t\tbreak;\n\t}\n}\n\ninline int solve() {\n\tif (n < 2) return 0;\n\telse {\n\t\tsolve(0, 1, 0);\n\t\treturn set.size();\n\t}\n}\n\nint main() {\n\t// freopen(\"cuts.in\", \"r\", stdin);\n\t// freopen(\"cuts.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\n\t\taddEdge(u, v, w);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cqoi2016-cuts","published":1,"updated":"2016-05-11T09:33:24.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6ctr016hc2xldh2b6iv3"},{"title":"CQOI2011 - CDQ","date":"2016-06-20T12:10:00.000Z","_content":"\n $ A $ $ i < j $ $ A_i > A_j $  $ (i,\\ j) $  $ 1 $  $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 3295](http://www.lydsy.com/JudgeOnline/problem.php?id=3295)\n\n### \n\n\n  ****************\n\n $ a_i $  $ n - a_i + 1 $******** CDQ \n\n $ i $  $ n - i + 1 $ CDQ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 50000;\n\nstruct Triple {\n\tint id, pos, num;\n\tunsigned int *ans;\n\n\tTriple(const int pos, const int num, unsigned int *ans) : pos(pos), num(num), ans(ans) {\n\t\tstatic int id = 0;\n\t\tthis->id = id++;\n\t}\n\n\tTriple() {}\n\t\n\tbool operator<(const Triple &other) const { return id < other.id; }\n} a[MAXN];\n\nint n, m;\n\nstruct BinaryIndexedTree {\n\tunsigned int a[MAXN];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tunsigned int query(const int x) {\n\t\tunsigned int ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\t/*\n\tfor (Triple *a = l; a <= r; a++) {\n\t\tif (a->ans) {\n\t\t\tfor (Triple *b = l; b < a; b++) {\n\t\t\t\tif (b->pos < a->pos && b->num < a->num) (*a->ans)++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n\t*/\n\n\tif (l == r) return;\n\n\tTriple *m = l + (r - l) / 2;\n\n\tcdq(l, m);\n\tcdq(m + 1, r);\n\n\tstatic Triple tmp[MAXN];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = m + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= m && p1->pos <= p2->pos) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tbit.update(q->num, 1);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\tif (q->ans) *q->ans += bit.query(q->num);\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; q++, p++) {\n\t\tbit.clear(q->num);\n\t\t*p = *q;\n\t\tassert(p->num != 0);\n\t}\n}\n\n/*\ninline void print() {\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"[%d, %d, %d]%s\", a[i].id, a[i].pos, a[i].num, i == n - 1 ? \"\\n\" : \", \");\n\t}\n}\n*/\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int num[MAXN], pos[MAXN], del[MAXM];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &num[i]), pos[num[i] - 1] = i + 1;\n\n\tstatic bool deleted[MAXN];\n\tfor (int i = 0; i < m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tdel[i] = pos[x - 1];\n\t\tdeleted[del[i] - 1] = true;\n\t}\n\n\tstatic unsigned int ans[MAXN];\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; i++) if (!deleted[i - 1]) {\n\t\ta[cnt] = Triple(i, num[i - 1], &ans[n - cnt - 1]); // , printf(\"ans[%d]\\n\", n - cnt - 1);\n\t\tcnt++;\n\t}\n\n\t// const int invalidCnt = cnt;\n\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\ta[cnt++] = Triple(del[i], num[del[i] - 1], &ans[i]); // , printf(\"ans[%d]\\n\", i);\n\t}\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i].pos = n - a[i].pos + 1;\n\t}\n\t\n\t// print();\n\n\tcdq(a, a + n - 1);\n\n\tstd::sort(a, a + cnt);\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i].pos = n - a[i].pos + 1;\n\t\ta[i].num = n - a[i].num + 1;\n\t}\n\n\t// print();\n\n\tcdq(a, a + n - 1);\n\n\tfor (int i = n - 2; i >= 0; i--) ans[i] += ans[i + 1];\n\tfor (int i = 0; i < m; i++) printf(\"%u\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/cqoi2011-inverse.md","raw":"title: CQOI2011 - CDQ\ndate: 2016-06-20 20:10:00\ncategories: OI\ntags:\n  - CQOI\n  - BZOJ\n  - CDQ\n  - \n  - \n  - \npermalink: cqoi2011-inverse\n---\n\n $ A $ $ i < j $ $ A_i > A_j $  $ (i,\\ j) $  $ 1 $  $ n $  $ m $ \n\n<!-- more -->\n\n### \n[BZOJ 3295](http://www.lydsy.com/JudgeOnline/problem.php?id=3295)\n\n### \n\n\n  ****************\n\n $ a_i $  $ n - a_i + 1 $******** CDQ \n\n $ i $  $ n - i + 1 $ CDQ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXM = 50000;\n\nstruct Triple {\n\tint id, pos, num;\n\tunsigned int *ans;\n\n\tTriple(const int pos, const int num, unsigned int *ans) : pos(pos), num(num), ans(ans) {\n\t\tstatic int id = 0;\n\t\tthis->id = id++;\n\t}\n\n\tTriple() {}\n\t\n\tbool operator<(const Triple &other) const { return id < other.id; }\n} a[MAXN];\n\nint n, m;\n\nstruct BinaryIndexedTree {\n\tunsigned int a[MAXN];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tunsigned int query(const int x) {\n\t\tunsigned int ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\t/*\n\tfor (Triple *a = l; a <= r; a++) {\n\t\tif (a->ans) {\n\t\t\tfor (Triple *b = l; b < a; b++) {\n\t\t\t\tif (b->pos < a->pos && b->num < a->num) (*a->ans)++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn;\n\t*/\n\n\tif (l == r) return;\n\n\tTriple *m = l + (r - l) / 2;\n\n\tcdq(l, m);\n\tcdq(m + 1, r);\n\n\tstatic Triple tmp[MAXN];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = m + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= m && p1->pos <= p2->pos) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tbit.update(q->num, 1);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\tif (q->ans) *q->ans += bit.query(q->num);\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; q++, p++) {\n\t\tbit.clear(q->num);\n\t\t*p = *q;\n\t\tassert(p->num != 0);\n\t}\n}\n\n/*\ninline void print() {\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"[%d, %d, %d]%s\", a[i].id, a[i].pos, a[i].num, i == n - 1 ? \"\\n\" : \", \");\n\t}\n}\n*/\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int num[MAXN], pos[MAXN], del[MAXM];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &num[i]), pos[num[i] - 1] = i + 1;\n\n\tstatic bool deleted[MAXN];\n\tfor (int i = 0; i < m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tdel[i] = pos[x - 1];\n\t\tdeleted[del[i] - 1] = true;\n\t}\n\n\tstatic unsigned int ans[MAXN];\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; i++) if (!deleted[i - 1]) {\n\t\ta[cnt] = Triple(i, num[i - 1], &ans[n - cnt - 1]); // , printf(\"ans[%d]\\n\", n - cnt - 1);\n\t\tcnt++;\n\t}\n\n\t// const int invalidCnt = cnt;\n\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\ta[cnt++] = Triple(del[i], num[del[i] - 1], &ans[i]); // , printf(\"ans[%d]\\n\", i);\n\t}\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i].pos = n - a[i].pos + 1;\n\t}\n\t\n\t// print();\n\n\tcdq(a, a + n - 1);\n\n\tstd::sort(a, a + cnt);\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i].pos = n - a[i].pos + 1;\n\t\ta[i].num = n - a[i].num + 1;\n\t}\n\n\t// print();\n\n\tcdq(a, a + n - 1);\n\n\tfor (int i = n - 2; i >= 0; i--) ans[i] += ans[i + 1];\n\tfor (int i = 0; i < m; i++) printf(\"%u\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"cqoi2011-inverse","published":1,"updated":"2016-06-20T14:10:53.556Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cty016oc2xlpke52uts"},{"title":"","date":"2016-03-15T09:16:12.000Z","_content":"\n\n\n<!-- more -->\n\n### \n#### \n $ n $  $ p_i $ \n\n$$ \\sum\\limits_{i = i}^{n}p_i $$\n\n#### \n $ n $  $ p_i $ \n\n$$ \\prod\\limits_{i = i}^{n}p_i $$\n\n#### \n \n\n\n\n### \n#### \n $ n $  $ f(n) $ $ f(0) = 1 $\n\n$$ f(n) = f(n - 1) * n $$\n\n $ f(n) = n! $\n\n#### \n $ n $  $ k $  $ P(n, k) $ $ n $  $ n - 1 $  $ k $  $ n - k + 1 $ \n\n$$ P(n, k) = \\prod\\limits_{i = 0}^{k - 1}(n - i) $$\n\n $ n! $  $ n - k $ \n\n$$ P(n, k) = \\frac{n!}{(n - k)!} $$\n\n#### \n $ k $  $ i $  $ n_i $  $ n = \\sum\\limits_{i = 1}^{k}n_i $ $ n! $\n\n$$ \\frac{n!}{\\prod\\limits_{i = 1}^{k}n_i!} $$\n\n### \n#### \n n  k  $ C(n, k) $ $ P(n, k) $  n  k  k \n\n$$ P(n, k) = C(n, k) * k! $$\n\n\n\n$$\n\\begin{align*}\nC(n, k) & = \\frac{P(n, k)}{k!} \\\\\n& = \\frac{n!}{(n - k)!k!} \\\\\n\\end{align*}\n$$\n\n#### \n$ C(n, 0) = C(n, n) = 1 $ \n\n$ C(n, k) = C(n, n - k) $  $ k $  $ n - k $ \n\n$ C(n, k) = C(n - 1, k) + C(n - 1, k - 1) $ Pascal \n\n#### \n n  k  $ C(n + k - 1, k) $ \n\n#### \n##### \n Pascal \n\n```cpp\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n    for (int i = 1; i <= MAXN; i++) {\n        combo[i][0] = combo[i][i] = 1;\n        for (int j = 1; j < i; j++){\n            combo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n        }\n    }\n}\n\ninline BigInt &C(int n, int k) {\n    return combo[n][k];\n}\n```\n\n##### \n `double`  `long long` \n\n```cpp\nlong long C(long long n, long long k) {\n    long long result = 1;\n    for (int i = 1; i <= k; i++) {\n        result = result * (n - i + 1) / i;\n    }\n    return result;\n}\n```\n\n### \n#### Fibonacci \n $ n $ \n\n$$ F_n = F_{n - 1} + F_{n - 2} $$\n\n\n\n$$ F_1 = F_2 = 1 $$\n\n#### Catalan \n $ n $  $ n - 3 $  $ n - 2 $  $ f(n) $\n\n $ i $  $ V_i $ $ {V_1}{V_k}{V_n} $$ 1 \\lt k \\lt n $ $ k $  $ n - k + 1 $ \n\n$$ f(n) = \\sum\\limits_{k = 2}^{n - 1}f(k)f(n - k + 1) $$\n\n### \n#### \n $ \\{ a_1, a_2, \\cdots, a_n \\} $  $ 1 \\lt i \\leq n $  $ a_t - a_{i - 1} = d $\n\n$$ a_i = a_i + (i - 1)d $$\n\n\n\n$$\n\\begin{align*}\n\\sum\\limits_{i = i}^{n}a_i & = \\frac{(a_1 + a_n)n}{2} \\\\\n& = \\frac{[2a_1 + (n - 1)d]n}{2} \\\\\n\\end{align*}\n$$\n\n#### \n$$ \\sum\\limits_{i = 1}^{n}i^2 = \\frac{n(n + 1)(2n + 1)}{6} $$\n\n\n\n#### \n$$ (a + b) ^ n = \\sum\\limits_{k = 0}^{n}\\binom{n}{k}a^{k}b^{n - k} $$\n","source":"_posts/combinatorics-notes.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  -   \npermalink: combinatorics-notes\ndate: 2016-03-15 17:16:12\n---\n\n\n\n<!-- more -->\n\n### \n#### \n $ n $  $ p_i $ \n\n$$ \\sum\\limits_{i = i}^{n}p_i $$\n\n#### \n $ n $  $ p_i $ \n\n$$ \\prod\\limits_{i = i}^{n}p_i $$\n\n#### \n \n\n\n\n### \n#### \n $ n $  $ f(n) $ $ f(0) = 1 $\n\n$$ f(n) = f(n - 1) * n $$\n\n $ f(n) = n! $\n\n#### \n $ n $  $ k $  $ P(n, k) $ $ n $  $ n - 1 $  $ k $  $ n - k + 1 $ \n\n$$ P(n, k) = \\prod\\limits_{i = 0}^{k - 1}(n - i) $$\n\n $ n! $  $ n - k $ \n\n$$ P(n, k) = \\frac{n!}{(n - k)!} $$\n\n#### \n $ k $  $ i $  $ n_i $  $ n = \\sum\\limits_{i = 1}^{k}n_i $ $ n! $\n\n$$ \\frac{n!}{\\prod\\limits_{i = 1}^{k}n_i!} $$\n\n### \n#### \n n  k  $ C(n, k) $ $ P(n, k) $  n  k  k \n\n$$ P(n, k) = C(n, k) * k! $$\n\n\n\n$$\n\\begin{align*}\nC(n, k) & = \\frac{P(n, k)}{k!} \\\\\n& = \\frac{n!}{(n - k)!k!} \\\\\n\\end{align*}\n$$\n\n#### \n$ C(n, 0) = C(n, n) = 1 $ \n\n$ C(n, k) = C(n, n - k) $  $ k $  $ n - k $ \n\n$ C(n, k) = C(n - 1, k) + C(n - 1, k - 1) $ Pascal \n\n#### \n n  k  $ C(n + k - 1, k) $ \n\n#### \n##### \n Pascal \n\n```cpp\nBigInt combo[MAXN + 1][MAXN + 1];\n\ninline void makeComboTable() {\n    for (int i = 1; i <= MAXN; i++) {\n        combo[i][0] = combo[i][i] = 1;\n        for (int j = 1; j < i; j++){\n            combo[i][j] = combo[i - 1][j] + combo[i - 1][j - 1];\n        }\n    }\n}\n\ninline BigInt &C(int n, int k) {\n    return combo[n][k];\n}\n```\n\n##### \n `double`  `long long` \n\n```cpp\nlong long C(long long n, long long k) {\n    long long result = 1;\n    for (int i = 1; i <= k; i++) {\n        result = result * (n - i + 1) / i;\n    }\n    return result;\n}\n```\n\n### \n#### Fibonacci \n $ n $ \n\n$$ F_n = F_{n - 1} + F_{n - 2} $$\n\n\n\n$$ F_1 = F_2 = 1 $$\n\n#### Catalan \n $ n $  $ n - 3 $  $ n - 2 $  $ f(n) $\n\n $ i $  $ V_i $ $ {V_1}{V_k}{V_n} $$ 1 \\lt k \\lt n $ $ k $  $ n - k + 1 $ \n\n$$ f(n) = \\sum\\limits_{k = 2}^{n - 1}f(k)f(n - k + 1) $$\n\n### \n#### \n $ \\{ a_1, a_2, \\cdots, a_n \\} $  $ 1 \\lt i \\leq n $  $ a_t - a_{i - 1} = d $\n\n$$ a_i = a_i + (i - 1)d $$\n\n\n\n$$\n\\begin{align*}\n\\sum\\limits_{i = i}^{n}a_i & = \\frac{(a_1 + a_n)n}{2} \\\\\n& = \\frac{[2a_1 + (n - 1)d]n}{2} \\\\\n\\end{align*}\n$$\n\n#### \n$$ \\sum\\limits_{i = 1}^{n}i^2 = \\frac{n(n + 1)(2n + 1)}{6} $$\n\n\n\n#### \n$$ (a + b) ^ n = \\sum\\limits_{k = 0}^{n}\\binom{n}{k}a^{k}b^{n - k} $$\n","slug":"combinatorics-notes","published":1,"updated":"2016-05-11T09:33:24.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cu5016wc2xlumk55knn"},{"title":"COGS 746 - ","id":"53","updated":"2016-02-19T03:44:48.000Z","date":"2016-02-19T03:43:42.000Z","_content":"\n $ N * N $ \n\n<!-- more -->\n\n### \n[COGS 746](http://cogs.top/cogs/problem/problem.php?pid=746)\n\n### \n\n\n> \n\n>  S  T X  S  Y  X  Y \n\n> COGS 734 - \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 200;\nconst int MAXM = MAXN * MAXN;\n\nstruct Point {\n\tint x, y;\n\n\tPoint(int x, int y) : x(x), y(y) {}\n\n\tPoint operator+(const Point &pt) const {\n\t\treturn Point(x + pt.x, y + pt.y);\n\t}\n};\n\nconst Point turns[8] = {\n\tPoint(1, 2),\n\tPoint(2, 1),\n\tPoint(-1, -2),\n\tPoint(-2, -1),\n\tPoint(1, -2),\n\tPoint(-2, 1),\n\tPoint(-1, 2),\n\tPoint(2, -1)\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\nbool blocked[MAXN][MAXN];\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0, nodes[i].currentEdge = nodes[i].firstEdge;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn y * n + x + 1;\n}\n\nint main() {\n\tfreopen(\"knight.in\", \"r\", stdin);\n\tfreopen(\"knight.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y), x--, y--;\n\n\t\tblocked[x][y] = true;\n\t}\n\n\tconst int s = 0, t = n * n + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (blocked[i][j]) continue;\n\n\t\t\tsum++;\n\n\t\t\tint id = getNodeID(i, j);\n\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\t//printf(\"S => (%d, %d)\\n\", i + 1, j + 1);\n\t\t\t\taddEdge(s, id, 1);\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tPoint pt = Point(i, j) + turns[k];\n\t\t\t\t\tif (pt.x < 0 || pt.x > n - 1 || pt.y < 0 || pt.y > n - 1 || blocked[pt.x][pt.y]) continue;\n\n\t\t\t\t\t//printf(\"(%d, %d) => (%d, %d)\\n\", i + 1, j + 1, pt.x + 1, pt.y + 1);\n\t\t\t\t\taddEdge(id, getNodeID(pt.x, pt.y), INT_MAX);\n\t\t\t\t}\n\t\t\t} else addEdge(id, t, 1);//, printf(\"(%d, %d) => T\\n\", i + 1, j + 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * n + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-746.md","raw":"title: COGS 746 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - Dinic\n  -  24 \n  - \npermalink: cogs-746\nid: 53\nupdated: '2016-02-19 11:44:48'\ndate: 2016-02-19 11:43:42\n---\n\n $ N * N $ \n\n<!-- more -->\n\n### \n[COGS 746](http://cogs.top/cogs/problem/problem.php?pid=746)\n\n### \n\n\n> \n\n>  S  T X  S  Y  X  Y \n\n> COGS 734 - \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 200;\nconst int MAXM = MAXN * MAXN;\n\nstruct Point {\n\tint x, y;\n\n\tPoint(int x, int y) : x(x), y(y) {}\n\n\tPoint operator+(const Point &pt) const {\n\t\treturn Point(x + pt.x, y + pt.y);\n\t}\n};\n\nconst Point turns[8] = {\n\tPoint(1, 2),\n\tPoint(2, 1),\n\tPoint(-1, -2),\n\tPoint(-2, -1),\n\tPoint(1, -2),\n\tPoint(-2, 1),\n\tPoint(-1, 2),\n\tPoint(2, -1)\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge;\n\tint level;\n} nodes[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\nbool blocked[MAXN][MAXN];\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0, nodes[i].currentEdge = nodes[i].firstEdge;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->currentEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn y * n + x + 1;\n}\n\nint main() {\n\tfreopen(\"knight.in\", \"r\", stdin);\n\tfreopen(\"knight.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y), x--, y--;\n\n\t\tblocked[x][y] = true;\n\t}\n\n\tconst int s = 0, t = n * n + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (blocked[i][j]) continue;\n\n\t\t\tsum++;\n\n\t\t\tint id = getNodeID(i, j);\n\n\t\t\tif ((i + j) % 2 == 0) {\n\t\t\t\t//printf(\"S => (%d, %d)\\n\", i + 1, j + 1);\n\t\t\t\taddEdge(s, id, 1);\n\t\t\t\tfor (int k = 0; k < 8; k++) {\n\t\t\t\t\tPoint pt = Point(i, j) + turns[k];\n\t\t\t\t\tif (pt.x < 0 || pt.x > n - 1 || pt.y < 0 || pt.y > n - 1 || blocked[pt.x][pt.y]) continue;\n\n\t\t\t\t\t//printf(\"(%d, %d) => (%d, %d)\\n\", i + 1, j + 1, pt.x + 1, pt.y + 1);\n\t\t\t\t\taddEdge(id, getNodeID(pt.x, pt.y), INT_MAX);\n\t\t\t\t}\n\t\t\t} else addEdge(id, t, 1);//, printf(\"(%d, %d) => T\\n\", i + 1, j + 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * n + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-746","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cub0172c2xlvt6c4qr5"},{"title":"COGS 742 - ","id":"58","updated":"2016-02-23T13:44:58.000Z","date":"2016-02-23T13:44:06.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[COGS 742](http://cogs.top/cogs/problem/problem.php?pid=742)\n\n### \n**** 1 0\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXP = 15;\nconst int MAXQ = 15;\nconst int MAXA = 10;\nconst int MAXB = 10;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[(MAXP + 1) * (MAXQ + 1) + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint a, b, p, q;\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\t//printf(\"%d -> %d = %d\\n\", (int)(e->from - nodes), (int)(e->to - nodes), t->flow);\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\t\t//printf(\"flow += %d, cost += %d\\n\", t->flow, t->dist * t->flow);\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tassert(from < (p + 1) * (q + 1) + 2);\n\tassert(to < (p + 1) * (q + 1) + 2);\n\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * (q + 1) + y + 1;\n}\n\nint main() {\n\tfreopen(\"shinkai.in\", \"r\", stdin);\n\tfreopen(\"shinkai.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n%d %d\", &a, &b, &p, &q);\n\n\tconst int s = 0, t = (p + 1) * (q + 1) + 1;\n\n\tfor (int i = 0; i < p + 1; i++) {\n\t\tfor (int j = 0; j < q; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i, j + 1, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int j = 0; j < q + 1; j++) {\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i + 1, j, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < a; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(s, getNodeID(x, y), k, 0);\n\t}\n\n\tfor (int i = 0; i < b; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(getNodeID(x, y), t, k, 0);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, (p + 1) * (q + 1) + 2, flow, cost);\n\n\tprintf(\"%d\\n\", -cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-742.md","raw":"title: COGS 742 - \ncategories: OI\ntags: \n  - COGS\n  - Edmonds-Karp\n  -  24 \n  - \n  - \n  - \npermalink: cogs-742\nid: 58\nupdated: '2016-02-23 21:44:58'\ndate: 2016-02-23 21:44:06\n---\n\n\n\n<!-- more -->\n\n### \n[COGS 742](http://cogs.top/cogs/problem/problem.php?pid=742)\n\n### \n**** 1 0\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXP = 15;\nconst int MAXQ = 15;\nconst int MAXA = 10;\nconst int MAXB = 10;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[(MAXP + 1) * (MAXQ + 1) + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint a, b, p, q;\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\t//printf(\"%d -> %d = %d\\n\", (int)(e->from - nodes), (int)(e->to - nodes), t->flow);\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\t\t//printf(\"flow += %d, cost += %d\\n\", t->flow, t->dist * t->flow);\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tassert(from < (p + 1) * (q + 1) + 2);\n\tassert(to < (p + 1) * (q + 1) + 2);\n\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * (q + 1) + y + 1;\n}\n\nint main() {\n\tfreopen(\"shinkai.in\", \"r\", stdin);\n\tfreopen(\"shinkai.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n%d %d\", &a, &b, &p, &q);\n\n\tconst int s = 0, t = (p + 1) * (q + 1) + 1;\n\n\tfor (int i = 0; i < p + 1; i++) {\n\t\tfor (int j = 0; j < q; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i, j + 1, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i, j + 1), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int j = 0; j < q + 1; j++) {\n\t\tfor (int i = 0; i < p; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\t//printf(\"(%d, %d) -> (%d, %d) = %d\\n\", i, j, i + 1, j, x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), 1, -x);\n\t\t\taddEdge(getNodeID(i, j), getNodeID(i + 1, j), INT_MAX, 0);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < a; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(s, getNodeID(x, y), k, 0);\n\t}\n\n\tfor (int i = 0; i < b; i++) {\n\t\tint k, x, y;\n\t\tscanf(\"%d %d %d\", &k, &x, &y);\n\n\t\taddEdge(getNodeID(x, y), t, k, 0);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, (p + 1) * (q + 1) + 2, flow, cost);\n\n\tprintf(\"%d\\n\", -cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-742","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cuj017bc2xlky1mii1p"},{"title":"COGS 741 - ","id":"61","updated":"2016-02-25T07:38:10.000Z","date":"2016-02-25T07:37:15.000Z","_content":"\nG  `n`  `n` \n\n<!-- more -->\n\n### \n[COGS 741](http://cogs.top/cogs/problem/problem.php?pid=741)\n\n### \n  \n\n\n\n   1****\n\n 0 0****\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], dist[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void getDistances() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tdist[i][j] = dist[j][i] = std::min(std::abs(j - i), (n - j) + i);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"overload.in\", \"r\", stdin);\n\tfreopen(\"overload.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tsum += a[i];\n\t}\n\n\tint average = sum / n;\n\tfor (int i = 0; i < n; i++) a[i] -= average;\n\n\tgetDistances();\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) addEdge(s, i, a[i - 1], 0);\n\t\telse if (a[i - 1] < 0) addEdge(i, t, -a[i - 1], 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (a[j - 1] < 0) addEdge(i, j, INT_MAX, dist[i - 1][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-741.md","raw":"title: COGS 741 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  -  24 \n  - Edmonds-Karp\n  - \npermalink: cogs-741\nid: 61\nupdated: '2016-02-25 15:38:10'\ndate: 2016-02-25 15:37:15\n---\n\nG  `n`  `n` \n\n<!-- more -->\n\n### \n[COGS 741](http://cogs.top/cogs/problem/problem.php?pid=741)\n\n### \n  \n\n\n\n   1****\n\n 0 0****\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint flow, capacity, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], dist[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->flow * t->dist;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void getDistances() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tdist[i][j] = dist[j][i] = std::min(std::abs(j - i), (n - j) + i);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"overload.in\", \"r\", stdin);\n\tfreopen(\"overload.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tsum += a[i];\n\t}\n\n\tint average = sum / n;\n\tfor (int i = 0; i < n; i++) a[i] -= average;\n\n\tgetDistances();\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) addEdge(s, i, a[i - 1], 0);\n\t\telse if (a[i - 1] < 0) addEdge(i, t, -a[i - 1], 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i - 1] > 0) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (a[j - 1] < 0) addEdge(i, j, INT_MAX, dist[i - 1][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-741","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cuq017jc2xlcfbch6uh"},{"title":"COGS 740 - ","id":"60","updated":"2016-02-25T00:10:00.000Z","date":"2016-02-25T00:08:29.000Z","_content":"\n `n`  `n`  `i`  `j`  `c[i][j]` `n`  `n` \n\n<!-- more -->\n\n### \n[COGS 740](http://cogs.top/cogs/problem/problem.php?pid=740)\n\n### \n****\n\n 1 0 1 0 0\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXN + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0), cost(cost) {}\n};\n\nint n, a[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < n + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = n + n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(n + i, t, 1, 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, n + j, 1, a[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n + 2, flow, cost);\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"job.in\", \"r\", stdin);\n\tfreopen(\"job.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n\n\n```","source":"_posts/cogs-740.md","raw":"title: COGS 740 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  -  24 \n  - Edmonds-Karp\n  - \n  - \npermalink: cogs-740\nid: 60\nupdated: '2016-02-25 08:10:00'\ndate: 2016-02-25 08:08:29\n---\n\n `n`  `n`  `i`  `j`  `c[i][j]` `n`  `n` \n\n<!-- more -->\n\n### \n[COGS 740](http://cogs.top/cogs/problem/problem.php?pid=740)\n\n### \n****\n\n 1 0 1 0 0\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXN + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0), cost(cost) {}\n};\n\nint n, a[MAXN][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < n + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = n + n + 1;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, 1, 0);\n\t\taddEdge(n + i, t, 1, 0);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, n + j, 1, a[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + n + 2, flow, cost);\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"job.in\", \"r\", stdin);\n\tfreopen(\"job.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n\n\n```","slug":"cogs-740","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cux017rc2xln2220k5d"},{"title":"COGS 739 - ","id":"57","updated":"2016-02-23T12:35:48.000Z","date":"2016-02-20T13:37:35.000Z","_content":"\nW  `m`  `n`  `i`  $ a_i $  `j`  $ b_j $  `i`  `j`  $ c_{ij} $\n\n<!-- more -->\n\n### \n[COGS 739](http://cogs.top/cogs/problem/problem.php?pid=739)\n\n### \n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXM], b[MAXN], cost[MAXM][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < m + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = m + n + 1;\n\t\n\tfor (int i = 1; i <= m; i++) addEdge(s, i, a[i - 1], 0);\n\tfor (int j = 1; j <= n; j++) addEdge(m + j, t, b[j - 1], 0);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, m + j, INT_MAX, cost[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, m + n + 2, flow, cost);\n\t\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"tran.in\", \"r\", stdin);\n\tfreopen(\"tran.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &a[i]);\n\tfor (int j = 0; j < n; j++) scanf(\"%d\", &b[j]);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &cost[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-739.md","raw":"title: COGS 739 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - \n  - Edmonds-Karp\n  -  24 \npermalink: cogs-739\nid: 57\nupdated: '2016-02-23 20:35:48'\ndate: 2016-02-20 21:37:35\n---\n\nW  `m`  `n`  `i`  $ a_i $  `j`  $ b_j $  `i`  `j`  $ c_{ij} $\n\n<!-- more -->\n\n### \n[COGS 739](http://cogs.top/cogs/problem/problem.php?pid=739)\n\n### \n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint dist, flow;\n\tbool inQueue;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), flow(0), cost(cost), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXM], b[MAXN], cost[MAXM][MAXN];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->dist = 0;\n\t\ts->flow = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Edge *e = t->inEdge; e; e = e->from->inEdge) {\n\t\t\te->flow += t->flow;\n\t\t\te->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tflow += t->flow;\n\t\tcost += t->dist * t->flow;\n\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int solve(int d) {\n\tfor (int i = 0; i < m + n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t}\n\n\tconst int s = 0, t = m + n + 1;\n\t\n\tfor (int i = 1; i <= m; i++) addEdge(s, i, a[i - 1], 0);\n\tfor (int j = 1; j <= n; j++) addEdge(m + j, t, b[j - 1], 0);\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\taddEdge(i, m + j, INT_MAX, cost[i - 1][j - 1] * d);\n\t\t}\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, m + n + 2, flow, cost);\n\t\n\treturn cost * d;\n}\n\nint main() {\n\tfreopen(\"tran.in\", \"r\", stdin);\n\tfreopen(\"tran.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m; i++) scanf(\"%d\", &a[i]);\n\tfor (int j = 0; j < n; j++) scanf(\"%d\", &b[j]);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &cost[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(1));\n\tprintf(\"%d\\n\", solve(-1));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-739","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cv50180c2xl5hotor5q"},{"title":"COGS 738 - ","id":"52","updated":"2016-02-19T03:35:21.000Z","date":"2016-02-19T03:33:27.000Z","_content":"\n `n`  `m` \n\n1. \n2. \n3. \n\n\n\n<!-- more -->\n\n### \n[COGS 738](http://cogs.top/cogs/problem/problem.php?pid=738)\n\n### \n\n\n 1 1 0 1 1 1 0\n\n\n\n**** `s`  0 $ \\frac{(m + (m + n - 1)) * n} {2} * 2 $ $ \\frac{(m + (m + n - 1)) * n} {2} * 2 + 1 $\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXM = 20;\nconst int MAXN = 20;\nconst int L = 0, R = 1, IN = 0, OUT = 1;\n\nstruct Point {\n\tint x, y;\n\n\tPoint() {}\n\tPoint(int x, int y) : x(x), y(y) {}\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[((MAXM + (MAXM + MAXN - 1)) * MAXN / 2) * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), cost(cost), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXN][MAXM + MAXN - 1], s, t;\nint mapNode[MAXN][MAXM + MAXN - 1][2], mapEdge[MAXN][MAXM + MAXN - 1][2];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\t//printf(\"dist((%d, %d), (%d, %d)) = %d\\n\", e->to->pt1.x, e->to->pt1.y, e->to->pt2.x, e->to->pt2.y, e->to->dist);\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Node *v = t; v != s; v = v->inEdge->from) {\n\t\t\tv->inEdge->flow += t->flow;\n\t\t\tv->inEdge->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tcost += t->dist * t->flow;\n\t\tflow += t->flow;\n\t\t//printf(\"flow += %d\\n\", t->flow);\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void releaseMemory() {\n\tfor (int i = 0; i < ((m + (m + n - 1)) * n / 2) * 2 + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t\tnodes[i].firstEdge = NULL;\n\t}\n}\n\ninline void buildNetwork(int limitPerNode, int limitPerEdge) {\n\treleaseMemory();\n\tfor (int i = 0; i < m; i++) addEdge(s, mapNode[0][i][IN], 1, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\t//printf(\"i(%d) -> %d, j(%d) -> %d\\n\", i + 1, n, j + 1, m + i);\n\t\t\tint (&v)[2] = mapNode[i][j];\n\t\t\tint (&e)[2] = mapEdge[i][j];\n\t\t\t//printf(\"a[i][j] = %d\\n\", a[i][j]);\n\t\t\taddEdge(v[IN], v[OUT], limitPerNode, -a[i][j]);\n\n\t\t\tif (i == n - 1) {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to t\\n\", i + 1, j + 1, a[i][j]);\n\t\t\t\taddEdge(v[OUT], t, limitPerNode, 0);\n\t\t\t} else {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1, a[i + 1][j]);\n\t\t\t\taddEdge(v[OUT], e[L], limitPerEdge, 0);\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1 + 1, a[i + 1][j + 1]);\n\t\t\t\taddEdge(v[OUT], e[R], limitPerEdge, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int solve() {\n\tint flow, cost;\n\tedmondskarp(s, t, ((m + (m + n - 1)) * n / 2) * 2 + 2, flow, cost);\n\treturn -cost;\n}\n\ninline int task1() {\n\tbuildNetwork(1, 1);\n\treturn solve();\n}\n\ninline int task2() {\n\tbuildNetwork(INT_MAX, 1);\n\treturn solve();\n}\n\ninline int task3() {\n\tbuildNetwork(INT_MAX, INT_MAX);\n\treturn solve();\n}\n\nint main() {\n\tfreopen(\"digit.in\", \"r\", stdin);\n\tfreopen(\"digit.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\t\n\ts = 0, t = ((m + (m + n - 1)) * n / 2) * 2 + 1;\n\t//printf(\"t = %d\\n\", t);\n\t\n\tint k = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\n\t\t\tmapNode[i][j][IN] = k++;\n\t\t\tmapNode[i][j][OUT] = k++;\n\t\t\tassert(k - 1 < ((m + (m + n - 1)) * n / 2) * 2 + 1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tmapEdge[i][j][L] = mapNode[i + 1][j][IN];\n\t\t\tmapEdge[i][j][R] = mapNode[i + 1][j + 1][IN];\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", task1());\n\tprintf(\"%d\\n\", task2());\n\tprintf(\"%d\\n\", task3());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-738.md","raw":"title: COGS 738 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - \n  - Edmonds-Karp\n  -  24 \npermalink: cogs-738\nid: 52\nupdated: '2016-02-19 11:35:21'\ndate: 2016-02-19 11:33:27\n---\n\n `n`  `m` \n\n1. \n2. \n3. \n\n\n\n<!-- more -->\n\n### \n[COGS 738](http://cogs.top/cogs/problem/problem.php?pid=738)\n\n### \n\n\n 1 1 0 1 1 1 0\n\n\n\n**** `s`  0 $ \\frac{(m + (m + n - 1)) * n} {2} * 2 $ $ \\frac{(m + (m + n - 1)) * n} {2} * 2 + 1 $\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXM = 20;\nconst int MAXN = 20;\nconst int L = 0, R = 1, IN = 0, OUT = 1;\n\nstruct Point {\n\tint x, y;\n\n\tPoint() {}\n\tPoint(int x, int y) : x(x), y(y) {}\n};\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge;\n\tint flow, dist;\n\tbool inQueue;\n} nodes[((MAXM + (MAXM + MAXN - 1)) * MAXN / 2) * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow, cost;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity, int cost) : from(from), to(to), capacity(capacity), cost(cost), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, a[MAXN][MAXM + MAXN - 1], s, t;\nint mapNode[MAXN][MAXM + MAXN - 1][2], mapEdge[MAXN][MAXM + MAXN - 1][2];\n\nstruct EdmondsKarp {\n\tbool bellmanford(Node *s, Node *t, int n, int &flow, int &cost) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].dist = INT_MAX;\n\t\t\tnodes[i].inEdge = NULL;\n\t\t\tnodes[i].flow = 0;\n\t\t\tnodes[i].inQueue = false;\n\t\t}\n\n\t\ts->flow = INT_MAX;\n\t\ts->dist = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->inQueue = false;\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->dist > v->dist + e->cost) {\n\t\t\t\t\te->to->dist = v->dist + e->cost;\n\t\t\t\t\t//printf(\"dist((%d, %d), (%d, %d)) = %d\\n\", e->to->pt1.x, e->to->pt1.y, e->to->pt2.x, e->to->pt2.y, e->to->dist);\n\t\t\t\t\te->to->inEdge = e;\n\t\t\t\t\te->to->flow = std::min(v->flow, e->capacity - e->flow);\n\t\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\t\tq.push(e->to);\n\t\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (t->dist == INT_MAX) return false;\n\n\t\tfor (Node *v = t; v != s; v = v->inEdge->from) {\n\t\t\tv->inEdge->flow += t->flow;\n\t\t\tv->inEdge->reversedEdge->flow -= t->flow;\n\t\t}\n\n\t\tcost += t->dist * t->flow;\n\t\tflow += t->flow;\n\t\t//printf(\"flow += %d\\n\", t->flow);\n\t\treturn true;\n\t}\n\n\tvoid operator()(int s, int t, int n, int &flow, int &cost) {\n\t\tflow = cost = 0;\n\t\twhile (bellmanford(&nodes[s], &nodes[t], n, flow, cost));\n\t}\n} edmondskarp;\n\ninline void addEdge(int from, int to, int capacity, int cost) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity, cost);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0, -cost);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void releaseMemory() {\n\tfor (int i = 0; i < ((m + (m + n - 1)) * n / 2) * 2 + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *e = nodes[i].firstEdge; e; next = e->next, delete e, e = next);\n\t\tnodes[i].firstEdge = NULL;\n\t}\n}\n\ninline void buildNetwork(int limitPerNode, int limitPerEdge) {\n\treleaseMemory();\n\tfor (int i = 0; i < m; i++) addEdge(s, mapNode[0][i][IN], 1, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\t//printf(\"i(%d) -> %d, j(%d) -> %d\\n\", i + 1, n, j + 1, m + i);\n\t\t\tint (&v)[2] = mapNode[i][j];\n\t\t\tint (&e)[2] = mapEdge[i][j];\n\t\t\t//printf(\"a[i][j] = %d\\n\", a[i][j]);\n\t\t\taddEdge(v[IN], v[OUT], limitPerNode, -a[i][j]);\n\n\t\t\tif (i == n - 1) {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to t\\n\", i + 1, j + 1, a[i][j]);\n\t\t\t\taddEdge(v[OUT], t, limitPerNode, 0);\n\t\t\t} else {\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1, a[i + 1][j]);\n\t\t\t\taddEdge(v[OUT], e[L], limitPerEdge, 0);\n\t\t\t\t//printf(\"OUT(%d, %d) = %d to IN(%d, %d) = %d\\n\", i + 1, j + 1, a[i][j], i + 1 + 1, j + 1 + 1, a[i + 1][j + 1]);\n\t\t\t\taddEdge(v[OUT], e[R], limitPerEdge, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int solve() {\n\tint flow, cost;\n\tedmondskarp(s, t, ((m + (m + n - 1)) * n / 2) * 2 + 2, flow, cost);\n\treturn -cost;\n}\n\ninline int task1() {\n\tbuildNetwork(1, 1);\n\treturn solve();\n}\n\ninline int task2() {\n\tbuildNetwork(INT_MAX, 1);\n\treturn solve();\n}\n\ninline int task3() {\n\tbuildNetwork(INT_MAX, INT_MAX);\n\treturn solve();\n}\n\nint main() {\n\tfreopen(\"digit.in\", \"r\", stdin);\n\tfreopen(\"digit.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\t\n\ts = 0, t = ((m + (m + n - 1)) * n / 2) * 2 + 1;\n\t//printf(\"t = %d\\n\", t);\n\t\n\tint k = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\n\t\t\tmapNode[i][j][IN] = k++;\n\t\t\tmapNode[i][j][OUT] = k++;\n\t\t\tassert(k - 1 < ((m + (m + n - 1)) * n / 2) * 2 + 1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tfor (int j = 0; j < m + i; j++) {\n\t\t\tmapEdge[i][j][L] = mapNode[i + 1][j][IN];\n\t\t\tmapEdge[i][j][R] = mapNode[i + 1][j + 1][IN];\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", task1());\n\tprintf(\"%d\\n\", task2());\n\tprintf(\"%d\\n\", task3());\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-738","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cvc0188c2xl2o3l0h16"},{"title":"COGS 734 - ","id":"51","updated":"2016-02-15T09:03:18.000Z","date":"2016-02-15T09:02:01.000Z","_content":"\n $ M * N $ \n\n<!-- more -->\n\n### \n[COGS 734](http://cogs.top/cogs/problem/problem.php?pid=734)\n\n### \n\n\n  ****\n\n\n\n S  T X  S  Y  X  Y \n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 30;\nconst int MAXM = 30;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN * MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * n + y + 1;\n}\n\nint main() {\n\tfreopen(\"grid.in\", \"r\", stdin);\n\tfreopen(\"grid.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tconst int s = 0, t = n * m + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint num;\n\t\t\tscanf(\"%d\", &num);\n\t\t\tsum += num;\n\n\t\t\tint id = getNodeID(i, j);\n\t\t\tbool flag = (i + j) % 2 == 0;\n\n\t\t\tif (flag) addEdge(s, id, num);\n\t\t\telse addEdge(id, t, num);\n\n\t\t\tif (flag) {\n\t\t\t\tif (i > 0) addEdge(id, getNodeID(i - 1, j), INT_MAX);\n\t\t\t\tif (i < m - 1) addEdge(id, getNodeID(i + 1, j), INT_MAX);\n\t\t\t\tif (j > 0) addEdge(id, getNodeID(i, j - 1), INT_MAX);\n\t\t\t\tif (j < n - 1) addEdge(id, getNodeID(i, j + 1), INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/cogs-734.md","raw":"title: COGS 734 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - Dinic\n  -  24 \n  - \npermalink: cogs-734\nid: 51\nupdated: '2016-02-15 17:03:18'\ndate: 2016-02-15 17:02:01\n---\n\n $ M * N $ \n\n<!-- more -->\n\n### \n[COGS 734](http://cogs.top/cogs/problem/problem.php?pid=734)\n\n### \n\n\n  ****\n\n\n\n S  T X  S  Y  X  Y \n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 30;\nconst int MAXM = 30;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN * MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int getNodeID(int x, int y) {\n\treturn x * n + y + 1;\n}\n\nint main() {\n\tfreopen(\"grid.in\", \"r\", stdin);\n\tfreopen(\"grid.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tconst int s = 0, t = n * m + 1;\n\n\tint sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint num;\n\t\t\tscanf(\"%d\", &num);\n\t\t\tsum += num;\n\n\t\t\tint id = getNodeID(i, j);\n\t\t\tbool flag = (i + j) % 2 == 0;\n\n\t\t\tif (flag) addEdge(s, id, num);\n\t\t\telse addEdge(id, t, num);\n\n\t\t\tif (flag) {\n\t\t\t\tif (i > 0) addEdge(id, getNodeID(i - 1, j), INT_MAX);\n\t\t\t\tif (i < m - 1) addEdge(id, getNodeID(i + 1, j), INT_MAX);\n\t\t\t\tif (j > 0) addEdge(id, getNodeID(i, j - 1), INT_MAX);\n\t\t\t\tif (j < n - 1) addEdge(id, getNodeID(i, j + 1), INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"cogs-734","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cvj018gc2xl8sc8taqf"},{"title":"COGS 731 -  DP + ","id":"48","updated":"2016-02-09T06:40:10.000Z","date":"2016-02-09T06:37:32.000Z","_content":"\n `X1 ~ Xn`\n\n1.  `s`\n2.  `s` \n3.  `X1`  `Xn` `s` \n\n<!-- more -->\n\n### \n[COGS 731](http://cogs.top/cogs/problem/problem.php?pid=731)\n\n### \n****\n\n $X_i$  $F_i$ $F_i$ $K$\n\n\n\n1.  $F_i = K$  1\n2.  $F_i = 1$  1\n3. $ X_jX_i $$F_i=F_j+1$ `i``j` `j`  `i`  1\n\n\n\n `i`  `i`  `i'` `i` `i'`  `i`  `i'`  1  1\n\n `1``n` \n\n**** 1NN\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 500;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], f[MAXN], k;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int dp() {\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint last = 0;\n\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j] <= a[i] && f[j] > last) last = f[j];\n\t\t}\n\n\t\tf[i] = last + 1;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\treturn ans;\n}\n\ninline int solve2() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(i, i + n, 1);\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, 1);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, 1);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\ninline int solve3() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint capacity = 1;\n\t\tif (i == 1 || i == n) capacity = INT_MAX;\n\n\t\taddEdge(i, i + n, capacity) ;\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, capacity);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, capacity);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1 && a[j - 1] <= a[i - 1]) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\nint main() {\n\tfreopen(\"alis.in\", \"r\", stdin);\n\tfreopen(\"alis.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tk = dp();\n\tprintf(\"%d\\n\", k);\n\n\tif (k == 1) printf(\"%d\\n%d\\n\", n, n);\n\telse {\n\t\tprintf(\"%d\\n\", solve2());\n\t\tprintf(\"%d\\n\", solve3());\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-731.md","raw":"title: COGS 731 -  DP + \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - Dinic\n  -  24 \npermalink: cogs-731\nid: 48\nupdated: '2016-02-09 14:40:10'\ndate: 2016-02-09 14:37:32\n---\n\n `X1 ~ Xn`\n\n1.  `s`\n2.  `s` \n3.  `X1`  `Xn` `s` \n\n<!-- more -->\n\n### \n[COGS 731](http://cogs.top/cogs/problem/problem.php?pid=731)\n\n### \n****\n\n $X_i$  $F_i$ $F_i$ $K$\n\n\n\n1.  $F_i = K$  1\n2.  $F_i = 1$  1\n3. $ X_jX_i $$F_i=F_j+1$ `i``j` `j`  `i`  1\n\n\n\n `i`  `i`  `i'` `i` `i'`  `i`  `i'`  1  1\n\n `1``n` \n\n**** 1NN\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 500;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, a[MAXN], f[MAXN], k;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline int dp() {\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint last = 0;\n\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j] <= a[i] && f[j] > last) last = f[j];\n\t\t}\n\n\t\tf[i] = last + 1;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\treturn ans;\n}\n\ninline int solve2() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(i, i + n, 1);\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, 1);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, 1);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\ninline int solve3() {\n\tmemset(nodes, 0, sizeof(Node) * (n * 2 + 2));\n\n\tconst int s = 0, t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint capacity = 1;\n\t\tif (i == 1 || i == n) capacity = INT_MAX;\n\n\t\taddEdge(i, i + n, capacity) ;\n\n\t\tif (f[i - 1] == 1) addEdge(s, i, capacity);\n\t\telse if (f[i - 1] == k) addEdge(i + n, t, capacity);\n\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (f[j - 1] == f[i - 1] - 1 && a[j - 1] <= a[i - 1]) addEdge(j + n, i, 1);\n\t\t}\n\t}\n\n\treturn dinic(s, t, n * 2 + 2);\n}\n\nint main() {\n\tfreopen(\"alis.in\", \"r\", stdin);\n\tfreopen(\"alis.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tk = dp();\n\tprintf(\"%d\\n\", k);\n\n\tif (k == 1) printf(\"%d\\n%d\\n\", n, n);\n\telse {\n\t\tprintf(\"%d\\n\", solve2());\n\t\tprintf(\"%d\\n\", solve3());\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-731","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cvq018oc2xluiysn7mv"},{"title":"COGS 729 - ","id":"47","updated":"2016-02-09T06:41:05.000Z","date":"2016-02-09T05:42:59.000Z","_content":"\n `m`  `ri` `n`  `ci` \n\n\n\n<!-- more -->\n\n### \n[COGS 729](http://cogs.top/cogs/problem/problem.php?pid=729)\n\n### \n\n\n****\n\n `S` `S`  `T` `T`  `1`\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 270;\nconst int MAXM = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint m, n;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint main() {\n\tfreopen(\"roundtable.in\", \"r\", stdin);\n\tfreopen(\"roundtable.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m + n + 2; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = m + n + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsum += x;\n\n\t\taddEdge(s, i, x);\n\n\t\tfor (int j = m + 1; j <= m + n; j++) addEdge(i, j, 1);\n\t}\n\n\tfor (int i = m + 1; i <= m + n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, m + n + 2);\n\tif (maxFlow == sum) {\n\t\tputs(\"1\");\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tstd::vector<int> v;\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->id > m && e->to->id <= m + n && e->flow == e->capacity) {\n\t\t\t\t\tv.push_back(e->to->id - m);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstd::sort(v.begin(), v.end());\n\n\t\t\tfor (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) {\n\t\t\t\tprintf(\"%d \", *p);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t} else puts(\"0\");\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-729.md","raw":"title: COGS 729 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  -  24 \n  - Dinic\npermalink: cogs-729\nid: 47\nupdated: '2016-02-09 14:41:05'\ndate: 2016-02-09 13:42:59\n---\n\n `m`  `ri` `n`  `ci` \n\n\n\n<!-- more -->\n\n### \n[COGS 729](http://cogs.top/cogs/problem/problem.php?pid=729)\n\n### \n\n\n****\n\n `S` `S`  `T` `T`  `1`\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 270;\nconst int MAXM = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n} nodes[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint m, n;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(e->capacity - e->flow, limit));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nint main() {\n\tfreopen(\"roundtable.in\", \"r\", stdin);\n\tfreopen(\"roundtable.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &m, &n);\n\n\tfor (int i = 0; i < m + n + 2; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = m + n + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsum += x;\n\n\t\taddEdge(s, i, x);\n\n\t\tfor (int j = m + 1; j <= m + n; j++) addEdge(i, j, 1);\n\t}\n\n\tfor (int i = m + 1; i <= m + n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, m + n + 2);\n\tif (maxFlow == sum) {\n\t\tputs(\"1\");\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tstd::vector<int> v;\n\t\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->id > m && e->to->id <= m + n && e->flow == e->capacity) {\n\t\t\t\t\tv.push_back(e->to->id - m);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstd::sort(v.begin(), v.end());\n\n\t\t\tfor (std::vector<int>::const_iterator p = v.begin(); p != v.end(); p++) {\n\t\t\t\tprintf(\"%d \", *p);\n\t\t\t}\n\t\t\tputchar('\\n');\n\t\t}\n\t} else puts(\"0\");\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-729","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cvx018vc2xlo3qz61yo"},{"title":"COGS 728 - ","id":"45","updated":"2016-02-06T14:53:58.000Z","date":"2016-02-06T14:52:12.000Z","_content":"\n $G=(V,E)$  P  G  V  P  P  G P  V  0G  G \n\n G \n\n<!-- more -->\n\n### \n[COGS 728](http://cogs.top/cogs/problem/problem.php?pid=728)\n\n### \n 1 1\n\n\n\n `(u, v)` `u`  `v` \n\n \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, level;\n\tbool visited;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void printPath(Node *v) {\n\tprintf(\"%d \", v->id);\n\n\tv->visited = true;\n\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\tif (e->flow == e->capacity && e->to->id != 0 && !nodes[e->to->id].visited) {\n\t\t\tprintPath(&nodes[e->to->id]);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"path3.in\", \"r\", stdin);\n\tfreopen(\"path3.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1), addEdge(i + n, t, 1), nodes[i].id = nodes[i + n].id = i;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u, v + n, 1);\n\t}\n\n\tint maxMatch = dinic(s, t, n * 2 + 2);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!nodes[i].visited) {\n\t\t\tprintPath(&nodes[i]);\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", n - maxMatch);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-728.md","raw":"title: COGS 728 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - Dinic\n  - \n  -  24 \npermalink: cogs-728\nid: 45\nupdated: '2016-02-06 22:53:58'\ndate: 2016-02-06 22:52:12\n---\n\n $G=(V,E)$  P  G  V  P  P  G P  V  0G  G \n\n G \n\n<!-- more -->\n\n### \n[COGS 728](http://cogs.top/cogs/problem/problem.php?pid=728)\n\n### \n 1 1\n\n\n\n `(u, v)` `u`  `v` \n\n \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 150;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, level;\n\tbool visited;\n} nodes[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void printPath(Node *v) {\n\tprintf(\"%d \", v->id);\n\n\tv->visited = true;\n\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\tif (e->flow == e->capacity && e->to->id != 0 && !nodes[e->to->id].visited) {\n\t\t\tprintPath(&nodes[e->to->id]);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"path3.in\", \"r\", stdin);\n\tfreopen(\"path3.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n * 2 + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(s, i, 1), addEdge(i + n, t, 1), nodes[i].id = nodes[i + n].id = i;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u, v + n, 1);\n\t}\n\n\tint maxMatch = dinic(s, t, n * 2 + 2);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!nodes[i].visited) {\n\t\t\tprintPath(&nodes[i]);\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", n - maxMatch);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-728","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cw30192c2xlhihsc9gg"},{"title":"COGS 727 - ","id":"49","updated":"2016-02-15T00:45:03.000Z","date":"2016-02-15T00:39:38.000Z","_content":"\nW  $ E = \\{ E1, E2, , Em \\} $ $ I = \\{ I1, I2, , In \\} $ $ E_j $  $ R_jI $ $ I_k $  $ c_k $ $ E_j $  $ p_j $ \n\n<!-- more -->\n\n### \n[COGS 727](http://cogs.top/cogs/problem/problem.php?pid=727)\n\n### \n  ****\n\n********************\n\n Dinic ******** BFSBFS  `S`  `T`  `S`  `T` \n\n `std::set_difference` \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <queue>\n#include <list>\n#include <utility>\n#include <vector>\n#include <set>\n#include <iterator>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n\tbool flag;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\nstd::list<std::pair<Node *, Node *> > edgeList;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n\n\tedgeList.push_back(std::make_pair(&nodes[from], &nodes[to]));\n}\n\ninline void minCut(int s) {\n\tstd::queue<Node *> q;;\n\tq.push(&nodes[s]);\n\tnodes[s].flag = true;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && !e->to->flag) {\n\t\t\t\te->to->flag = true;\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::list<std::pair<Node *, Node *> >::iterator p = edgeList.begin();\n\twhile (p != edgeList.end()) {\n\t\tif (p->first->flag && !p->second->flag) p++;\n\t\telse p = edgeList.erase(p);\n\t}\n}\n\nint main() {\n\tfreopen(\"shuttle.in\", \"r\", stdin);\n\tfreopen(\"shuttle.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n\", &m, &n);\n\n\tfor (int i = 0; i < n + m + 1; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = n + m + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tstd::string str;\n\t\tstd::getline(std::cin, str);\n\n\t\tstd::stringstream ss;\n\t\tss << str;\n\n\t\tint x;\n\t\tss >> x;\n\t\tsum += x;\n\t\taddEdge(s, n + i, x);\n\n\t\twhile (!ss.eof()) {\n\t\t\tss >> x;\n\t\t\taddEdge(n + i, x, INT_MAX);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\n\tminCut(s);\n\n\tstd::vector<int> v;\n\tstd::set<int> set, setAll;\n\tfor (std::list<std::pair<Node *, Node *> >::const_iterator p = edgeList.begin(); p != edgeList.end(); p++) {\n\t\tif (p->first->id == s) set.insert(p->second->id - n);\n\t\telse v.push_back(p->first->id);\n\t}\n\n\tfor (int i = 1; i <= m; i++) setAll.insert(i);\n\n\tstd::set<int> setDifference;\n\tstd::set_difference(setAll.begin(), setAll.end(), set.begin(), set.end(), std::inserter(setDifference, setDifference.begin()));\n\tstd::copy(setDifference.begin(), setDifference.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\t\n\tstd::sort(v.begin(), v.end());\n\tstd::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-727.md","raw":"title: COGS 727 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - Dinic\n  -  24 \n  - \npermalink: cogs-727\nid: 49\nupdated: '2016-02-15 08:45:03'\ndate: 2016-02-15 08:39:38\n---\n\nW  $ E = \\{ E1, E2, , Em \\} $ $ I = \\{ I1, I2, , In \\} $ $ E_j $  $ R_jI $ $ I_k $  $ c_k $ $ E_j $  $ p_j $ \n\n<!-- more -->\n\n### \n[COGS 727](http://cogs.top/cogs/problem/problem.php?pid=727)\n\n### \n  ****\n\n********************\n\n Dinic ******** BFSBFS  `S`  `T`  `S`  `T` \n\n `std::set_difference` \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <queue>\n#include <list>\n#include <utility>\n#include <vector>\n#include <set>\n#include <iterator>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level, id;\n\tbool flag;\n} nodes[MAXM + MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), next(from->firstEdge), capacity(capacity), flow(0) {}\n};\n\nint n, m;\nstd::list<std::pair<Node *, Node *> > edgeList;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t, int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t], n)) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t], INT_MAX)) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n\n\tedgeList.push_back(std::make_pair(&nodes[from], &nodes[to]));\n}\n\ninline void minCut(int s) {\n\tstd::queue<Node *> q;;\n\tq.push(&nodes[s]);\n\tnodes[s].flag = true;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->flow < e->capacity && !e->to->flag) {\n\t\t\t\te->to->flag = true;\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::list<std::pair<Node *, Node *> >::iterator p = edgeList.begin();\n\twhile (p != edgeList.end()) {\n\t\tif (p->first->flag && !p->second->flag) p++;\n\t\telse p = edgeList.erase(p);\n\t}\n}\n\nint main() {\n\tfreopen(\"shuttle.in\", \"r\", stdin);\n\tfreopen(\"shuttle.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\\n\", &m, &n);\n\n\tfor (int i = 0; i < n + m + 1; i++) nodes[i].id = i;\n\n\tconst int s = 0, t = n + m + 1;\n\n\tint sum = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tstd::string str;\n\t\tstd::getline(std::cin, str);\n\n\t\tstd::stringstream ss;\n\t\tss << str;\n\n\t\tint x;\n\t\tss >> x;\n\t\tsum += x;\n\t\taddEdge(s, n + i, x);\n\n\t\twhile (!ss.eof()) {\n\t\t\tss >> x;\n\t\t\taddEdge(n + i, x, INT_MAX);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\taddEdge(i, t, x);\n\t}\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\n\tminCut(s);\n\n\tstd::vector<int> v;\n\tstd::set<int> set, setAll;\n\tfor (std::list<std::pair<Node *, Node *> >::const_iterator p = edgeList.begin(); p != edgeList.end(); p++) {\n\t\tif (p->first->id == s) set.insert(p->second->id - n);\n\t\telse v.push_back(p->first->id);\n\t}\n\n\tfor (int i = 1; i <= m; i++) setAll.insert(i);\n\n\tstd::set<int> setDifference;\n\tstd::set_difference(setAll.begin(), setAll.end(), set.begin(), set.end(), std::inserter(setDifference, setDifference.begin()));\n\tstd::copy(setDifference.begin(), setDifference.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\t\n\tstd::sort(v.begin(), v.end());\n\tstd::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, \" \"));\n\tstd::cout << std::endl;\n\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-727","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cwb019ac2xll827ieda"},{"title":"COGS 439 -  + ","id":"50","updated":"2016-02-15T02:17:27.000Z","date":"2016-02-15T02:13:28.000Z","_content":"\n `n`  BUG `m`  BUG  BUG  BUG  BUG  BUG  BUG  BUG \n\n<!-- more -->\n\n### \n[COGS 439](http://cogs.top/cogs/problem/problem.php?pid=439)\n\n### \n `unsigned int`  `i`  `i`  BUG  `std::tr1::unordered_map` `map[status]`  `status` \n\n `effectAddition``effectSubtract` BUG BUG\n\n```cpp\nnewStatus = ~(~(status | effectAddition) | effectSubtract)\n```\n\n BUG  BUG  BUG\n\n```cpp\n  \t((status | conditionAny) & conditionTrue)\n\t\t== (conditionTrue | conditionAny)\n&&\t(~status & conditionFalse)\n\t\t== conditionFalse\n```\n\n COGS  \n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <tr1/unordered_map>\n#include <queue>\n\nconst int MAXN = 20;\nconst int MAXM = 100;\n\nstruct Patch {\n\tunsigned int conditionTrue, conditionFalse, conditionAny;\n\tunsigned int effectAddition, effectSubtract;\n\tint time;\n} patches[MAXM];\n\nint n, m;\nstd::tr1::unordered_map<unsigned int, int> map;\n\ninline void setBit(unsigned int &status, int i, bool flag) {\n\tif (flag) status |= (1 << i);\n\telse status &= ~(1 << i);\n}\n\ninline bool getBit(unsigned int &status, int i) {\n\treturn ((status >> i) & 1) == 1;\n}\n\ninline void printStatus(unsigned int status, bool newLine = true) {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (getBit(status, i) == true) putchar('1');\n\t\telse putchar('0');\n\t}\n\n\tif (newLine) putchar('\\n');\n}\n\ninline void bfs(unsigned int start) {\n\tstd::queue<unsigned int> q;\n\tq.push(start);\n\tmap[start] = 0;\n\n\twhile (!q.empty()) {\n\t\tunsigned int status = q.front();\n\t\t//printStatus(status);\n\t\tq.pop();\n\n\t\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\t\tif (!(\n\t\t\t\t\t\t((status | p->conditionAny) & p->conditionTrue)\n\t\t\t\t\t\t\t== (p->conditionTrue | p->conditionAny)\n\t\t\t\t\t&&\t(~status & p->conditionFalse)\n\t\t\t\t\t\t\t== p->conditionFalse\n\t\t\t)) continue;\n\t\t\t\n\t\t\tunsigned int newStatus = ~(~(status | p->effectAddition) | p->effectSubtract);\n\n\t\t\tint step = map[status];\n\t\t\tif (map.count(newStatus) != 0 && map[newStatus] <= step + p->time) continue;\n\n\t\t\t//printf(\"from `\"), printStatus(status, false), printf(\"` useing `%d(%s, %s)`  to `\", (int)(p - patches + 1), p->condition, p->effect), printStatus(newStatus, false), printf(\"`\\n\");\n\n\t\t\tmap[newStatus] = step + p->time;\n\t\t\tq.push(newStatus);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"bugs.in\", \"r\", stdin);\n\tfreopen(\"bugs.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\tchar condition[MAXN + 1], effect[MAXN + 1];\n\t\tscanf(\"%d %s %s\", &p->time, condition, effect);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (condition[i] == '0') setBit(p->conditionAny, i, true), setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '+') setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '-') setBit(p->conditionFalse, i, true);\n\n\t\t\tif (effect[i] == '+') setBit(p->effectAddition, i, true);\n\t\t\telse if (effect[i] == '-') setBit(p->effectSubtract, i, true);\n\t\t}\n\t}\n\n\tunsigned int status = 0;\n\tfor (int i = 0; i < n; i++) setBit(status, i, true);\n\n\tbfs(status);\n\n\tif (map.count(0) == 0) puts(\"-1\");\n\telse printf(\"%d\\n\", map[0]);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n\n### \n 24 ~~~~","source":"_posts/cogs-439.md","raw":"title: COGS 439 -  + \ncategories: OI\ntags: \n  - \n  - \n  - \n  - COGS\n  -  24 \n  - map\npermalink: cogs-439\nid: 50\nupdated: '2016-02-15 10:17:27'\ndate: 2016-02-15 10:13:28\n---\n\n `n`  BUG `m`  BUG  BUG  BUG  BUG  BUG  BUG  BUG \n\n<!-- more -->\n\n### \n[COGS 439](http://cogs.top/cogs/problem/problem.php?pid=439)\n\n### \n `unsigned int`  `i`  `i`  BUG  `std::tr1::unordered_map` `map[status]`  `status` \n\n `effectAddition``effectSubtract` BUG BUG\n\n```cpp\nnewStatus = ~(~(status | effectAddition) | effectSubtract)\n```\n\n BUG  BUG  BUG\n\n```cpp\n  \t((status | conditionAny) & conditionTrue)\n\t\t== (conditionTrue | conditionAny)\n&&\t(~status & conditionFalse)\n\t\t== conditionFalse\n```\n\n COGS  \n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <tr1/unordered_map>\n#include <queue>\n\nconst int MAXN = 20;\nconst int MAXM = 100;\n\nstruct Patch {\n\tunsigned int conditionTrue, conditionFalse, conditionAny;\n\tunsigned int effectAddition, effectSubtract;\n\tint time;\n} patches[MAXM];\n\nint n, m;\nstd::tr1::unordered_map<unsigned int, int> map;\n\ninline void setBit(unsigned int &status, int i, bool flag) {\n\tif (flag) status |= (1 << i);\n\telse status &= ~(1 << i);\n}\n\ninline bool getBit(unsigned int &status, int i) {\n\treturn ((status >> i) & 1) == 1;\n}\n\ninline void printStatus(unsigned int status, bool newLine = true) {\n\tfor (int i = 0; i < n; i++) {\n\t\tif (getBit(status, i) == true) putchar('1');\n\t\telse putchar('0');\n\t}\n\n\tif (newLine) putchar('\\n');\n}\n\ninline void bfs(unsigned int start) {\n\tstd::queue<unsigned int> q;\n\tq.push(start);\n\tmap[start] = 0;\n\n\twhile (!q.empty()) {\n\t\tunsigned int status = q.front();\n\t\t//printStatus(status);\n\t\tq.pop();\n\n\t\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\t\tif (!(\n\t\t\t\t\t\t((status | p->conditionAny) & p->conditionTrue)\n\t\t\t\t\t\t\t== (p->conditionTrue | p->conditionAny)\n\t\t\t\t\t&&\t(~status & p->conditionFalse)\n\t\t\t\t\t\t\t== p->conditionFalse\n\t\t\t)) continue;\n\t\t\t\n\t\t\tunsigned int newStatus = ~(~(status | p->effectAddition) | p->effectSubtract);\n\n\t\t\tint step = map[status];\n\t\t\tif (map.count(newStatus) != 0 && map[newStatus] <= step + p->time) continue;\n\n\t\t\t//printf(\"from `\"), printStatus(status, false), printf(\"` useing `%d(%s, %s)`  to `\", (int)(p - patches + 1), p->condition, p->effect), printStatus(newStatus, false), printf(\"`\\n\");\n\n\t\t\tmap[newStatus] = step + p->time;\n\t\t\tq.push(newStatus);\n\t\t}\n\t}\n}\n\nint main() {\n\tfreopen(\"bugs.in\", \"r\", stdin);\n\tfreopen(\"bugs.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (Patch *p = patches; p != patches + m; p++) {\n\t\tchar condition[MAXN + 1], effect[MAXN + 1];\n\t\tscanf(\"%d %s %s\", &p->time, condition, effect);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (condition[i] == '0') setBit(p->conditionAny, i, true), setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '+') setBit(p->conditionTrue, i, true);\n\t\t\telse if (condition[i] == '-') setBit(p->conditionFalse, i, true);\n\n\t\t\tif (effect[i] == '+') setBit(p->effectAddition, i, true);\n\t\t\telse if (effect[i] == '-') setBit(p->effectSubtract, i, true);\n\t\t}\n\t}\n\n\tunsigned int status = 0;\n\tfor (int i = 0; i < n; i++) setBit(status, i, true);\n\n\tbfs(status);\n\n\tif (map.count(0) == 0) puts(\"-1\");\n\telse printf(\"%d\\n\", map[0]);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n\n### \n 24 ~~~~","slug":"cogs-439","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cwj019ic2xla8jsi931"},{"title":"COGS 396 - ","id":"46","updated":"2016-02-06T15:04:22.000Z","date":"2016-02-06T15:02:55.000Z","_content":"\n `n` n 1234 ...... \n\n1. \n2.  2 \n\n `n` \n\n<!-- more -->\n\n### \n[COGS 396](http://cogs.top/cogs/problem/problem.php?pid=396)\n\n### \n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nconst int MAXN = 60;\n\nint n;\nstd::vector<int> v[MAXN];\n\ninline bool isSquareNumber(int x) {\n\tint root = floor(sqrt(x));\n\treturn root * root == x;\n}\n\nint main() {\n\tfreopen(\"balla.in\", \"r\", stdin);\n\tfreopen(\"balla.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint x = 1;\n\tfor (int k = 1; k <= n; k++) {\n\t\twhile (20000528) {\n\t\t\tbool flag = false;\n\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tif (v[i].empty() || isSquareNumber(v[i].back() + x)) {\n\t\t\t\t\tv[i].push_back(x++);\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!flag) break;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", x - 1);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-396.md","raw":"title: COGS 396 - \ncategories: OI\ntags: \n  - COGS\n  - \n  -  24 \npermalink: cogs-396\nid: 46\nupdated: '2016-02-06 23:04:22'\ndate: 2016-02-06 23:02:55\n---\n\n `n` n 1234 ...... \n\n1. \n2.  2 \n\n `n` \n\n<!-- more -->\n\n### \n[COGS 396](http://cogs.top/cogs/problem/problem.php?pid=396)\n\n### \n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nconst int MAXN = 60;\n\nint n;\nstd::vector<int> v[MAXN];\n\ninline bool isSquareNumber(int x) {\n\tint root = floor(sqrt(x));\n\treturn root * root == x;\n}\n\nint main() {\n\tfreopen(\"balla.in\", \"r\", stdin);\n\tfreopen(\"balla.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\n\tint x = 1;\n\tfor (int k = 1; k <= n; k++) {\n\t\twhile (20000528) {\n\t\t\tbool flag = false;\n\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tif (v[i].empty() || isSquareNumber(v[i].back() + x)) {\n\t\t\t\t\tv[i].push_back(x++);\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!flag) break;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", x - 1);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-396","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cwt019rc2xlb0u387nq"},{"title":"COGS 14 - ","id":"44","updated":"2016-02-06T14:22:28.000Z","date":"2016-02-06T14:21:18.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[COGS 14](http://cogs.top/cogs/problem/problem.php?pid=14)\n\n### \n~~~~\n\n  \n\n `X`  `Y` `S` `S`  `X`  `1` `T` `Y`  `T`  `1` `(u, v)` `u`  `v`  `u`  `v` **** `1`\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, n1;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + 1; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tfreopen(\"flyer.in\", \"r\", stdin);\n\tfreopen(\"flyer.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &n1);\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n1; i++) addEdge(s, i, 1);\n\tfor (int i = n1 + 1; i <= n; i++) addEdge(i, t, 1);\n\n\twhile (!feof(stdin)) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v, 1);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s, t));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/cogs-14.md","raw":"title: COGS 14 - \ncategories: OI\ntags: \n  - COGS\n  - \n  - \n  - Dinic\n  - \n  -  24 \npermalink: cogs-14\nid: 44\nupdated: '2016-02-06 22:22:28'\ndate: 2016-02-06 22:21:18\n---\n\n\n\n<!-- more -->\n\n### \n[COGS 14](http://cogs.top/cogs/problem/problem.php?pid=14)\n\n### \n~~~~\n\n  \n\n `X`  `Y` `S` `S`  `X`  `1` `T` `Y`  `T`  `1` `(u, v)` `u`  `v`  `u`  `v` **** `1`\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + 2];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, n1;\n\ninline void addEdge(int from, int to, int capacity) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + 1; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->flow < e->capacity && e->to->level == 0) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tif (e->to == t) return true;\n\t\t\t\t\telse q.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1 && e->capacity > e->flow) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tfreopen(\"flyer.in\", \"r\", stdin);\n\tfreopen(\"flyer.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &n1);\n\n\tconst int s = 0, t = n + 1;\n\n\tfor (int i = 1; i <= n1; i++) addEdge(s, i, 1);\n\tfor (int i = n1 + 1; i <= n; i++) addEdge(i, t, 1);\n\n\twhile (!feof(stdin)) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tif (u > v) std::swap(u, v);\n\n\t\taddEdge(u, v, 1);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s, t));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"cogs-14","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cwy019wc2xls4ucr3xb"},{"title":"CodeVS 3269 -  DP","id":"3","updated":"2016-01-19T13:08:13.000Z","date":"2015-11-22T21:00:15.000Z","_content":"\n `V`<= 200,000 `N`<= 200 `Vi` `Wi` `1`  `Mi`> 1\n\n<!-- more -->\n\n### \n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### \n  \n  \n `f[v]`  `v` `v` <= `V`    \n 01 \n\n$$f[v] = max(f[v], f[v - Vi] + Wi)$$\n\n`t[i].v`  `t[i].w`  `Vi`  `Wi`\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (int v = V; v >= 0; v--) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n `v` `v`  `V`  `0`  `f[v]`  `v`  `f[v]`  `Vi`  `i`  `f[v]` `f[v - Vi]` **** `i`   \n\n `V` / `Vi`  `01`  01   \n 01  01 ******** `f[v]` `f[v - Vi]` **** `i`  `v`  `0`  `V`   \n`t[i].v`  `t[i].w`  `Vi`  `Wi`\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (unsigned int v = 0; v <= V; v++) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n `V = 10` `Vi = 3` `Wi = 5`  \n\n `01`   \n `v = 10` **`f[v - Vi] = f[7] = 0`**`f[v]`  `5`  \n `v = 9` `f[v - Vi] = f[6] = 0``f[v]`  `5`  \n `v = 8` `f[v - Vi] = f[5] = 0``f[v]`  `5`  \n** `v = 7` `f[v - Vi] = f[4] = 0``f[v]`  `5`**  \n  \n `v = 4` `f[v - Vi] = f[1] = 0``f[v]`  `5`  \n `v = 3` `f[v - Vi] = f[0] = 0``f[v]`  `5`  \n\n  \n `v = 3` **`f[v - Vi] = f[0] = 0`**`f[v]`  `5`  \n `v = 4` `f[v - Vi] = f[1] = 0``f[v]`  `5`  \n  \n** `v = 6` `f[v - Vi] = f[3] = 5``f[v]`  `10`**  \n  \n** `v = 9` `f[v - Vi] = f[6] = 10``f[v]`  `15`**  \n `v = 10` `f[v - Vi] = f[7] = 10``f[v]`  `15`  \n\n 01   \n\n01   \n `Mi`  `Mi`  01  01 $O(V*{\\Sigma}Mi)$  \n `t`  01  `k`****${\\Sigma}k = Mi$ `k`  $1$,$2$,$4$,,$2 ^ {t - 1}$,$Wi - 2 ^ {t - 1}$  \n `Mi = 17`  `5`  `k`  `1`,`2`,`4`,`8`,`2`  \n$O(V * {\\Sigma}{\\log}Wi)$  \n`t[i].v`  `t[i].w`  `Vi`  `Wi`  \n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tunsigned int logx = log2(t[i].m), x = 0;\n\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\tx += (1 << j); // 1 << j  1  j  2  j \n\t\tfor (int v = V; v >= 0; v--) { // 01 \n\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x < t[i].m) { //  2  k = Wi - 2 ^ (t - 1)\n\t\tfor (int v = V; v >= 0; v--) { // 01 \n\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t}\n\t\t}\n\t}\n}\n```\n  \n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 200;\nconst unsigned int MAXV = 200000;\n\nunsigned int n, V;\n\nstruct thing_t {\n\tunsigned int v, w;\n\tint m;\n} t[MAXN];\n\nunsigned int f[MAXV + 1];\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tch = getchar();\n\t\tflag = true;\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nunsigned int log2(unsigned int x) {\n\tunsigned int i = 0, y = 0;\n\twhile ((y += (1 << i)) <= x) {\n\t\ti++;\n\t}\n\treturn i - 1;\n}\n\nint main() {\n\tread(n), read(V);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tread(t[i].v), read(t[i].w), read(t[i].m);\n\t}\n\n\tregister unsigned int result = 0;\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tif (t[i].m == 1) {\n\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (t[i].m == -1) {\n\t\t\tfor (unsigned int v = 0; v <= V; v++) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned int logx = log2(t[i].m), x = 0;\n\t\t\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\t\t\tx += (1 << j);\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (x < t[i].m) {\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", result);\n\n\treturn 0;\n}\n```\n### \n dp liujz    \n >_<\n","source":"_posts/codevs-3269.md","raw":"title: CodeVS 3269 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  -  DP\npermalink: codevs-3269\nid: 3\nupdated: '2016-01-19 21:08:13'\ndate: 2015-11-23 05:00:15\n---\n\n `V`<= 200,000 `N`<= 200 `Vi` `Wi` `1`  `Mi`> 1\n\n<!-- more -->\n\n### \n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### \n  \n  \n `f[v]`  `v` `v` <= `V`    \n 01 \n\n$$f[v] = max(f[v], f[v - Vi] + Wi)$$\n\n`t[i].v`  `t[i].w`  `Vi`  `Wi`\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (int v = V; v >= 0; v--) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n `v` `v`  `V`  `0`  `f[v]`  `v`  `f[v]`  `Vi`  `i`  `f[v]` `f[v - Vi]` **** `i`   \n\n `V` / `Vi`  `01`  01   \n 01  01 ******** `f[v]` `f[v - Vi]` **** `i`  `v`  `0`  `V`   \n`t[i].v`  `t[i].w`  `Vi`  `Wi`\n\n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tfor (unsigned int v = 0; v <= V; v++) {\n\t\tif (v >= t[i].v) {\n\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t}\n\t}\n}\n```\n `V = 10` `Vi = 3` `Wi = 5`  \n\n `01`   \n `v = 10` **`f[v - Vi] = f[7] = 0`**`f[v]`  `5`  \n `v = 9` `f[v - Vi] = f[6] = 0``f[v]`  `5`  \n `v = 8` `f[v - Vi] = f[5] = 0``f[v]`  `5`  \n** `v = 7` `f[v - Vi] = f[4] = 0``f[v]`  `5`**  \n  \n `v = 4` `f[v - Vi] = f[1] = 0``f[v]`  `5`  \n `v = 3` `f[v - Vi] = f[0] = 0``f[v]`  `5`  \n\n  \n `v = 3` **`f[v - Vi] = f[0] = 0`**`f[v]`  `5`  \n `v = 4` `f[v - Vi] = f[1] = 0``f[v]`  `5`  \n  \n** `v = 6` `f[v - Vi] = f[3] = 5``f[v]`  `10`**  \n  \n** `v = 9` `f[v - Vi] = f[6] = 10``f[v]`  `15`**  \n `v = 10` `f[v - Vi] = f[7] = 10``f[v]`  `15`  \n\n 01   \n\n01   \n `Mi`  `Mi`  01  01 $O(V*{\\Sigma}Mi)$  \n `t`  01  `k`****${\\Sigma}k = Mi$ `k`  $1$,$2$,$4$,,$2 ^ {t - 1}$,$Wi - 2 ^ {t - 1}$  \n `Mi = 17`  `5`  `k`  `1`,`2`,`4`,`8`,`2`  \n$O(V * {\\Sigma}{\\log}Wi)$  \n`t[i].v`  `t[i].w`  `Vi`  `Wi`  \n```cpp\nfor (unsigned int i = 0; i < n; i++) {\n\tunsigned int logx = log2(t[i].m), x = 0;\n\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\tx += (1 << j); // 1 << j  1  j  2  j \n\t\tfor (int v = V; v >= 0; v--) { // 01 \n\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x < t[i].m) { //  2  k = Wi - 2 ^ (t - 1)\n\t\tfor (int v = V; v >= 0; v--) { // 01 \n\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t}\n\t\t}\n\t}\n}\n```\n  \n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst unsigned int MAXN = 200;\nconst unsigned int MAXV = 200000;\n\nunsigned int n, V;\n\nstruct thing_t {\n\tunsigned int v, w;\n\tint m;\n} t[MAXN];\n\nunsigned int f[MAXV + 1];\n\ninline bool isempty(char ch) {\n\treturn ch != '-' && (ch < '0' || ch > '9');\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (isempty(ch = getchar()));\n\n\tregister bool flag = false;\n\tif (ch == '-') {\n\t\tch = getchar();\n\t\tflag = true;\n\t}\n\n\tdo {\n\t\tx = x * 10 + (ch - '0');\n\t} while (!isempty(ch = getchar()));\n\n\tif (flag) {\n\t\tx = -x;\n\t}\n}\n\nunsigned int log2(unsigned int x) {\n\tunsigned int i = 0, y = 0;\n\twhile ((y += (1 << i)) <= x) {\n\t\ti++;\n\t}\n\treturn i - 1;\n}\n\nint main() {\n\tread(n), read(V);\n\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tread(t[i].v), read(t[i].w), read(t[i].m);\n\t}\n\n\tregister unsigned int result = 0;\n\tfor (unsigned int i = 0; i < n; i++) {\n\t\tif (t[i].m == 1) {\n\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (t[i].m == -1) {\n\t\t\tfor (unsigned int v = 0; v <= V; v++) {\n\t\t\t\tif (v >= t[i].v) {\n\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v] + t[i].w);\n\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned int logx = log2(t[i].m), x = 0;\n\t\t\tfor (unsigned int j = 0; j <= logx; j++) {\n\t\t\t\tx += (1 << j);\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (1 << j)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (1 << j)] + t[i].w * (1 << j));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (x < t[i].m) {\n\t\t\t\tfor (int v = V; v >= 0; v--) {\n\t\t\t\t\tif (v >= t[i].v * (t[i].m - x)) {\n\t\t\t\t\t\tf[v] = std::max(f[v], f[v - t[i].v * (t[i].m - x)] + t[i].w * (t[i].m - x));\n\t\t\t\t\t\tresult = std::max(result, f[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%u\\n\", result);\n\n\treturn 0;\n}\n```\n### \n dp liujz    \n >_<\n","slug":"codevs-3269","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cx601a4c2xlyrt4c2en"},{"title":"CodeVS 3269 -  DP + ","id":"23","updated":"2016-01-19T13:03:26.000Z","date":"2016-01-14T21:47:45.000Z","_content":"\n `V`<= 200,000 `N`<= 200 `Vi` `Wi` `1`  `Mi`> `1`\n\n<!-- more -->\n\n### \n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### \n01 \n\n`n` `w` `c` \n\n\n\n$$ f[i]=\\max\\{f[i-k*c]+k*w,k{\\in}[0,n]\\} $$\n\n $r=i ~~ \\% ~~ c$$m=i ~~ / ~~ c$\n\n`m`   \n`r` \n\n `i`  `r` $[0,m]$  `d` $(m-d)*c+r$ `i`\n\n$$ f[(m-d)*c+r]=\\max\\{f[(m-d)*c+r]+d*w,d{\\in}[0,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n\n\n$$ k=m-d $$\n\n\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]+(m-k)*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]-k*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n\n\n$$ g(k,r)=f[k*c+r]-k*w $$\n\n\n\n$$ f[k*c+r]=\\max\\{g(k,r),k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n$ f[k*c+r] $ `n + 1`  `n + 1`  $g(k,r)$ $O(1)$ \n\n `m`  `k` `k` ****\n\n### \n```cpp\n#include <cstdio>\n#include <deque>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXV = 200000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, V;\nint f[MAXV + 1];\n\ninline void pack(int c, int w, int n) {\n\tif (n == 1) {\n\t\tfor (int v = V; v >= c; v--) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else if (n == -1) {\n\t\tfor (int v = c; v <= V; v++) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else {\n\t\tn = std::min(n, V / c);\n\t\tfor (int r = 0; r < c; r++) {\n\t\t\tMonotoneQueue<int> q;\n\t\t\tint m = (V - r) / c;\n\t\t\tfor (int k = 0; k <= m; k++) {\n\t\t\t\tif (q.size() == n + 1) q.pop();\n\t\t\t\tq.push(f[k * c + r] - k * w);\n\t\t\t\tf[k * c + r] = q.top() + k * w;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &V);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, w, n;\n\t\tscanf(\"%d %d %d\", &c, &w, &n);\n\t\tpack(c, w, n);\n\t}\n\n\tprintf(\"%d\\n\", f[V]);\n\n\treturn 0;\n}\n```\n","source":"_posts/codevs-3269-monotone-queue.md","raw":"title: CodeVS 3269 -  DP + \ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - \n  -  DP\npermalink: codevs-3269-monotone-queue\nid: 23\nupdated: '2016-01-19 21:03:26'\ndate: 2016-01-15 05:47:45\n---\n\n `V`<= 200,000 `N`<= 200 `Vi` `Wi` `1`  `Mi`> `1`\n\n<!-- more -->\n\n### \n[CodeVS 3269](htp://codevs.cn/problem/3269/)\n\n### \n01 \n\n`n` `w` `c` \n\n\n\n$$ f[i]=\\max\\{f[i-k*c]+k*w,k{\\in}[0,n]\\} $$\n\n $r=i ~~ \\% ~~ c$$m=i ~~ / ~~ c$\n\n`m`   \n`r` \n\n `i`  `r` $[0,m]$  `d` $(m-d)*c+r$ `i`\n\n$$ f[(m-d)*c+r]=\\max\\{f[(m-d)*c+r]+d*w,d{\\in}[0,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n\n\n$$ k=m-d $$\n\n\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]+(m-k)*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} $$\n\n\n\n$$ f[k*c+r]=\\max\\{f[k*c+r]-k*w,k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n\n\n$$ g(k,r)=f[k*c+r]-k*w $$\n\n\n\n$$ f[k*c+r]=\\max\\{g(k,r),k{\\in}[m-n,m],r{\\in}[0,V \\ \\% \\ c]\\} + m * w $$\n\n$ f[k*c+r] $ `n + 1`  `n + 1`  $g(k,r)$ $O(1)$ \n\n `m`  `k` `k` ****\n\n### \n```cpp\n#include <cstdio>\n#include <deque>\n#include <algorithm>\n\nconst int MAXN = 200;\nconst int MAXV = 200000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, V;\nint f[MAXV + 1];\n\ninline void pack(int c, int w, int n) {\n\tif (n == 1) {\n\t\tfor (int v = V; v >= c; v--) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else if (n == -1) {\n\t\tfor (int v = c; v <= V; v++) {\n\t\t\tf[v] = std::max(f[v], f[v - c] + w);\n\t\t}\n\t} else {\n\t\tn = std::min(n, V / c);\n\t\tfor (int r = 0; r < c; r++) {\n\t\t\tMonotoneQueue<int> q;\n\t\t\tint m = (V - r) / c;\n\t\t\tfor (int k = 0; k <= m; k++) {\n\t\t\t\tif (q.size() == n + 1) q.pop();\n\t\t\t\tq.push(f[k * c + r] - k * w);\n\t\t\t\tf[k * c + r] = q.top() + k * w;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &V);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, w, n;\n\t\tscanf(\"%d %d %d\", &c, &w, &n);\n\t\tpack(c, w, n);\n\t}\n\n\tprintf(\"%d\\n\", f[V]);\n\n\treturn 0;\n}\n```\n","slug":"codevs-3269-monotone-queue","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cxc01a9c2xl2h3i18hx"},{"title":"CodeVS 3168 / 3162 -  DP / ","id":"14","updated":"2016-01-06T13:03:26.000Z","date":"2016-01-05T21:47:45.000Z","_content":"\n `M`  `K` \n\n<!-- more -->\n\n### \n[CodeVS 3162 - ](http://codevs.cn/problem/3162/)  \n[CodeVS 3168 -  3](http://codevs.cn/problem/3168/)\n\n###  DP\n $a[m]$  `m` $f[m][k]$  `m`  `k` \n\n\n$$f[m][1]={\\sum_{i=1}^{n}}a[i]$$\n\n\n$$f[m][k]={\\min} \\{ {\\max}(f[i][k-1],{ \\sum_{j=i+1}^{m}}a[j]), i{\\in}[k-1,m-1]\\}$$\n\n `k`  `k - 1`  `k`  `k - 1`  `m - 1`  `k`  `k` \n\n $O(km^2)$\n\n```C++\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n```\n### \n DP ************\n\n $O(m{\\log}m)$\n\n```C++\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n```\n### \n~~ WA  8 ~~\n\n****\n\n\n\n```C++\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n```\n###  DPCodeVS 3162\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 100;\nconst int MAXK = 100;\n\nint m, k;\nint a[MAXM], prefix[MAXM], f[MAXM][MAXK], pageCount[MAXK];\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefix();\n\tmemset(f, 0xff, sizeof(f));\n\n\tans = search(m, k);\n\tprintPlan();\n\n\treturn 0;\n}\n```\n\n### CodeVS 3162CodeVS 3168\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 1000000;\nconst int MAXK = 10000;\n\nint m, k;\nint a[MAXM], prefix[MAXM], pageCount[MAXK], max;\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tmax = std::max(max, a[i]);\n\t}\n\n\tmakePrefix();\n\n\tans = binaryDivide();\n\tprintPlan();\n\n\treturn 0;\n}\n```\n","source":"_posts/codevs-3168-3162.md","raw":"title: CodeVS 3168 / 3162 -  DP / \ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - \n  -  DP\n  - \npermalink: codevs-3168-3162\nid: 14\nupdated: '2016-01-06 21:03:26'\ndate: 2016-01-06 05:47:45\n---\n\n `M`  `K` \n\n<!-- more -->\n\n### \n[CodeVS 3162 - ](http://codevs.cn/problem/3162/)  \n[CodeVS 3168 -  3](http://codevs.cn/problem/3168/)\n\n###  DP\n $a[m]$  `m` $f[m][k]$  `m`  `k` \n\n\n$$f[m][1]={\\sum_{i=1}^{n}}a[i]$$\n\n\n$$f[m][k]={\\min} \\{ {\\max}(f[i][k-1],{ \\sum_{j=i+1}^{m}}a[j]), i{\\in}[k-1,m-1]\\}$$\n\n `k`  `k - 1`  `k`  `k - 1`  `m - 1`  `k`  `k` \n\n $O(km^2)$\n\n```C++\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n```\n### \n DP ************\n\n $O(m{\\log}m)$\n\n```C++\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n```\n### \n~~ WA  8 ~~\n\n****\n\n\n\n```C++\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n```\n###  DPCodeVS 3162\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 100;\nconst int MAXK = 100;\n\nint m, k;\nint a[MAXM], prefix[MAXM], f[MAXM][MAXK], pageCount[MAXK];\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\nint search(int m, int k) {\n\tif (f[m - 1][k - 1] == -1) {\n\n\t\tif (k == 1) {\n\t\t\tf[m - 1][k - 1] = sum(0, m - 1);\n\t\t} else {\n\t\t\tfor (int i = k - 1; i <= m - 1; i++) {\n\t\t\t\tint ans = std::max(search(i, k - 1), sum(i + 1 - 1, m - 1));\n\t\t\t\tif (f[m - 1][k - 1] == -1 || f[m - 1][k - 1] > ans) {\n\t\t\t\t\tf[m - 1][k - 1] = ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[m - 1][k - 1];\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefix();\n\tmemset(f, 0xff, sizeof(f));\n\n\tans = search(m, k);\n\tprintPlan();\n\n\treturn 0;\n}\n```\n\n### CodeVS 3162CodeVS 3168\n```C++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <utility>\n\nusing std::stack;\nusing std::pair;\nusing std::make_pair;\n\nconst int MAXM = 1000000;\nconst int MAXK = 10000;\n\nint m, k;\nint a[MAXM], prefix[MAXM], pageCount[MAXK], max;\nint ans;\n\ninline void makePrefix() {\n\tprefix[0] = a[0];\n\tfor (int i = 1; i < m; i++) {\n\t\tprefix[i] = prefix[i - 1] + a[i];\n\t}\n}\n\ninline int sum(int i, int j) {\n\treturn i == 0 ? prefix[j] : prefix[j] - prefix[i - 1];\n}\n\ninline bool check(int limit) {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (pageCount[j] + a[i] <= limit) {\n\t\t\tpageCount[j] += a[i];\n\t\t} else {\n\t\t\tif (j == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlastEnd = i;\n\t\t\tpageCount[--j] += a[i];\n\t\t}\n\t}\n\n\treturn sum(0, lastEnd - 1) <= limit;\n}\n\ninline int binaryDivide() {\n\tint l = max, r = sum(0, m - 1);\n\twhile (l < r) {\n\t\tint mid = l + ((r - l) >> 1);\n\t\tif (check(mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\n\treturn l;\n}\n\ninline void printPlan() {\n\tmemset(pageCount, 0, sizeof(pageCount));\n\n\tint j = k - 1, lastEnd = m - 1;\n\tstack<pair<int, int> > s;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (j > i || pageCount[j] + a[i] > ans) {\n\t\t\tpageCount[--j] += a[i];\n\t\t\ts.push(make_pair(i + 1 + 1, lastEnd + 1));\n\t\t\tlastEnd = i;\n\t\t} else {\n\t\t\tpageCount[j] += a[i];\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", 1, lastEnd + 1);\n\twhile (!s.empty()) {\n\t\tpair<int, int> range = s.top();\n\t\ts.pop();\n\t\tprintf(\"%d %d\\n\", range.first, range.second);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &m, &k);\n\n\tif (!m) return 0;\n\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tmax = std::max(max, a[i]);\n\t}\n\n\tmakePrefix();\n\n\tans = binaryDivide();\n\tprintPlan();\n\n\treturn 0;\n}\n```\n","slug":"codevs-3168-3162","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cxi01afc2xlcm2f8ysy"},{"title":"CodeVS 2822 - ","date":"2016-03-04T02:47:42.000Z","_content":"\n N  A  BB  C A  C\n\n -1\n\n<!-- more -->\n\n### \n[CodeVS 2822](http://codevs.cn/problem/2822/)\n\n### \n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint id, dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tstd::vector<int> vec;\n\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t\tu->connected->vec.push_back(u->id);\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1 && connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1) {\n\t\t\tans++;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\tConnected *loved = contract(count);\n\tif (!loved) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tstd::sort(loved->vec.begin(), loved->vec.end());\n\n\t\tfor (std::vector<int>::const_iterator p = loved->vec.begin(); p != loved->vec.end(); p++) {\n\t\t\tprintf(\"%d \", *p);\n\t\t}\n\n\t\tputchar('\\n');\n\t}\n\n\treturn 0;\n}\n\n```\n","source":"_posts/codevs-2822.md","raw":"title: CodeVS 2822 - \ncategories: OI\ntags: \n  - CodeVS\n  - \n  - Tarjan\n  - \n  - \npermalink: codevs-2822\ndate: 2016-03-04 10:47:42\n---\n\n N  A  BB  C A  C\n\n -1\n\n<!-- more -->\n\n### \n[CodeVS 2822](http://codevs.cn/problem/2822/)\n\n### \n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\nstruct Connected;\n\nstruct Node {\n\tEdge *firstEdge, *currentEdge, *inEdge;\n\tint id, dfn, low, outDegree;\n\tbool visited, pushed, inStack;\n\tConnected *connected;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Connected {\n\tint size;\n\tstd::vector<int> vec;\n\n\tNode v;\n} connecteds[MAXN];\n\nint n, m;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\telse if (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\te = e->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tv->connected = &connecteds[count++];\n\t\t\t\t\tNode *u;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->connected = v->connected;\n\t\t\t\t\t\tu->connected->size++;\n\t\t\t\t\t\tu->connected->vec.push_back(u->id);\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline Connected *contract(int count) {\n\tint zeroCount = count;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->connected != e->to->connected) {\n\t\t\t\te->from->connected->v.firstEdge = new Edge(&e->from->connected->v, &e->to->connected->v);\n\t\t\t\tif (e->from->connected->v.outDegree++ == 0) zeroCount--;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (zeroCount != 1) return NULL;\n\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1 && connecteds[i].v.outDegree == 0) return &connecteds[i];\n\t}\n\n\treturn NULL;\n}\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tint count = tarjan();\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (connecteds[i].size > 1) {\n\t\t\tans++;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\tConnected *loved = contract(count);\n\tif (!loved) {\n\t\tputs(\"-1\");\n\t} else {\n\t\tstd::sort(loved->vec.begin(), loved->vec.end());\n\n\t\tfor (std::vector<int>::const_iterator p = loved->vec.begin(); p != loved->vec.end(); p++) {\n\t\t\tprintf(\"%d \", *p);\n\t\t}\n\n\t\tputchar('\\n');\n\t}\n\n\treturn 0;\n}\n\n```\n","slug":"codevs-2822","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cxp01amc2xlo2dpurq8"},{"title":"CodeVS 2598 -  DP","id":"17","updated":"2016-01-19T13:05:21.000Z","date":"2016-01-08T21:32:19.000Z","_content":"\n A  B  2  A  B\n\n1. \n2. \n3. \n\n A  B  A  B \n\n AB 4000\n\n<!-- more -->\n\n### \n[CodeVS 2598](http://codevs.cn/problem/2598/)\n\n### \n\n `f[i][j]`  A  `i`  B  `j` \n\n$$ f[i][j] = \\cases{ f[i-1][j-1] & A[i]=B[j] \\\\ {\\min}(f[i][j-1],f[i-1][j],f[i-1][j-1])+1 & A[i]  B[j]} $$\n\n $ A[i]=B[j] $ \n\n $ A[i]B[j] $ \n\n1.  B  `j`  $A[i]$  $B[j-1]$  B  `j` \n2.  B  `j`  $A[i-1]$  $B[j]$  A  `i` \n3.  B  `j`  $A[i-1]$  $B[j-1]$  A  `i`  B  `j` \n\n### \n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 4000;\n\nchar s1[MAXN + 1], s2[MAXN + 1];\nint n1, n2, ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == 0) return j;\n\tif (j == 0) return i;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (s1[i - 1] == s2[j - 1]) {\n\t\t\tans[i - 1][j - 1] = search(i - 1, j - 1);\n\t\t} else {\n\t\t\tans[i - 1][j - 1] = INT_MAX;\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j - 1) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i, j - 1) + 1);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%s %s\", s1, s2);\n\tn1 = strlen(s1), n2 = strlen(s2);\n\n\tprintf(\"%d\\n\", search(n1, n2));\n\treturn 0;\n}\n```\n","source":"_posts/codevs-2598.md","raw":"title: CodeVS 2598 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - DP\n  - \n  -  DP\npermalink: codevs-2598\nid: 17\nupdated: '2016-01-19 21:05:21'\ndate: 2016-01-09 05:32:19\n---\n\n A  B  2  A  B\n\n1. \n2. \n3. \n\n A  B  A  B \n\n AB 4000\n\n<!-- more -->\n\n### \n[CodeVS 2598](http://codevs.cn/problem/2598/)\n\n### \n\n `f[i][j]`  A  `i`  B  `j` \n\n$$ f[i][j] = \\cases{ f[i-1][j-1] & A[i]=B[j] \\\\ {\\min}(f[i][j-1],f[i-1][j],f[i-1][j-1])+1 & A[i]  B[j]} $$\n\n $ A[i]=B[j] $ \n\n $ A[i]B[j] $ \n\n1.  B  `j`  $A[i]$  $B[j-1]$  B  `j` \n2.  B  `j`  $A[i-1]$  $B[j]$  A  `i` \n3.  B  `j`  $A[i-1]$  $B[j-1]$  A  `i`  B  `j` \n\n### \n```C++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 4000;\n\nchar s1[MAXN + 1], s2[MAXN + 1];\nint n1, n2, ans[MAXN][MAXN];\nbool calced[MAXN][MAXN];\n\nint search(int i, int j) {\n\tif (i == 0) return j;\n\tif (j == 0) return i;\n\n\tif (!calced[i - 1][j - 1]) {\n\t\tif (s1[i - 1] == s2[j - 1]) {\n\t\t\tans[i - 1][j - 1] = search(i - 1, j - 1);\n\t\t} else {\n\t\t\tans[i - 1][j - 1] = INT_MAX;\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j - 1) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i - 1, j) + 1);\n\t\t\tans[i - 1][j - 1] = std::min(ans[i - 1][j - 1], search(i, j - 1) + 1);\n\t\t}\n\n\t\tcalced[i - 1][j - 1] = true;\n\t}\n\n\treturn ans[i - 1][j - 1];\n}\n\nint main() {\n\tscanf(\"%s %s\", s1, s2);\n\tn1 = strlen(s1), n2 = strlen(s2);\n\n\tprintf(\"%d\\n\", search(n1, n2));\n\treturn 0;\n}\n```\n","slug":"codevs-2598","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cxw01atc2xlmtjmku4s"},{"title":"CodeVS 1563 - ","id":"42","updated":"2016-02-06T14:23:12.000Z","date":"2016-02-05T13:06:41.000Z","_content":"\n `s`  `t` \n\n<!-- more -->\n\n### \n[CodeVS 1563](http://codevs.cn/problem/1563/)  \n[ 1345](http://www.luogu.org/problem/show?pid=1345)\n\n### \n\n\n\n\n  \n\n `i`  `i'` `i` `i'`  `i`  `i'`  1 `(i, j)` `(i', j)`\n\n `s'`  `t`  `s`  `t'`\n\n###\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 600;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, s, t;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"addEdge(%d, %d, %d)\\n\", from + 1, to + 1, capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void link(int u, int v) {\n\taddEdge(u + n, v, INT_MAX);\n\taddEdge(v + n, u, INT_MAX);\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->capacity != e->flow) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn t->level != 0;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t){\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tscanf(\"%d %d %d %d\", &n, &m, &s, &t), s--, t--;\n\n\tfor (int i = 0; i < n; i++) addEdge(i, i + n, 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\n\t\tlink(u, v);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s + n, t));\n\n\treturn 0;\n}\n```\n","source":"_posts/codevs-1563.md","raw":"title: CodeVS 1563 - \ncategories: OI\ntags: \n  - CodeVS\n  - USACO\n  - \n  - Dinic\n  - \npermalink: codevs-1563\nid: 42\nupdated: '2016-02-06 22:23:12'\ndate: 2016-02-05 21:06:41\n---\n\n `s`  `t` \n\n<!-- more -->\n\n### \n[CodeVS 1563](http://codevs.cn/problem/1563/)  \n[ 1345](http://www.luogu.org/problem/show?pid=1345)\n\n### \n\n\n\n\n  \n\n `i`  `i'` `i` `i'`  `i`  `i'`  1 `(i, j)` `(i', j)`\n\n `s'`  `t`  `s`  `t'`\n\n###\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\nconst int MAXM = 600;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint level;\n} nodes[MAXN + MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tint capacity, flow;\n\tEdge *next, *reversedEdge;\n\n\tEdge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n\nint n, m, s, t;\n\ninline void addEdge(int from, int to, int capacity) {\n\t//printf(\"addEdge(%d, %d, %d)\\n\", from + 1, to + 1, capacity);\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to], capacity);\n\tnodes[to].firstEdge = new Edge(&nodes[to], &nodes[from], 0);\n\n\tnodes[from].firstEdge->reversedEdge = nodes[to].firstEdge, nodes[to].firstEdge->reversedEdge = nodes[from].firstEdge;\n}\n\ninline void link(int u, int v) {\n\taddEdge(u + n, v, INT_MAX);\n\taddEdge(v + n, u, INT_MAX);\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t) {\n\t\tfor (int i = 0; i < n + n; i++) nodes[i].level = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->level = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\t\tif (e->to->level == 0 && e->capacity != e->flow) {\n\t\t\t\t\te->to->level = v->level + 1;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn t->level != 0;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *e = s->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->to, t, std::min(limit, e->capacity - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->reversedEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(int s, int t){\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&nodes[s], &nodes[t])) {\n\t\t\tint flow;\n\t\t\twhile ((flow = findPath(&nodes[s], &nodes[t])) > 0) ans += flow;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\nint main() {\n\tscanf(\"%d %d %d %d\", &n, &m, &s, &t), s--, t--;\n\n\tfor (int i = 0; i < n; i++) addEdge(i, i + n, 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\n\t\tlink(u, v);\n\t}\n\n\tprintf(\"%d\\n\", dinic(s + n, t));\n\n\treturn 0;\n}\n```\n","slug":"codevs-1563","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cy201azc2xlks3fmfmk"},{"title":"CodeVS 1345 -  DP","id":"21","updated":"2016-01-19T13:04:02.000Z","date":"2016-01-13T21:17:18.000Z","_content":"\n `n` 1000\n\n<!-- more -->\n\n### \n[CodeVS 1345](http://codevs.cn/problem/1345/)\n\n### \n \n\n  ****\n\n $ f[i] $  `i`  `i` \n\n$$ f[i]=\\max\\{f[j],r(j)< l(i)\\}+length(i) $$\n\n****\n\n $ max\\{f[i],i{\\in}[1,n]\\} $ $f[n]$\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 1000;\n\nstruct Range {\n\tint l, r;\n\n\tint length() {\n\t\treturn r - l + 1;\n\t}\n\n\tbool operator<(const Range &other) const {\n\t\tif (r == other.r) return l < other.l;\n\t\telse return r < other.r;\n\t}\n} a[MAXN];\n\nint n, f[MAXN];\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].l, &a[i].r);\n\t}\n\n\tstd::sort(a, a + n);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint max = 0;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j].r < a[i].l) max = std::max(max, f[j]);\n\t\t}\n\n\t\tf[i] = a[i].length() + max;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/codevs-1345.md","raw":"title: CodeVS 1345 -  DP\ncategories: OI\ntags: \n  - CodeVS\n  - USACO\n  - DP\n  -  DP\npermalink: codevs-1345\nid: 21\nupdated: '2016-01-19 21:04:02'\ndate: 2016-01-14 05:17:18\n---\n\n `n` 1000\n\n<!-- more -->\n\n### \n[CodeVS 1345](http://codevs.cn/problem/1345/)\n\n### \n \n\n  ****\n\n $ f[i] $  `i`  `i` \n\n$$ f[i]=\\max\\{f[j],r(j)< l(i)\\}+length(i) $$\n\n****\n\n $ max\\{f[i],i{\\in}[1,n]\\} $ $f[n]$\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 1000;\n\nstruct Range {\n\tint l, r;\n\n\tint length() {\n\t\treturn r - l + 1;\n\t}\n\n\tbool operator<(const Range &other) const {\n\t\tif (r == other.r) return l < other.l;\n\t\telse return r < other.r;\n\t}\n} a[MAXN];\n\nint n, f[MAXN];\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a[i].l, &a[i].r);\n\t}\n\n\tstd::sort(a, a + n);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint max = 0;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[j].r < a[i].l) max = std::max(max, f[j]);\n\t\t}\n\n\t\tf[i] = a[i].length() + max;\n\t\tans = std::max(ans, f[i]);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"codevs-1345","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cy901b7c2xljqpcfsx5"},{"title":"BZOJ 3881Divljak - AC  + ","date":"2016-09-17T23:27:00.000Z","_content":"\n $ n $  $ S_1, S_2, \\ldots, S_n $ $ T $  \n $ q $  $ T $  $ P $ $ T $  $ S_i $\n\n<!-- more -->\n\n### \n[BZOJ 3881](http://www.lydsy.com/JudgeOnline/problem.php?id=3881)\n\n### \n $ S_i $  AC  $ P $  $ P $  $ +1 $\n\n $ O(n ^ 2) $  $ O(n) $ Fail \n\n $ P $  Fail **** $ +1 $\n\n DFS \n\n $ +1 $ $ -1 $\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXLEN = 2000000;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nint tot;\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tint id;\n\t\tbool isWord, visited;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), id(tot++), isWord(isWord), visited(false) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end, std::vector<int> &vec) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = v->c[*p];\n\t\t\tif (v->isWord) vec.push_back(v->id);\n\t\t\telse if (v->next) vec.push_back(v->next->id);\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tstruct Edge *e;\n\tint l, r, depth, size;\n\tNode *p, *c, *top;\n\tbool visited;\n} N[MAXLEN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n#ifdef DBG\n\tprintf(\"addEdge: %d -> %d\\n\", s + 1, t + 1);\n#endif\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\ninline void build() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->fail != v) addEdge(v->id, v->fail->id);\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tif (!v->c[i]->visited) {\n\t\t\t\tv->c[i]->visited = true;\n\t\t\t\tq.push(v->c[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void split() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].depth = 1;\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->depth) {\n\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\te->t->p = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (!v->c || v->c->size < e->t->size) v->c = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) N[i].visited = false;\n\n\ts.push(&N[0]);\n\tint ts = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->top = (!v->p || v != v->p->c) ? v : v->p->top;\n\t\t\tv->l = ++ts;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) {\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else {\n\t\t\tv->r = ts;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) assert(N[i].l && N[i].r);\n\n#ifdef DBG\n\tfor (int i = 0; i < tot; i++) {\n\t\tprintf(\"N[%d] => [%d, %d]\\n\", i + 1, N[i].l, N[i].r);\n\t}\n#endif\n}\n\ninline Node *lca(Node *a, Node *b) {\n\twhile (a->top != b->top) {\n\t\tif (a->top->depth < b->top->depth) std::swap(a, b);\n\t\ta = a->top->p;\n\t}\n\tNode *res = a->depth < b->depth ? a : b;\n#ifdef DBG\n\tprintf(\"lca(%lu, %lu) = %lu\\n\", a - N + 1, b - N + 1, res - N + 1);\n#endif\n\treturn res;\n}\n\ninline bool compare(const int a, const int b) {\n\treturn N[a].l < N[b].l;\n}\n\nstruct BinaryIndexedTree {\n\tint a[MAXLEN + 1 + 1 + 1], n;\n\n\tvoid init(const int n) { this->n = n; }\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tvoid update(const int pos, const int delta) {\n#ifdef DBG\n\t\tprintf(\"BIT: %d add %d\\n\", pos, delta);\n#endif\n#ifdef FORCE\n\t\ta[pos] += delta;\n\t\treturn;\n#endif\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n\n\tint sum(const int pos) {\n\t\tint res = 0;\n#ifdef FORCE\n\t\tfor (int i = 1; i <= pos; i++) res += a[i];\n\t\t// printf(\"sum(%d) = %d\\n\", pos, res);\n\t\treturn res;\n#endif\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(const int l, const int r) {\n#ifdef FORCE\n\t\tint res = 0;\n\t\tfor (int i = l; i <= r; i++) res += a[i];\n\t\t// printf(\"query(%d, %d) = %d\\n\", l, r, res);\n\t\treturn res;\n#endif\n\t\treturn sum(r) - sum(l - 1);\n\t}\n} bit;\n\ninline void add(const char *begin, const char *end) {\n\tstd::vector<int> vec;\n\tt.exec(begin, end, vec);\n\tstd::sort(vec.begin(), vec.end(), compare);\n\tvec.erase(std::unique(vec.begin(), vec.end()), vec.end());\n\n#ifdef DBG\n\tprintf(\"%lu matched:\", vec.size());\n\tfor (size_t i = 0; i < vec.size(); i++) printf(\" %d\", vec[i] + 1);\n\tputchar('\\n');\n#endif\n\n\tfor (size_t i = 0; i < vec.size(); i++) {\n\t\tbit.update(N[vec[i]].l, 1);\n\t\tif (i != 0) {\n\t\t\tNode *p = lca(&N[vec[i]], &N[vec[i - 1]]);\n\t\t\tbit.update(p->l, -1);\n\t\t}\n\t}\n}\n\ninline int solve(const int x) {\n\treturn bit.query(N[x].l, N[x].r);\n}\n\nint main() {\n\tint n;\n\tstatic char s[MAXLEN + 1];\n\tscanf(\"%d\", &n);\n\tTrie::Node *a[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\ta[i] = t.insert(s, s + len);\n\t}\n\n\tt.build();\n\tbuild();\n\tsplit();\n\tbit.init(tot);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--) {\n\t\tint cmd;\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tscanf(\"%s\", s);\n\t\t\tconst int len = strlen(s);\n#ifdef DBG\n\t\t\tprintf(\"add(\\\"%s\\\"): \", s);\n#endif\n\t\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\t\tadd(s, s + len);\n\t\t} else {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x), x--;\n\t\t\tprintf(\"%d\\n\", solve(a[x]->id));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/coci2015-divljak.md","raw":"title: BZOJ 3881Divljak - AC  + \ncategories: OI\ntags: \n  - BZOJ\n  - COCI\n  - \n  - AC \n  - \n  - \npermalink: bzoj-3881\ndate: 2016-09-18 07:27:00\n---\n\n $ n $  $ S_1, S_2, \\ldots, S_n $ $ T $  \n $ q $  $ T $  $ P $ $ T $  $ S_i $\n\n<!-- more -->\n\n### \n[BZOJ 3881](http://www.lydsy.com/JudgeOnline/problem.php?id=3881)\n\n### \n $ S_i $  AC  $ P $  $ P $  $ +1 $\n\n $ O(n ^ 2) $  $ O(n) $ Fail \n\n $ P $  Fail **** $ +1 $\n\n DFS \n\n $ +1 $ $ -1 $\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n\nconst int MAXN = 100000;\nconst int MAXLEN = 2000000;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nint tot;\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tint id;\n\t\tbool isWord, visited;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), id(tot++), isWord(isWord), visited(false) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end, std::vector<int> &vec) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = v->c[*p];\n\t\t\tif (v->isWord) vec.push_back(v->id);\n\t\t\telse if (v->next) vec.push_back(v->next->id);\n\t\t}\n\t}\n} t;\n\nstruct Node {\n\tstruct Edge *e;\n\tint l, r, depth, size;\n\tNode *p, *c, *top;\n\tbool visited;\n} N[MAXLEN + 1];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t) {\n#ifdef DBG\n\tprintf(\"addEdge: %d -> %d\\n\", s + 1, t + 1);\n#endif\n\tN[s].e = new Edge(&N[s], &N[t]);\n\tN[t].e = new Edge(&N[t], &N[s]);\n}\n\ninline void build() {\n\tstd::queue<Trie::Node *> q;\n\tq.push(t.root);\n\tt.root->visited = true;\n\twhile (!q.empty()) {\n\t\tTrie::Node *v = q.front();\n\t\tq.pop();\n\n\t\tif (v->fail != v) addEdge(v->id, v->fail->id);\n\n\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\tif (!v->c[i]->visited) {\n\t\t\t\tv->c[i]->visited = true;\n\t\t\t\tq.push(v->c[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void split() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\tN[0].depth = 1;\n\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->depth) {\n\t\t\t\te->t->depth = v->depth + 1;\n\t\t\t\te->t->p = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tif (!v->c || v->c->size < e->t->size) v->c = e->t;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) N[i].visited = false;\n\n\ts.push(&N[0]);\n\tint ts = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\tv->top = (!v->p || v != v->p->c) ? v : v->p->top;\n\t\t\tv->l = ++ts;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->p == v && e->t != v->c) {\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t\tif (v->c) s.push(v->c);\n\t\t} else {\n\t\t\tv->r = ts;\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tfor (int i = 0; i < tot; i++) assert(N[i].l && N[i].r);\n\n#ifdef DBG\n\tfor (int i = 0; i < tot; i++) {\n\t\tprintf(\"N[%d] => [%d, %d]\\n\", i + 1, N[i].l, N[i].r);\n\t}\n#endif\n}\n\ninline Node *lca(Node *a, Node *b) {\n\twhile (a->top != b->top) {\n\t\tif (a->top->depth < b->top->depth) std::swap(a, b);\n\t\ta = a->top->p;\n\t}\n\tNode *res = a->depth < b->depth ? a : b;\n#ifdef DBG\n\tprintf(\"lca(%lu, %lu) = %lu\\n\", a - N + 1, b - N + 1, res - N + 1);\n#endif\n\treturn res;\n}\n\ninline bool compare(const int a, const int b) {\n\treturn N[a].l < N[b].l;\n}\n\nstruct BinaryIndexedTree {\n\tint a[MAXLEN + 1 + 1 + 1], n;\n\n\tvoid init(const int n) { this->n = n; }\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tvoid update(const int pos, const int delta) {\n#ifdef DBG\n\t\tprintf(\"BIT: %d add %d\\n\", pos, delta);\n#endif\n#ifdef FORCE\n\t\ta[pos] += delta;\n\t\treturn;\n#endif\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i] += delta;\n\t}\n\n\tint sum(const int pos) {\n\t\tint res = 0;\n#ifdef FORCE\n\t\tfor (int i = 1; i <= pos; i++) res += a[i];\n\t\t// printf(\"sum(%d) = %d\\n\", pos, res);\n\t\treturn res;\n#endif\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) res += a[i];\n\t\treturn res;\n\t}\n\n\tint query(const int l, const int r) {\n#ifdef FORCE\n\t\tint res = 0;\n\t\tfor (int i = l; i <= r; i++) res += a[i];\n\t\t// printf(\"query(%d, %d) = %d\\n\", l, r, res);\n\t\treturn res;\n#endif\n\t\treturn sum(r) - sum(l - 1);\n\t}\n} bit;\n\ninline void add(const char *begin, const char *end) {\n\tstd::vector<int> vec;\n\tt.exec(begin, end, vec);\n\tstd::sort(vec.begin(), vec.end(), compare);\n\tvec.erase(std::unique(vec.begin(), vec.end()), vec.end());\n\n#ifdef DBG\n\tprintf(\"%lu matched:\", vec.size());\n\tfor (size_t i = 0; i < vec.size(); i++) printf(\" %d\", vec[i] + 1);\n\tputchar('\\n');\n#endif\n\n\tfor (size_t i = 0; i < vec.size(); i++) {\n\t\tbit.update(N[vec[i]].l, 1);\n\t\tif (i != 0) {\n\t\t\tNode *p = lca(&N[vec[i]], &N[vec[i - 1]]);\n\t\t\tbit.update(p->l, -1);\n\t\t}\n\t}\n}\n\ninline int solve(const int x) {\n\treturn bit.query(N[x].l, N[x].r);\n}\n\nint main() {\n\tint n;\n\tstatic char s[MAXLEN + 1];\n\tscanf(\"%d\", &n);\n\tTrie::Node *a[MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\ta[i] = t.insert(s, s + len);\n\t}\n\n\tt.build();\n\tbuild();\n\tsplit();\n\tbit.init(tot);\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--) {\n\t\tint cmd;\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd == 1) {\n\t\t\tscanf(\"%s\", s);\n\t\t\tconst int len = strlen(s);\n#ifdef DBG\n\t\t\tprintf(\"add(\\\"%s\\\"): \", s);\n#endif\n\t\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\t\tadd(s, s + len);\n\t\t} else {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x), x--;\n\t\t\tprintf(\"%d\\n\", solve(a[x]->id));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3881","published":1,"updated":"2016-09-18T23:01:08.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cyg01bdc2xluekyf0f3"},{"title":"","date":"2016-05-11T13:06:00.000Z","_content":"\n $ k $ \n\n<!-- more -->\n\n### \n\n\n $ k $    $ k $  $ k $  $ k $  $ k $ \n\n $ O(\\log n) $\n\n### \n $ k $  $ n $  $ a $  $ n $  $ i $ $ a_1 $ ~ $ a_i $  $ [l, r] $  $ k $  $ r $  $ l - 1 $  $ k $ \n\n\n\n1.  $ O(n \\log n) $  $ O(n ^ 2 \\log n) $\n2.  $ O(n \\log n) $  $ O(n \\log n) $  $ O((n + m) n \\log n) $\n\n**** $ O(n ^ 2) $ \n\n### \n $ n $  $ O(\\log n) $  $ O(n \\log n) $ \n\n $ 0 $  $ O(\\log n) $  $ O(n \\log n) $\n\n $ O(n \\log n) $  $ O(\\log n) $ \n\n### \n[POJ 2104](http://poj.org/problem?id=2104)  \n\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <new>\n\nconst int MAXN = 100000;\nconst int MAXM = 5000;\n\ntemplate <size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tvoid *alloc(const int size) {\n\t\tif (cur == buf + SIZE) return malloc(size);\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += size;\n\t\t\treturn p;\n\t\t}\n\t}\n};\n\nMemoryPool<(4 + 4 + 8 + 8 + 4) * MAXN * 10> pool;\nstruct ChairmanTree {\n\tstruct Node {\n\t\tint l, r;\n\t\tNode *lc, *rc;\n\t\tint cnt;\n\n\t\tNode(const int l, const int r, Node *lc = NULL, Node *rc = NULL) : l(l), r(r), lc(lc), rc(rc), cnt((lc ? lc->cnt : 0) + (rc ? rc->cnt : 0)) {}\n\t\tNode(const int l, const int r, const int cnt) : l(l), r(r), lc(NULL), rc(NULL), cnt(cnt) {}\n\n\t\tvoid pushDown() {\n\t\t\tif (lc && rc) return;\n\t\t\tint mid = l + ((r - l) >> 1);\n\t\t\tif (!lc) lc = new (pool.alloc(sizeof(Node))) Node(l, mid);\n\t\t\tif (!rc) rc = new (pool.alloc(sizeof(Node))) Node(mid + 1, r);\n\t\t}\n\n\t\tNode *insert(const int num) {\n\t\t\tif (num < l || num > r) return this;\n\t\t\telse if (num == l && num == r) return new (pool.alloc(sizeof(Node))) Node(l, r, this->cnt + 1);\n\t\t\telse {\n\t\t\t\tconst int mid = l + ((r - l) >> 1);\n\t\t\t\tpushDown();\n\t\t\t\tif (num <= mid) return new (pool.alloc(sizeof(Node))) Node(l, r, lc->insert(num), rc);\n\t\t\t\telse return new (pool.alloc(sizeof(Node))) Node(l, r, lc, rc->insert(num));\n\t\t\t}\n\t\t}\n\n\t\tint rank() const {\n\t\t\treturn lc ? lc->cnt : 0;\n\t\t}\n\t} *root[MAXN + 1];\n\tint n;\n\n\tvoid build(const int a[], const int n) {\n\t\tthis->n = n;\n\t\troot[0] = new (pool.alloc(sizeof(Node))) Node(0, n - 1);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\troot[i] = root[i - 1]->insert(a[i - 1]);\n\t\t}\n\t}\n\n\tint query(const int l, const int r, int k) {\n\t\tNode *L = root[l - 1], *R = root[r];\n\t\tint min = 0, max = n - 1;\n\t\twhile (min != max) {\n\t\t\tL->pushDown(), R->pushDown();\n\t\t\tint mid = min + ((max - min) >> 1), t = R->rank() - L->rank();\n\t\t\tif (k <= t) L = L->lc, R = R->lc, max = mid;\n\t\t\telse k -= t, L = L->rc, R = R->rc, min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n} t;\n\nint n, m, a[MAXN];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tt.build(a, n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint l, r, k;\n\t\tscanf(\"%d %d %d\", &l, &r, &k);\n\t\tint ans = t.query(l, r, k);\n\t\tprintf(\"%d\\n\", set[ans]);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/chairman-tree-notes.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \npermalink: chairman-tree-notes\ndate: 2016-05-11 21:06:00\n---\n\n $ k $ \n\n<!-- more -->\n\n### \n\n\n $ k $    $ k $  $ k $  $ k $  $ k $ \n\n $ O(\\log n) $\n\n### \n $ k $  $ n $  $ a $  $ n $  $ i $ $ a_1 $ ~ $ a_i $  $ [l, r] $  $ k $  $ r $  $ l - 1 $  $ k $ \n\n\n\n1.  $ O(n \\log n) $  $ O(n ^ 2 \\log n) $\n2.  $ O(n \\log n) $  $ O(n \\log n) $  $ O((n + m) n \\log n) $\n\n**** $ O(n ^ 2) $ \n\n### \n $ n $  $ O(\\log n) $  $ O(n \\log n) $ \n\n $ 0 $  $ O(\\log n) $  $ O(n \\log n) $\n\n $ O(n \\log n) $  $ O(\\log n) $ \n\n### \n[POJ 2104](http://poj.org/problem?id=2104)  \n\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <new>\n\nconst int MAXN = 100000;\nconst int MAXM = 5000;\n\ntemplate <size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tvoid *alloc(const int size) {\n\t\tif (cur == buf + SIZE) return malloc(size);\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += size;\n\t\t\treturn p;\n\t\t}\n\t}\n};\n\nMemoryPool<(4 + 4 + 8 + 8 + 4) * MAXN * 10> pool;\nstruct ChairmanTree {\n\tstruct Node {\n\t\tint l, r;\n\t\tNode *lc, *rc;\n\t\tint cnt;\n\n\t\tNode(const int l, const int r, Node *lc = NULL, Node *rc = NULL) : l(l), r(r), lc(lc), rc(rc), cnt((lc ? lc->cnt : 0) + (rc ? rc->cnt : 0)) {}\n\t\tNode(const int l, const int r, const int cnt) : l(l), r(r), lc(NULL), rc(NULL), cnt(cnt) {}\n\n\t\tvoid pushDown() {\n\t\t\tif (lc && rc) return;\n\t\t\tint mid = l + ((r - l) >> 1);\n\t\t\tif (!lc) lc = new (pool.alloc(sizeof(Node))) Node(l, mid);\n\t\t\tif (!rc) rc = new (pool.alloc(sizeof(Node))) Node(mid + 1, r);\n\t\t}\n\n\t\tNode *insert(const int num) {\n\t\t\tif (num < l || num > r) return this;\n\t\t\telse if (num == l && num == r) return new (pool.alloc(sizeof(Node))) Node(l, r, this->cnt + 1);\n\t\t\telse {\n\t\t\t\tconst int mid = l + ((r - l) >> 1);\n\t\t\t\tpushDown();\n\t\t\t\tif (num <= mid) return new (pool.alloc(sizeof(Node))) Node(l, r, lc->insert(num), rc);\n\t\t\t\telse return new (pool.alloc(sizeof(Node))) Node(l, r, lc, rc->insert(num));\n\t\t\t}\n\t\t}\n\n\t\tint rank() const {\n\t\t\treturn lc ? lc->cnt : 0;\n\t\t}\n\t} *root[MAXN + 1];\n\tint n;\n\n\tvoid build(const int a[], const int n) {\n\t\tthis->n = n;\n\t\troot[0] = new (pool.alloc(sizeof(Node))) Node(0, n - 1);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\troot[i] = root[i - 1]->insert(a[i - 1]);\n\t\t}\n\t}\n\n\tint query(const int l, const int r, int k) {\n\t\tNode *L = root[l - 1], *R = root[r];\n\t\tint min = 0, max = n - 1;\n\t\twhile (min != max) {\n\t\t\tL->pushDown(), R->pushDown();\n\t\t\tint mid = min + ((max - min) >> 1), t = R->rank() - L->rank();\n\t\t\tif (k <= t) L = L->lc, R = R->lc, max = mid;\n\t\t\telse k -= t, L = L->rc, R = R->rc, min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n} t;\n\nint n, m, a[MAXN];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tstatic int set[MAXN];\n\tstd::copy(a, a + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, a[i]) - set;\n\n\tt.build(a, n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint l, r, k;\n\t\tscanf(\"%d %d %d\", &l, &r, &k);\n\t\tint ans = t.query(l, r, k);\n\t\tprintf(\"%d\\n\", set[ans]);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"chairman-tree-notes","published":1,"updated":"2016-05-11T13:06:44.900Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cyq01bnc2xl0a9o9024"},{"title":"Codeforces 716EDigit Tree - ","date":"2016-09-21T02:30:00.000Z","_content":"\n $ [1, 9] $  $ (u, v) $  $ u $  $ v $  $ m $  $ \\gcd(m, 10) = 1 $\n\n<!-- more -->\n\n### \n[Codeforces 716E](http://codeforces.com/contest/716/problem/E)\n\n### \n\n\n $ a_i $  $ i $ $ b_i $ $ d_i $  $ i $  $ a_i $  $ b_i $ \n\n![](/cf-716e/example.svg)\n\n$$\n\\begin{cases}\na_u = 321 & a_v = 54 \\\\\nb_u = 123 & b_v = 45 \\\\\nd_u = 3 & d_v = 2\n\\end{cases}\n$$\n\n $ u $  $ v $ \n\n$$ a_u \\times 10 ^ {d_v} + b_v $$\n\n\n\n$$ a_u \\times 10 ^ {d_v} + b_v \\equiv 0 \\pmod m $$\n\n $ a_i $  $ b_i $ \n\n\n\n$$ a_u \\equiv -b_v \\times \\frac{1}{10 ^ {d_v}} \\pmod m $$\n\n $ u $ $ a_u $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <map>\n#include <iostream>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent;\n\tint size, depth, max;\n\tbool visited, solved;\n\tlong long backward, forward;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, mod;\nlong long pow10[MAXN + 1], pow10Inv[MAXN + 1];\n\nvoid exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long x) {\n\tlong long tmp1, res, tmp2;\n\texgcd(x, mod, tmp1, res, tmp2);\n\treturn (res % mod + mod) % mod;\n}\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline long long calc(Node *root, const int pre = 0) {\n\tif (pre != 0) {\n\t\troot->forward = root->backward = pre;\n\t\troot->depth = 1;\n\t} else {\n\t\troot->forward = root->backward = 0;\n\t\troot->depth = 0;\n\t}\n\troot->parent = NULL;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\n\tstd::map<long long, int> map;\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tmap[(mod - v->forward) * pow10Inv[v->depth] % mod]++;\n\t\tassert((mod - v->forward) * pow10Inv[v->depth] % mod >= 0);\n\t\ta[cnt++] = v;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->forward = (v->forward * 10 + e->w) % mod;\n\t\t\te->t->backward = (e->w * pow10[v->depth] + v->backward) % mod;\n#ifdef DBG\n\t\t\tprintf(\"%lld <--> %lld\\n\", e->t->forward, e->t->backward);\n#endif\n\t\t\te->t->parent = v;\n\t\t\te->t->depth = v->depth + 1;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tlong long ans = 0; // pre ? 0 : -1 * 0;\n#ifdef FORCE\n\tfor (int i = 0; i < cnt; i++) {\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tif ((a[i]->backward * pow10[a[j]->depth] + a[j]->forward) % 3 == 0 /*&& !(a[i]->backward == 0 && a[j]->forward == 0)*/) {\n\t\t\t\tans++;\n#ifdef DBG\n\t\t\t\tprintf(\"%lld\\n\", a[i]->backward * pow10[a[j]->depth] + a[j]->forward);\n#endif\n\t\t\t}\n\t\t\tif (a[i]->backward == 0 && a[j]->forward == 0) printf(\"%lu %lu in %lu, %d\\n\", a[i] - N + 1, a[j] - N + 1, root - N + 1, pre), ans--;\n\t\t}\n\t}\n#else\n\tmap[0]--;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tans += map[a[i]->backward];\n#ifdef DBG\n\t\tprintf(\"back = %lld, ans + %d\\n\", a[i]->backward, map[a[i]->backward]);\n#endif\n\t}\n#endif\n#ifdef DBG\n\tfor (std::map<long long, int>::const_iterator it = map.begin(); it != map.end(); it++) printf(\"[%lld => %d]\\n\", it->first, it->second);\n\tprintf(\"** ans = %lld\\n\", ans);\n#endif\n\n\treturn ans;\n}\n\ninline long long solve() {\n\tstd::queue<Node *> q;\n\tq.push(&N[0]);\n\n\tlong long ans = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n#ifdef DBG\n\t\tputs(\"+++++++++++++++++++\");\n#endif\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n#ifdef DBG\n\t\t\tputs(\"-------------------\");\n#endif\n\t\t\tans -= calc(e->t, e->w);\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &mod);\n#ifdef FORCE\n\tmod = 1e9 + 7;\n#endif\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\taddEdge(u, v, w % mod);\n\t}\n\n\tpow10[0] = pow10Inv[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tpow10[i] = pow10[i - 1] * 10 % mod;\n\t\tpow10Inv[i] = inv(pow10[i]);\n\t}\n\n\tstd::cout << solve() << std::endl;\n\n\treturn 0;\n}\n```","source":"_posts/cf-716e.md","raw":"title: Codeforces 716EDigit Tree - \ncategories: OI\ntags: \n  - Codeforces\n  - \n  - \n  - \n  - \n  - \npermalink: cf-716e\ndate: 2016-09-21 10:30:00\n---\n\n $ [1, 9] $  $ (u, v) $  $ u $  $ v $  $ m $  $ \\gcd(m, 10) = 1 $\n\n<!-- more -->\n\n### \n[Codeforces 716E](http://codeforces.com/contest/716/problem/E)\n\n### \n\n\n $ a_i $  $ i $ $ b_i $ $ d_i $  $ i $  $ a_i $  $ b_i $ \n\n![](/cf-716e/example.svg)\n\n$$\n\\begin{cases}\na_u = 321 & a_v = 54 \\\\\nb_u = 123 & b_v = 45 \\\\\nd_u = 3 & d_v = 2\n\\end{cases}\n$$\n\n $ u $  $ v $ \n\n$$ a_u \\times 10 ^ {d_v} + b_v $$\n\n\n\n$$ a_u \\times 10 ^ {d_v} + b_v \\equiv 0 \\pmod m $$\n\n $ a_i $  $ b_i $ \n\n\n\n$$ a_u \\equiv -b_v \\times \\frac{1}{10 ^ {d_v}} \\pmod m $$\n\n $ u $ $ a_u $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <map>\n#include <iostream>\n\nconst int MAXN = 100000;\n\nstruct Node {\n\tstruct Edge *e;\n\tNode *parent;\n\tint size, depth, max;\n\tbool visited, solved;\n\tlong long backward, forward;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, mod;\nlong long pow10[MAXN + 1], pow10Inv[MAXN + 1];\n\nvoid exgcd(const long long a, const long long b, long long &g, long long &x, long long &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ninline long long inv(const long long x) {\n\tlong long tmp1, res, tmp2;\n\texgcd(x, mod, tmp1, res, tmp2);\n\treturn (res % mod + mod) % mod;\n}\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, cnt - a[i]->size);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline long long calc(Node *root, const int pre = 0) {\n\tif (pre != 0) {\n\t\troot->forward = root->backward = pre;\n\t\troot->depth = 1;\n\t} else {\n\t\troot->forward = root->backward = 0;\n\t\troot->depth = 0;\n\t}\n\troot->parent = NULL;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\n\tstd::map<long long, int> map;\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tmap[(mod - v->forward) * pow10Inv[v->depth] % mod]++;\n\t\tassert((mod - v->forward) * pow10Inv[v->depth] % mod >= 0);\n\t\ta[cnt++] = v;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->forward = (v->forward * 10 + e->w) % mod;\n\t\t\te->t->backward = (e->w * pow10[v->depth] + v->backward) % mod;\n#ifdef DBG\n\t\t\tprintf(\"%lld <--> %lld\\n\", e->t->forward, e->t->backward);\n#endif\n\t\t\te->t->parent = v;\n\t\t\te->t->depth = v->depth + 1;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tlong long ans = 0; // pre ? 0 : -1 * 0;\n#ifdef FORCE\n\tfor (int i = 0; i < cnt; i++) {\n\t\tfor (int j = 0; j < cnt; j++) {\n\t\t\tif ((a[i]->backward * pow10[a[j]->depth] + a[j]->forward) % 3 == 0 /*&& !(a[i]->backward == 0 && a[j]->forward == 0)*/) {\n\t\t\t\tans++;\n#ifdef DBG\n\t\t\t\tprintf(\"%lld\\n\", a[i]->backward * pow10[a[j]->depth] + a[j]->forward);\n#endif\n\t\t\t}\n\t\t\tif (a[i]->backward == 0 && a[j]->forward == 0) printf(\"%lu %lu in %lu, %d\\n\", a[i] - N + 1, a[j] - N + 1, root - N + 1, pre), ans--;\n\t\t}\n\t}\n#else\n\tmap[0]--;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tans += map[a[i]->backward];\n#ifdef DBG\n\t\tprintf(\"back = %lld, ans + %d\\n\", a[i]->backward, map[a[i]->backward]);\n#endif\n\t}\n#endif\n#ifdef DBG\n\tfor (std::map<long long, int>::const_iterator it = map.begin(); it != map.end(); it++) printf(\"[%lld => %d]\\n\", it->first, it->second);\n\tprintf(\"** ans = %lld\\n\", ans);\n#endif\n\n\treturn ans;\n}\n\ninline long long solve() {\n\tstd::queue<Node *> q;\n\tq.push(&N[0]);\n\n\tlong long ans = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n#ifdef DBG\n\t\tputs(\"+++++++++++++++++++\");\n#endif\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n#ifdef DBG\n\t\t\tputs(\"-------------------\");\n#endif\n\t\t\tans -= calc(e->t, e->w);\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &mod);\n#ifdef FORCE\n\tmod = 1e9 + 7;\n#endif\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\taddEdge(u, v, w % mod);\n\t}\n\n\tpow10[0] = pow10Inv[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tpow10[i] = pow10[i - 1] * 10 % mod;\n\t\tpow10Inv[i] = inv(pow10[i]);\n\t}\n\n\tstd::cout << solve() << std::endl;\n\n\treturn 0;\n}\n```","slug":"cf-716e","published":1,"updated":"2016-09-21T06:44:32.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cyx01btc2xlgexlzpn6"},{"title":"Codeforces 628DMagic Numbers -  DP","date":"2016-05-12T07:47:00.000Z","_content":"\n `d-magic`  $ d $ \n\n$ 1727374,\\ 17,\\ 1 $  `7-magic`  $ 77,\\ 7,\\ 123,\\ 34,\\ 71 $  `7-magic` \n\n `m`  `d-magic`  $ [a, b] $ \n\n<!-- more -->\n\n### \n[Codeforces 628D](http://codeforces.com/contest/628/problem/D)\n\n### \n DP\n\n$$ f[n][limit][r] $$\n\n $ n $  $ limit $ $ m $  $ r $ \n\n $ [a, b] $  $ g(x) $  $ [0, x] $  $ g(b) - g(a - 1) $ $ a $  $ g(b) - g(a) $ $ a $ \n\n### \n```c++\n// #pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 2000;\nconst int MAXM = 2000;\nconst int MAXD = 9;\nconst int MOD = 1e9 + 7;\nconst int LIMIT_UNLIMITED = 10;\n\nint a[MAXN];\nint mem[MAXN + 1][11][MAXM + 1];\nbool calced[MAXN + 1][11][MAXM + 1];\n\nint pow10[MAXN + 1];\n\nint n, d, m;\nbool isEven[MAXN];\n\ninline void prepare() {\n    pow10[0] = 1;\n    for (int i = 1; i <= MAXN; i++)  {\n        pow10[i] = static_cast<long long>(pow10[i - 1]) * 10 % m;\n    }\n}\n\ninline int modm(const int r) {\n    return ((r % m) + m) % m;\n}\n\ninline int mul(const int x, const int n) {\n    return static_cast<long long>(pow10[n]) * x % m;\n}\n\ninline int dec(const int r, const int x) {\n    return modm(r - x);\n}\n\n// int A[MAXN];\ninline int dp(const int n, const int limit, const int r) {\n    int &ans = mem[n][limit][r];\n    if (calced[n][limit][r]) return ans;\n    calced[n][limit][r] = true;\n    \n    if (n == 0) {\n        if (r == 0) ans = 1;\n        else ans = 0;\n        // if (ans == 1) {\n        //     for (int i = 0; i < ::n; i++) putchar('0' + A[i]);\n        //     putchar('\\n');\n        // }\n    } else {\n        int next;\n        if (n != 1) next = a[::n - n + 1];\n        else next = LIMIT_UNLIMITED;\n        \n        int _l, _r;\n        if (isEven[n]) _l = d, _r = std::min(limit, d);\n        else _l = 0, _r = std::min(limit, 9);\n        \n        for (int i = _l; i <= _r; i++) {\n            // A[::n - n] = i;\n\n            if (!isEven[n] && i == d) continue;\n            // if (isEven[n] && i != d) continue;\n            \n            int t;\n            if (i < limit || limit == LIMIT_UNLIMITED) {\n                t = LIMIT_UNLIMITED;\n            } else {\n                t = next;\n            }\n            \n            ans = (ans + dp(\n                    n - 1,\n                    t,\n                    dec(r, mul(i, n - 1))\n            )) % MOD;\n        }\n    }\n    \n    // if (r == 178) printf(\"f[%d][%d][%s][%d] = %d\\n\", n, limit, isEven ? \"true\" : \"false\", r, ans);\n    return ans;\n}\n\ninline int solve(const char *s) {\n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    for (int i = 0; i < n; i++) a[i] = s[i] - '0';\n    \n    int ans = 0, &limit = a[0];\n    for (int i = 1; i <= std::min(limit, 9); i++) {\n        if (i == d) continue;\n        \n        int t;\n        if (i < limit || n == 1) {\n            t = LIMIT_UNLIMITED;\n        } else {\n            t = a[1];\n        }\n        \n        // A[0] = i;\n        ans = (ans + dp(n - 1, t, dec(0, mul(i, n - 1)))) % MOD;\n    }\n    \n    // printf(\"solve(%s) = %d\\n\", s, ans);\n    return ans;\n}\n\ninline int judge(const char *s) {\n    int r = 0;\n    bool isEven = false;\n    for (int i = 0; i < n; i++) {\n        if (!isEven && s[i] - '0' == d) return 0;\n        if (isEven && s[i] - '0' != d) return 0;\n        \n        r = modm(r - mul(s[i] - '0', n - i - 1));\n        isEven ^= 1;\n    }\n    return r == 0 ? 1 : 0;\n}\n\nint main() {\n    // int size = 16 << 20;\n    // char *p = (char *)malloc(size) + size;\n    // __asm__(\"movq %0, %%rsp\\n\" :: \"r\"(p));\n    // __asm__(\"movl %0, %%esp\\n\" :: \"r\"(p));\n    \n    static char s1[MAXN + 1], s2[MAXN + 1];\n    scanf(\"%d %d\\n%s\\n%s\", &m, &d, s1, s2);\n    \n    prepare();\n    n = strlen(s1);\n    \n    isEven[n - 1] = true;\n    for (int i = n - 2; i >= 0; i--) isEven[i] = !isEven[i + 1];\n    \n    int ans = (solve(s2) - solve(s1) + judge(s1)) % MOD;\n    printf(\"%d\\n\", (ans + MOD) % MOD);\n    \n    // exit(0);\n    return 0;\n}\n```\n","source":"_posts/cf-628d.md","raw":"title: Codeforces 628DMagic Numbers -  DP\ncategories: OI\ntags: \n  - Codeforces\n  -  DP\n  - DP\npermalink: cf-628d\ndate: 2016-05-12 15:47:00\n---\n\n `d-magic`  $ d $ \n\n$ 1727374,\\ 17,\\ 1 $  `7-magic`  $ 77,\\ 7,\\ 123,\\ 34,\\ 71 $  `7-magic` \n\n `m`  `d-magic`  $ [a, b] $ \n\n<!-- more -->\n\n### \n[Codeforces 628D](http://codeforces.com/contest/628/problem/D)\n\n### \n DP\n\n$$ f[n][limit][r] $$\n\n $ n $  $ limit $ $ m $  $ r $ \n\n $ [a, b] $  $ g(x) $  $ [0, x] $  $ g(b) - g(a - 1) $ $ a $  $ g(b) - g(a) $ $ a $ \n\n### \n```c++\n// #pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 2000;\nconst int MAXM = 2000;\nconst int MAXD = 9;\nconst int MOD = 1e9 + 7;\nconst int LIMIT_UNLIMITED = 10;\n\nint a[MAXN];\nint mem[MAXN + 1][11][MAXM + 1];\nbool calced[MAXN + 1][11][MAXM + 1];\n\nint pow10[MAXN + 1];\n\nint n, d, m;\nbool isEven[MAXN];\n\ninline void prepare() {\n    pow10[0] = 1;\n    for (int i = 1; i <= MAXN; i++)  {\n        pow10[i] = static_cast<long long>(pow10[i - 1]) * 10 % m;\n    }\n}\n\ninline int modm(const int r) {\n    return ((r % m) + m) % m;\n}\n\ninline int mul(const int x, const int n) {\n    return static_cast<long long>(pow10[n]) * x % m;\n}\n\ninline int dec(const int r, const int x) {\n    return modm(r - x);\n}\n\n// int A[MAXN];\ninline int dp(const int n, const int limit, const int r) {\n    int &ans = mem[n][limit][r];\n    if (calced[n][limit][r]) return ans;\n    calced[n][limit][r] = true;\n    \n    if (n == 0) {\n        if (r == 0) ans = 1;\n        else ans = 0;\n        // if (ans == 1) {\n        //     for (int i = 0; i < ::n; i++) putchar('0' + A[i]);\n        //     putchar('\\n');\n        // }\n    } else {\n        int next;\n        if (n != 1) next = a[::n - n + 1];\n        else next = LIMIT_UNLIMITED;\n        \n        int _l, _r;\n        if (isEven[n]) _l = d, _r = std::min(limit, d);\n        else _l = 0, _r = std::min(limit, 9);\n        \n        for (int i = _l; i <= _r; i++) {\n            // A[::n - n] = i;\n\n            if (!isEven[n] && i == d) continue;\n            // if (isEven[n] && i != d) continue;\n            \n            int t;\n            if (i < limit || limit == LIMIT_UNLIMITED) {\n                t = LIMIT_UNLIMITED;\n            } else {\n                t = next;\n            }\n            \n            ans = (ans + dp(\n                    n - 1,\n                    t,\n                    dec(r, mul(i, n - 1))\n            )) % MOD;\n        }\n    }\n    \n    // if (r == 178) printf(\"f[%d][%d][%s][%d] = %d\\n\", n, limit, isEven ? \"true\" : \"false\", r, ans);\n    return ans;\n}\n\ninline int solve(const char *s) {\n    memset(mem, 0, sizeof(mem));\n    memset(calced, 0, sizeof(calced));\n    \n    for (int i = 0; i < n; i++) a[i] = s[i] - '0';\n    \n    int ans = 0, &limit = a[0];\n    for (int i = 1; i <= std::min(limit, 9); i++) {\n        if (i == d) continue;\n        \n        int t;\n        if (i < limit || n == 1) {\n            t = LIMIT_UNLIMITED;\n        } else {\n            t = a[1];\n        }\n        \n        // A[0] = i;\n        ans = (ans + dp(n - 1, t, dec(0, mul(i, n - 1)))) % MOD;\n    }\n    \n    // printf(\"solve(%s) = %d\\n\", s, ans);\n    return ans;\n}\n\ninline int judge(const char *s) {\n    int r = 0;\n    bool isEven = false;\n    for (int i = 0; i < n; i++) {\n        if (!isEven && s[i] - '0' == d) return 0;\n        if (isEven && s[i] - '0' != d) return 0;\n        \n        r = modm(r - mul(s[i] - '0', n - i - 1));\n        isEven ^= 1;\n    }\n    return r == 0 ? 1 : 0;\n}\n\nint main() {\n    // int size = 16 << 20;\n    // char *p = (char *)malloc(size) + size;\n    // __asm__(\"movq %0, %%rsp\\n\" :: \"r\"(p));\n    // __asm__(\"movl %0, %%esp\\n\" :: \"r\"(p));\n    \n    static char s1[MAXN + 1], s2[MAXN + 1];\n    scanf(\"%d %d\\n%s\\n%s\", &m, &d, s1, s2);\n    \n    prepare();\n    n = strlen(s1);\n    \n    isEven[n - 1] = true;\n    for (int i = n - 2; i >= 0; i--) isEven[i] = !isEven[i + 1];\n    \n    int ans = (solve(s2) - solve(s1) + judge(s1)) % MOD;\n    printf(\"%d\\n\", (ans + MOD) % MOD);\n    \n    // exit(0);\n    return 0;\n}\n```\n","slug":"cf-628d","published":1,"updated":"2016-10-24T23:38:39.769Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6cza01c2c2xl6g35bgwb"},{"title":"CEOI2008Order - ","date":"2016-06-22T08:07:00.000Z","_content":"\n $ N $ $ M $ \n\n<!-- more -->\n\n### \n[BZOJ 1391](http://www.lydsy.com/JudgeOnline/problem.php?id=1391)\n\n### \n\n\n\n\n\n\n\n\n### \n MLE \n\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n// #include <queue>\n// #include <vector>\n\nconst int MAXN = 1200;\nconst int MAXM = 1200;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\t// std::queue<Node *> q;\n\t\t// q.push(s);\n\t\tstatic Node *q[MAXN + MAXM + 2];\n\t\tNode **l = q, **r = q - 1;\n\t\t*++r = s;\n\n\t\ts->l = 1;\n\n\t\twhile (l <= r /* !q.empty() */) {\n\t\t\tNode *v = *l++ /* q.front() */;\n\t\t\t// q.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse *++r = e->t; // q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint w, k;\n\t\tscanf(\"%d %d\", &w, &k);\n\t\tsum += w;\n\n\t\taddEdge(s, i, w);\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x, c;\n\t\t\tscanf(\"%d %d\", &x, &c);\n\n\t\t\taddEdge(i, n + x, c);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\taddEdge(n + i, t, x);\n\t}\n\n\t/*\n\tstatic int w[MAXN];\n\tstatic std::vector< std::pair<int, int> > used[MAXN];\n\tstatic std::vector<int> borrow[MAXM];\n\tstatic std::pair<int, int> buy[MAXM];\n\tint id = n + 1, sum = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint k;\n\t\tscanf(\"%d %d\", &w[i - 1], &k);\n\t\tsum += w[i - 1];\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x, c;\n\t\t\tscanf(\"%d %d\", &x, &c);\n\n\t\t\tint t = id++;\n\t\t\tused[i - 1].push_back(std::make_pair(t, c));\n\t\t\tborrow[x - 1].push_back(t);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d\", &buy[i].second);\n\t\tbuy[i].first = id++;\n\t}\n\n\tconst int s = 0, t = id++;\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, w[i - 1]);\n\n\t\tfor (std::vector< std::pair<int, int> >::const_iterator it = used[i - 1].begin(); it != used[i - 1].end(); it++) {\n\t\t\taddEdge(i, it->first, it->second);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (std::vector<int>::const_iterator it = borrow[i].begin(); it != borrow[i].end(); it++) {\n\t\t\taddEdge(*it, buy[i].first, INT_MAX);\n\t\t}\n\t\taddEdge(buy[i].first, t, buy[i].second);\n\t}\n\t*/\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/ceoi2008-order.md","raw":"title: CEOI2008Order - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - Dinic\n  - \npermalink: ceoi2008-order\ndate: 2016-06-22 16:07:00\n---\n\n $ N $ $ M $ \n\n<!-- more -->\n\n### \n[BZOJ 1391](http://www.lydsy.com/JudgeOnline/problem.php?id=1391)\n\n### \n\n\n\n\n\n\n\n\n### \n MLE \n\n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n// #include <queue>\n// #include <vector>\n\nconst int MAXN = 1200;\nconst int MAXM = 1200;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\t// std::queue<Node *> q;\n\t\t// q.push(s);\n\t\tstatic Node *q[MAXN + MAXM + 2];\n\t\tNode **l = q, **r = q - 1;\n\t\t*++r = s;\n\n\t\ts->l = 1;\n\n\t\twhile (l <= r /* !q.empty() */) {\n\t\t\tNode *v = *l++ /* q.front() */;\n\t\t\t// q.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse *++r = e->t; // q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tconst int s = 0, t = n + m + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint w, k;\n\t\tscanf(\"%d %d\", &w, &k);\n\t\tsum += w;\n\n\t\taddEdge(s, i, w);\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x, c;\n\t\t\tscanf(\"%d %d\", &x, &c);\n\n\t\t\taddEdge(i, n + x, c);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\taddEdge(n + i, t, x);\n\t}\n\n\t/*\n\tstatic int w[MAXN];\n\tstatic std::vector< std::pair<int, int> > used[MAXN];\n\tstatic std::vector<int> borrow[MAXM];\n\tstatic std::pair<int, int> buy[MAXM];\n\tint id = n + 1, sum = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint k;\n\t\tscanf(\"%d %d\", &w[i - 1], &k);\n\t\tsum += w[i - 1];\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x, c;\n\t\t\tscanf(\"%d %d\", &x, &c);\n\n\t\t\tint t = id++;\n\t\t\tused[i - 1].push_back(std::make_pair(t, c));\n\t\t\tborrow[x - 1].push_back(t);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d\", &buy[i].second);\n\t\tbuy[i].first = id++;\n\t}\n\n\tconst int s = 0, t = id++;\n\tfor (int i = 1; i <= n; i++) {\n\t\taddEdge(s, i, w[i - 1]);\n\n\t\tfor (std::vector< std::pair<int, int> >::const_iterator it = used[i - 1].begin(); it != used[i - 1].end(); it++) {\n\t\t\taddEdge(i, it->first, it->second);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (std::vector<int>::const_iterator it = borrow[i].begin(); it != borrow[i].end(); it++) {\n\t\t\taddEdge(*it, buy[i].first, INT_MAX);\n\t\t}\n\t\taddEdge(buy[i].first, t, buy[i].second);\n\t}\n\t*/\n\n\tint maxFlow = dinic(s, t, n + m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"ceoi2008-order","published":1,"updated":"2016-06-22T08:07:58.396Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6czf01c7c2xl31nuewiw"},{"title":"CEOI2004 -  DP","date":"2016-05-18T10:03:00.000Z","_content":"\n $ n $ \n\n\n<!-- more -->\n\n### \n[COGS 362](http://cogs.top/cogs/problem/problem.php?pid=362)\n\n### \n $ 0 $ \n\n $ f[i][j] $  $ i $  $ j $  $ f(i) $  $ f[i][j] $$ g(i) $  $ f[i][j - 1] $$ S(i) $  $ i $  $ 0 $ $ s(i) $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i} \\{ g(j) + S(i) - S(j) - (s(i) - s(j)) \\times d(j + 1) \\} $$\n\n $ a $$ b $ $ a $  $ b $ \n\n$$\n{(g(a) - S(a) + s(a) \\times d(a + 1)) - (g(b) - S(b) + s(b) \\times d(b + 1)) \\over d(a + 1) - d(b + 1)} < s(i)\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 3;\n\nint n;\nlong long w[MAXN + 1], d[MAXN + 1], s[MAXN + 1], S[MAXN + 1];\nlong long g[MAXN + 1], f[MAXN + 1];\n\ninline void prepare() {\n    std::reverse(w + 1, w + n + 1);\n    std::reverse(d + 1, d + n + 1);\n    \n    for (int i = 1; i <= n; i++) {\n        d[i] += d[i - 1];\n        s[i] = s[i - 1] + w[i];\n        S[i] = S[i - 1] + w[i] * d[i];\n    }\n}\n\n/*\ninline void force() {\n    std::copy(S, S + n + 1, f);\n    for (int k = 1; k < MAXM; k++) {\n        std::copy(f, f + n + 1, g);\n        std::fill(f, f + n + 1, LLONG_MAX);\n\n        f[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            int _j = -1;\n            for (int j = 0; j < i; j++) {\n                if (f[i] > g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]) {\n                    f[i] = g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n                    _j = j;\n                }\n            }\n            printf(\"%d --> %d\\n\", i, _j);\n        }\n    }\n}\n*/\n\ninline long long x(const int i) { return g[i] - S[i] + s[i] * d[i + 1]; }\n\ninline double slope(const int a, const int b) {\n    return double(x(a) - x(b))\n         / double(d[a + 1] - d[b + 1]);\n}\n\ninline void dp() {\n    std::copy(S, S + n + 1, f);\n    for (int k = 1; k < MAXM; k++) {\n        std::copy(f, f + n + 1, g);\n        std::fill(f, f + n + 1, LLONG_MAX);\n\n        f[0] = 0;\n\n        static int q[MAXN];\n        int *l = q, *r = q;\n        *r = 0;\n\n        for (int i = 1; i <= n; i++) {\n            while (l < r && slope(*(l + 1), *l) < s[i]) l++;\n\n            int &j = *l;\n            f[i] = g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n            // printf(\"%d --> %d\\n\", i, j);\n\n            if (i < n) {\n                while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n                *++r = i;\n            }\n        }\n    }\n}\n\nint main() {\n    freopen(\"two.in\", \"r\", stdin);\n    freopen(\"two.out\", \"w\", stdout);\n\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lld %lld\", &w[i], &d[i]);\n    }\n\n    prepare();\n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","source":"_posts/ceoi2004-two.md","raw":"title: CEOI2004 -  DP\ncategories: OI\ntags: \n  - COGS\n  - CEOI\n  - \n  - \n  - DP\npermalink: ceoi2004-two\ndate: 2016-05-18 18:03:00\n---\n\n $ n $ \n\n\n<!-- more -->\n\n### \n[COGS 362](http://cogs.top/cogs/problem/problem.php?pid=362)\n\n### \n $ 0 $ \n\n $ f[i][j] $  $ i $  $ j $  $ f(i) $  $ f[i][j] $$ g(i) $  $ f[i][j - 1] $$ S(i) $  $ i $  $ 0 $ $ s(i) $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i} \\{ g(j) + S(i) - S(j) - (s(i) - s(j)) \\times d(j + 1) \\} $$\n\n $ a $$ b $ $ a $  $ b $ \n\n$$\n{(g(a) - S(a) + s(a) \\times d(a + 1)) - (g(b) - S(b) + s(b) \\times d(b + 1)) \\over d(a + 1) - d(b + 1)} < s(i)\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 3;\n\nint n;\nlong long w[MAXN + 1], d[MAXN + 1], s[MAXN + 1], S[MAXN + 1];\nlong long g[MAXN + 1], f[MAXN + 1];\n\ninline void prepare() {\n    std::reverse(w + 1, w + n + 1);\n    std::reverse(d + 1, d + n + 1);\n    \n    for (int i = 1; i <= n; i++) {\n        d[i] += d[i - 1];\n        s[i] = s[i - 1] + w[i];\n        S[i] = S[i - 1] + w[i] * d[i];\n    }\n}\n\n/*\ninline void force() {\n    std::copy(S, S + n + 1, f);\n    for (int k = 1; k < MAXM; k++) {\n        std::copy(f, f + n + 1, g);\n        std::fill(f, f + n + 1, LLONG_MAX);\n\n        f[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            int _j = -1;\n            for (int j = 0; j < i; j++) {\n                if (f[i] > g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1]) {\n                    f[i] = g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n                    _j = j;\n                }\n            }\n            printf(\"%d --> %d\\n\", i, _j);\n        }\n    }\n}\n*/\n\ninline long long x(const int i) { return g[i] - S[i] + s[i] * d[i + 1]; }\n\ninline double slope(const int a, const int b) {\n    return double(x(a) - x(b))\n         / double(d[a + 1] - d[b + 1]);\n}\n\ninline void dp() {\n    std::copy(S, S + n + 1, f);\n    for (int k = 1; k < MAXM; k++) {\n        std::copy(f, f + n + 1, g);\n        std::fill(f, f + n + 1, LLONG_MAX);\n\n        f[0] = 0;\n\n        static int q[MAXN];\n        int *l = q, *r = q;\n        *r = 0;\n\n        for (int i = 1; i <= n; i++) {\n            while (l < r && slope(*(l + 1), *l) < s[i]) l++;\n\n            int &j = *l;\n            f[i] = g[j] + S[i] - S[j] - (s[i] - s[j]) * d[j + 1];\n            // printf(\"%d --> %d\\n\", i, j);\n\n            if (i < n) {\n                while (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n                *++r = i;\n            }\n        }\n    }\n}\n\nint main() {\n    freopen(\"two.in\", \"r\", stdin);\n    freopen(\"two.out\", \"w\", stdout);\n\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lld %lld\", &w[i], &d[i]);\n    }\n\n    prepare();\n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n\n    fclose(stdin);\n    fclose(stdout);\n\n    return 0;\n}\n```\n","slug":"ceoi2004-two","published":1,"updated":"2016-10-24T23:34:14.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6czl01cdc2xlczfe3g86"},{"title":"BZOJ 4403 - ","date":"2016-04-08T14:11:34.000Z","_content":"\n $ N $$ L $  $ R $ $ 1 $  $ N $  $ L $  $ R $  $ 10 ^ 6 + 3 $ \n\n<!-- more -->\n\n### \n[BZOJ 4403](http://www.lydsy.com/JudgeOnline/problem.php?id=4403)\n\n### \n $ [1, R - L + 1] $  $ N $ \n\n\n\n$$ M = R - L + 1 $$\n\n\n\n$$\n\\begin{align}\n& \\sum\\limits_{i = 1} ^ N C(i + M - 1, i) \\\\\n= & \\sum\\limits_{i = 1} ^ N C(i + M - 1, M - 1) \\\\\n= & \\sum\\limits_{i = 1} ^ N C(i + M - 1, M - 1) + C(m, m) - 1 \\\\\n= & \\sum\\limits_{i = 2} ^ N C(i + M - 1, M - 1) + C(m, m - 1) + C(m, m) - 1 \\\\\n= & \\sum\\limits_{i = 2} ^ N C(i + M - 1, M - 1) + C(m + 1, m) - 1 \\\\\n= & \\sum\\limits_{i = 3} ^ N C(i + M - 1, M - 1) + C(m + 2, m) - 1 \\\\\n= & C(m + n, m) - 1 \\\\\n\\end{align}\n$$\n\n Lucas \n\n$$ C(n, m) \\ {\\rm mod} \\ p = C(\\lfloor \\frac{n}{p} \\rfloor, \\lfloor \\frac{m}{p} \\rfloor) * C(n \\ {\\rm mod} \\ p, m \\ {\\rm mod} \\ p) $$\n\n $ n \\lt p, m \\lt p $ ****\n\n\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1e9;\nconst int MOD = 1e6 + 3;\nconst int PHI_MOD = MOD - 1;\n\nlong long fac[MOD];\n\ninline long long pow(const long long x, const long long n) {\n\tlong long ans = 1;\n\tfor (long long num = x, t = n; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\ninline void makeTable() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < MOD; i++) fac[i] = fac[i - 1] * i % MOD;\n}\n\ninline long long inv(const long long x) {\n\treturn pow(x, PHI_MOD - 1);\n}\n\nlong long lucas(const int n, const int m) {\n\tif (n < m) return 0;\n\telse if (n < MOD && m < MOD) return fac[n] * inv(fac[m]) % MOD * inv(fac[n - m]) % MOD;\n\treturn lucas(n / MOD, m / MOD) * lucas(n % MOD, m % MOD) % MOD;\n}\n\ninline int solve(const int n, const int l, const int r) {\n\treturn ((lucas(n + r - l + 1, r - l + 1) - 1) + MOD) % MOD;\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, l, r;\n\t\tscanf(\"%d %d %d\", &n, &l, &r);\n\t\tprintf(\"%d\\n\", solve(n, l, r));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-4403.md","raw":"title: BZOJ 4403 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - \n  - \n  - Lucas \n  - \npermalink: bzoj-4403\ndate: 2016-04-08 22:11:34\n---\n\n $ N $$ L $  $ R $ $ 1 $  $ N $  $ L $  $ R $  $ 10 ^ 6 + 3 $ \n\n<!-- more -->\n\n### \n[BZOJ 4403](http://www.lydsy.com/JudgeOnline/problem.php?id=4403)\n\n### \n $ [1, R - L + 1] $  $ N $ \n\n\n\n$$ M = R - L + 1 $$\n\n\n\n$$\n\\begin{align}\n& \\sum\\limits_{i = 1} ^ N C(i + M - 1, i) \\\\\n= & \\sum\\limits_{i = 1} ^ N C(i + M - 1, M - 1) \\\\\n= & \\sum\\limits_{i = 1} ^ N C(i + M - 1, M - 1) + C(m, m) - 1 \\\\\n= & \\sum\\limits_{i = 2} ^ N C(i + M - 1, M - 1) + C(m, m - 1) + C(m, m) - 1 \\\\\n= & \\sum\\limits_{i = 2} ^ N C(i + M - 1, M - 1) + C(m + 1, m) - 1 \\\\\n= & \\sum\\limits_{i = 3} ^ N C(i + M - 1, M - 1) + C(m + 2, m) - 1 \\\\\n= & C(m + n, m) - 1 \\\\\n\\end{align}\n$$\n\n Lucas \n\n$$ C(n, m) \\ {\\rm mod} \\ p = C(\\lfloor \\frac{n}{p} \\rfloor, \\lfloor \\frac{m}{p} \\rfloor) * C(n \\ {\\rm mod} \\ p, m \\ {\\rm mod} \\ p) $$\n\n $ n \\lt p, m \\lt p $ ****\n\n\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1e9;\nconst int MOD = 1e6 + 3;\nconst int PHI_MOD = MOD - 1;\n\nlong long fac[MOD];\n\ninline long long pow(const long long x, const long long n) {\n\tlong long ans = 1;\n\tfor (long long num = x, t = n; t; num = num * num % MOD, t >>= 1) if (t & 1) ans = ans * num % MOD;\n\treturn ans;\n}\n\ninline void makeTable() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < MOD; i++) fac[i] = fac[i - 1] * i % MOD;\n}\n\ninline long long inv(const long long x) {\n\treturn pow(x, PHI_MOD - 1);\n}\n\nlong long lucas(const int n, const int m) {\n\tif (n < m) return 0;\n\telse if (n < MOD && m < MOD) return fac[n] * inv(fac[m]) % MOD * inv(fac[n - m]) % MOD;\n\treturn lucas(n / MOD, m / MOD) * lucas(n % MOD, m % MOD) % MOD;\n}\n\ninline int solve(const int n, const int l, const int r) {\n\treturn ((lucas(n + r - l + 1, r - l + 1) - 1) + MOD) % MOD;\n}\n\nint main() {\n\tmakeTable();\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, l, r;\n\t\tscanf(\"%d %d %d\", &n, &l, &r);\n\t\tprintf(\"%d\\n\", solve(n, l, r));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-4403","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6czt01clc2xlc3rmt97a"},{"title":"BZOJ 4318OSU! - ","date":"2016-05-31T09:32:00.000Z","_content":"\n osu! : \n\n $ n $  $ 1 $ $ 0 $$ n $  $ 1 $  $ n $  01  $ x $  $ 1 $  $ x ^ 3 $  $ x $  $ 1 $  $ 1 $  $ 1 $\n\n $ n $\n\n<!-- more -->\n\n### \n[BZOJ 4318](http://www.lydsy.com/JudgeOnline/problem.php?id=4318)\n\n### \n $ f(i) $  $ i $ $ p(i) $  $ i $ \n\n $ 1 $  $ x $  $ i $  $ x_i = x_{i - 1} + 1 $ $ x ^ 3 $ \n\n$$ (x + 1) ^ 3 - x ^ 3 = 3x ^ 2 + 3x + 1 $$\n\n $ E_{x ^ 2} $  $ E_x $\n\n$$ E_{(x + 1) ^ 3 - x ^ 3} = 3E_{x ^ 2} + 3E_x + 1 $$\n\n $ i - 1 $ \n\n$$ f(i) = f(i - 1) + (3E_{x ^ 2}(i) + 3E_x(i) + 1) \\times p(i) $$\n\n $ E_{x ^ 2}(i) $  $ E_x(i) $\n\n\n\n$$ E_{x + 1} = E_x + 1 $$\n\n $ p(i) $  $ 1 $  $ 1 - p(i) $  $ 0 $\n\n$$ E_x(i) = (E_x(i - 1) + 1) \\times p(i) $$\n\n\n\n$$ E_{(x + 1) ^ 2} = E_{x ^ 2} + 2E_{x} + 1 $$\n\n\n\n$$ E_{x ^ 2}(i) = E_{x ^ 2}(i - 1) + 2E_{x}(i - 1) + 1 $$\n\n$ E_{x ^ 2}(i) $$ E_{x}(i) $$ f(i) $ \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n\nconst int MAXN = 100000;\n\nint n;\ndouble p[MAXN + 1], f[MAXN + 1];\ndouble ex1[MAXN + 1], ex2[MAXN + 1];\n\ninline void dp() {\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tex1[i] = (ex1[i - 1] + 1) * p[i];\n\t\tex2[i] = (ex2[i - 1] + 2 * ex1[i - 1] + 1) * p[i];\n\t\tdouble t = (3 * ex2[i - 1] + 3 * ex1[i - 1] + 1) * p[i];\n\t\tf[i] = f[i - 1] + t;\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n\n\tdp();\n\n\tprintf(\"%.1lf\\n\", floor(f[n] * 10 + 0.5) / 10);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-4318.md","raw":"title: BZOJ 4318OSU! - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - DP\npermalink: bzoj-4318\ndate: 2016-05-31 17:32:00\n---\n\n osu! : \n\n $ n $  $ 1 $ $ 0 $$ n $  $ 1 $  $ n $  01  $ x $  $ 1 $  $ x ^ 3 $  $ x $  $ 1 $  $ 1 $  $ 1 $\n\n $ n $\n\n<!-- more -->\n\n### \n[BZOJ 4318](http://www.lydsy.com/JudgeOnline/problem.php?id=4318)\n\n### \n $ f(i) $  $ i $ $ p(i) $  $ i $ \n\n $ 1 $  $ x $  $ i $  $ x_i = x_{i - 1} + 1 $ $ x ^ 3 $ \n\n$$ (x + 1) ^ 3 - x ^ 3 = 3x ^ 2 + 3x + 1 $$\n\n $ E_{x ^ 2} $  $ E_x $\n\n$$ E_{(x + 1) ^ 3 - x ^ 3} = 3E_{x ^ 2} + 3E_x + 1 $$\n\n $ i - 1 $ \n\n$$ f(i) = f(i - 1) + (3E_{x ^ 2}(i) + 3E_x(i) + 1) \\times p(i) $$\n\n $ E_{x ^ 2}(i) $  $ E_x(i) $\n\n\n\n$$ E_{x + 1} = E_x + 1 $$\n\n $ p(i) $  $ 1 $  $ 1 - p(i) $  $ 0 $\n\n$$ E_x(i) = (E_x(i - 1) + 1) \\times p(i) $$\n\n\n\n$$ E_{(x + 1) ^ 2} = E_{x ^ 2} + 2E_{x} + 1 $$\n\n\n\n$$ E_{x ^ 2}(i) = E_{x ^ 2}(i - 1) + 2E_{x}(i - 1) + 1 $$\n\n$ E_{x ^ 2}(i) $$ E_{x}(i) $$ f(i) $ \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n\nconst int MAXN = 100000;\n\nint n;\ndouble p[MAXN + 1], f[MAXN + 1];\ndouble ex1[MAXN + 1], ex2[MAXN + 1];\n\ninline void dp() {\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tex1[i] = (ex1[i - 1] + 1) * p[i];\n\t\tex2[i] = (ex2[i - 1] + 2 * ex1[i - 1] + 1) * p[i];\n\t\tdouble t = (3 * ex2[i - 1] + 3 * ex1[i - 1] + 1) * p[i];\n\t\tf[i] = f[i - 1] + t;\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lf\", &p[i]);\n\n\tdp();\n\n\tprintf(\"%.1lf\\n\", floor(f[n] * 10 + 0.5) / 10);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-4318","published":1,"updated":"2016-05-31T12:06:27.692Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d0401cvc2xle8wmyb2e"},{"title":"BZOJ 4247 -  DP","date":"2016-07-11T15:22:00.000Z","_content":"\nJOI  $ N $  $ 1 \\to N $ JOI\n\n $ 1 $ \n\nJOI \n\n<!-- more -->\n\n### \n[BZOJ 4247](http://www.lydsy.com/JudgeOnline/problem.php?id=4247)\n\n### \n $ -n $  $ 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 2000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic struct Array {\n\t\tint a[MAXN * 2 + 1];\n\t\tint &operator[](const int i) { return a[i + MAXN]; }\n\t} f[MAXN + 1];\n\n\tfor (int i = -n; i < 0; i++) f[0][i] = INT_MIN;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x, v;\n\t\tscanf(\"%d %d\", &x, &v);\n\n\t\tconst int w = 1 - x;\n\n\t\tfor (int j = -n; j <= n; j++) {\n\t\t\tif (j - w >= -n && j - w <= n && f[i - 1][j - w] != INT_MIN) f[i][j] = std::max(f[i - 1][j], f[i - 1][j - w] + v);\n\t\t\telse if (j - w > n) f[i][j] = std::max(f[i - 1][j], f[i - 1][n] + v);\n\t\t\telse f[i][j] = f[i - 1][j];\n\t\t\t// printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = -n; i <= 1; i++) ans = std::max(ans, f[n][i]);\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-4247.md","raw":"title: BZOJ 4247 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - DP\n  -  DP\npermalink: bzoj-4247\ndate: 2016-07-11 23:22:00\n---\n\nJOI  $ N $  $ 1 \\to N $ JOI\n\n $ 1 $ \n\nJOI \n\n<!-- more -->\n\n### \n[BZOJ 4247](http://www.lydsy.com/JudgeOnline/problem.php?id=4247)\n\n### \n $ -n $  $ 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 2000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic struct Array {\n\t\tint a[MAXN * 2 + 1];\n\t\tint &operator[](const int i) { return a[i + MAXN]; }\n\t} f[MAXN + 1];\n\n\tfor (int i = -n; i < 0; i++) f[0][i] = INT_MIN;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x, v;\n\t\tscanf(\"%d %d\", &x, &v);\n\n\t\tconst int w = 1 - x;\n\n\t\tfor (int j = -n; j <= n; j++) {\n\t\t\tif (j - w >= -n && j - w <= n && f[i - 1][j - w] != INT_MIN) f[i][j] = std::max(f[i - 1][j], f[i - 1][j - w] + v);\n\t\t\telse if (j - w > n) f[i][j] = std::max(f[i - 1][j], f[i - 1][n] + v);\n\t\t\telse f[i][j] = f[i - 1][j];\n\t\t\t// printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = -n; i <= 1; i++) ans = std::max(ans, f[n][i]);\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-4247","published":1,"updated":"2016-10-24T23:34:05.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d0b01d1c2xlodmx85zc"},{"title":"BZOJ 4145The Prices -  DP","date":"2016-07-11T15:29:00.000Z","_content":"\n $ m $  $ n $  $ i $  $ d(i) $ $ i $  $ j $  $ c(i)(j) $\n\n<!-- more -->\n\n### \n[BZOJ 4145](http://www.lydsy.com/JudgeOnline/problem.php?id=4145)\n\n### \n $ f(i, j) $  $ i $  $ j $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <utility>\n\nconst int maxn = 100;\nconst int maxm = 16;\nconst int maxstatus = 1 << 16;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int c[maxn][maxm], d[maxn];\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &d[i]);\n\t\tfor (int j = 0; j < m; j++) scanf(\"%d\", &c[i][j]);\n\t}\n\n\tstatic int f[maxn][maxstatus];\n\tfor (int j = 0; j < (1 << m); j++) {\n\t\tf[0][j] = d[0];\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (j & (1 << k)) f[0][j] += c[0][k];\n\t\t}\n\t}\n\tf[0][0] = 0;\n\t\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 0; j < (1 << m); j++) f[i][j] = f[i - 1][j] + d[i];\n\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\tfor (int k = 0; k < m; k++) {\n\t\t\t\tif (j & (1 << k)) f[i][j] = std::min(f[i][j], f[i][j ^ (1 << k)] + c[i][k]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < (1 << m); j++) f[i][j] = std::min(f[i][j], f[i - 1][j]); // , printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t}\n\n\tprintf(\"%d\\n\", f[n - 1][(1 << m) - 1]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-4145.md","raw":"title: BZOJ 4145The Prices -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - DP\n  -  DP\npermalink: bzoj-4145\ndate: 2016-07-11 23:29:00\n---\n\n $ m $  $ n $  $ i $  $ d(i) $ $ i $  $ j $  $ c(i)(j) $\n\n<!-- more -->\n\n### \n[BZOJ 4145](http://www.lydsy.com/JudgeOnline/problem.php?id=4145)\n\n### \n $ f(i, j) $  $ i $  $ j $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <utility>\n\nconst int maxn = 100;\nconst int maxm = 16;\nconst int maxstatus = 1 << 16;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int c[maxn][maxm], d[maxn];\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &d[i]);\n\t\tfor (int j = 0; j < m; j++) scanf(\"%d\", &c[i][j]);\n\t}\n\n\tstatic int f[maxn][maxstatus];\n\tfor (int j = 0; j < (1 << m); j++) {\n\t\tf[0][j] = d[0];\n\t\tfor (int k = 0; k < m; k++) {\n\t\t\tif (j & (1 << k)) f[0][j] += c[0][k];\n\t\t}\n\t}\n\tf[0][0] = 0;\n\t\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = 0; j < (1 << m); j++) f[i][j] = f[i - 1][j] + d[i];\n\t\tfor (int j = 0; j < (1 << m); j++) {\n\t\t\tfor (int k = 0; k < m; k++) {\n\t\t\t\tif (j & (1 << k)) f[i][j] = std::min(f[i][j], f[i][j ^ (1 << k)] + c[i][k]);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < (1 << m); j++) f[i][j] = std::min(f[i][j], f[i - 1][j]); // , printf(\"f[%d][%d] = %d\\n\", i, j, f[i][j]);\n\t}\n\n\tprintf(\"%d\\n\", f[n - 1][(1 << m) - 1]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-4145","published":1,"updated":"2016-10-24T23:33:52.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d0g01d6c2xltmret6t5"},{"title":"BZOJ 3940Censoring - AC ","date":"2016-09-13T23:52:00.000Z","_content":"\n $ S $  $ S $ \n\n<!-- more -->\n\n### \n[BZOJ 3940](http://www.lydsy.com/JudgeOnline/problem.php?id=3940)\n\n### \n AC \n\n  \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <list>\n\nconst int MAXN = 1e5;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint length;\n\n\t\tNode(const bool isWord = false, const int length = 0) : fail(NULL), next(NULL), isWord(isWord), length(length) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true, end - begin);\n\t\telse (*v)->isWord = true, (*v)->length = end - begin;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v == root ? root : v->fail->c[i];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(std::list<char> &list) {\n\t\tNode *v = root;\n\t\tstd::stack<Node *> history;\n\t\tfor (std::list<char>::iterator it = list.begin(); it != list.end(); ) {\n\t\t\thistory.push(v);\n\t\t\t// while (v != root && !v->c[*it]) v = v->fail, assert(false);\n\t\t\tif (v->c[*it]) v = v->c[*it];\n\t\t\tif (!v->isWord && v->next) v = v->next;\n\t\t\tif (v->isWord) {\n\t\t\t\tfor (int i = 1; i < v->length; i++) it--;\n\t\t\t\tfor (int i = 0; i < v->length; i++) it = list.erase(it);\n\t\t\t\tfor (int i = 1; i < v->length; i++) history.pop();\n\t\t\t\tv = history.top();\n\t\t\t\thistory.pop();\n\t\t\t} else it++;\n\t\t}\n\t}\n} t;\n\nint main() {\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tstd::list<char> list;\n\tfor (const char *p = s; *p; p++) list.push_back(*p - BASE_CHAR);\n\n\tint n;\n\tscanf(\"%d\", &n);\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\tt.exec(list);\n\n\tfor (std::list<char>::const_iterator it = list.begin(); it != list.end(); it++) putchar(*it + BASE_CHAR);\n\tputchar('\\n');\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-3940.md","raw":"title: BZOJ 3940Censoring - AC \ncategories: OI\ntags: \n  - BZOJ\n  - USACO\n  - \n  - AC \n  - \n  - \npermalink: bzoj-3940\ndate: 2016-09-14 07:52:00\n---\n\n $ S $  $ S $ \n\n<!-- more -->\n\n### \n[BZOJ 3940](http://www.lydsy.com/JudgeOnline/problem.php?id=3940)\n\n### \n AC \n\n  \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <list>\n\nconst int MAXN = 1e5;\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint length;\n\n\t\tNode(const bool isWord = false, const int length = 0) : fail(NULL), next(NULL), isWord(isWord), length(length) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true, end - begin);\n\t\telse (*v)->isWord = true, (*v)->length = end - begin;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v == root ? root : v->fail->c[i];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(std::list<char> &list) {\n\t\tNode *v = root;\n\t\tstd::stack<Node *> history;\n\t\tfor (std::list<char>::iterator it = list.begin(); it != list.end(); ) {\n\t\t\thistory.push(v);\n\t\t\t// while (v != root && !v->c[*it]) v = v->fail, assert(false);\n\t\t\tif (v->c[*it]) v = v->c[*it];\n\t\t\tif (!v->isWord && v->next) v = v->next;\n\t\t\tif (v->isWord) {\n\t\t\t\tfor (int i = 1; i < v->length; i++) it--;\n\t\t\t\tfor (int i = 0; i < v->length; i++) it = list.erase(it);\n\t\t\t\tfor (int i = 1; i < v->length; i++) history.pop();\n\t\t\t\tv = history.top();\n\t\t\t\thistory.pop();\n\t\t\t} else it++;\n\t\t}\n\t}\n} t;\n\nint main() {\n\tstatic char s[MAXN + 1];\n\tscanf(\"%s\", s);\n\tstd::list<char> list;\n\tfor (const char *p = s; *p; p++) list.push_back(*p - BASE_CHAR);\n\n\tint n;\n\tscanf(\"%d\", &n);\n\twhile (n--) {\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tt.build();\n\tt.exec(list);\n\n\tfor (std::list<char>::const_iterator it = list.begin(); it != list.end(); it++) putchar(*it + BASE_CHAR);\n\tputchar('\\n');\n\n\treturn 0;\n}\n```","slug":"bzoj-3940","published":1,"updated":"2016-09-13T23:47:40.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d0m01dbc2xlvjjay1lq"},{"title":"BZOJ 3894 - ","date":"2016-06-21T09:51:00.000Z","_content":"\n P  $ n \\times m $ \n\n1.  $ i $  $ j $  $ a[i][j] $  $ b[i][j] $ \n2.  $ i $  $ j $  $ A[i][j] $ \n3.  $ i $  $ j $  $ B[i][j] $ \n\n P \n\n<!-- more -->\n\n### \n[BZOJ 2127](http://www.lydsy.com/JudgeOnline/problem.php?id=2127)\n\n### \n\n\n $ 3 $  TA  $ b[i][j] - a[i][j] $TA  TA TA  TA   \n**TA  TA ** TA  TA  TA  TA \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN * 3 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN][MAXN], b[MAXN][MAXN], A[MAXN][MAXN], B[MAXN][MAXN], id[MAXN][MAXN][3];\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &a[i][j]), sum += a[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &b[i][j]);\n\t\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &A[i][j]), sum += A[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &B[i][j]);\n\t\n\tint x = 1;\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) for (int k = 0; k < 3; k++) id[i][j][k] = x++;\n\n\tconst int s = 0, t = n * m * 3 + 1;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint x = b[i][j] - a[i][j];\n\t\t\tif (x > 0) addEdge(s, id[i][j][0], x), sum += x;\n\t\t\telse addEdge(id[i][j][0], t, -x);\n\t\t\taddEdge(id[i][j][1], t, A[i][j]);\n\t\t\taddEdge(s, id[i][j][2], B[i][j]), sum += B[i][j];\n\n\t\t\taddEdge(id[i][j][0], id[i][j][1], INT_MAX);\n\t\t\taddEdge(id[i][j][2], id[i][j][0], INT_MAX);\n\n\t\t\tif (i != 0) {\n\t\t\t\taddEdge(id[i][j][0], id[i - 1][j][1], INT_MAX);\n\t\t\t\taddEdge(id[i - 1][j][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (i != n - 1) {\n\t\t\t\taddEdge(id[i][j][0], id[i + 1][j][1], INT_MAX);\n\t\t\t\taddEdge(id[i + 1][j][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != 0) {\n\t\t\t\taddEdge(id[i][j][0], id[i][j - 1][1], INT_MAX);\n\t\t\t\taddEdge(id[i][j - 1][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != m - 1) {\n\t\t\t\taddEdge(id[i][j][0], id[i][j + 1][1], INT_MAX);\n\t\t\t\taddEdge(id[i][j + 1][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m * 3 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3894.md","raw":"title: BZOJ 3894 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - Dinic\n  - \npermalink: bzoj-3894\ndate: 2016-06-21 17:51:00\n---\n\n P  $ n \\times m $ \n\n1.  $ i $  $ j $  $ a[i][j] $  $ b[i][j] $ \n2.  $ i $  $ j $  $ A[i][j] $ \n3.  $ i $  $ j $  $ B[i][j] $ \n\n P \n\n<!-- more -->\n\n### \n[BZOJ 2127](http://www.lydsy.com/JudgeOnline/problem.php?id=2127)\n\n### \n\n\n $ 3 $  TA  $ b[i][j] - a[i][j] $TA  TA TA  TA   \n**TA  TA ** TA  TA  TA  TA \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN * 3 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN][MAXN], b[MAXN][MAXN], A[MAXN][MAXN], B[MAXN][MAXN], id[MAXN][MAXN][3];\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &a[i][j]), sum += a[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &b[i][j]);\n\t\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &A[i][j]), sum += A[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &B[i][j]);\n\t\n\tint x = 1;\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) for (int k = 0; k < 3; k++) id[i][j][k] = x++;\n\n\tconst int s = 0, t = n * m * 3 + 1;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint x = b[i][j] - a[i][j];\n\t\t\tif (x > 0) addEdge(s, id[i][j][0], x), sum += x;\n\t\t\telse addEdge(id[i][j][0], t, -x);\n\t\t\taddEdge(id[i][j][1], t, A[i][j]);\n\t\t\taddEdge(s, id[i][j][2], B[i][j]), sum += B[i][j];\n\n\t\t\taddEdge(id[i][j][0], id[i][j][1], INT_MAX);\n\t\t\taddEdge(id[i][j][2], id[i][j][0], INT_MAX);\n\n\t\t\tif (i != 0) {\n\t\t\t\taddEdge(id[i][j][0], id[i - 1][j][1], INT_MAX);\n\t\t\t\taddEdge(id[i - 1][j][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (i != n - 1) {\n\t\t\t\taddEdge(id[i][j][0], id[i + 1][j][1], INT_MAX);\n\t\t\t\taddEdge(id[i + 1][j][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != 0) {\n\t\t\t\taddEdge(id[i][j][0], id[i][j - 1][1], INT_MAX);\n\t\t\t\taddEdge(id[i][j - 1][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != m - 1) {\n\t\t\t\taddEdge(id[i][j][0], id[i][j + 1][1], INT_MAX);\n\t\t\t\taddEdge(id[i][j + 1][2], id[i][j][0], INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m * 3 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3894","published":1,"updated":"2016-06-22T08:25:43.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d0w01dlc2xl0e0xhez1"},{"title":"BZOJ 3796Mushroom -  + AC ","date":"2016-09-29T23:41:00.000Z","_content":"\n $ s_1, s_2, s_3 $ $ w $\n\n1. $ w $  $ s_1 $ \n2. $ w $  $ s_2 $ \n3. $ s_3 $  $ w $ \n\n<!-- more -->\n\n### \n[BZOJ 3796](http://www.lydsy.com/JudgeOnline/problem.php?id=3796)\n\n### \n $ s_1 $  $ s_2 $  $ s_1 $  $ s_2 $ \n\n 3 $ s_3 $  AC  $ s_3 $  $ s_1 $  $ i $  $ s_3 $  $ r(i) $ $ i $  $ r(i) - i + \\mathrm{len}(s_3) - 1 $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812\nconst int CHARSET_SIZE = 12;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail;\n\t\tbool isWord;\n\t\tint depth;\n\n\t\tNode(const int isWord = false) : fail(NULL), isWord(isWord), depth(0) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p - BASE_CHAR];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\troot->fail = root;\n\t\troot->depth = 0;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tc->depth = v->depth + 1;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end, bool *match) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = v->c[*p - BASE_CHAR];\n\t\t\tif (v->isWord) match[p - begin - v->depth + 1] = true;\n\t\t}\n\t}\n} t;\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1], log[MAXN + 1];\n\n\ttemplate <typename T>\n\tvoid build(const T *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"build: %s\\n\", s);\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n#endif\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) < n) st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t\telse st[i][j] = st[i][j - 1];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tint x = 0;\n\t\t\twhile ((1 << x) <= i) x++;\n\t\t\tlog[i] = x - 1;\n\t\t}\n\t}\n\n\tint rmq(const int l, const int r) {\n\t\tif (l == r) return st[l][0];\n\t\telse {\n\t\t\tconst int t = log[r - l];\n\t\t\treturn std::min(st[l][t], st[r - (1 << t) + 1][t]);\n\t\t}\n\t}\n\n\tint lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn rmq(a + 1, b);\n\t}\n} sa1, sa2;\n\nint main() {\n\tstatic char buf[MAXN];\n\tscanf(\"%s\", buf);\n\tconst int n1 = strlen(buf);\n\tbuf[n1] = '$';\n\tscanf(\"%s\", buf + n1 + 1);\n\tconst int n2 = strlen(buf + n1 + 1);\n\tsa1.build(buf, n1 + 1 + n2);\n\n\tscanf(\"%s\", buf + n1 + 1);\n\tconst int n3 = strlen(buf + n1 + 1);\n\t// sa2.build(buf, n1 + 1 + n3);\n\n\tt.insert(buf + n1 + 1, buf + n1 + 1 + n3);\n\tt.build();\n\n\tstatic bool match[MAXN];\n\tt.exec(buf, buf + n1, match);\n\n\tstatic int nextMatch[MAXN];\n\tfor (int i = n1 - 1, x = INT_MAX; i >= 0; i--) {\n\t\tif (match[i]) x = i;\n\t\tnextMatch[i] = x == INT_MAX ? INT_MAX : x - i + n3 - 1;\n\t}\n\n#ifdef DBG\n\tputs(\"KMP:\");\n\tbuf[n1] = '\\0';\n\tfor (int i = 0; i < n1; i++) printf(\"%d %s\\n\", nextMatch[i], &buf[i]);\n#endif\n\n\tstatic int l[MAXN], r[MAXN];\n\tfor (int i = 1, x = -1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] < n1) l[i] = x;\n\t\telse if (sa1.sa[i] > n1) x = i;\n\t}\n\tfor (int i = n1 + n2 + 1 - 1, x = -1; i >= 1; i--) {\n\t\tif (sa1.sa[i] < n1) r[i] = x;\n\t\telse if (sa1.sa[i] > n1) x = i;\n\t}\n\n#ifdef DBG\n\tfor (int i = 1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] < n1) printf(\"l[%d] = %d\\n\", i, l[i]);\n\t\tif (sa1.sa[i] < n1) printf(\"r[%d] = %d\\n\", i, r[i]);\n\t}\n#endif\n\n\tint ans = 0;\n\tfor (int i = 1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] > n1) continue;\n\t\tint x;\n\t\tif (l[i] != -1) {\n\t\t\tx = sa1.lcp(sa1.sa[l[i]], sa1.sa[i]);\n\t\t\tx = std::min(x, nextMatch[sa1.sa[i]]);\n\t\t\tif (x) {\n\t\t\t\tans = std::max(ans, x);\n#ifdef DBG\n\t\t\t\tprintf(\"%d\\n\", x);\n#endif\n\t\t\t}\n\t\t}\n\t\tif (r[i] != -1) {\n\t\t\tx = sa1.lcp(sa1.sa[r[i]], sa1.sa[i]);\n\t\t\tx = std::min(x, nextMatch[sa1.sa[i]]);\n\t\t\tif (x) {\n\t\t\t\tans = std::max(ans, x);\n#ifdef DBG\n\t\t\t\tprintf(\"%d\\n\", x);\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-3796.md","raw":"title: BZOJ 3796Mushroom -  + AC \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - AC \npermalink: bzoj-3796\ndate: 2016-09-30 07:41:00\n---\n\n $ s_1, s_2, s_3 $ $ w $\n\n1. $ w $  $ s_1 $ \n2. $ w $  $ s_2 $ \n3. $ s_3 $  $ w $ \n\n<!-- more -->\n\n### \n[BZOJ 3796](http://www.lydsy.com/JudgeOnline/problem.php?id=3796)\n\n### \n $ s_1 $  $ s_2 $  $ s_1 $  $ s_2 $ \n\n 3 $ s_3 $  AC  $ s_3 $  $ s_1 $  $ i $  $ s_3 $  $ r(i) $ $ i $  $ r(i) - i + \\mathrm{len}(s_3) - 1 $\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812\nconst int CHARSET_SIZE = 12;\nconst int BASE_CHAR = 'a';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail;\n\t\tbool isWord;\n\t\tint depth;\n\n\t\tNode(const int isWord = false) : fail(NULL), isWord(isWord), depth(0) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p - BASE_CHAR];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\troot->fail = root;\n\t\troot->depth = 0;\n\t\tq.push(root);\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tc->depth = v->depth + 1;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end, bool *match) {\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tv = v->c[*p - BASE_CHAR];\n\t\t\tif (v->isWord) match[p - begin - v->depth + 1] = true;\n\t\t}\n\t}\n} t;\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1], log[MAXN + 1];\n\n\ttemplate <typename T>\n\tvoid build(const T *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n#ifdef DBG\n\t\tprintf(\"build: %s\\n\", s);\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n#endif\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) < n) st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t\telse st[i][j] = st[i][j - 1];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tint x = 0;\n\t\t\twhile ((1 << x) <= i) x++;\n\t\t\tlog[i] = x - 1;\n\t\t}\n\t}\n\n\tint rmq(const int l, const int r) {\n\t\tif (l == r) return st[l][0];\n\t\telse {\n\t\t\tconst int t = log[r - l];\n\t\t\treturn std::min(st[l][t], st[r - (1 << t) + 1][t]);\n\t\t}\n\t}\n\n\tint lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn rmq(a + 1, b);\n\t}\n} sa1, sa2;\n\nint main() {\n\tstatic char buf[MAXN];\n\tscanf(\"%s\", buf);\n\tconst int n1 = strlen(buf);\n\tbuf[n1] = '$';\n\tscanf(\"%s\", buf + n1 + 1);\n\tconst int n2 = strlen(buf + n1 + 1);\n\tsa1.build(buf, n1 + 1 + n2);\n\n\tscanf(\"%s\", buf + n1 + 1);\n\tconst int n3 = strlen(buf + n1 + 1);\n\t// sa2.build(buf, n1 + 1 + n3);\n\n\tt.insert(buf + n1 + 1, buf + n1 + 1 + n3);\n\tt.build();\n\n\tstatic bool match[MAXN];\n\tt.exec(buf, buf + n1, match);\n\n\tstatic int nextMatch[MAXN];\n\tfor (int i = n1 - 1, x = INT_MAX; i >= 0; i--) {\n\t\tif (match[i]) x = i;\n\t\tnextMatch[i] = x == INT_MAX ? INT_MAX : x - i + n3 - 1;\n\t}\n\n#ifdef DBG\n\tputs(\"KMP:\");\n\tbuf[n1] = '\\0';\n\tfor (int i = 0; i < n1; i++) printf(\"%d %s\\n\", nextMatch[i], &buf[i]);\n#endif\n\n\tstatic int l[MAXN], r[MAXN];\n\tfor (int i = 1, x = -1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] < n1) l[i] = x;\n\t\telse if (sa1.sa[i] > n1) x = i;\n\t}\n\tfor (int i = n1 + n2 + 1 - 1, x = -1; i >= 1; i--) {\n\t\tif (sa1.sa[i] < n1) r[i] = x;\n\t\telse if (sa1.sa[i] > n1) x = i;\n\t}\n\n#ifdef DBG\n\tfor (int i = 1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] < n1) printf(\"l[%d] = %d\\n\", i, l[i]);\n\t\tif (sa1.sa[i] < n1) printf(\"r[%d] = %d\\n\", i, r[i]);\n\t}\n#endif\n\n\tint ans = 0;\n\tfor (int i = 1; i < n1 + n2 + 1; i++) {\n\t\tif (sa1.sa[i] > n1) continue;\n\t\tint x;\n\t\tif (l[i] != -1) {\n\t\t\tx = sa1.lcp(sa1.sa[l[i]], sa1.sa[i]);\n\t\t\tx = std::min(x, nextMatch[sa1.sa[i]]);\n\t\t\tif (x) {\n\t\t\t\tans = std::max(ans, x);\n#ifdef DBG\n\t\t\t\tprintf(\"%d\\n\", x);\n#endif\n\t\t\t}\n\t\t}\n\t\tif (r[i] != -1) {\n\t\t\tx = sa1.lcp(sa1.sa[r[i]], sa1.sa[i]);\n\t\t\tx = std::min(x, nextMatch[sa1.sa[i]]);\n\t\t\tif (x) {\n\t\t\t\tans = std::max(ans, x);\n#ifdef DBG\n\t\t\t\tprintf(\"%d\\n\", x);\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```","slug":"bzoj-3796","published":1,"updated":"2016-09-29T23:48:43.083Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d1201dsc2xllj5nwbfo"},{"title":"BZOJ 3697 - ","date":"2016-06-15T02:26:00.000Z","_content":"\n\n\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 3697](http://www.lydsy.com/JudgeOnline/problem.php?id=3697)\n\n### \n\n\n $ 0 $  $ -1 $\n\n DFS  $ f(i,\\ 0) $  $ i $ ** $ i $ **$ f(i,\\ 1) $  $ i $ ** $ i $ **\n\n $ i $  $ -i $    $ i $ \n\n DFS  $ c(i) $  $ i $  $ f(i,\\ 0) $  $ f(i,\\ 1 ) $ \n\n $ g(i,\\ 0) $$ g(i,\\ 1) $ \n\n$$ \\sum\\limits_i f(i,\\ 0) g(-i,\\ 1) + f(i,\\ 1) g(-i,\\ 0) + f(i,\\ 1) g(-i,\\ 1) $$\n\n $ g(0,\\ 0) $  $ 1 $\n\n$$ (g(0,\\ 0) - 1) \\times f(0,\\ 0) $$\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100003;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint size, max, dist;\n\tbool solved, visited;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n;\n\ntemplate <typename T, int L, int R>\nstruct Array {\n\tT a[R - L + 1];\n\n\tT &operator[](const int pos) { return a[pos - L]; }\n\n\tconst T &operator[](const int pos) const { return a[pos - L]; }\n};\n\nArray<long long [2], -(MAXN - 1), MAXN - 1> f, g;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline void dfs(Node *start, const int dist, int &max) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->parent = NULL;\n\tstart->dist = dist;\n\tstart->visited = false;\n\n\tstatic int _cnt[MAXN * 2 - 1], *cnt = _cnt + MAXN - 1;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tf[v->dist][!cnt[v->dist] ? 0 : 1]++;\n\t\t\tcnt[v->dist]++;\n\n\t\t\tmax = std::max(max, v->dist);\n\t\t\tmax = std::max(max, abs(v->dist));\n\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->dist = v->dist + e->w;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tcnt[v->dist]--;\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n\n/*\ninline void print(const int max) {\n\tfor (int i = -max; i <= max; i++) {\n\t\tprintf(\"f[%d][0] = %lld, f[%d][1] = %lld\\n\", i, f[i][0], i, f[i][1]);\n\t\tprintf(\"g[%d][0] = %lld, g[%d][1] = %lld\\n\", i, g[i][0], i, g[i][1]);\n\t}\n\tputchar('\\n');\n}\n*/\n\ninline long long calc(Node *root) {\n\tlong long res = 0;\n\tint max = 0;\n\tg[0][0] = 1;\n\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\tint curr = 0;\n\t\tdfs(e->t, e->w, curr);\n\t\t// print(max);\n\n\t\tres += (g[0][0] - 1) * f[0][0];\n\t\tfor (int i = -curr; i <= curr; i++) {\n\t\t\t// printf(\"res += %lld\\n\", (g[-i][1] * f[i][1]) + (g[-i][0] * f[i][1]) + (g[-i][1] * f[i][0]));\n\t\t\tres += (g[-i][1] * f[i][1]) + (g[-i][0] * f[i][1]) + (g[-i][1] * f[i][0]);\n\t\t}\n\n\t\tfor (int i = -curr; i <= curr; i++) {\n\t\t\tg[i][0] += f[i][0];\n\t\t\tg[i][1] += f[i][1];\n\t\t\tf[i][0] = f[i][1] = 0;\n\t\t}\n\n\t\tmax = std::max(max, curr);\n\t}\n\n\tfor (int i = -max; i <= max; i++) {\n\t\tg[i][0] = g[i][1] = 0;\n\t}\n\n\t// printf(\"calc(%ld) = %lld\\n\", root - N + 1, res);\n\treturn res;\n}\n\ninline long long solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tlong long ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\t\tans += calc(root);\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\t\tif (w == 0) w = -1;\n\t\taddEdge(u, v, w);\n\t}\n\n\tlong long ans = solve();\n\tprintf(\"%lld\\n\", ans);\n\t// printf(\"counter: %lld\\n\", counter);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3697.md","raw":"title: BZOJ 3697 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \npermalink: bzoj-3697\ndate: 2016-06-15 10:26:00\n---\n\n\n\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 3697](http://www.lydsy.com/JudgeOnline/problem.php?id=3697)\n\n### \n\n\n $ 0 $  $ -1 $\n\n DFS  $ f(i,\\ 0) $  $ i $ ** $ i $ **$ f(i,\\ 1) $  $ i $ ** $ i $ **\n\n $ i $  $ -i $    $ i $ \n\n DFS  $ c(i) $  $ i $  $ f(i,\\ 0) $  $ f(i,\\ 1 ) $ \n\n $ g(i,\\ 0) $$ g(i,\\ 1) $ \n\n$$ \\sum\\limits_i f(i,\\ 0) g(-i,\\ 1) + f(i,\\ 1) g(-i,\\ 0) + f(i,\\ 1) g(-i,\\ 1) $$\n\n $ g(0,\\ 0) $  $ 1 $\n\n$$ (g(0,\\ 0) - 1) \\times f(0,\\ 0) $$\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 100003;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint size, max, dist;\n\tbool solved, visited;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n;\n\ntemplate <typename T, int L, int R>\nstruct Array {\n\tT a[R - L + 1];\n\n\tT &operator[](const int pos) { return a[pos - L]; }\n\n\tconst T &operator[](const int pos) const { return a[pos - L]; }\n};\n\nArray<long long [2], -(MAXN - 1), MAXN - 1> f, g;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline void dfs(Node *start, const int dist, int &max) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->parent = NULL;\n\tstart->dist = dist;\n\tstart->visited = false;\n\n\tstatic int _cnt[MAXN * 2 - 1], *cnt = _cnt + MAXN - 1;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tf[v->dist][!cnt[v->dist] ? 0 : 1]++;\n\t\t\tcnt[v->dist]++;\n\n\t\t\tmax = std::max(max, v->dist);\n\t\t\tmax = std::max(max, abs(v->dist));\n\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->dist = v->dist + e->w;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tcnt[v->dist]--;\n\t\t\ts.pop();\n\t\t}\n\t}\n}\n\n/*\ninline void print(const int max) {\n\tfor (int i = -max; i <= max; i++) {\n\t\tprintf(\"f[%d][0] = %lld, f[%d][1] = %lld\\n\", i, f[i][0], i, f[i][1]);\n\t\tprintf(\"g[%d][0] = %lld, g[%d][1] = %lld\\n\", i, g[i][0], i, g[i][1]);\n\t}\n\tputchar('\\n');\n}\n*/\n\ninline long long calc(Node *root) {\n\tlong long res = 0;\n\tint max = 0;\n\tg[0][0] = 1;\n\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\tint curr = 0;\n\t\tdfs(e->t, e->w, curr);\n\t\t// print(max);\n\n\t\tres += (g[0][0] - 1) * f[0][0];\n\t\tfor (int i = -curr; i <= curr; i++) {\n\t\t\t// printf(\"res += %lld\\n\", (g[-i][1] * f[i][1]) + (g[-i][0] * f[i][1]) + (g[-i][1] * f[i][0]));\n\t\t\tres += (g[-i][1] * f[i][1]) + (g[-i][0] * f[i][1]) + (g[-i][1] * f[i][0]);\n\t\t}\n\n\t\tfor (int i = -curr; i <= curr; i++) {\n\t\t\tg[i][0] += f[i][0];\n\t\t\tg[i][1] += f[i][1];\n\t\t\tf[i][0] = f[i][1] = 0;\n\t\t}\n\n\t\tmax = std::max(max, curr);\n\t}\n\n\tfor (int i = -max; i <= max; i++) {\n\t\tg[i][0] = g[i][1] = 0;\n\t}\n\n\t// printf(\"calc(%ld) = %lld\\n\", root - N + 1, res);\n\treturn res;\n}\n\ninline long long solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tlong long ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\t\tans += calc(root);\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\t\tif (w == 0) w = -1;\n\t\taddEdge(u, v, w);\n\t}\n\n\tlong long ans = solve();\n\tprintf(\"%lld\\n\", ans);\n\t// printf(\"counter: %lld\\n\", counter);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3697","published":1,"updated":"2016-09-25T13:05:40.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d1901dyc2xlmy00aokl"},{"title":"BZOJ 3511 - ","date":"2016-04-06T14:33:05.000Z","_content":"\n $ n $  $ m $  $ 1 $  $ A $$ n $  $ B $\n\n1.  $ i $ $ A $  $ VA_i $  $ B $  $ VB_i $ \n2.  $ i $ $ A $  $ EA_i $  $ B $  $ EB_i $  $ EC_i $ \n\n<!-- more -->\n\n### \n[BZOJ 3511](http://www.lydsy.com/JudgeOnline/problem.php?id=3511)\n\n### \n $ A $  $ S $ $ B $  $ T $ \n\n $ u $ $ (S, u) = VA_i $ $ A $  $ (u, T) = VB_i $ $ B $ \n\n $ 1 $  $ n $ $ (S, 1) $  $ (n, T) $\n\n $ \\frac{EA_i}{2} + \\frac{EB_i}{2} + EC_i $  $ (S, u) = \\frac{EA_i}{2}, (u, T) = \\frac{EB_i}{2} $\n\n $ A $  $ EB_i $  $ B $  $ EA_i $  $ EA_i $ $ EB_i $ \n\n$ \\sum\\limits_{i = 1} ^ {n}(VA_i + VB_i) + \\sum\\limits_{i = 1} ^ {m}(EA_i + EB_i) $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 10000;\nconst int MAXM = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tT *alloc() {\n\t\tif (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tT *p = (T *)cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn p;\n\t\t}\n\t}\n};\n\nint n, m;\nMemoryPool<Edge, MAXM * 5 * 2 + MAXN * 2 * 2> pool;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\tN[s].e = &(*(pool.alloc()) = Edge(&N[s], &N[t], c));\n\tN[t].e = &(*(pool.alloc()) = Edge(&N[t], &N[s], rc));\n\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tint sum = 0;\n\n\tconst int s = 0, t = n + 1;\n\taddEdge(s, 1, INT_MAX), addEdge(n, t, INT_MAX);\n\tfor (int i = 2; i <= n - 1; i++) {\n\t\tint va;\n\t\tscanf(\"%d\", &va), va *= 2;\n\t\tsum += va;\n\t\taddEdge(s, i, va);\n\t}\n\n\tfor (int i = 2; i <= n - 1; i++) {\n\t\tint vb;\n\t\tscanf(\"%d\", &vb), vb *= 2;\n\t\tsum += vb;\n\t\taddEdge(i, t, vb);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, ea, eb, ec;\n\t\tscanf(\"%d %d %d %d %d\", &u, &v, &ea, &eb, &ec);\n\t\tea *= 2, eb *= 2, ec *= 2;\n\t\tsum += ea, sum += eb;\n\n\t\tint c = (ea / 2 + eb / 2 + ec);\n\t\taddEdge(u, v, c, c);\n\n\t\taddEdge(s, u, ea / 2), addEdge(s, v, ea / 2);\n\t\taddEdge(u, t, eb / 2), addEdge(v, t, eb / 2);\n\t}\n\n\tint minCut = dinic(s, t, n + 2);\n\tprintf(\"%d\\n\", (sum - minCut) / 2);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3511.md","raw":"title: BZOJ 3511 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - Dinic\n  - \npermalink: bzoj-3511\ndate: 2016-04-06 22:33:05\n---\n\n $ n $  $ m $  $ 1 $  $ A $$ n $  $ B $\n\n1.  $ i $ $ A $  $ VA_i $  $ B $  $ VB_i $ \n2.  $ i $ $ A $  $ EA_i $  $ B $  $ EB_i $  $ EC_i $ \n\n<!-- more -->\n\n### \n[BZOJ 3511](http://www.lydsy.com/JudgeOnline/problem.php?id=3511)\n\n### \n $ A $  $ S $ $ B $  $ T $ \n\n $ u $ $ (S, u) = VA_i $ $ A $  $ (u, T) = VB_i $ $ B $ \n\n $ 1 $  $ n $ $ (S, 1) $  $ (n, T) $\n\n $ \\frac{EA_i}{2} + \\frac{EB_i}{2} + EC_i $  $ (S, u) = \\frac{EA_i}{2}, (u, T) = \\frac{EB_i}{2} $\n\n $ A $  $ EB_i $  $ B $  $ EA_i $  $ EA_i $ $ EB_i $ \n\n$ \\sum\\limits_{i = 1} ^ {n}(VA_i + VB_i) + \\sum\\limits_{i = 1} ^ {m}(EA_i + EB_i) $ \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 10000;\nconst int MAXM = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tT *alloc() {\n\t\tif (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tT *p = (T *)cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn p;\n\t\t}\n\t}\n};\n\nint n, m;\nMemoryPool<Edge, MAXM * 5 * 2 + MAXN * 2 * 2> pool;\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\tN[s].e = &(*(pool.alloc()) = Edge(&N[s], &N[t], c));\n\tN[t].e = &(*(pool.alloc()) = Edge(&N[t], &N[s], rc));\n\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tint sum = 0;\n\n\tconst int s = 0, t = n + 1;\n\taddEdge(s, 1, INT_MAX), addEdge(n, t, INT_MAX);\n\tfor (int i = 2; i <= n - 1; i++) {\n\t\tint va;\n\t\tscanf(\"%d\", &va), va *= 2;\n\t\tsum += va;\n\t\taddEdge(s, i, va);\n\t}\n\n\tfor (int i = 2; i <= n - 1; i++) {\n\t\tint vb;\n\t\tscanf(\"%d\", &vb), vb *= 2;\n\t\tsum += vb;\n\t\taddEdge(i, t, vb);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v, ea, eb, ec;\n\t\tscanf(\"%d %d %d %d %d\", &u, &v, &ea, &eb, &ec);\n\t\tea *= 2, eb *= 2, ec *= 2;\n\t\tsum += ea, sum += eb;\n\n\t\tint c = (ea / 2 + eb / 2 + ec);\n\t\taddEdge(u, v, c, c);\n\n\t\taddEdge(s, u, ea / 2), addEdge(s, v, ea / 2);\n\t\taddEdge(u, t, eb / 2), addEdge(v, t, eb / 2);\n\t}\n\n\tint minCut = dinic(s, t, n + 2);\n\tprintf(\"%d\\n\", (sum - minCut) / 2);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3511","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d1f01e3c2xlu1xl80px"},{"title":"BZOJ 3438 M  - ","date":"2016-06-21T07:18:00.000Z","_content":"\n M  $ A $  $ B $ $ n $ i $ A $  $ a_i $  $ B $  $ b_i $   \n $ m $  $ i $  $ A $  $ c_{1_i} $ $ B $  $ c_{2_i} $   \n\n\n<!-- more -->\n\n### \n[BZOJ 3438](http://www.lydsy.com/JudgeOnline/problem.php?id=3438)\n\n### \n $ A $  $ \\sum\\limits_{i = 1} ^ n a_i + \\sum\\limits_{i = 1} ^ m c_{1_i} $\n\n $ B $  $ B $  $ i $  $ c_{1_i} $ **** $ B $  $ i $  $ c_{2_i} $ \n\n $ B_i - A_i $ $ c_{1_i} $ $ c_{2_i} $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\t// printf(\"[%d, %d] = %d\\n\", s, t, c);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint sum = 0;\n\n\tstatic int a[MAXN], b[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), sum += a[i];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &b[i]);\n\n\tint m;\n\tscanf(\"%d\", &m);\n\n\tconst int s = 0, t = n + m * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint w = b[i - 1] - a[i - 1];\n\t\tif (w > 0) addEdge(s, i, w), sum += w;\n\t\telse addEdge(i, t, -w);\n\t}\n\n\tfor (int i = n + 1; i <= n + m; i++) {\n\t\tint k, c1, c2;\n\t\tscanf(\"%d %d %d\", &k, &c1, &c2);\n\n\t\taddEdge(i, t, c1);\n\t\taddEdge(s, i + m, c2);\n\n\t\tsum += c1 + c2;\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(x, i, INT_MAX);\n\t\t\taddEdge(i + m, x, INT_MAX);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n + m * 2 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3438.md","raw":"title: BZOJ 3438 M  - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - Dinic\n  - \npermalink: bzoj-3438\ndate: 2016-06-21 15:18:00\n---\n\n M  $ A $  $ B $ $ n $ i $ A $  $ a_i $  $ B $  $ b_i $   \n $ m $  $ i $  $ A $  $ c_{1_i} $ $ B $  $ c_{2_i} $   \n\n\n<!-- more -->\n\n### \n[BZOJ 3438](http://www.lydsy.com/JudgeOnline/problem.php?id=3438)\n\n### \n $ A $  $ \\sum\\limits_{i = 1} ^ n a_i + \\sum\\limits_{i = 1} ^ m c_{1_i} $\n\n $ B $  $ B $  $ i $  $ c_{1_i} $ **** $ B $  $ i $  $ c_{2_i} $ \n\n $ B_i - A_i $ $ c_{1_i} $ $ c_{2_i} $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + MAXM * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\t// printf(\"[%d, %d] = %d\\n\", s, t, c);\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tint sum = 0;\n\n\tstatic int a[MAXN], b[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), sum += a[i];\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &b[i]);\n\n\tint m;\n\tscanf(\"%d\", &m);\n\n\tconst int s = 0, t = n + m * 2 + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint w = b[i - 1] - a[i - 1];\n\t\tif (w > 0) addEdge(s, i, w), sum += w;\n\t\telse addEdge(i, t, -w);\n\t}\n\n\tfor (int i = n + 1; i <= n + m; i++) {\n\t\tint k, c1, c2;\n\t\tscanf(\"%d %d %d\", &k, &c1, &c2);\n\n\t\taddEdge(i, t, c1);\n\t\taddEdge(s, i + m, c2);\n\n\t\tsum += c1 + c2;\n\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(x, i, INT_MAX);\n\t\t\taddEdge(i + m, x, INT_MAX);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n + m * 2 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3438","published":1,"updated":"2016-06-21T07:18:27.214Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d1m01eac2xlti16uxm8"},{"title":"BZOJ 3365Distance Statistics - ","date":"2016-06-16T10:09:00.000Z","_content":"\n $ K $$ 1 \\leq K \\leq 10 ^ 9 $ $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 3365](http://www.lydsy.com/JudgeOnline/problem.php?id=3365)\n\n### \n [BZOJ 1468](bzoj-1468) \n\n### \n```c++\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tbool solved, visited;\n\tint size, dist, max;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\n// int cnt_root, cnt_calc;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\t// printf(\"start->size - cnt = %d\\n\", start->size - cnt);\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\t// cnt_root++;\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstatic int a[MAXN];\n\tint cnt = 0;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->dist = dist;\n\troot->parent = NULL;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\ta[cnt++] = v->dist;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tint res = 0;\n\tstd::sort(a, a + cnt);\n\tfor (int i = 0, j = cnt - 1; i < j; i++) {\n\t\twhile (i < j && a[i] + a[j] > k) j--;\n\t\tres += j - i;\n\t}\n\n\t// cnt_calc++;\n\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\t\t// printf(\"work(%ld)\\n\", v - N + 1);\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tans -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tchar s[2];\n\t\tscanf(\"%d %d %d %s\", &u, &v, &w, s), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tscanf(\"%d\", &k);\n\n\tint ans = solve();\n\tprintf(\"%d\\n\", ans);\n\t// printf(\"cnt_root = %d, cnt_calc = %d\\n\", cnt_root, cnt_calc);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3365.md","raw":"title: BZOJ 3365Distance Statistics - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \npermalink: bzoj-3365\ndate: 2016-06-16 18:09:00\n---\n\n $ K $$ 1 \\leq K \\leq 10 ^ 9 $ $ K $ \n\n<!-- more -->\n\n### \n[BZOJ 3365](http://www.lydsy.com/JudgeOnline/problem.php?id=3365)\n\n### \n [BZOJ 1468](bzoj-1468) \n\n### \n```c++\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tbool solved, visited;\n\tint size, dist, max;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\n// int cnt_root, cnt_calc;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\t// printf(\"start->size - cnt = %d\\n\", start->size - cnt);\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\t// cnt_root++;\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstatic int a[MAXN];\n\tint cnt = 0;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->dist = dist;\n\troot->parent = NULL;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\ta[cnt++] = v->dist;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tint res = 0;\n\tstd::sort(a, a + cnt);\n\tfor (int i = 0, j = cnt - 1; i < j; i++) {\n\t\twhile (i < j && a[i] + a[j] > k) j--;\n\t\tres += j - i;\n\t}\n\n\t// cnt_calc++;\n\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\t\t// printf(\"work(%ld)\\n\", v - N + 1);\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tans -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tchar s[2];\n\t\tscanf(\"%d %d %d %s\", &u, &v, &w, s), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tscanf(\"%d\", &k);\n\n\tint ans = solve();\n\tprintf(\"%d\\n\", ans);\n\t// printf(\"cnt_root = %d, cnt_calc = %d\\n\", cnt_root, cnt_calc);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3365","published":1,"updated":"2016-06-16T10:09:41.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d1t01ehc2xl1oiu6to6"},{"title":"BZOJ 3280 R  - ","date":"2016-09-03T23:21:00.000Z","_content":"\n $ n $  $ i $  $ a_i $  $ m $  $ j $  $ l_j $  $ p_j $ \n\n $ k $  $ i $  $ d_i $  $ q_i $ \n\n<!-- more -->\n\n### \n[BZOJ 3280](http://www.lydsy.com/JudgeOnline/problem.php?id=3280)\n\n### \n\n\n $ a_i $\n\n $ m $  $ l_i $ $ p_i $\n\n $ i $  $ i + d_i $  $ q_i $\n\n $ a_i $ $ a_i $ $ \\sum a_i $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 50;\nconst int MAXM = 50;\nconst int MAXK = 50;\n\nstruct Node {\n\tstruct Edge *e, *in;\n\tbool q;\n\tint d, f;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].q = false;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].f = 0;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tflow += N[t].f;\n\t\tcost += N[t].f * N[t].d;\n\t}\n}\n\ninline void clear(const int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 1; i <= t; i++) {\n\t\tint n, m, k;\n\t\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\t\tconst int s = 0, t = n * 2 + 1;\n\t\tint sum = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(i, t, x, 0);\n\t\t\taddEdge(s, i + n, x, 0);\n\t\t\tsum += x;\n\n\t\t\tif (i != n) addEdge(i, i + 1, INT_MAX, 0);\n\t\t}\n\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\taddEdge(s, 1, a, b);\n\t\t}\n\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b), a++;\n\t\t\tfor (int j = 1; j <= n - a; j++) addEdge(j + n, j + a, INT_MAX, b);\n\t\t}\n\n\t\tint flow, cost;\n\t\tedmondskarp(s, t, n * 2 + 2, flow, cost);\n\n\t\tprintf(\"Case %d: \", i);\n\t\tif (flow == sum) printf(\"%d\\n\", cost);\n\t\telse puts(\"impossible\");\n\n\t\tclear(n * 2 + 2);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3280.md","raw":"title: BZOJ 3280 R  - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - Edmonds-Karp\npermalink: bzoj-3280\ndate: 2016-09-04 07:21:00\n---\n\n $ n $  $ i $  $ a_i $  $ m $  $ j $  $ l_j $  $ p_j $ \n\n $ k $  $ i $  $ d_i $  $ q_i $ \n\n<!-- more -->\n\n### \n[BZOJ 3280](http://www.lydsy.com/JudgeOnline/problem.php?id=3280)\n\n### \n\n\n $ a_i $\n\n $ m $  $ l_i $ $ p_i $\n\n $ i $  $ i + d_i $  $ q_i $\n\n $ a_i $ $ a_i $ $ \\sum a_i $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 50;\nconst int MAXM = 50;\nconst int MAXK = 50;\n\nstruct Node {\n\tstruct Edge *e, *in;\n\tbool q;\n\tint d, f;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], c, w);\n\tN[t].e = new Edge(&N[t], &N[s], 0, -w);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].q = false;\n\t\t\tN[i].d = INT_MAX;\n\t\t\tN[i].f = 0;\n\t\t}\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\t\tN[s].d = 0, N[s].f = INT_MAX;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\te->t->in = e;\n\t\t\t\tif (!e->t->q) {\n\t\t\t\t\te->t->q = true;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tflow += N[t].f;\n\t\tcost += N[t].f * N[t].d;\n\t}\n}\n\ninline void clear(const int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tfor (int i = 1; i <= t; i++) {\n\t\tint n, m, k;\n\t\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\t\tconst int s = 0, t = n * 2 + 1;\n\t\tint sum = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(i, t, x, 0);\n\t\t\taddEdge(s, i + n, x, 0);\n\t\t\tsum += x;\n\n\t\t\tif (i != n) addEdge(i, i + 1, INT_MAX, 0);\n\t\t}\n\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\taddEdge(s, 1, a, b);\n\t\t}\n\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b), a++;\n\t\t\tfor (int j = 1; j <= n - a; j++) addEdge(j + n, j + a, INT_MAX, b);\n\t\t}\n\n\t\tint flow, cost;\n\t\tedmondskarp(s, t, n * 2 + 2, flow, cost);\n\n\t\tprintf(\"Case %d: \", i);\n\t\tif (flow == sum) printf(\"%d\\n\", cost);\n\t\telse puts(\"impossible\");\n\n\t\tclear(n * 2 + 2);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3280","published":1,"updated":"2016-09-10T11:54:33.657Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d1z01emc2xlddjbdlva"},{"title":"BZOJ 3277 -  +  + ","date":"2016-09-29T23:24:00.000Z","_content":"\n $ n $  $ n $  $ k $ \n\n<!-- more -->\n\n### \n[BZOJ 3277](http://www.lydsy.com/JudgeOnline/problem.php?id=3277)  \n[Codeforces 204E](http://codeforces.com/problemset/problem/204/E)\n\n### \n$ \\geq x $  $ \\geq k $  $ x $ \n\n $ x $ $ \\geq x $  `set`  $ x $  $ < x $ \n\n $ x $  $ x - 1 $  $ x - 1 $  $ x - 1 $  $ x $ \n\n $ k = 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <iostream>\n\nconst int MAXN = 100000;\nconst int MAXLEN = 100000 + MAXN;\n\nint s[MAXLEN];\nint n, m, sa[MAXLEN], rk[MAXLEN], ht[MAXLEN], pos[MAXN], belong[MAXLEN];\n\ninline void suffixArray() {\n\tstatic int set[MAXLEN], a[MAXLEN];\n\tstd::copy(s, s + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXLEN], sec[MAXLEN], tmp[MAXLEN], _buc[MAXLEN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\t\t\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\tbool unique = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t\tif (unique) break;\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (!rk[i]) continue;\n\t\tint j = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n#endif\n}\n\nstruct UnionFindSet {\n\tint a[MAXLEN], l[MAXLEN], r[MAXLEN];\n\tstd::set<int> set[MAXLEN];\n\n\tvoid init(const int n, const int *belong) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = i;\n\t\t\trk[i] = 1;\n\t\t\tl[i] = r[i] = i;\n\t\t\tset[i].insert(belong[i]);\n\t\t}\n\t}\n\n\tint find(const int x) {\n\t\treturn x == a[x] ? x : a[x] = find(a[x]);\n\t}\n\n\tint merge(const int x, const int y) {\n#ifdef DBG\n\t\tprintf(\"merge(%d, %d)\\n\", x, y);\n#endif\n\t\tint _x = find(x), _y = find(y);\n\t\tif (set[_x].size() < set[_y].size()) std::swap(_x, _y);\n\t\ta[_y] = _x;\n\t\tset[_x].insert(set[_y].begin(), set[_y].end());\n\t\tl[_x] = std::min(l[_x], l[_y]);\n\t\tr[_x] = std::max(r[_x], r[_y]);\n\t\treturn _x;\n\t}\n\n\tint uniqueCount(const int x) {\n\t\treturn set[x].size();\n\t}\n\n\tvoid getRange(const int x, int &l, int &r) {\n\t\tl = this->l[x];\n\t\tr = this->r[x];\n\t}\n} ufs;\n\nlong long gap[MAXLEN + 1];\ninline void apply(const int id, const int val = 1) {\n\tint l, r;\n\tufs.getRange(id, l, r);\n\tgap[l] += val, gap[r + 1] -= val;\n#ifdef DBG\n\tfor (int i = l; i <= r; i++) printf(\"ans[%d] += %d\\n\", belong[i], val);\n#endif\n}\n\nint main() {\n\tint k;\n\tscanf(\"%d %d\", &m, &k);\n\n\tint *p = s;\n\tint spliter = 233;\n\tfor (int i = 0; i < m; i++) {\n#ifdef DBG\n\t\tprintf(\"%d\\n\", i);\n#endif\n\t\tpos[i] = p - s;\n\t\tstatic char buf[MAXLEN];\n\t\tscanf(\"%s\", buf);\n\t\tint len = strlen(buf);\n\t\tif (k == 1) {\n\t\t\tstd::cout << (static_cast<long long>(len) * (len + 1) / 2) << (i == m - 1 ? '\\n' : ' ');\n\t\t}\n\t\tfor (int i = 0; i < len; i++) *p++ = buf[i];\n\t\t*p++ = spliter++;\n\t}\n\t\n\tif (k == 1) return 0;\n\n\t*--p = '\\0';\n\tn = p - s;\n\n\tsuffixArray();\n\n\tfor (int i = 0; i < n; i++) belong[i] = std::upper_bound(pos, pos + m, sa[i]) - pos - 1;\n\tufs.init(n, belong);\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d %d %s\\n\", belong[i], ht[i], &s[sa[i]]);\n\t}\n#endif\n\n\tstd::vector<int> v[MAXLEN];\n\tint maxH = 0;\n\tfor (int i = 0; i < n; i++) v[ht[i]].push_back(i), maxH = std::max(maxH, ht[i]);\n\tfor (int i = maxH; i > 0; i--) {\n#ifdef DBG\n\t\tprintf(\"Now processing h = %d\\n\", i);\n#endif\n\t\tstd::vector<int> vec;\n\t\tfor (std::vector<int>::const_iterator it = v[i].begin(); it != v[i].end(); it++) {\n\t\t\tint id = ufs.merge(*it, *it - 1);\n\t\t\tif (ufs.uniqueCount(id) >= k) {\n\t\t\t\t// apply(id);\n\t\t\t\tvec.push_back(id);\n\t\t\t}\n\t\t}\n\t\tfor (std::vector<int>::iterator it = vec.begin(); it != vec.end(); it++) *it = ufs.find(*it);\n\t\tstd::sort(vec.begin(), vec.end());\n\t\tstd::vector<int>::const_iterator end = std::unique(vec.begin(), vec.end());\n\t\tfor (std::vector<int>::const_iterator it = vec.begin(); it != end; it++) {\n\t\t\tint l, r;\n\t\t\tufs.getRange(*it, l, r);\n\t\t\tint x = ht[l];\n\t\t\tif (r != n - 1) x = std::max(x, ht[r + 1]);\n\t\t\tapply(*it, i - x);\n\t\t}\n\t}\n\n\tstatic long long ans[MAXN];\n\tfor (int i = 1; i < n; i++) gap[i] += gap[i - 1];\n\tfor (int i = 0; i < n; i++) ans[belong[i]] += gap[i];\n\n\t// for (int i = 0; i < m; i++) printf(\"%lld%c\", ans[i], i == m - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < m; i++) {\n\t\tstd::cout << ans[i]; //  << (i == m - 1 ? '\\0' : ' ');\n\t\tif (i != m - 1) std::cout << ' ';\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3277.md","raw":"title: BZOJ 3277 -  +  + \ncategories: OI\ntags: \n  - BZOJ\n  - Codeforces\n  - \n  - \n  - \n  - \npermalink: bzoj-3277\ndate: 2016-09-30 07:24:00\n---\n\n $ n $  $ n $  $ k $ \n\n<!-- more -->\n\n### \n[BZOJ 3277](http://www.lydsy.com/JudgeOnline/problem.php?id=3277)  \n[Codeforces 204E](http://codeforces.com/problemset/problem/204/E)\n\n### \n$ \\geq x $  $ \\geq k $  $ x $ \n\n $ x $ $ \\geq x $  `set`  $ x $  $ < x $ \n\n $ x $  $ x - 1 $  $ x - 1 $  $ x - 1 $  $ x $ \n\n $ k = 1 $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <iostream>\n\nconst int MAXN = 100000;\nconst int MAXLEN = 100000 + MAXN;\n\nint s[MAXLEN];\nint n, m, sa[MAXLEN], rk[MAXLEN], ht[MAXLEN], pos[MAXN], belong[MAXLEN];\n\ninline void suffixArray() {\n\tstatic int set[MAXLEN], a[MAXLEN];\n\tstd::copy(s, s + n, set);\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXLEN], sec[MAXLEN], tmp[MAXLEN], _buc[MAXLEN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\t\t\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\tbool unique = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t\tif (unique) break;\n\t}\n\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tif (!rk[i]) continue;\n\t\tint j = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n#endif\n}\n\nstruct UnionFindSet {\n\tint a[MAXLEN], l[MAXLEN], r[MAXLEN];\n\tstd::set<int> set[MAXLEN];\n\n\tvoid init(const int n, const int *belong) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = i;\n\t\t\trk[i] = 1;\n\t\t\tl[i] = r[i] = i;\n\t\t\tset[i].insert(belong[i]);\n\t\t}\n\t}\n\n\tint find(const int x) {\n\t\treturn x == a[x] ? x : a[x] = find(a[x]);\n\t}\n\n\tint merge(const int x, const int y) {\n#ifdef DBG\n\t\tprintf(\"merge(%d, %d)\\n\", x, y);\n#endif\n\t\tint _x = find(x), _y = find(y);\n\t\tif (set[_x].size() < set[_y].size()) std::swap(_x, _y);\n\t\ta[_y] = _x;\n\t\tset[_x].insert(set[_y].begin(), set[_y].end());\n\t\tl[_x] = std::min(l[_x], l[_y]);\n\t\tr[_x] = std::max(r[_x], r[_y]);\n\t\treturn _x;\n\t}\n\n\tint uniqueCount(const int x) {\n\t\treturn set[x].size();\n\t}\n\n\tvoid getRange(const int x, int &l, int &r) {\n\t\tl = this->l[x];\n\t\tr = this->r[x];\n\t}\n} ufs;\n\nlong long gap[MAXLEN + 1];\ninline void apply(const int id, const int val = 1) {\n\tint l, r;\n\tufs.getRange(id, l, r);\n\tgap[l] += val, gap[r + 1] -= val;\n#ifdef DBG\n\tfor (int i = l; i <= r; i++) printf(\"ans[%d] += %d\\n\", belong[i], val);\n#endif\n}\n\nint main() {\n\tint k;\n\tscanf(\"%d %d\", &m, &k);\n\n\tint *p = s;\n\tint spliter = 233;\n\tfor (int i = 0; i < m; i++) {\n#ifdef DBG\n\t\tprintf(\"%d\\n\", i);\n#endif\n\t\tpos[i] = p - s;\n\t\tstatic char buf[MAXLEN];\n\t\tscanf(\"%s\", buf);\n\t\tint len = strlen(buf);\n\t\tif (k == 1) {\n\t\t\tstd::cout << (static_cast<long long>(len) * (len + 1) / 2) << (i == m - 1 ? '\\n' : ' ');\n\t\t}\n\t\tfor (int i = 0; i < len; i++) *p++ = buf[i];\n\t\t*p++ = spliter++;\n\t}\n\t\n\tif (k == 1) return 0;\n\n\t*--p = '\\0';\n\tn = p - s;\n\n\tsuffixArray();\n\n\tfor (int i = 0; i < n; i++) belong[i] = std::upper_bound(pos, pos + m, sa[i]) - pos - 1;\n\tufs.init(n, belong);\n\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) {\n\t\tprintf(\"%d %d %s\\n\", belong[i], ht[i], &s[sa[i]]);\n\t}\n#endif\n\n\tstd::vector<int> v[MAXLEN];\n\tint maxH = 0;\n\tfor (int i = 0; i < n; i++) v[ht[i]].push_back(i), maxH = std::max(maxH, ht[i]);\n\tfor (int i = maxH; i > 0; i--) {\n#ifdef DBG\n\t\tprintf(\"Now processing h = %d\\n\", i);\n#endif\n\t\tstd::vector<int> vec;\n\t\tfor (std::vector<int>::const_iterator it = v[i].begin(); it != v[i].end(); it++) {\n\t\t\tint id = ufs.merge(*it, *it - 1);\n\t\t\tif (ufs.uniqueCount(id) >= k) {\n\t\t\t\t// apply(id);\n\t\t\t\tvec.push_back(id);\n\t\t\t}\n\t\t}\n\t\tfor (std::vector<int>::iterator it = vec.begin(); it != vec.end(); it++) *it = ufs.find(*it);\n\t\tstd::sort(vec.begin(), vec.end());\n\t\tstd::vector<int>::const_iterator end = std::unique(vec.begin(), vec.end());\n\t\tfor (std::vector<int>::const_iterator it = vec.begin(); it != end; it++) {\n\t\t\tint l, r;\n\t\t\tufs.getRange(*it, l, r);\n\t\t\tint x = ht[l];\n\t\t\tif (r != n - 1) x = std::max(x, ht[r + 1]);\n\t\t\tapply(*it, i - x);\n\t\t}\n\t}\n\n\tstatic long long ans[MAXN];\n\tfor (int i = 1; i < n; i++) gap[i] += gap[i - 1];\n\tfor (int i = 0; i < n; i++) ans[belong[i]] += gap[i];\n\n\t// for (int i = 0; i < m; i++) printf(\"%lld%c\", ans[i], i == m - 1 ? '\\n' : ' ');\n\tfor (int i = 0; i < m; i++) {\n\t\tstd::cout << ans[i]; //  << (i == m - 1 ? '\\0' : ' ');\n\t\tif (i != m - 1) std::cout << ' ';\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3277","published":1,"updated":"2016-09-29T23:40:34.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d2501esc2xlsrkezl16"},{"title":"BZOJ 3275Number - ","date":"2016-05-23T13:50:00.000Z","_content":"\n $ N $ \n\n $ a,\\ b $  $ a,\\ b $ \n\n1.  $ c $ $ a ^ 2 + b ^ 2 = c ^ 2 $\n2. $ \\gcd(a,\\ b) = 1 $\n\n<!-- more -->\n\n### \n[BZOJ 3275](http://www.lydsy.com/JudgeOnline/problem.php?id=3275)  \n[COGS 1389](http://cogs.top/cogs/problem/problem.php?pid=1389)\n\n### \n\n\n $ X $  $ Y $  $ X $  $ Y $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 3000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n\tlong long x;\n\tbool color, v;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tlong long f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const long long c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v, const long long c) {\n\tN[u].e = new Edge(&N[u], &N[v], c);\n\tN[v].e = new Edge(&N[v], &N[u], 0);\n\t(N[u].e->r = N[v].e)->r = N[u].e;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *const s, Node *const t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->l == 0) {\n\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\tif (e->t == t) return true;\n\t\t\t\t\telse q.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tlong long findPath(Node *const s, Node *const t, const long long limit = LLONG_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\t\tlong long flow = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->f += flow;\n\t\t\t\t\te->r->f -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tlong long operator()(const int s, const int t, const int n) {\n\t\tlong long res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tlong long flow;\n\t\t\twhile ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\nint n;\nbool flag[MAXN][MAXN];\n\ntemplate <typename T> inline T sqr(const T x) { return x * x; }\n\ntemplate <typename T>\ninline bool isSquare(const T x) {\n\tT t = static_cast<T>(sqrt(static_cast<double>(x)));\n\treturn t * t == x;\n}\n\ntemplate <typename T>\ninline T gcd(const T a, const T b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n\ninline void color() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].v) continue;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].color = true;\n\t\tN[i].v = true;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->v) {\n\t\t\t\t\te->t->v = true;\n\t\t\t\t\te->t->color = !v->color;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t} else assert(e->t->color != v->color);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void clean() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tlong long sum = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &N[i].x);\n\t\tsum += N[i].x;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (isSquare(sqr(N[i].x) + sqr(N[j].x)) && gcd(N[i].x, N[j].x) == 1) {\n\t\t\t\tflag[i][j] = flag[j][i] = true;\n\t\t\t\taddEdge(i, j, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tcolor();\n\tclean();\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].color) addEdge(s, i, N[i].x);\n\t\telse addEdge(i, t, N[i].x);\n\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (flag[i][j]) {\n\t\t\t\tif (N[i].color) addEdge(i, j, LLONG_MAX);\n\t\t\t\telse addEdge(j, i, LLONG_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long maxFlow = dinic(s, t, n + 2);\n\tprintf(\"%lld\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3275.md","raw":"title: BZOJ 3275Number - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - Dinic\n  - \n  - \npermalink: bzoj-3275\ndate: 2016-05-23 21:50:00\n---\n\n $ N $ \n\n $ a,\\ b $  $ a,\\ b $ \n\n1.  $ c $ $ a ^ 2 + b ^ 2 = c ^ 2 $\n2. $ \\gcd(a,\\ b) = 1 $\n\n<!-- more -->\n\n### \n[BZOJ 3275](http://www.lydsy.com/JudgeOnline/problem.php?id=3275)  \n[COGS 1389](http://cogs.top/cogs/problem/problem.php?pid=1389)\n\n### \n\n\n $ X $  $ Y $  $ X $  $ Y $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 3000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n\tlong long x;\n\tbool color, v;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tlong long f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const long long c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\ninline void addEdge(const int u, const int v, const long long c) {\n\tN[u].e = new Edge(&N[u], &N[v], c);\n\tN[v].e = new Edge(&N[v], &N[u], 0);\n\t(N[u].e->r = N[v].e)->r = N[u].e;\n}\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *const s, Node *const t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->l == 0) {\n\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\tif (e->t == t) return true;\n\t\t\t\t\telse q.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tlong long findPath(Node *const s, Node *const t, const long long limit = LLONG_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\t\tlong long flow = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->f += flow;\n\t\t\t\t\te->r->f -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tlong long operator()(const int s, const int t, const int n) {\n\t\tlong long res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tlong long flow;\n\t\t\twhile ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\nint n;\nbool flag[MAXN][MAXN];\n\ntemplate <typename T> inline T sqr(const T x) { return x * x; }\n\ntemplate <typename T>\ninline bool isSquare(const T x) {\n\tT t = static_cast<T>(sqrt(static_cast<double>(x)));\n\treturn t * t == x;\n}\n\ntemplate <typename T>\ninline T gcd(const T a, const T b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n\ninline void color() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].v) continue;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i]);\n\t\tN[i].color = true;\n\t\tN[i].v = true;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->v) {\n\t\t\t\t\te->t->v = true;\n\t\t\t\t\te->t->color = !v->color;\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t} else assert(e->t->color != v->color);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void clean() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tlong long sum = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &N[i].x);\n\t\tsum += N[i].x;\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (isSquare(sqr(N[i].x) + sqr(N[j].x)) && gcd(N[i].x, N[j].x) == 1) {\n\t\t\t\tflag[i][j] = flag[j][i] = true;\n\t\t\t\taddEdge(i, j, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tcolor();\n\tclean();\n\n\tconst int s = 0, t = n + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (N[i].color) addEdge(s, i, N[i].x);\n\t\telse addEdge(i, t, N[i].x);\n\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (flag[i][j]) {\n\t\t\t\tif (N[i].color) addEdge(i, j, LLONG_MAX);\n\t\t\t\telse addEdge(j, i, LLONG_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long maxFlow = dinic(s, t, n + 2);\n\tprintf(\"%lld\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3275","published":1,"updated":"2016-05-23T15:09:19.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d2d01f0c2xlyynqa9kv"},{"title":"BZOJ 3262 - CDQ","date":"2016-06-19T12:56:00.000Z","_content":"\n $ A_i = (a,\\ b,\\ c) $  \n $ a_i \\leq a_j,\\ b_i \\leq b_j,\\ c_i \\leq c_j $ $ A_j $  $ A_i $   \n $ A_i $  $ A_j $  $ A_i $  $ A_j $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 3262](http://www.lydsy.com/JudgeOnline/problem.php?id=3262)\n\n### \n CDQ \n\n CDQ  $ a $  $ b $ \n\n $ b $  $ c $  $ c $  $ c $  $ b $  $ a $ CDQ \n\n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXK = 200000;\n\nstruct Triple {\n\tint a, b, c, cnt, ans;\n} a[MAXN], A[MAXN];\n\nbool operator<(const Triple &a, const Triple &b) {\n\treturn a.a < b.a || (a.a == b.a && a.b < b.b) || (a.a == b.a && a.b == b.b && a.c < b.c);\n}\n\nint n, k;\n\nstruct BinaryIndexedTree {\n\tint a[MAXK];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= k; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clean(const int x) {\n\t\tfor (int i = x; i <= k; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) {\n\t\tl->ans += l->cnt - 1;\n\t\treturn;\n\t}\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN];\n\tfor (Triple *p = tmp, *p1 = l, *p2 = mid + 1; p <= tmp + (r - l); p++) {\n\t\tif ((p1->b <= p2->b && p1 <= mid) || p2 > r) {\n\t\t\t*p = *p1++;\n\t\t\tbit.update(p->c, p->cnt);\n\t\t} else {\n\t\t\t*p = *p2++;\n\t\t\tp->ans += bit.query(p->c);\n\t\t}\n\t}\n\n\tfor (Triple *p = tmp, *q = l; q <= r; p++, q++) {\n\t\tbit.clean(p->c);\n\t\t*q = *p;\n\t}\n\n\t/*\n\tprintf(\"cdq(%ld, %ld): \", l - A + 1, r - A + 1);\n\tfor (Triple *p = l; p <= r; p++) {\n\t\tprintf(\"(%d, %d, %d)%s\", p->a, p->b, p->c, p == r ? \"\\n\" : \", \");\n\t}\n\t*/\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T &x) {\n\tstatic char s[20];\n\tint cnt = 0;\n\tdo s[cnt++] = x % 10; while (x /= 10);\n\twhile (cnt--) putchar(s[cnt] + '0');\n\tputchar('\\n');\n}\n\nint main() {\n\tread(n), read(k);\n\tfor (int i = 0; i < n; i++) read(a[i].a), read(a[i].b), read(a[i].c), a[i].cnt = 1;\n\t// scanf(\"%d %d\", &n, &k);\n\t// for (int i = 0; i < n; i++) scanf(\"%d %d %d\", &a[i].a, &a[i].b, &a[i].c), a[i].cnt = 1;\n\n\tstd::sort(a, a + n);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0 || !(a[i].a == a[i - 1].a && a[i].b == a[i - 1].b && a[i].c == a[i - 1].c)) A[cnt++] = a[i];\n\t\telse A[cnt - 1].cnt++;\n\t}\n\n\tcdq(A, A + cnt - 1);\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0; i < cnt; i++) ans[A[i].ans] += A[i].cnt;\n\t\n\tfor (int i = 0; i < n; i++) write(ans[i]);\n\t// for (int i = 0; i < n; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3262.md","raw":"title: BZOJ 3262 - CDQ\ncategories: OI\ntags: \n  - BZOJ\n  - CDQ\n  - \n  - \n  - \npermalink: bzoj-3262\ndate: 2016-06-19 20:56:00\n---\n\n $ A_i = (a,\\ b,\\ c) $  \n $ a_i \\leq a_j,\\ b_i \\leq b_j,\\ c_i \\leq c_j $ $ A_j $  $ A_i $   \n $ A_i $  $ A_j $  $ A_i $  $ A_j $ \n\n\n\n<!-- more -->\n\n### \n[BZOJ 3262](http://www.lydsy.com/JudgeOnline/problem.php?id=3262)\n\n### \n CDQ \n\n CDQ  $ a $  $ b $ \n\n $ b $  $ c $  $ c $  $ c $  $ b $  $ a $ CDQ \n\n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXK = 200000;\n\nstruct Triple {\n\tint a, b, c, cnt, ans;\n} a[MAXN], A[MAXN];\n\nbool operator<(const Triple &a, const Triple &b) {\n\treturn a.a < b.a || (a.a == b.a && a.b < b.b) || (a.a == b.a && a.b == b.b && a.c < b.c);\n}\n\nint n, k;\n\nstruct BinaryIndexedTree {\n\tint a[MAXK];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= k; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clean(const int x) {\n\t\tfor (int i = x; i <= k; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) {\n\t\tl->ans += l->cnt - 1;\n\t\treturn;\n\t}\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN];\n\tfor (Triple *p = tmp, *p1 = l, *p2 = mid + 1; p <= tmp + (r - l); p++) {\n\t\tif ((p1->b <= p2->b && p1 <= mid) || p2 > r) {\n\t\t\t*p = *p1++;\n\t\t\tbit.update(p->c, p->cnt);\n\t\t} else {\n\t\t\t*p = *p2++;\n\t\t\tp->ans += bit.query(p->c);\n\t\t}\n\t}\n\n\tfor (Triple *p = tmp, *q = l; q <= r; p++, q++) {\n\t\tbit.clean(p->c);\n\t\t*q = *p;\n\t}\n\n\t/*\n\tprintf(\"cdq(%ld, %ld): \", l - A + 1, r - A + 1);\n\tfor (Triple *p = l; p <= r; p++) {\n\t\tprintf(\"(%d, %d, %d)%s\", p->a, p->b, p->c, p == r ? \"\\n\" : \", \");\n\t}\n\t*/\n}\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T &x) {\n\tstatic char s[20];\n\tint cnt = 0;\n\tdo s[cnt++] = x % 10; while (x /= 10);\n\twhile (cnt--) putchar(s[cnt] + '0');\n\tputchar('\\n');\n}\n\nint main() {\n\tread(n), read(k);\n\tfor (int i = 0; i < n; i++) read(a[i].a), read(a[i].b), read(a[i].c), a[i].cnt = 1;\n\t// scanf(\"%d %d\", &n, &k);\n\t// for (int i = 0; i < n; i++) scanf(\"%d %d %d\", &a[i].a, &a[i].b, &a[i].c), a[i].cnt = 1;\n\n\tstd::sort(a, a + n);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0 || !(a[i].a == a[i - 1].a && a[i].b == a[i - 1].b && a[i].c == a[i - 1].c)) A[cnt++] = a[i];\n\t\telse A[cnt - 1].cnt++;\n\t}\n\n\tcdq(A, A + cnt - 1);\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0; i < cnt; i++) ans[A[i].ans] += A[i].cnt;\n\t\n\tfor (int i = 0; i < n; i++) write(ans[i]);\n\t// for (int i = 0; i < n; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3262","published":1,"updated":"2016-06-19T12:56:40.696Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d2l01f7c2xlnbgi70cq"},{"title":"BZOJ 3230 - ","date":"2016-09-29T22:59:00.000Z","_content":"\n $ N $  $ S $ $ f = a ^ 2 + b ^ 2 $  $ a $$ b $ $ S[l \\ldots l + a - 1] = S[p \\ldots p + a - 1] $$ S[r - b + 1 \\ldots r] = S[q - b + 1 \\ldots q] $$ 0 \\leq a \\leq r - l + 1 $$ 0 \\leq b \\leq q - p + 1 $\n\n $ i $  $ j $ \n\n<!-- more -->\n\n### \n[BZOJ 3230](http://www.lydsy.com/JudgeOnline/problem.php?id=3230)\n\n### \n $ N $  $ O(N ^ 2) $ \n\n $ i $  $ i - 1 $  $ l $ $ i $  $ i - 1 $  $ \\mathrm{len}(i) - l $  $ l + 1 $\n\n $ i $ $ a $  $ b $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812;\n\nchar s[MAXN], sRev[MAXN];\nint n, log[MAXN + 1];\nlong long cnt[MAXN];\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1];\n\n\tvoid build(const char *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tbool unique = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t\tif (unique) break;\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n\t\t/*\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n\t\t// */\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) >= n) st[i][j] = st[i][j - 1];\n\t\t\t\telse st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(const int l, const int r) {\n#ifdef TEST\n\t\tassert(l <= r);\n#endif\n\t\tif (l == r) return st[l][0];\n\t\tint t = log[r - l];\n\t\tint res = std::min(st[l][t], st[r - (1 << t) + 1][t]);\n#ifdef TEST\n\t\tint ans = n;\n\t\tfor (int k = l; k <= r; k++) ans = std::min(ans, ht[k]);\n\t\tassert(res == ans);\n#endif\n\t\treturn res;\n\t}\n\n\tint lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn query(a + 1, b);\n\t}\n} sa, saRev;\n\ninline int lcp(const int i, const int j) {\n\tint res = sa.lcp(i, j);\n#ifdef TEST\n\tint ans;\n\tfor (ans = 0; i + ans < n && j + ans < n && s[i + ans] == s[j + ans]; ans++);\n\tassert(res == ans);\n#endif\n\treturn res;\n}\n\ninline int lcs(const int i, const int j) {\n\tint res = saRev.lcp(n - i - 1, n - j - 1);\n#ifdef TEST\n\tint ans;\n\tfor (ans = 0; i - ans >= 0 && j - ans >= 0 && s[i - ans] == s[j - ans]; ans++);\n\tassert(res == ans);\n#endif\n\treturn res;\n}\n\ninline void prepare() {\n\tfor (int i = 0; i <= n; i++) {\n\t\tint x = 0;\n\t\twhile ((1 << x) <= i) x++;\n\t\tlog[i] = x - 1;\n\t\t// printf(\"log(%d) = %d\\n\", i, log[i]);\n\t}\n\n\tsa.build(s, n);\n\n\tlong long x = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tx += n - sa.sa[i];\n\t\tif (i) x -= sa.ht[i];\n\t\tcnt[i] = x;\n\t\t// printf(\"%lld\\n\", x);\n\t}\n\n\tstd::copy(s, s + n, sRev);\n\tstd::reverse(sRev, sRev + n);\n\tsaRev.build(sRev, n);\n}\n\ninline bool locate(const long long k, int &l, int &r) {\n\tlong long *p = std::upper_bound(cnt, cnt + n, k - 1);\n\tif (p == cnt + n) return false;\n\tint t = *p - k;\n\tl = sa.sa[p - cnt];\n\tr = n - t - 1;\n\treturn true;\n}\n\ninline void all() {\n\tstd::vector<std::string> v;\n\tfor (int i = 0; i < n; i++) for (int j = i + 1; j <= n; j++) v.push_back(std::string(&s[i], &s[j]));\n\tstd::sort(v.begin(), v.end());\n\tv.erase(std::unique(v.begin(), v.end()), v.end());\n\tint i = 1;\n\tfor (std::vector<std::string>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tint l, r;\n\t\tlocate(i++, l, r);\n\t\t// printf(\"%d %d\\n\", l, r);\n\t\tfor (int j = l; j <= r; j++) putchar(s[j]);\n\t\tputchar('\\n');\n\t\tprintf(\"%s\\n\", it->c_str());\n\t}\n}\n\nint main() {\n\tint q;\n\tscanf(\"%d %d\\n%s\", &n, &q, s);\n\tn = strlen(s);\n\tprepare();\n\t// all();\n\n\t/*\n\tputs(\"left query:\");\n\tfor (int i = 0; i < n; i++) for (int j = i; j < n; j++) printf(\"lq(%d, %d) = %d\\n\", i, j, query(stp, i, j));\n\n\tputs(\"right query:\");\n\tfor (int i = 0; i < n; i++) for (int j = i; j < n; j++) printf(\"rq(%d, %d) = %d\\n\", i, j, query(sts, i, j));\n\t*/\n\n\t/*\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"lcp(%d, %d) = %d\\n\", i, j, lcp(i, j));\n\tputchar('\\n');\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"lcs(%d, %d) = %d\\n\", i, j, lcs(i, j));\n\t*/\n\n\twhile (q--) {\n\t\tlong long i, j;\n\t\tscanf(\"%lld %lld\", &i, &j);\n\t\tint l1, r1, l2, r2;\n\t\tif (!locate(i, l1, r1) || !locate(j, l2, r2)) {\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tint lim = std::min(r1 - l1 + 1, r2 - l2 + 1);\n\t\tlong long a = std::min(lim, lcp(l1, l2)), b = std::min(lim, lcs(r1, r2));\n\t\tprintf(\"%lld\\n\", a * a + b * b);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3230.md","raw":"title: BZOJ 3230 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \npermalink: bzoj-3230\ndate: 2016-09-30 06:59:00\n---\n\n $ N $  $ S $ $ f = a ^ 2 + b ^ 2 $  $ a $$ b $ $ S[l \\ldots l + a - 1] = S[p \\ldots p + a - 1] $$ S[r - b + 1 \\ldots r] = S[q - b + 1 \\ldots q] $$ 0 \\leq a \\leq r - l + 1 $$ 0 \\leq b \\leq q - p + 1 $\n\n $ i $  $ j $ \n\n<!-- more -->\n\n### \n[BZOJ 3230](http://www.lydsy.com/JudgeOnline/problem.php?id=3230)\n\n### \n $ N $  $ O(N ^ 2) $ \n\n $ i $  $ i - 1 $  $ l $ $ i $  $ i - 1 $  $ \\mathrm{len}(i) - l $  $ l + 1 $\n\n $ i $ $ a $  $ b $ \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(1e5) = 16.609640474436812;\n\nchar s[MAXN], sRev[MAXN];\nint n, log[MAXN + 1];\nlong long cnt[MAXN];\n\nstruct SuffixArray {\n\tint n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][MAXN_LOG + 1];\n\n\tvoid build(const char *s, const int n) {\n\t\tthis->n = n;\n\t\tstatic int set[MAXN], a[MAXN];\n\t\tstd::copy(s, s + n, set);\n\t\tstd::sort(set, set + n);\n\t\tint *end = std::unique(set, set + n);\n\t\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\t\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\n\t\tfor (int t = 1; t < n; t *= 2) {\n\t\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i], sec[i] = i + t < n ? rk[i + t] : -1;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\t\tstd::fill(buc - 1, buc + n, 0);\n\t\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\t\tbool unique = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]], unique = false;\n\t\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t\t}\n\t\t\tif (unique) break;\n\t\t}\n\n\t\tfor (int i = 0, k = 0; i < n; i++) {\n\t\t\tif (!rk[i]) continue;\n\t\t\tint j = sa[rk[i] - 1];\n\t\t\tif (k) k--;\n\t\t\twhile (i + k < n && j + k < n && s[i + k] == s[j + k]) k++;\n\t\t\tht[rk[i]] = k;\n\t\t}\n\n\t\t/*\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n\t\tfor (int i = 0; i < n; i++) printf(\"%d %s\\n\", ht[i], &s[sa[i]]);\n\t\t// */\n\n\t\tfor (int i = 0; i < n; i++) st[i][0] = ht[i];\n\t\tfor (int j = 1; (1 << j) < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i + (1 << (j - 1)) >= n) st[i][j] = st[i][j - 1];\n\t\t\t\telse st[i][j] = std::min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint query(const int l, const int r) {\n#ifdef TEST\n\t\tassert(l <= r);\n#endif\n\t\tif (l == r) return st[l][0];\n\t\tint t = log[r - l];\n\t\tint res = std::min(st[l][t], st[r - (1 << t) + 1][t]);\n#ifdef TEST\n\t\tint ans = n;\n\t\tfor (int k = l; k <= r; k++) ans = std::min(ans, ht[k]);\n\t\tassert(res == ans);\n#endif\n\t\treturn res;\n\t}\n\n\tint lcp(const int i, const int j) {\n\t\tif (i == j) return n - i;\n\t\tint a = rk[i], b = rk[j];\n\t\tif (a > b) std::swap(a, b);\n\t\treturn query(a + 1, b);\n\t}\n} sa, saRev;\n\ninline int lcp(const int i, const int j) {\n\tint res = sa.lcp(i, j);\n#ifdef TEST\n\tint ans;\n\tfor (ans = 0; i + ans < n && j + ans < n && s[i + ans] == s[j + ans]; ans++);\n\tassert(res == ans);\n#endif\n\treturn res;\n}\n\ninline int lcs(const int i, const int j) {\n\tint res = saRev.lcp(n - i - 1, n - j - 1);\n#ifdef TEST\n\tint ans;\n\tfor (ans = 0; i - ans >= 0 && j - ans >= 0 && s[i - ans] == s[j - ans]; ans++);\n\tassert(res == ans);\n#endif\n\treturn res;\n}\n\ninline void prepare() {\n\tfor (int i = 0; i <= n; i++) {\n\t\tint x = 0;\n\t\twhile ((1 << x) <= i) x++;\n\t\tlog[i] = x - 1;\n\t\t// printf(\"log(%d) = %d\\n\", i, log[i]);\n\t}\n\n\tsa.build(s, n);\n\n\tlong long x = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tx += n - sa.sa[i];\n\t\tif (i) x -= sa.ht[i];\n\t\tcnt[i] = x;\n\t\t// printf(\"%lld\\n\", x);\n\t}\n\n\tstd::copy(s, s + n, sRev);\n\tstd::reverse(sRev, sRev + n);\n\tsaRev.build(sRev, n);\n}\n\ninline bool locate(const long long k, int &l, int &r) {\n\tlong long *p = std::upper_bound(cnt, cnt + n, k - 1);\n\tif (p == cnt + n) return false;\n\tint t = *p - k;\n\tl = sa.sa[p - cnt];\n\tr = n - t - 1;\n\treturn true;\n}\n\ninline void all() {\n\tstd::vector<std::string> v;\n\tfor (int i = 0; i < n; i++) for (int j = i + 1; j <= n; j++) v.push_back(std::string(&s[i], &s[j]));\n\tstd::sort(v.begin(), v.end());\n\tv.erase(std::unique(v.begin(), v.end()), v.end());\n\tint i = 1;\n\tfor (std::vector<std::string>::const_iterator it = v.begin(); it != v.end(); it++) {\n\t\tint l, r;\n\t\tlocate(i++, l, r);\n\t\t// printf(\"%d %d\\n\", l, r);\n\t\tfor (int j = l; j <= r; j++) putchar(s[j]);\n\t\tputchar('\\n');\n\t\tprintf(\"%s\\n\", it->c_str());\n\t}\n}\n\nint main() {\n\tint q;\n\tscanf(\"%d %d\\n%s\", &n, &q, s);\n\tn = strlen(s);\n\tprepare();\n\t// all();\n\n\t/*\n\tputs(\"left query:\");\n\tfor (int i = 0; i < n; i++) for (int j = i; j < n; j++) printf(\"lq(%d, %d) = %d\\n\", i, j, query(stp, i, j));\n\n\tputs(\"right query:\");\n\tfor (int i = 0; i < n; i++) for (int j = i; j < n; j++) printf(\"rq(%d, %d) = %d\\n\", i, j, query(sts, i, j));\n\t*/\n\n\t/*\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"lcp(%d, %d) = %d\\n\", i, j, lcp(i, j));\n\tputchar('\\n');\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < n; j++) printf(\"lcs(%d, %d) = %d\\n\", i, j, lcs(i, j));\n\t*/\n\n\twhile (q--) {\n\t\tlong long i, j;\n\t\tscanf(\"%lld %lld\", &i, &j);\n\t\tint l1, r1, l2, r2;\n\t\tif (!locate(i, l1, r1) || !locate(j, l2, r2)) {\n\t\t\tputs(\"-1\");\n\t\t\tcontinue;\n\t\t}\n\t\tint lim = std::min(r1 - l1 + 1, r2 - l2 + 1);\n\t\tlong long a = std::min(lim, lcp(l1, l2)), b = std::min(lim, lcs(r1, r2));\n\t\tprintf(\"%lld\\n\", a * a + b * b);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3230","published":1,"updated":"2016-09-29T23:26:11.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d2s01fec2xlo6134k3k"},{"title":"BZOJ 3196 - ","date":"2016-06-19T01:37:00.000Z","_content":"\n\n\n1.  $ k $ \n2.  $ k $ \n3. \n4.  $ k $  $ x $\n5.  $ k $  $ x $\n\n<!-- more -->\n\n### \n[BZOJ 3196](http://www.lydsy.com/JudgeOnline/problem.php?id=3196)\n\n### \n\n\n $ O(\\log n) $  $ O(n \\log n) $ $ O(n \\log ^ 2 n) $ \n\n#### \n $ O(\\log n) $ \n\n#### \n\n\n $ x $ $ x $  $ k $ $ x $\n\n\n\n#### \n\n\n#### \n $ O(\\log n) $ \n\n $ O(n \\log ^ 3 n) $ Splay  BZOJ \n\n $ O(n \\log ^ 2 n) $ 512M \n\n![](http://127.0.0.1/lemon.png)\n\n $ O(n \\sqrt n \\log n) $\n\n### \n SplayRP  TLE\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nint n, m, a[MAXN];\n\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tint size, cnt, val;\n\n\t\tNode(Node *p, const int val, Node **r) : p(p), r(r), size(1), cnt(1), val(val) {\n\t\t\tc[L] = c[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (c[L]) delete c[L];\n\t\t\tif (c[R]) delete c[R];\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = cnt;\n\t\t\tif (c[L]) size += c[L]->size;\n\t\t\tif (c[R]) size += c[R]->size;\n\t\t}\n\n\t\tRelation relatain() const {\n\t\t\treturn this == p->c[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relatain();\n\t\t\tNode *o = p;\n\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relatain()] = this;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tNode *splay(Node *targetParent = NULL) {\n\t\t\twhile (p != targetParent) {\n\t\t\t\tif (p->p == targetParent) rotate();\n\t\t\t\telse if (p->relatain() == relatain()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tNode *prec() {\n\t\t\tsplay();\n\t\t\tNode *v = c[L];\n\t\t\twhile (v->c[R]) v = v->c[R];\n\t\t\treturn v->splay();\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = c[R];\n\t\t\twhile (v->c[L]) v = v->c[L];\n\t\t\treturn v->splay();\n\t\t}\n\n\t\tint left() const { return c[L] ? c[L]->size : 0; }\n\n#ifdef DBG\n\t\tvoid validate() {\n\t\t\tint size = 0;\n\t\t\tif (c[L]) c[L]->validate(), assert(this->val > c[L]->val), size += c[L]->size;\n\t\t\tif (c[R]) c[R]->validate(), assert(this->val < c[R]->val), size += c[R]->size;\n\t\t\tassert(this->size == size + cnt);\n\t\t}\n\n\t\tvoid print(const int depth = 0);\n#endif\n\t} *r;\n#ifdef DBG\n\tint id;\n#endif\n\n\tSplay(const int *a, const int n) : r(NULL) {\n\t\tinsert(INT_MAX), insert(INT_MIN);\n#ifdef DBG\n\t\tstatic int time = 0;\n\t\ttime++;\n\t\tid = time;\n\t\tprintf(\"build(%d): \", id);\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n#endif\n\t\tfor (int i = 0; i < n; i++) insert(a[i]);\n\t}\n\n\t~Splay() { delete r; }\n\n\tNode *find(const int x) {\n\t\tNode *v = r;\n\t\twhile (v && x != v->val) {\n\t\t\tif (x < v->val) v = v->c[L];\n\t\t\telse v = v->c[R];\n\t\t}\n\t\treturn v ? v->splay() : NULL;\n\t}\n\n\tNode *insert(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) {\n\t\t\tv->cnt++, v->size++;\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &r, *p = NULL;\n\t\twhile (*target) {\n\t\t\tp = *target;\n\t\t\tp->size++;\n\t\t\tif (x< p->val) target = &p->c[L];\n\t\t\telse target = &p->c[R];\n\t\t}\n\n\t\treturn (*target = new Node(p, x, &r))->splay();\n\t}\n\n\tint rank(const int x) {\n\t\tNode *v = find(x);\n\t\tint res;\n\t\tif (v) res = v->left();\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tres = v->left();\n\t\t\terase(v);\n\t\t}\n#ifdef DBG\n\t\tprintf(\"rank(%d) in (%d) = %d\\n\", x, id, res);\n#endif\n\t\treturn res;\n\t}\n\n\tNode *select(const int k) {\n\t\tint x = k + 1;\n\t\tNode *v = r;\n\t\twhile (!(x >= v->left() + 1 && x <= v->left() + v->cnt)) {\n\t\t\tif (x < v->left() + 1) v = v->c[L];\n\t\t\telse x -= v->left() + v->cnt, v = v->c[R];\n\t\t}\n\t\treturn v->splay();\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->cnt != 1) {\n\t\t\tv->cnt--, v->size--;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tNode *prec = v->prec(), *succ = v->succ();\n\n\t\tprec->splay();\n\t\tsucc->splay(prec);\n\n\t\tdelete succ->c[L];\n\t\tsucc->c[L] = NULL;\n\n\t\tsucc->maintain(), prec->maintain();\n\t}\n\n\tvoid erase(const int x) {\n\t\tNode *v = find(x);\n\t\terase(v);\n\t}\n\n\tint prec(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) return v->prec()->val;\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tint res = v->prec()->val;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint succ(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) return v->succ()->val;\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tint res = v->succ()->val;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tr->validate();\n\t}\n#endif\n};\n\n#ifdef DBG\nvoid Splay::Node::print(const int depth) {\n\tif (c[L]) c[L]->print(depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' '), putchar(' ');\n\tprintf(\"%d\\n\", val);\n\tif (c[R]) c[R]->print(depth + 1);\n}\n#endif\n\nint map[MAXM + MAXN], max;\n\nstruct SegmentTree {\n\tSegmentTree *lc, *rc;\n\tint l, r;\n\tSplay s;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, int *a) : lc(lc), rc(rc), l(l), r(r), s(a, r - l + 1) {\n#ifdef DBG\n\t\tprintf(\" [%d, %d]\\n\", l, r);\n\t\tvalidate();\n#endif\n\t}\n\n\t~SegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r, int *a) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL, a);\n\t\telse {\n\t\t\tint m = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, m, a), build(m + 1, r, a + (m - l) + 1), a);\n\t\t}\n\t}\n\n\tvoid update(const int pos, const int old, const int curr) {\n\t\tif (pos > this->r || pos < this->l);\n\t\telse if (pos >= this->l && pos <= this->r) {\n\t\t\ts.erase(old);\n\t\t\ts.insert(curr);\n\t\t\tif (pos != this->l || pos != this->r) lc->update(pos, old, curr), rc->update(pos, old, curr);\n\t\t}\n\t}\n\n\tint rank(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return 1;\n\t\telse if (l <= this->l && r >= this->r) return s.rank(k);\n\t\telse return (lc->rank(l, r, k) - 1) + (rc->rank(l, r, k) - 1) + 1;\n\t}\n\n\tint prec(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return s.prec(k);\n\t\telse return std::max(lc->prec(l, r, k), rc->prec(l, r, k));\n\t}\n\n\tint succ(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return s.succ(k);\n\t\telse return std::min(lc->succ(l, r, k), rc->succ(l, r, k));\n\t}\n\n\tint select(const int l, const int r, const int k) {\n\t\tint L = 0, R = max;\n\t\twhile (L + 1 < R) {\n\t\t\tint m = L + (R - L) / 2;\n\t\t\tif (rank(l, r, m) > k) R = m;\n\t\t\telse L = m;\n\t\t}\n\t\tif (rank(l, r, R) == k) return R;\n\t\telse return L;\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tassert(s.r->size == r - l + 1 + 2);\n\t\ts.validate();\n\t\tif (lc) lc->validate();\n\t\tif (rc) rc->validate();\n\t}\n#endif\n} *segment;\n\nstruct Query {\n\tint opt, l, r, pos, k;\n} Q[MAXM];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tscanf(\"%d\", &q.opt);\n\t\tif (q.opt == 3) {\n\t\t\tscanf(\"%d %d\", &q.pos, &q.k);\n\t\t} else {\n\t\t\tscanf(\"%d %d %d\", &q.l, &q.r, &q.k);\n\t\t}\n\n\t\tif (q.opt != 2) {\n\t\t\tmap[cnt++] = q.k;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) map[cnt++] = a[i];\n\n\tstd::sort(map, map + cnt);\n\tint *end = std::unique(map, map + cnt);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(map, end, a[i]) - map;\n\tfor (int i = 0; i < m; i++) if (Q[i].opt != 2) Q[i].k = std::lower_bound(map, end, Q[i].k) - map;\n\tmax = end - map - 1;\n\n\tsegment = SegmentTree::build(1, n, a);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tif (q.opt == 1) {\n\t\t\tprintf(\"%d\\n\", segment->rank(q.l, q.r, q.k));\n\t\t} else if (q.opt == 2) {\n\t\t\tprintf(\"%d\\n\", map[segment->select(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 3) {\n\t\t\tsegment->update(q.pos, a[q.pos - 1], q.k);\n\t\t\ta[q.pos - 1] = q.k;\n\t\t} else if (q.opt == 4) {\n\t\t\tprintf(\"%d\\n\", map[segment->prec(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 5) {\n\t\t\tprintf(\"%d\\n\", map[segment->succ(q.l, q.r, q.k)]);\n\t\t}\n\n#ifdef DBG\n\t\tsegment->validate();\n#endif\n\t}\n\t\n\treturn 0;\n}\n```\n\nMLE\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nint n, m, a[MAXN];\nint map[MAXM + MAXN], max;\n\nstruct WeightSegmentTree {\n\tint l, r, mid;\n\tWeightSegmentTree *lc, *rc;\n\tint min, max, cnt;\n\n\tWeightSegmentTree(const int l, const int r)\n\t\t: l(l), r(r), mid(l + (r - l) / 2),\n\t\t  lc(NULL), rc(NULL),\n\t\t  min(INT_MAX), max(INT_MIN), cnt(0)\n\t{}\n\n\tWeightSegmentTree(const int *a, const int n)\n\t\t: l(0), r(::max - 1), mid((max - 1) / 2),\n\t\t  lc(NULL), rc(NULL),\n\t\t  min(INT_MAX), max(INT_MIN), cnt(0)\n\t{\n\t\tfor (int i = 0; i < n; i++) insert(a[i]);\n\t}\n\n\t~WeightSegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tvoid maintain() {\n\t\tmin = INT_MAX;\n\t\tif (lc) min = std::min(min, lc->min);\n\t\tif (rc) min = std::min(min, rc->min);\n\n\t\tmax = INT_MIN;\n\t\tif (lc) max = std::max(max, lc->max);\n\t\tif (rc) max = std::max(max, rc->max);\n\n\t\tcnt = 0;\n\t\tif (lc) cnt += lc->cnt;\n\t\tif (rc) cnt += rc->cnt;\n\t}\n\n\tvoid insert(const int x) {\n\t\tif (x > r || x < l);\n\t\telse if (x == l && x == r) {\n\t\t\tif (!cnt++) min = max = x;\n\t\t} else {\n\t\t\tif (x <= mid) {\n\t\t\t\tif (!lc) lc = new WeightSegmentTree(l, mid);\n\t\t\t\tlc->insert(x);\n\t\t\t} else {\n\t\t\t\tif (!rc) rc = new WeightSegmentTree(mid + 1, r);\n\t\t\t\trc->insert(x);\n\t\t\t}\n\t\t\tmaintain();\n\t\t}\n\t}\n\n\tvoid erase(const int x) {\n\t\tif (x > r || x < l);\n\t\telse if (x == l && x == r) {\n\t\t\tif (!--cnt) min = INT_MAX, max = INT_MIN;\n\t\t} else {\n\t\t\tif (x <= mid) lc->erase(x);\n\t\t\telse rc->erase(x);\n\t\t\tmaintain();\n\t\t\tif (x <= mid && lc->cnt == 0) delete lc, lc = NULL;\n\t\t\telse if (x > mid && rc->cnt == 0) delete rc, rc = NULL;\n\t\t}\n\t}\n\n\tint prec(const int x) {\n\t\treturn queryMax(0, x - 1);\n\t}\n\n\tint succ(const int x) {\n\t\treturn queryMin(x + 1, ::max);\n\t}\n\n\tint rank(const int x) {\n\t\treturn queryCnt(0, x - 1) + 1;\n\t}\n\n\tint select(const int k) {\n\t\tint x = k;\n\t\tWeightSegmentTree *v = this;\n\t\twhile (v->l != v->r) {\n\t\t\tif (!v->lc) v = v->rc;\n\t\t\telse if (x <= v->lc->cnt) v = v->lc;\n\t\t\telse x -= v->lc->cnt, v = v->rc;\n\t\t}\n\t\treturn v->mid;\n\t}\n\n\tint queryMin(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return min;\n\t\telse {\n\t\t\tint res = INT_MAX;\n\t\t\tif (lc) res = lc->queryMin(l, r);\n\t\t\tif (res == INT_MAX && rc) return rc->queryMin(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint queryMax(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return max;\n\t\telse {\n\t\t\tint res = INT_MIN;\n\t\t\tif (rc) res = rc->queryMax(l, r);\n\t\t\tif (res == INT_MIN && lc) return lc->queryMax(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint queryCnt(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\telse {\n\t\t\tint res = 0;\n\t\t\tif (lc) res += lc->queryCnt(l, r);\n\t\t\tif (rc) res += rc->queryCnt(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n};\n\nstruct SegmentTree {\n\tSegmentTree *lc, *rc;\n\tint l, r;\n\tWeightSegmentTree s;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, int *a) : lc(lc), rc(rc), l(l), r(r), s(a, r - l + 1) {\n#ifdef DBG\n\t\tprintf(\" [%d, %d]\\n\", l, r);\n\t\tvalidate();\n#endif\n\t}\n\n\t~SegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r, int *a) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL, a);\n\t\telse {\n\t\t\tint m = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, m, a), build(m + 1, r, a + (m - l) + 1), a);\n\t\t}\n\t}\n\n\tvoid update(const int pos, const int old, const int curr) {\n\t\tif (pos > this->r || pos < this->l);\n\t\telse if (pos >= this->l && pos <= this->r) {\n\t\t\ts.erase(old);\n\t\t\ts.insert(curr);\n\t\t\tif (pos != this->l || pos != this->r) lc->update(pos, old, curr), rc->update(pos, old, curr);\n\t\t}\n\t}\n\n\tint rank(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return 1;\n\t\telse if (l <= this->l && r >= this->r) return s.rank(k);\n\t\telse return (lc->rank(l, r, k) - 1) + (rc->rank(l, r, k) - 1) + 1;\n\t}\n\n\tint prec(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return s.prec(k);\n\t\telse return std::max(lc->prec(l, r, k), rc->prec(l, r, k));\n\t}\n\n\tint succ(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return s.succ(k);\n\t\telse return std::min(lc->succ(l, r, k), rc->succ(l, r, k));\n\t}\n\n\tint select(const int l, const int r, const int k) {\n\t\tint L = 0, R = max;\n\t\twhile (L + 1 < R) {\n\t\t\tint m = L + (R - L) / 2;\n\t\t\tif (rank(l, r, m) > k) R = m;\n\t\t\telse L = m;\n\t\t}\n\t\tif (rank(l, r, R) == k) return R;\n\t\telse return L;\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tassert(s.r->size == r - l + 1 + 2);\n\t\ts.validate();\n\t\tif (lc) lc->validate();\n\t\tif (rc) rc->validate();\n\t}\n#endif\n} *segment;\n\nstruct Query {\n\tint opt, l, r, pos, k;\n} Q[MAXM];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tscanf(\"%d\", &q.opt);\n\t\tif (q.opt == 3) {\n\t\t\tscanf(\"%d %d\", &q.pos, &q.k);\n\t\t} else {\n\t\t\tscanf(\"%d %d %d\", &q.l, &q.r, &q.k);\n\t\t}\n\n\t\tif (q.opt != 2) {\n\t\t\tmap[cnt++] = q.k;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) map[cnt++] = a[i];\n\n\tstd::sort(map, map + cnt);\n\tint *end = std::unique(map, map + cnt);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(map, end, a[i]) - map;\n\tfor (int i = 0; i < m; i++) if (Q[i].opt != 2) Q[i].k = std::lower_bound(map, end, Q[i].k) - map;\n\tmax = end - map - 1;\n\n\tsegment = SegmentTree::build(1, n, a);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tif (q.opt == 1) {\n\t\t\tprintf(\"%d\\n\", segment->rank(q.l, q.r, q.k));\n\t\t} else if (q.opt == 2) {\n\t\t\tprintf(\"%d\\n\", map[segment->select(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 3) {\n\t\t\tsegment->update(q.pos, a[q.pos - 1], q.k);\n\t\t\ta[q.pos - 1] = q.k;\n\t\t} else if (q.opt == 4) {\n\t\t\tprintf(\"%d\\n\", map[segment->prec(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 5) {\n\t\t\tprintf(\"%d\\n\", map[segment->succ(q.l, q.r, q.k)]);\n\t\t}\n\n#ifdef DBG\n\t\tsegment->validate();\n#endif\n\t}\n\t\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3196.md","raw":"title: BZOJ 3196 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - Splay\n  - \npermalink: bzoj-3196\ndate: 2016-06-19 09:37:00\n---\n\n\n\n1.  $ k $ \n2.  $ k $ \n3. \n4.  $ k $  $ x $\n5.  $ k $  $ x $\n\n<!-- more -->\n\n### \n[BZOJ 3196](http://www.lydsy.com/JudgeOnline/problem.php?id=3196)\n\n### \n\n\n $ O(\\log n) $  $ O(n \\log n) $ $ O(n \\log ^ 2 n) $ \n\n#### \n $ O(\\log n) $ \n\n#### \n\n\n $ x $ $ x $  $ k $ $ x $\n\n\n\n#### \n\n\n#### \n $ O(\\log n) $ \n\n $ O(n \\log ^ 3 n) $ Splay  BZOJ \n\n $ O(n \\log ^ 2 n) $ 512M \n\n![](http://127.0.0.1/lemon.png)\n\n $ O(n \\sqrt n \\log n) $\n\n### \n SplayRP  TLE\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nint n, m, a[MAXN];\n\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *c[2], *p, **r;\n\t\tint size, cnt, val;\n\n\t\tNode(Node *p, const int val, Node **r) : p(p), r(r), size(1), cnt(1), val(val) {\n\t\t\tc[L] = c[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (c[L]) delete c[L];\n\t\t\tif (c[R]) delete c[R];\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tsize = cnt;\n\t\t\tif (c[L]) size += c[L]->size;\n\t\t\tif (c[R]) size += c[R]->size;\n\t\t}\n\n\t\tRelation relatain() const {\n\t\t\treturn this == p->c[L] ? L : R;\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tRelation x = relatain();\n\t\t\tNode *o = p;\n\n\t\t\tp = o->p;\n\t\t\tif (o->p) o->p->c[o->relatain()] = this;\n\n\t\t\to->c[x] = c[x ^ 1];\n\t\t\tif (c[x ^ 1]) c[x ^ 1]->p = o;\n\n\t\t\tc[x ^ 1] = o;\n\t\t\to->p = this;\n\n\t\t\to->maintain(), maintain();\n\n\t\t\tif (!p) *r = this;\n\t\t}\n\n\t\tNode *splay(Node *targetParent = NULL) {\n\t\t\twhile (p != targetParent) {\n\t\t\t\tif (p->p == targetParent) rotate();\n\t\t\t\telse if (p->relatain() == relatain()) p->rotate(), rotate();\n\t\t\t\telse rotate(), rotate();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tNode *prec() {\n\t\t\tsplay();\n\t\t\tNode *v = c[L];\n\t\t\twhile (v->c[R]) v = v->c[R];\n\t\t\treturn v->splay();\n\t\t}\n\n\t\tNode *succ() {\n\t\t\tsplay();\n\t\t\tNode *v = c[R];\n\t\t\twhile (v->c[L]) v = v->c[L];\n\t\t\treturn v->splay();\n\t\t}\n\n\t\tint left() const { return c[L] ? c[L]->size : 0; }\n\n#ifdef DBG\n\t\tvoid validate() {\n\t\t\tint size = 0;\n\t\t\tif (c[L]) c[L]->validate(), assert(this->val > c[L]->val), size += c[L]->size;\n\t\t\tif (c[R]) c[R]->validate(), assert(this->val < c[R]->val), size += c[R]->size;\n\t\t\tassert(this->size == size + cnt);\n\t\t}\n\n\t\tvoid print(const int depth = 0);\n#endif\n\t} *r;\n#ifdef DBG\n\tint id;\n#endif\n\n\tSplay(const int *a, const int n) : r(NULL) {\n\t\tinsert(INT_MAX), insert(INT_MIN);\n#ifdef DBG\n\t\tstatic int time = 0;\n\t\ttime++;\n\t\tid = time;\n\t\tprintf(\"build(%d): \", id);\n\t\tfor (int i = 0; i < n; i++) printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n#endif\n\t\tfor (int i = 0; i < n; i++) insert(a[i]);\n\t}\n\n\t~Splay() { delete r; }\n\n\tNode *find(const int x) {\n\t\tNode *v = r;\n\t\twhile (v && x != v->val) {\n\t\t\tif (x < v->val) v = v->c[L];\n\t\t\telse v = v->c[R];\n\t\t}\n\t\treturn v ? v->splay() : NULL;\n\t}\n\n\tNode *insert(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) {\n\t\t\tv->cnt++, v->size++;\n\t\t\treturn v;\n\t\t}\n\n\t\tNode **target = &r, *p = NULL;\n\t\twhile (*target) {\n\t\t\tp = *target;\n\t\t\tp->size++;\n\t\t\tif (x< p->val) target = &p->c[L];\n\t\t\telse target = &p->c[R];\n\t\t}\n\n\t\treturn (*target = new Node(p, x, &r))->splay();\n\t}\n\n\tint rank(const int x) {\n\t\tNode *v = find(x);\n\t\tint res;\n\t\tif (v) res = v->left();\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tres = v->left();\n\t\t\terase(v);\n\t\t}\n#ifdef DBG\n\t\tprintf(\"rank(%d) in (%d) = %d\\n\", x, id, res);\n#endif\n\t\treturn res;\n\t}\n\n\tNode *select(const int k) {\n\t\tint x = k + 1;\n\t\tNode *v = r;\n\t\twhile (!(x >= v->left() + 1 && x <= v->left() + v->cnt)) {\n\t\t\tif (x < v->left() + 1) v = v->c[L];\n\t\t\telse x -= v->left() + v->cnt, v = v->c[R];\n\t\t}\n\t\treturn v->splay();\n\t}\n\n\tvoid erase(Node *v) {\n\t\tif (v->cnt != 1) {\n\t\t\tv->cnt--, v->size--;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tNode *prec = v->prec(), *succ = v->succ();\n\n\t\tprec->splay();\n\t\tsucc->splay(prec);\n\n\t\tdelete succ->c[L];\n\t\tsucc->c[L] = NULL;\n\n\t\tsucc->maintain(), prec->maintain();\n\t}\n\n\tvoid erase(const int x) {\n\t\tNode *v = find(x);\n\t\terase(v);\n\t}\n\n\tint prec(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) return v->prec()->val;\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tint res = v->prec()->val;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint succ(const int x) {\n\t\tNode *v = find(x);\n\t\tif (v) return v->succ()->val;\n\t\telse {\n\t\t\tv = insert(x);\n\t\t\tint res = v->succ()->val;\n\t\t\terase(v);\n\t\t\treturn res;\n\t\t}\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tr->validate();\n\t}\n#endif\n};\n\n#ifdef DBG\nvoid Splay::Node::print(const int depth) {\n\tif (c[L]) c[L]->print(depth + 1);\n\tfor (int i = 0; i < depth; i++) putchar(' '), putchar(' ');\n\tprintf(\"%d\\n\", val);\n\tif (c[R]) c[R]->print(depth + 1);\n}\n#endif\n\nint map[MAXM + MAXN], max;\n\nstruct SegmentTree {\n\tSegmentTree *lc, *rc;\n\tint l, r;\n\tSplay s;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, int *a) : lc(lc), rc(rc), l(l), r(r), s(a, r - l + 1) {\n#ifdef DBG\n\t\tprintf(\" [%d, %d]\\n\", l, r);\n\t\tvalidate();\n#endif\n\t}\n\n\t~SegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r, int *a) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL, a);\n\t\telse {\n\t\t\tint m = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, m, a), build(m + 1, r, a + (m - l) + 1), a);\n\t\t}\n\t}\n\n\tvoid update(const int pos, const int old, const int curr) {\n\t\tif (pos > this->r || pos < this->l);\n\t\telse if (pos >= this->l && pos <= this->r) {\n\t\t\ts.erase(old);\n\t\t\ts.insert(curr);\n\t\t\tif (pos != this->l || pos != this->r) lc->update(pos, old, curr), rc->update(pos, old, curr);\n\t\t}\n\t}\n\n\tint rank(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return 1;\n\t\telse if (l <= this->l && r >= this->r) return s.rank(k);\n\t\telse return (lc->rank(l, r, k) - 1) + (rc->rank(l, r, k) - 1) + 1;\n\t}\n\n\tint prec(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return s.prec(k);\n\t\telse return std::max(lc->prec(l, r, k), rc->prec(l, r, k));\n\t}\n\n\tint succ(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return s.succ(k);\n\t\telse return std::min(lc->succ(l, r, k), rc->succ(l, r, k));\n\t}\n\n\tint select(const int l, const int r, const int k) {\n\t\tint L = 0, R = max;\n\t\twhile (L + 1 < R) {\n\t\t\tint m = L + (R - L) / 2;\n\t\t\tif (rank(l, r, m) > k) R = m;\n\t\t\telse L = m;\n\t\t}\n\t\tif (rank(l, r, R) == k) return R;\n\t\telse return L;\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tassert(s.r->size == r - l + 1 + 2);\n\t\ts.validate();\n\t\tif (lc) lc->validate();\n\t\tif (rc) rc->validate();\n\t}\n#endif\n} *segment;\n\nstruct Query {\n\tint opt, l, r, pos, k;\n} Q[MAXM];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tscanf(\"%d\", &q.opt);\n\t\tif (q.opt == 3) {\n\t\t\tscanf(\"%d %d\", &q.pos, &q.k);\n\t\t} else {\n\t\t\tscanf(\"%d %d %d\", &q.l, &q.r, &q.k);\n\t\t}\n\n\t\tif (q.opt != 2) {\n\t\t\tmap[cnt++] = q.k;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) map[cnt++] = a[i];\n\n\tstd::sort(map, map + cnt);\n\tint *end = std::unique(map, map + cnt);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(map, end, a[i]) - map;\n\tfor (int i = 0; i < m; i++) if (Q[i].opt != 2) Q[i].k = std::lower_bound(map, end, Q[i].k) - map;\n\tmax = end - map - 1;\n\n\tsegment = SegmentTree::build(1, n, a);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tif (q.opt == 1) {\n\t\t\tprintf(\"%d\\n\", segment->rank(q.l, q.r, q.k));\n\t\t} else if (q.opt == 2) {\n\t\t\tprintf(\"%d\\n\", map[segment->select(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 3) {\n\t\t\tsegment->update(q.pos, a[q.pos - 1], q.k);\n\t\t\ta[q.pos - 1] = q.k;\n\t\t} else if (q.opt == 4) {\n\t\t\tprintf(\"%d\\n\", map[segment->prec(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 5) {\n\t\t\tprintf(\"%d\\n\", map[segment->succ(q.l, q.r, q.k)]);\n\t\t}\n\n#ifdef DBG\n\t\tsegment->validate();\n#endif\n\t}\n\t\n\treturn 0;\n}\n```\n\nMLE\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nint n, m, a[MAXN];\nint map[MAXM + MAXN], max;\n\nstruct WeightSegmentTree {\n\tint l, r, mid;\n\tWeightSegmentTree *lc, *rc;\n\tint min, max, cnt;\n\n\tWeightSegmentTree(const int l, const int r)\n\t\t: l(l), r(r), mid(l + (r - l) / 2),\n\t\t  lc(NULL), rc(NULL),\n\t\t  min(INT_MAX), max(INT_MIN), cnt(0)\n\t{}\n\n\tWeightSegmentTree(const int *a, const int n)\n\t\t: l(0), r(::max - 1), mid((max - 1) / 2),\n\t\t  lc(NULL), rc(NULL),\n\t\t  min(INT_MAX), max(INT_MIN), cnt(0)\n\t{\n\t\tfor (int i = 0; i < n; i++) insert(a[i]);\n\t}\n\n\t~WeightSegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tvoid maintain() {\n\t\tmin = INT_MAX;\n\t\tif (lc) min = std::min(min, lc->min);\n\t\tif (rc) min = std::min(min, rc->min);\n\n\t\tmax = INT_MIN;\n\t\tif (lc) max = std::max(max, lc->max);\n\t\tif (rc) max = std::max(max, rc->max);\n\n\t\tcnt = 0;\n\t\tif (lc) cnt += lc->cnt;\n\t\tif (rc) cnt += rc->cnt;\n\t}\n\n\tvoid insert(const int x) {\n\t\tif (x > r || x < l);\n\t\telse if (x == l && x == r) {\n\t\t\tif (!cnt++) min = max = x;\n\t\t} else {\n\t\t\tif (x <= mid) {\n\t\t\t\tif (!lc) lc = new WeightSegmentTree(l, mid);\n\t\t\t\tlc->insert(x);\n\t\t\t} else {\n\t\t\t\tif (!rc) rc = new WeightSegmentTree(mid + 1, r);\n\t\t\t\trc->insert(x);\n\t\t\t}\n\t\t\tmaintain();\n\t\t}\n\t}\n\n\tvoid erase(const int x) {\n\t\tif (x > r || x < l);\n\t\telse if (x == l && x == r) {\n\t\t\tif (!--cnt) min = INT_MAX, max = INT_MIN;\n\t\t} else {\n\t\t\tif (x <= mid) lc->erase(x);\n\t\t\telse rc->erase(x);\n\t\t\tmaintain();\n\t\t\tif (x <= mid && lc->cnt == 0) delete lc, lc = NULL;\n\t\t\telse if (x > mid && rc->cnt == 0) delete rc, rc = NULL;\n\t\t}\n\t}\n\n\tint prec(const int x) {\n\t\treturn queryMax(0, x - 1);\n\t}\n\n\tint succ(const int x) {\n\t\treturn queryMin(x + 1, ::max);\n\t}\n\n\tint rank(const int x) {\n\t\treturn queryCnt(0, x - 1) + 1;\n\t}\n\n\tint select(const int k) {\n\t\tint x = k;\n\t\tWeightSegmentTree *v = this;\n\t\twhile (v->l != v->r) {\n\t\t\tif (!v->lc) v = v->rc;\n\t\t\telse if (x <= v->lc->cnt) v = v->lc;\n\t\t\telse x -= v->lc->cnt, v = v->rc;\n\t\t}\n\t\treturn v->mid;\n\t}\n\n\tint queryMin(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return min;\n\t\telse {\n\t\t\tint res = INT_MAX;\n\t\t\tif (lc) res = lc->queryMin(l, r);\n\t\t\tif (res == INT_MAX && rc) return rc->queryMin(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint queryMax(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return max;\n\t\telse {\n\t\t\tint res = INT_MIN;\n\t\t\tif (rc) res = rc->queryMax(l, r);\n\t\t\tif (res == INT_MIN && lc) return lc->queryMax(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tint queryCnt(const int l, const int r) {\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return cnt;\n\t\telse {\n\t\t\tint res = 0;\n\t\t\tif (lc) res += lc->queryCnt(l, r);\n\t\t\tif (rc) res += rc->queryCnt(l, r);\n\t\t\treturn res;\n\t\t}\n\t}\n};\n\nstruct SegmentTree {\n\tSegmentTree *lc, *rc;\n\tint l, r;\n\tWeightSegmentTree s;\n\n\tSegmentTree(const int l, const int r, SegmentTree *lc, SegmentTree *rc, int *a) : lc(lc), rc(rc), l(l), r(r), s(a, r - l + 1) {\n#ifdef DBG\n\t\tprintf(\" [%d, %d]\\n\", l, r);\n\t\tvalidate();\n#endif\n\t}\n\n\t~SegmentTree() {\n\t\tif (lc) delete lc;\n\t\tif (rc) delete rc;\n\t}\n\n\tstatic SegmentTree *build(const int l, const int r, int *a) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new SegmentTree(l, r, NULL, NULL, a);\n\t\telse {\n\t\t\tint m = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, m, a), build(m + 1, r, a + (m - l) + 1), a);\n\t\t}\n\t}\n\n\tvoid update(const int pos, const int old, const int curr) {\n\t\tif (pos > this->r || pos < this->l);\n\t\telse if (pos >= this->l && pos <= this->r) {\n\t\t\ts.erase(old);\n\t\t\ts.insert(curr);\n\t\t\tif (pos != this->l || pos != this->r) lc->update(pos, old, curr), rc->update(pos, old, curr);\n\t\t}\n\t}\n\n\tint rank(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return 1;\n\t\telse if (l <= this->l && r >= this->r) return s.rank(k);\n\t\telse return (lc->rank(l, r, k) - 1) + (rc->rank(l, r, k) - 1) + 1;\n\t}\n\n\tint prec(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return s.prec(k);\n\t\telse return std::max(lc->prec(l, r, k), rc->prec(l, r, k));\n\t}\n\n\tint succ(const int l, const int r, const int k) {\n\t\tif (l > this->r || r < this->l) return INT_MAX;\n\t\telse if (l <= this->l && r >= this->r) return s.succ(k);\n\t\telse return std::min(lc->succ(l, r, k), rc->succ(l, r, k));\n\t}\n\n\tint select(const int l, const int r, const int k) {\n\t\tint L = 0, R = max;\n\t\twhile (L + 1 < R) {\n\t\t\tint m = L + (R - L) / 2;\n\t\t\tif (rank(l, r, m) > k) R = m;\n\t\t\telse L = m;\n\t\t}\n\t\tif (rank(l, r, R) == k) return R;\n\t\telse return L;\n\t}\n\n#ifdef DBG\n\tvoid validate() {\n\t\tassert(s.r->size == r - l + 1 + 2);\n\t\ts.validate();\n\t\tif (lc) lc->validate();\n\t\tif (rc) rc->validate();\n\t}\n#endif\n} *segment;\n\nstruct Query {\n\tint opt, l, r, pos, k;\n} Q[MAXM];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tscanf(\"%d\", &q.opt);\n\t\tif (q.opt == 3) {\n\t\t\tscanf(\"%d %d\", &q.pos, &q.k);\n\t\t} else {\n\t\t\tscanf(\"%d %d %d\", &q.l, &q.r, &q.k);\n\t\t}\n\n\t\tif (q.opt != 2) {\n\t\t\tmap[cnt++] = q.k;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) map[cnt++] = a[i];\n\n\tstd::sort(map, map + cnt);\n\tint *end = std::unique(map, map + cnt);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(map, end, a[i]) - map;\n\tfor (int i = 0; i < m; i++) if (Q[i].opt != 2) Q[i].k = std::lower_bound(map, end, Q[i].k) - map;\n\tmax = end - map - 1;\n\n\tsegment = SegmentTree::build(1, n, a);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tif (q.opt == 1) {\n\t\t\tprintf(\"%d\\n\", segment->rank(q.l, q.r, q.k));\n\t\t} else if (q.opt == 2) {\n\t\t\tprintf(\"%d\\n\", map[segment->select(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 3) {\n\t\t\tsegment->update(q.pos, a[q.pos - 1], q.k);\n\t\t\ta[q.pos - 1] = q.k;\n\t\t} else if (q.opt == 4) {\n\t\t\tprintf(\"%d\\n\", map[segment->prec(q.l, q.r, q.k)]);\n\t\t} else if (q.opt == 5) {\n\t\t\tprintf(\"%d\\n\", map[segment->succ(q.l, q.r, q.k)]);\n\t\t}\n\n#ifdef DBG\n\t\tsegment->validate();\n#endif\n\t}\n\t\n\treturn 0;\n}\n```\n","slug":"bzoj-3196","published":1,"updated":"2016-06-19T01:37:23.903Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d2y01fjc2xl3eio6kpp"},{"title":"BZOJ 3156 -  DP","date":"2016-05-19T03:58:00.000Z","_content":"\n $ n $  $ n $  $ 1 $  $ n $ $ i $  $ c(i) $  $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 3156](http://www.lydsy.com/JudgeOnline/problem.php?id=3156)\n\n### \n****\n\n $ f(i) $  $ i $  $ j $ $ j + 1 $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + c(j + 1) + \\frac{(i - j - 1)(i - j)}{2} \\} $$\n\n $ a $$ b $$ a > b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\nf(a) + c(a + 1) + \\frac{(i - a - 1)(i - a)}{2} &< f(b) + c(b + 1) + \\frac{(i - b - 1)(i - b)}{2} \\\\\nf(a) + c(a + 1) + \\frac{i ^ 2}{2} + \\frac{a ^ 2}{2} - ia - \\frac{i}{2} + \\frac{a}{2} &< f(b) + c(b + 1) + \\frac{i ^ 2}{2} + \\frac{b ^ 2}{2} - ib - \\frac{i}{2} + \\frac{b}{2} \\\\\n{ (f(a) + c(a + 1) + \\frac{a ^ 2}{2} + \\frac{a}{2}) - (f(b) + c(b + 1) + \\frac{b ^ 2}{2} + \\frac{b}{2}) \\over a - b } &< i \\\\\n\\end{align*}\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000000;\n\nint n;\nlong long c[MAXN + 1], f[MAXN + 1];\n\ninline void prepare() {\n\tstd::reverse(c + 1, c + n + 1);\n}\n\n/*\ninline void force() {\n\tstd::fill(f, f + n + 1, LLONG_MAX);\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint _j = -1;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (f[i] > f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2) {\n\t\t\t\tf[i] = f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2;\n\t\t\t\t_j = j;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d --> %d\\n\", i, _j);\n\t}\n}\n*/\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline double x(const int i) { return f[i] + c[i + 1] + sqr(static_cast<long long>(i)) * 0.5 + i * 0.5; }\n\ninline double slope(const int a, const int b) {\n\treturn double(x(a) - x(b))\n\t\t / double(a - b);\n}\n\ninline void dp() {\n\tstd::fill(f, f + n + 1, LLONG_MAX);\n\tf[0] = 0;\n\n\tstatic int q[MAXN];\n\tint *l = q, *r = q;\n\t*r = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\twhile (l < r && slope(*(l + 1), *l) < i) l++;\n\n\t\tint &j = *l;\n\t\tf[i] = f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2;\n\t\t// printf(\"%d --> %d\\n\", i, j);\n\n\t\tif (i < n) {\n\t\t\twhile (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n\t\t\t*++r = i;\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", &c[i]);\n\n\tprepare();\n\n\t// force();\n\tdp();\n\tprintf(\"%lld\\n\", f[n]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-3156.md","raw":"title: BZOJ 3156 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - DP\n  - \n  - \npermalink: bzoj-3156\ndate: 2016-05-19 11:58:00\n---\n\n $ n $  $ n $  $ 1 $  $ n $ $ i $  $ c(i) $  $ n $ \n\n<!-- more -->\n\n### \n[BZOJ 3156](http://www.lydsy.com/JudgeOnline/problem.php?id=3156)\n\n### \n****\n\n $ f(i) $  $ i $  $ j $ $ j + 1 $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + c(j + 1) + \\frac{(i - j - 1)(i - j)}{2} \\} $$\n\n $ a $$ b $$ a > b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\nf(a) + c(a + 1) + \\frac{(i - a - 1)(i - a)}{2} &< f(b) + c(b + 1) + \\frac{(i - b - 1)(i - b)}{2} \\\\\nf(a) + c(a + 1) + \\frac{i ^ 2}{2} + \\frac{a ^ 2}{2} - ia - \\frac{i}{2} + \\frac{a}{2} &< f(b) + c(b + 1) + \\frac{i ^ 2}{2} + \\frac{b ^ 2}{2} - ib - \\frac{i}{2} + \\frac{b}{2} \\\\\n{ (f(a) + c(a + 1) + \\frac{a ^ 2}{2} + \\frac{a}{2}) - (f(b) + c(b + 1) + \\frac{b ^ 2}{2} + \\frac{b}{2}) \\over a - b } &< i \\\\\n\\end{align*}\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000000;\n\nint n;\nlong long c[MAXN + 1], f[MAXN + 1];\n\ninline void prepare() {\n\tstd::reverse(c + 1, c + n + 1);\n}\n\n/*\ninline void force() {\n\tstd::fill(f, f + n + 1, LLONG_MAX);\n\tf[0] = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint _j = -1;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (f[i] > f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2) {\n\t\t\t\tf[i] = f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2;\n\t\t\t\t_j = j;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d --> %d\\n\", i, _j);\n\t}\n}\n*/\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline double x(const int i) { return f[i] + c[i + 1] + sqr(static_cast<long long>(i)) * 0.5 + i * 0.5; }\n\ninline double slope(const int a, const int b) {\n\treturn double(x(a) - x(b))\n\t\t / double(a - b);\n}\n\ninline void dp() {\n\tstd::fill(f, f + n + 1, LLONG_MAX);\n\tf[0] = 0;\n\n\tstatic int q[MAXN];\n\tint *l = q, *r = q;\n\t*r = 0;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\twhile (l < r && slope(*(l + 1), *l) < i) l++;\n\n\t\tint &j = *l;\n\t\tf[i] = f[j] + c[j + 1] + (i - j - 1) * (i - j) / 2;\n\t\t// printf(\"%d --> %d\\n\", i, j);\n\n\t\tif (i < n) {\n\t\t\twhile (l < r && slope(*r, *(r - 1)) > slope(i, *r)) r--;\n\t\t\t*++r = i;\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", &c[i]);\n\n\tprepare();\n\n\t// force();\n\tdp();\n\tprintf(\"%lld\\n\", f[n]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-3156","published":1,"updated":"2016-10-24T23:33:42.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d3601frc2xlr32why36"},{"title":"BZOJ 2820YYGCD - ","date":"2016-04-07T14:24:12.000Z","_content":"\n $ 1 \\leq x \\leq N $$ 1 \\leq y \\leq M $  $ \\gcd(x, y) $  $ (x, y) $ \n\n<!-- more -->\n\n### \n[BZOJ 2820](http://www.lydsy.com/JudgeOnline/problem.php?id=2820)\n\n### \n $ N \\leq M $  $ M \\lt N $  $ N $  $ M $ \n\n $ N $  $ p_1, p_2, , p_n $\n\n$$ \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{i = 1} ^ {N} \\sum\\limits_{j = 1} ^ {M} [\\gcd(i, j) = p_k] $$\n\n\n\n$$ \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{i = 1} ^ {N} \\sum\\limits_{j = 1} ^ {M} [\\gcd(i, j) = p_k] = \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{d = 1} ^ {\\lfloor \\frac{N}{p_k} \\rfloor} \\mu(d) \\lfloor \\frac{N}{p_k \\times d} \\rfloor \\lfloor \\frac{M}{p_k \\times d} \\rfloor $$\n\n $ T = p_k \\times d $\t $ T $  $ \\mu $\n\n$$ \\sum\\limits_{T = 1} ^ {N} \\lfloor \\frac{N}{T} \\rfloor \\lfloor \\frac{M}{T} \\rfloor \\sum\\limits_{k \\mid T} \\mu(\\frac{T}{k}) $$\n\n\n\n$$ f(T) = \\sum\\limits_{k \\mid T} \\mu(\\frac{T}{k}) $$\n\n$$ T = p_1 ^ {x_1} \\times p_2 ^ {x_2} \\times  p_n ^ {x_n} $$\n\n$$ T' = p_1 ^ {x_1 - 1} \\times p_2 ^ {x_2} \\times  p_n ^ {x_n} $$\n\n $ \\mu $  $ T' \\ {\\rm mod} \\ p_1 = 0 $ \n\n$$\n\\begin{align}\nf(T') &= \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i}) \\\\\nf(T) &= \\sum\\limits_{i = 1} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(\\frac{T}{p_i}) + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i} \\times p_1) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i}) \\times \\mu(p_1) \\\\\n\\mu(p_i) &= 1 \\\\\nf(T) &= \\mu(T') - f(T')\n\\end{align}\n$$\n\n $ x_1 \\gt 1 $ \n\n$$\n\\begin{align}\n\\mu(p_1 ^ {x_1}) &= 0 \\\\\nf(T) &= \\sum\\limits_{i = 1} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(\\frac{T}{p_1}) + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i \\times p_1 ^ {x_1}} \\times p_1 ^ {x_1}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i \\times p_1 ^ {x_1}}) \\times \\mu(p_1 ^ {x_1}) \\\\\n&= \\mu(T')\n\\end{align}\n$$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nconst int MAXT = 10000;\nconst int MAXN = 10000000;\nconst int MAXM = 10000000;\n\nbool isNotPrime[MAXN + 1];\nint miu[MAXN + 1], f[MAXN + 1], s[MAXN + 1];\nstd::vector<int> primes;\ninline void getPrimes() {\n\tprimes.reserve(MAXN);\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes.push_back(i);\n\t\t\tmiu[i] = -1;\n\t\t\tf[i] = 1;\n\t\t}\n\t\tfor (std::vector<int>::const_iterator p = primes.begin(); p != primes.end() && i * *p <= MAXN; p++) {\n\t\t\tisNotPrime[i * *p] = true;\n\t\t\tif (i % *p == 0) {\n\t\t\t\tmiu[i * *p] = 0;\n\t\t\t\tf[i * *p] = miu[i];\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmiu[i * *p] = -miu[i];\n\t\t\t\tf[i * *p] = miu[i] - f[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= MAXN; i++) s[i] = s[i - 1] + f[i];\n}\n\ninline long long solve(const int n, const int m) {\n\tlong long ans = 0;\n\tfor (int l = 1, r; l <= n; l = r + 1) {\n\t\tr = std::min(n / (n / l), m / (m / l));\n\t\tans += (s[r] - s[l - 1]) * static_cast<long long>(n / l) * static_cast<long long>(m / l);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tgetPrimes();\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif (n > m) std::swap(n, m);\n\t\tprintf(\"%lld\\n\", solve(n, m));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2820.md","raw":"title: BZOJ 2820YYGCD - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - \n  - \npermalink: bzoj-2820\ndate: 2016-04-07 22:24:12\n---\n\n $ 1 \\leq x \\leq N $$ 1 \\leq y \\leq M $  $ \\gcd(x, y) $  $ (x, y) $ \n\n<!-- more -->\n\n### \n[BZOJ 2820](http://www.lydsy.com/JudgeOnline/problem.php?id=2820)\n\n### \n $ N \\leq M $  $ M \\lt N $  $ N $  $ M $ \n\n $ N $  $ p_1, p_2, , p_n $\n\n$$ \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{i = 1} ^ {N} \\sum\\limits_{j = 1} ^ {M} [\\gcd(i, j) = p_k] $$\n\n\n\n$$ \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{i = 1} ^ {N} \\sum\\limits_{j = 1} ^ {M} [\\gcd(i, j) = p_k] = \\sum\\limits_{k = 1} ^ {n} \\sum\\limits_{d = 1} ^ {\\lfloor \\frac{N}{p_k} \\rfloor} \\mu(d) \\lfloor \\frac{N}{p_k \\times d} \\rfloor \\lfloor \\frac{M}{p_k \\times d} \\rfloor $$\n\n $ T = p_k \\times d $\t $ T $  $ \\mu $\n\n$$ \\sum\\limits_{T = 1} ^ {N} \\lfloor \\frac{N}{T} \\rfloor \\lfloor \\frac{M}{T} \\rfloor \\sum\\limits_{k \\mid T} \\mu(\\frac{T}{k}) $$\n\n\n\n$$ f(T) = \\sum\\limits_{k \\mid T} \\mu(\\frac{T}{k}) $$\n\n$$ T = p_1 ^ {x_1} \\times p_2 ^ {x_2} \\times  p_n ^ {x_n} $$\n\n$$ T' = p_1 ^ {x_1 - 1} \\times p_2 ^ {x_2} \\times  p_n ^ {x_n} $$\n\n $ \\mu $  $ T' \\ {\\rm mod} \\ p_1 = 0 $ \n\n$$\n\\begin{align}\nf(T') &= \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i}) \\\\\nf(T) &= \\sum\\limits_{i = 1} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(\\frac{T}{p_i}) + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i} \\times p_1) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T'}{p_i}) \\times \\mu(p_1) \\\\\n\\mu(p_i) &= 1 \\\\\nf(T) &= \\mu(T') - f(T')\n\\end{align}\n$$\n\n $ x_1 \\gt 1 $ \n\n$$\n\\begin{align}\n\\mu(p_1 ^ {x_1}) &= 0 \\\\\nf(T) &= \\sum\\limits_{i = 1} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(\\frac{T}{p_1}) + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i \\times p_1 ^ {x_1}} \\times p_1 ^ {x_1}) \\\\\n&= \\mu(T') + \\sum\\limits_{i = 2} ^ {k} \\mu(\\frac{T}{p_i \\times p_1 ^ {x_1}}) \\times \\mu(p_1 ^ {x_1}) \\\\\n&= \\mu(T')\n\\end{align}\n$$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nconst int MAXT = 10000;\nconst int MAXN = 10000000;\nconst int MAXM = 10000000;\n\nbool isNotPrime[MAXN + 1];\nint miu[MAXN + 1], f[MAXN + 1], s[MAXN + 1];\nstd::vector<int> primes;\ninline void getPrimes() {\n\tprimes.reserve(MAXN);\n\tisNotPrime[0] = isNotPrime[1] = true;\n\tfor (int i = 2; i <= MAXN; i++) {\n\t\tif (!isNotPrime[i]) {\n\t\t\tprimes.push_back(i);\n\t\t\tmiu[i] = -1;\n\t\t\tf[i] = 1;\n\t\t}\n\t\tfor (std::vector<int>::const_iterator p = primes.begin(); p != primes.end() && i * *p <= MAXN; p++) {\n\t\t\tisNotPrime[i * *p] = true;\n\t\t\tif (i % *p == 0) {\n\t\t\t\tmiu[i * *p] = 0;\n\t\t\t\tf[i * *p] = miu[i];\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmiu[i * *p] = -miu[i];\n\t\t\t\tf[i * *p] = miu[i] - f[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= MAXN; i++) s[i] = s[i - 1] + f[i];\n}\n\ninline long long solve(const int n, const int m) {\n\tlong long ans = 0;\n\tfor (int l = 1, r; l <= n; l = r + 1) {\n\t\tr = std::min(n / (n / l), m / (m / l));\n\t\tans += (s[r] - s[l - 1]) * static_cast<long long>(n / l) * static_cast<long long>(m / l);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tgetPrimes();\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tint n, m;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tif (n > m) std::swap(n, m);\n\t\tprintf(\"%lld\\n\", solve(n, m));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2820","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d3i01fxc2xlf210bu7p"},{"title":"BZOJ 2716 - CDQ","date":"2016-06-25T03:08:00.000Z","_content":"\n\n\n1.  $ (x,\\ y) $\n2. **** $ (x,\\ y) $ \n\n<!-- more -->\n\n### \n[BZOJ 2716](http://www.lydsy.com/JudgeOnline/problem.php?id=2716)\n\n### \n $ (x_1,\\ y_1) $$ (x_2,\\ y_2) $  $ | x_1 - x_2 | + | y_1 - y_2 | $\n\n $ (x_1,\\ y_1) $  $ (x_2,\\ y_2) $ \n\n$$\n\\begin{aligned}\n & | x_1 - x_2 | + | y_1 - y_2 | \\\\\n=& ( x_1 - x_2 ) + ( y_1 - y_2 ) \\\\\n=& ( x_1 + y_1 ) - (x_2 + y_2)\n\\end{aligned}\n$$\n\n $ (x_2 + y_2) $  CDQ  CDQ \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\nconst int MAXX = 1000000;\n\nstruct Triple {\n\tint id, x, y, *ans;\n\n\tTriple() {}\n\n\tTriple(const int x, const int y, int *ans = NULL) : x(x), y(y), ans(ans) {\n\t\tstatic int i = 0;\n\t\tid = i++;\n\t}\n} a[MAXN + MAXM];\n\nbool operator<(const Triple &a, const Triple &b) {\n\treturn a.id < b.id;\n}\n\nint maxX, maxY;\n\nstruct BinaryIndexedTree {\n\tint a[MAXX + 2];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans = std::max(ans, a[i - 1]);\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int v) {\n\t\tfor (int i = x; i <= maxY; i += lowbit(i)) a[i - 1] = std::max(a[i - 1], v);\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= maxY; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN + MAXM];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = mid + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= mid && p1->x <= p2->x) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tif (!q->ans) bit.update(q->y, q->x + q->y);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\tif (q->ans) {\n\t\t\t\tint res = bit.query(q->y);\n\t\t\t\tif (res) *q->ans = std::min(*q->ans, q->x + q->y - res);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; p++, q++) {\n\t\t*p = *q;\n\t\tbit.clear(p->y);\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\\n\", &x, &y), x += 2, y += 2;\n\t\ta[cnt++] = Triple(x, y);\n\n\t\tmaxX = std::max(maxX, x);\n\t\tmaxY = std::max(maxY, y);\n\t}\n\n\tstatic int ans[MAXM];\n\tint qCnt = 0;\n\tfor (int j = 0; j < m; j++) {\n\t\tint t, x, y;\n\t\tscanf(\"%d %d %d\", &t, &x, &y), x += 2, y += 2;\n\t\tif (t == 1) {\n\t\t\ta[cnt++] = Triple(x, y);\n\t\t} else {\n\t\t\ta[cnt++] = Triple(x, y, &ans[qCnt++]);\n\t\t}\n\n\t\tmaxX = std::max(maxX, x);\n\t\tmaxY = std::max(maxY, y);\n\t}\n\n\tfor (int i = 0; i < qCnt; i++) ans[i] = INT_MAX;\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].x = maxX - a[i].x + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].y = maxY - a[i].y + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].x = maxX - a[i].x + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < qCnt; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2716.md","raw":"title: BZOJ 2716 - CDQ\ncategories: OI\ntags: \n  - BZOJ\n  - \n  - CDQ\n  - \n  - \npermalink: bzoj-2716\ndate: 2016-06-25 11:08:00\n---\n\n\n\n1.  $ (x,\\ y) $\n2. **** $ (x,\\ y) $ \n\n<!-- more -->\n\n### \n[BZOJ 2716](http://www.lydsy.com/JudgeOnline/problem.php?id=2716)\n\n### \n $ (x_1,\\ y_1) $$ (x_2,\\ y_2) $  $ | x_1 - x_2 | + | y_1 - y_2 | $\n\n $ (x_1,\\ y_1) $  $ (x_2,\\ y_2) $ \n\n$$\n\\begin{aligned}\n & | x_1 - x_2 | + | y_1 - y_2 | \\\\\n=& ( x_1 - x_2 ) + ( y_1 - y_2 ) \\\\\n=& ( x_1 + y_1 ) - (x_2 + y_2)\n\\end{aligned}\n$$\n\n $ (x_2 + y_2) $  CDQ  CDQ \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\nconst int MAXX = 1000000;\n\nstruct Triple {\n\tint id, x, y, *ans;\n\n\tTriple() {}\n\n\tTriple(const int x, const int y, int *ans = NULL) : x(x), y(y), ans(ans) {\n\t\tstatic int i = 0;\n\t\tid = i++;\n\t}\n} a[MAXN + MAXM];\n\nbool operator<(const Triple &a, const Triple &b) {\n\treturn a.id < b.id;\n}\n\nint maxX, maxY;\n\nstruct BinaryIndexedTree {\n\tint a[MAXX + 2];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans = std::max(ans, a[i - 1]);\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int v) {\n\t\tfor (int i = x; i <= maxY; i += lowbit(i)) a[i - 1] = std::max(a[i - 1], v);\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= maxY; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXN + MAXM];\n\tfor (Triple *q = tmp, *p1 = l, *p2 = mid + 1; q <= tmp + (r - l); q++) {\n\t\tif ((p1 <= mid && p1->x <= p2->x) || p2 > r) {\n\t\t\t*q = *p1++;\n\t\t\tif (!q->ans) bit.update(q->y, q->x + q->y);\n\t\t} else {\n\t\t\t*q = *p2++;\n\t\t\tif (q->ans) {\n\t\t\t\tint res = bit.query(q->y);\n\t\t\t\tif (res) *q->ans = std::min(*q->ans, q->x + q->y - res);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (Triple *q = tmp, *p = l; p <= r; p++, q++) {\n\t\t*p = *q;\n\t\tbit.clear(p->y);\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\\n\", &x, &y), x += 2, y += 2;\n\t\ta[cnt++] = Triple(x, y);\n\n\t\tmaxX = std::max(maxX, x);\n\t\tmaxY = std::max(maxY, y);\n\t}\n\n\tstatic int ans[MAXM];\n\tint qCnt = 0;\n\tfor (int j = 0; j < m; j++) {\n\t\tint t, x, y;\n\t\tscanf(\"%d %d %d\", &t, &x, &y), x += 2, y += 2;\n\t\tif (t == 1) {\n\t\t\ta[cnt++] = Triple(x, y);\n\t\t} else {\n\t\t\ta[cnt++] = Triple(x, y, &ans[qCnt++]);\n\t\t}\n\n\t\tmaxX = std::max(maxX, x);\n\t\tmaxY = std::max(maxY, y);\n\t}\n\n\tfor (int i = 0; i < qCnt; i++) ans[i] = INT_MAX;\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].x = maxX - a[i].x + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].y = maxY - a[i].y + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < cnt; i++) a[i].x = maxX - a[i].x + 1;\n\tstd::sort(a, a + cnt);\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < qCnt; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2716","published":1,"updated":"2016-06-25T03:08:50.905Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d3r01g4c2xl6g233gn3"},{"title":"BZOJ 2683 - CDQ","id":"43","updated":"2016-02-05T14:46:27.000Z","date":"2016-02-05T14:42:35.000Z","_content":"\n$N*N$ 0\n\n1. $(x,y)$$A$\n2. $(x1,y1)(x2,y2)$\n\n<!-- more -->\n\n### \n[BZOJ 2683](http://www.lydsy.com/JudgeOnline/problem.php?id=2683)\n\n### \n [BZOJ 1176](bzoj-1176)\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 200000 * 4;\n\nenum OperateType {\n\tUpdate = 1, Query = 2\n};\n\nstruct Operate {\n\tOperateType type;\n\tint id, x, y, *ans, num;\n\n\tOperate(OperateType type, int id, int x, int y, int num, int *ans = NULL) : type(type), id(id), x(x), y(y), ans(ans), num(num) {}\n\tOperate() {}\n\n\tbool operator<(const Operate &other) const {\n\t\tif (x < other.x) return true;\n\t\telse if (x == other.x && y < other.y) return true;\n\t\telse if (x == other.x && y == other.y && id < other.id) return true;\n\t\treturn false;\n\t}\n};\n\nstd::vector<Operate> v;\nint n, ans[MAXM];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & (-x);\n\t}\n\n\tvoid update(int pos, int x) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) {\n\t\t\ta[i - 1] += x;\n\t\t}\n\t}\n\n\tint query(int pos) {\n\t\tint ans = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) {\n\t\t\tans += a[i - 1];\n\t\t}\n\n\t\treturn ans;\n\t}\n} bit;\n\nvoid cdq(int l, int r) {\n\tif (l >= r) return;\n\n\tint mid = l + ((r - l) >> 1);\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, o.num);\n\t\telse if (o.id > mid && o.type == Query) *o.ans += bit.query(o.y) * o.num;\n\t}\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, -o.num);\n\t}\n\n\tstatic Operate a[MAXM];\n\tint L = l, R = mid + 1;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (v[i - 1].id <= mid) a[L++ - 1] = v[i - 1];\n\t\telse a[R++ - 1] = v[i - 1];\n\t}\n\tmemcpy(&v[l - 1], &a[l - 1], sizeof(Operate) * (r - l + 1));\n\n\tcdq(l, mid), cdq(mid + 1, r);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tint m = 0, queryCount = 0;\n\twhile (20000528) {\n\t\tint type;\n\t\tscanf(\"%d\", &type);\n\n\t\tif (type == 1) {\n\t\t\tint x, y, num;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &num);\n\t\t\tv.push_back(Operate(Update, ++m, x, y, num));\n\t\t} else if (type == 2) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y1 - 1, 1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y2, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y1 - 1, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y2, 1, &ans[queryCount]));\n\t\t\tqueryCount++;\n\t\t} else break;\n\t}\n\n\tstd::sort(v.begin(), v.end());\n\tcdq(1, m);\n\n\tfor (int i = 0; i < queryCount; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2683.md","raw":"title: BZOJ 2683 - CDQ\ncategories: OI\ntags: \n  - BZOJ\n  - CDQ\n  - \n  - \n  - \npermalink: bzoj-2683\nid: 43\nupdated: '2016-02-05 22:46:27'\ndate: 2016-02-05 22:42:35\n---\n\n$N*N$ 0\n\n1. $(x,y)$$A$\n2. $(x1,y1)(x2,y2)$\n\n<!-- more -->\n\n### \n[BZOJ 2683](http://www.lydsy.com/JudgeOnline/problem.php?id=2683)\n\n### \n [BZOJ 1176](bzoj-1176)\n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 200000 * 4;\n\nenum OperateType {\n\tUpdate = 1, Query = 2\n};\n\nstruct Operate {\n\tOperateType type;\n\tint id, x, y, *ans, num;\n\n\tOperate(OperateType type, int id, int x, int y, int num, int *ans = NULL) : type(type), id(id), x(x), y(y), ans(ans), num(num) {}\n\tOperate() {}\n\n\tbool operator<(const Operate &other) const {\n\t\tif (x < other.x) return true;\n\t\telse if (x == other.x && y < other.y) return true;\n\t\telse if (x == other.x && y == other.y && id < other.id) return true;\n\t\treturn false;\n\t}\n};\n\nstd::vector<Operate> v;\nint n, ans[MAXM];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & (-x);\n\t}\n\n\tvoid update(int pos, int x) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) {\n\t\t\ta[i - 1] += x;\n\t\t}\n\t}\n\n\tint query(int pos) {\n\t\tint ans = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) {\n\t\t\tans += a[i - 1];\n\t\t}\n\n\t\treturn ans;\n\t}\n} bit;\n\nvoid cdq(int l, int r) {\n\tif (l >= r) return;\n\n\tint mid = l + ((r - l) >> 1);\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, o.num);\n\t\telse if (o.id > mid && o.type == Query) *o.ans += bit.query(o.y) * o.num;\n\t}\n\n\tfor (int i = l; i <= r; i++) {\n\t\tconst Operate &o = v[i - 1];\n\t\tif (o.id <= mid && o.type == Update) bit.update(o.y, -o.num);\n\t}\n\n\tstatic Operate a[MAXM];\n\tint L = l, R = mid + 1;\n\tfor (int i = l; i <= r; i++) {\n\t\tif (v[i - 1].id <= mid) a[L++ - 1] = v[i - 1];\n\t\telse a[R++ - 1] = v[i - 1];\n\t}\n\tmemcpy(&v[l - 1], &a[l - 1], sizeof(Operate) * (r - l + 1));\n\n\tcdq(l, mid), cdq(mid + 1, r);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tint m = 0, queryCount = 0;\n\twhile (20000528) {\n\t\tint type;\n\t\tscanf(\"%d\", &type);\n\n\t\tif (type == 1) {\n\t\t\tint x, y, num;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &num);\n\t\t\tv.push_back(Operate(Update, ++m, x, y, num));\n\t\t} else if (type == 2) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y1 - 1, 1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x1 - 1, y2, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y1 - 1, -1, &ans[queryCount]));\n\t\t\tv.push_back(Operate(Query, ++m, x2, y2, 1, &ans[queryCount]));\n\t\t\tqueryCount++;\n\t\t} else break;\n\t}\n\n\tstd::sort(v.begin(), v.end());\n\tcdq(1, m);\n\n\tfor (int i = 0; i < queryCount; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2683","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d3y01gbc2xlf2gf6nh1"},{"title":"BZOJ 2580Video Game - AC ","date":"2016-09-17T23:16:00.000Z","_content":"\n $ n $  $ s_i $ $ k $  $ S $ $ S $  $ s_i $\n\n<!-- more -->\n\n### \n[BZOJ 2580](http://www.lydsy.com/JudgeOnline/problem.php?id=2580)\n\n### \n $ f(i, j) $  $ k - i $  AC  $ j $  $ i $ \n\n $ + $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 15;\nconst int MAXM = 20;\nconst int MAXK = 1000;\nconst int CHARSET_SIZE = 26;\nconst int BASE_CHAR = 'A';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint wordCnt, id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build(std::vector<Node *> &vec) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tv->id = vec.size();\n#ifdef DBG\n\t\t\tprintf(\"wordCnt(%d) = %d\\n\", v->id, v->wordCnt);\n#endif\n\t\t\tvec.push_back(v);\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tc->wordCnt = c->isWord + (c->next ? c->next->wordCnt : 0);\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nint main() {\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\twhile (n--) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tstd::vector<Trie::Node *> vec;\n\tt.build(vec);\n\n\tstatic int f[MAXN * MAXM + 1][MAXK + 1];\n#ifdef DBG\n\tstatic char g[MAXN * MAXM + 1][MAXK + 1];\n#endif\n\t// for (size_t i = 0; i < vec.size(); i++) f[i][0] = vec[i]->wordCnt;\n\n\tfor (int i = 1; i <= k; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) {\n\t\t\tfor (int k = 0; k < CHARSET_SIZE; k++) {\n\t\t\t\tint t = f[vec[j]->c[k]->id][i - 1] + vec[j]->c[k]->wordCnt;\n\t\t\t\tif (t >= f[j][i]) {\n\t\t\t\t\tf[j][i] = t;\n#ifdef DBG\n\t\t\t\t\tg[j][i] = k;\n#endif\n\t\t\t\t}\n\t\t\t}\n#ifdef DBG\n\t\t\tprintf(\"f(%lu, %d) = %d\\n\", j, i, f[j][i]);\n#endif\n\t\t}\n\t}\n\n#ifdef DBG\n\tint last = 0;\n\tfor (int i = k; i >= 1; i--) {\n\t\tputchar(g[last][i] + 'A');\n\t\tlast = vec[last]->c[g[last][i]]->id;\n\t}\n\tputchar('\\n');\n\n\tlast = 0;\n\tfor (int i = k; i >= 1; i--) {\n\t\tprintf(\"%d%c\", last, i == 1 ? '\\n' : ' ');\n\t\tlast = vec[last]->c[g[last][i]]->id;\n\t}\n#endif\n\n\tprintf(\"%d\\n\", f[0][k]);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-2580.md","raw":"title: BZOJ 2580Video Game - AC \ncategories: OI\ntags: \n  - BZOJ\n  - USACO\n  - \n  - AC \n  - DP\npermalink: bzoj-2580\ndate: 2016-09-18 07:16:00\n---\n\n $ n $  $ s_i $ $ k $  $ S $ $ S $  $ s_i $\n\n<!-- more -->\n\n### \n[BZOJ 2580](http://www.lydsy.com/JudgeOnline/problem.php?id=2580)\n\n### \n $ f(i, j) $  $ k - i $  AC  $ j $  $ i $ \n\n $ + $ \n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 15;\nconst int MAXM = 20;\nconst int MAXK = 1000;\nconst int CHARSET_SIZE = 26;\nconst int BASE_CHAR = 'A';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint wordCnt, id;\n\n\t\tNode(const bool isWord = false) : fail(NULL), next(NULL), isWord(isWord) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tvoid insert(const char *begin, const char *end) {\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t}\n\n\tvoid build(std::vector<Node *> &vec) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tv->id = vec.size();\n#ifdef DBG\n\t\t\tprintf(\"wordCnt(%d) = %d\\n\", v->id, v->wordCnt);\n#endif\n\t\t\tvec.push_back(v);\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) {\n\t\t\t\t\tc = v->fail->c[i] ? v->fail->c[i] : root;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tc->wordCnt = c->isWord + (c->next ? c->next->wordCnt : 0);\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n} t;\n\nint main() {\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\twhile (n--) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tconst int len = strlen(s);\n\t\tfor (int i = 0; i < len; i++) s[i] -= BASE_CHAR;\n\t\tt.insert(s, s + len);\n\t}\n\n\tstd::vector<Trie::Node *> vec;\n\tt.build(vec);\n\n\tstatic int f[MAXN * MAXM + 1][MAXK + 1];\n#ifdef DBG\n\tstatic char g[MAXN * MAXM + 1][MAXK + 1];\n#endif\n\t// for (size_t i = 0; i < vec.size(); i++) f[i][0] = vec[i]->wordCnt;\n\n\tfor (int i = 1; i <= k; i++) {\n\t\tfor (size_t j = 0; j < vec.size(); j++) {\n\t\t\tfor (int k = 0; k < CHARSET_SIZE; k++) {\n\t\t\t\tint t = f[vec[j]->c[k]->id][i - 1] + vec[j]->c[k]->wordCnt;\n\t\t\t\tif (t >= f[j][i]) {\n\t\t\t\t\tf[j][i] = t;\n#ifdef DBG\n\t\t\t\t\tg[j][i] = k;\n#endif\n\t\t\t\t}\n\t\t\t}\n#ifdef DBG\n\t\t\tprintf(\"f(%lu, %d) = %d\\n\", j, i, f[j][i]);\n#endif\n\t\t}\n\t}\n\n#ifdef DBG\n\tint last = 0;\n\tfor (int i = k; i >= 1; i--) {\n\t\tputchar(g[last][i] + 'A');\n\t\tlast = vec[last]->c[g[last][i]]->id;\n\t}\n\tputchar('\\n');\n\n\tlast = 0;\n\tfor (int i = k; i >= 1; i--) {\n\t\tprintf(\"%d%c\", last, i == 1 ? '\\n' : ' ');\n\t\tlast = vec[last]->c[g[last][i]]->id;\n\t}\n#endif\n\n\tprintf(\"%d\\n\", f[0][k]);\n\n\treturn 0;\n}\n```","slug":"bzoj-2580","published":1,"updated":"2016-09-17T23:25:45.766Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d4801gic2xlg10r6hhy"},{"title":"BeiJing2011 - AC ","date":"2016-09-13T23:32:00.000Z","_content":"\n $ M $  $ N $  01  $ Q $  $ A $  $ B $  01  $ Q $  \n\n<!-- more -->\n\n### \n[BZOJ 2462](http://www.lydsy.com/JudgeOnline/problem.php?id=2462)\n\n### \n AC  $ i $  $ j $  $ k $  $ (i - k, j - b + 1) $  $ 1 $ \n\n $ \\geq b $\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 1000;\nconst int CHARSET_SIZE = '1' - '0' + 1;\nconst int BASE_CHAR = '0';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint id;\n\n\t\tNode(const bool isWord = false, const int id = -1) : fail(NULL), next(NULL), isWord(isWord), id(id) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply(std::vector< std::pair<int, int> > &vec, const int pos) {\n\t\t\tassert(isWord);\n\t\t\tvec.push_back(std::make_pair(pos, id));\n\t\t\tif (next) next->apply(vec, pos);\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\ttemplate <typename T>\n\tvoid insert(const T *begin, const T *end, const int id) {\n\t\tNode **v = &root;\n\t\tfor (const T *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true, id);\n\t\telse (*v)->id = id, (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root;\n\t\troot->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const bool *begin, const bool *end, std::vector< std::pair<int, int> > &vec) {\n\t\tNode *v = root;\n\t\tfor (const bool *p = begin; p != end; p++) {\n\t\t\twhile (v != root && !v->c[*p]) v = v->fail;\n\t\t\tv = v->c[*p] ? v->c[*p] : root;\n\t\t\tif (v->isWord) v->apply(vec, p - begin);\n\t\t\telse if (v->next) v->next->apply(vec, p - begin);\n\t\t}\n\t}\n\n\tvoid clear() {\n\t\troot = NULL;\n\t}\n} t;\n\nint main() {\n\tint n, m, a, b;\n\tscanf(\"%d %d %d %d\", &n, &m, &a, &b);\n\n\tstatic bool matrix[MAXN][MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tfor (int j = 0; j < m; j++) matrix[i][j] = s[j] - BASE_CHAR;\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--) {\n\t\tt.clear();\n\t\tfor (int i = 0; i < a; i++) {\n\t\t\tstatic char s[MAXN + 1];\n\t\t\tscanf(\"%s\", s);\n\t\t\tfor (int j = 0; j < b; j++) s[j] -= BASE_CHAR;\n\t\t\tt.insert(s, s + b, i);\n\t\t}\n\n\t\tt.build();\n\n\t\tstatic int matchCnt[MAXN][MAXN];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstd::vector< std::pair<int, int> > vec;\n\t\t\tt.exec(matrix[i], matrix[i] + m, vec);\n\t\t\tfor (std::vector< std::pair<int, int> >::const_iterator it = vec.begin(); it != vec.end(); it++) {\n \t\t\t\t// printf(\"%d matched %d\\n\", i, *it);\n\t\t\t\tif (i - it->second >= 0) matchCnt[i - it->second][it->first - b + 1]++;\n\t\t\t}\n\t\t}\n\n\t\tbool flag = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t// printf(\"match(%d) = %d\\n\", i, matchCnt[i]);\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (matchCnt[i][j] >= b) flag = true;\n\t\t\t\tmatchCnt[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tputs(flag ? \"1\" : \"0\");\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-2462.md","raw":"title: BeiJing2011 - AC \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - AC \npermalink: bzoj-2462\ndate: 2016-09-14 07:32:00\n---\n\n $ M $  $ N $  01  $ Q $  $ A $  $ B $  01  $ Q $  \n\n<!-- more -->\n\n### \n[BZOJ 2462](http://www.lydsy.com/JudgeOnline/problem.php?id=2462)\n\n### \n AC  $ i $  $ j $  $ k $  $ (i - k, j - b + 1) $  $ 1 $ \n\n $ \\geq b $\n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 1000;\nconst int CHARSET_SIZE = '1' - '0' + 1;\nconst int BASE_CHAR = '0';\n\nstruct Trie {\n\tstruct Node {\n\t\tNode *c[CHARSET_SIZE], *fail, *next;\n\t\tbool isWord;\n\t\tint id;\n\n\t\tNode(const bool isWord = false, const int id = -1) : fail(NULL), next(NULL), isWord(isWord), id(id) {\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply(std::vector< std::pair<int, int> > &vec, const int pos) {\n\t\t\tassert(isWord);\n\t\t\tvec.push_back(std::make_pair(pos, id));\n\t\t\tif (next) next->apply(vec, pos);\n\t\t}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\ttemplate <typename T>\n\tvoid insert(const T *begin, const T *end, const int id) {\n\t\tNode **v = &root;\n\t\tfor (const T *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node();\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true, id);\n\t\telse (*v)->id = id, (*v)->isWord = true;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root;\n\t\troot->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) {\n\t\t\t\tNode *&c = v->c[i];\n\t\t\t\tif (!c) continue;\n\t\t\t\tNode *u = v->fail;\n\t\t\t\twhile (u != root && !u->c[i]) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const bool *begin, const bool *end, std::vector< std::pair<int, int> > &vec) {\n\t\tNode *v = root;\n\t\tfor (const bool *p = begin; p != end; p++) {\n\t\t\twhile (v != root && !v->c[*p]) v = v->fail;\n\t\t\tv = v->c[*p] ? v->c[*p] : root;\n\t\t\tif (v->isWord) v->apply(vec, p - begin);\n\t\t\telse if (v->next) v->next->apply(vec, p - begin);\n\t\t}\n\t}\n\n\tvoid clear() {\n\t\troot = NULL;\n\t}\n} t;\n\nint main() {\n\tint n, m, a, b;\n\tscanf(\"%d %d %d %d\", &n, &m, &a, &b);\n\n\tstatic bool matrix[MAXN][MAXN];\n\tfor (int i = 0; i < n; i++) {\n\t\tstatic char s[MAXN + 1];\n\t\tscanf(\"%s\", s);\n\t\tfor (int j = 0; j < m; j++) matrix[i][j] = s[j] - BASE_CHAR;\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--) {\n\t\tt.clear();\n\t\tfor (int i = 0; i < a; i++) {\n\t\t\tstatic char s[MAXN + 1];\n\t\t\tscanf(\"%s\", s);\n\t\t\tfor (int j = 0; j < b; j++) s[j] -= BASE_CHAR;\n\t\t\tt.insert(s, s + b, i);\n\t\t}\n\n\t\tt.build();\n\n\t\tstatic int matchCnt[MAXN][MAXN];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstd::vector< std::pair<int, int> > vec;\n\t\t\tt.exec(matrix[i], matrix[i] + m, vec);\n\t\t\tfor (std::vector< std::pair<int, int> >::const_iterator it = vec.begin(); it != vec.end(); it++) {\n \t\t\t\t// printf(\"%d matched %d\\n\", i, *it);\n\t\t\t\tif (i - it->second >= 0) matchCnt[i - it->second][it->first - b + 1]++;\n\t\t\t}\n\t\t}\n\n\t\tbool flag = false;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t// printf(\"match(%d) = %d\\n\", i, matchCnt[i]);\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (matchCnt[i][j] >= b) flag = true;\n\t\t\t\tmatchCnt[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tputs(flag ? \"1\" : \"0\");\n\t}\n\n\treturn 0;\n}\n```","slug":"bzoj-2462","published":1,"updated":"2016-09-13T23:41:03.694Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d4g01gpc2xld6lpuze4"},{"title":"BZOJ 2456mode - ","date":"2016-06-17T14:07:00.000Z","_content":"\n $ n $  $ n \\over 2 $ \n\n<!-- more -->\n\n### \n[BZOJ 2456](http://www.lydsy.com/JudgeOnline/problem.php?id=2456)\n\n### \n$ 500,000 $ $ \\text {1M} $  $ O(1) $ \n\n $ n \\over 2 $ \n\n $ 0 $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 500000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tint ans = -1, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\tif (cnt == 0) {\n\t\t\tans = x;\n\t\t\tcnt = 1;\n\t\t} else {\n\t\t\tif (ans == x) {\n\t\t\t\tcnt++;\n\t\t\t} else {\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2456.md","raw":"title: BZOJ 2456mode - \ncategories: OI\ntags: \n  - BZOJ\n  - \npermalink: bzoj-2456\ndate: 2016-06-17 22:07:00\n---\n\n $ n $  $ n \\over 2 $ \n\n<!-- more -->\n\n### \n[BZOJ 2456](http://www.lydsy.com/JudgeOnline/problem.php?id=2456)\n\n### \n$ 500,000 $ $ \\text {1M} $  $ O(1) $ \n\n $ n \\over 2 $ \n\n $ 0 $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 500000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tint ans = -1, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\n\t\tif (cnt == 0) {\n\t\t\tans = x;\n\t\t\tcnt = 1;\n\t\t} else {\n\t\t\tif (ans == x) {\n\t\t\t\tcnt++;\n\t\t\t} else {\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2456","published":1,"updated":"2016-06-17T14:08:31.587Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d4m01guc2xl6mpt9qv4"},{"title":"BZOJ 2442 -  DP + ","id":"24","updated":"2016-01-19T13:03:11.000Z","date":"2016-01-16T14:32:47.000Z","_content":"\nFJ  `N`$1  N  100,000$ `1`  `N` `i` $E_i$$0  E_i  1,000,000,000$\n\n FJ  `K`  FJ  FJ  `K` \n\n<!-- more -->\n\n### \n[CodeVS 4654](http://codevs.cn/problem/4654/)  \n[BZOJ 2442](http://www.lydsy.com/JudgeOnline/problem.php?id=2442)\n\n### \n $O(n^2)$  DP $a[i]$  `i` $f[i]$  `i`  `j`$i-k  j < i$ `j` \n\n$$ f[i]=\\max(\\max\\{f[j-1]+{\\sum_{x=j+1}^{i}}a[x],j{\\in}[i-k,i)\\},f[i-1]) $$\n\n\n\n$$ f[1]=a[1] $$\n\n $O(n)$ \n\n `-1`\n\n```cpp\nf[0] = a[0];\nfor (int i = 2; i <= n; i++) {\n\tfor (int j = std::max(i - k, 0); j < i; j++) {\n\t\tif (j == 0) f[i - 1] = std::max(f[i - 1], prefixSum[i - 1] - 0);\n\t\telse f[i - 1] = std::max(f[i - 1], (j == 1 ? 0 : f[j - 1 - 1]) + prefixSum[i - 1] - prefixSum[j + 1 - 1 - 1]);\n\t\tf[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n}\n```\n\n DP\n\n$$ sum[i]={\\sum_{x=1}^{i}}a[x] $$\n\n $f[i-1]$\n\n$$ f[i] = \\max\\{f[j-1]+sum[i]-sum[j-1],j{\\in}[i-k,i)\\} $$\n\n\n\n$$ g(x) = f[x-1]-sum[x-1] $$\n\n\n\n$$ f[i] = \\max\\{g(j),j{\\in}[i-k,i)\\}+sum[i] $$\n\n `k + 1`  $g(j)$ $O(1)$ \n\n\n\n$$ f[i] = \\max(\\max\\{f[j-1]-sum(j-1),j{\\in}[i-k,i)\\}+sum[i],f[i-1]) $$\n\n\n\n1. $E_i$ `int` `long long` \n2. \n\n~~~~\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <deque>\n\nconst int MAXN = 100000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, k, a[MAXN];\nlong long prefixSum[MAXN], f[MAXN + 1];\n\ninline void makePrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 0; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline long long sum(int i, int j) {\n\tif (i > j) return 0;\n\treturn i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefixSum();\n\n\tMonotoneQueue<long long> q;\n\tq.push(0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (q.size() == k + 1) q.pop();\n\n\t\tq.push((i == 1 ? 0 : f[i - 1 - 1]) - prefixSum[i + 1 - 1 - 1]);\n\n\t\tf[i - 1] = q.top() + prefixSum[i - 1];\n\t\tif (i != 1) f[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n\n\tprintf(\"%lld\\n\", f[n - 1]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2442.md","raw":"title: BZOJ 2442 -  DP + \ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - USACO\n  - DP\n  - \n  -  DP\npermalink: bzoj-2442\nid: 24\nupdated: '2016-01-19 21:03:11'\ndate: 2016-01-16 22:32:47\n---\n\nFJ  `N`$1  N  100,000$ `1`  `N` `i` $E_i$$0  E_i  1,000,000,000$\n\n FJ  `K`  FJ  FJ  `K` \n\n<!-- more -->\n\n### \n[CodeVS 4654](http://codevs.cn/problem/4654/)  \n[BZOJ 2442](http://www.lydsy.com/JudgeOnline/problem.php?id=2442)\n\n### \n $O(n^2)$  DP $a[i]$  `i` $f[i]$  `i`  `j`$i-k  j < i$ `j` \n\n$$ f[i]=\\max(\\max\\{f[j-1]+{\\sum_{x=j+1}^{i}}a[x],j{\\in}[i-k,i)\\},f[i-1]) $$\n\n\n\n$$ f[1]=a[1] $$\n\n $O(n)$ \n\n `-1`\n\n```cpp\nf[0] = a[0];\nfor (int i = 2; i <= n; i++) {\n\tfor (int j = std::max(i - k, 0); j < i; j++) {\n\t\tif (j == 0) f[i - 1] = std::max(f[i - 1], prefixSum[i - 1] - 0);\n\t\telse f[i - 1] = std::max(f[i - 1], (j == 1 ? 0 : f[j - 1 - 1]) + prefixSum[i - 1] - prefixSum[j + 1 - 1 - 1]);\n\t\tf[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n}\n```\n\n DP\n\n$$ sum[i]={\\sum_{x=1}^{i}}a[x] $$\n\n $f[i-1]$\n\n$$ f[i] = \\max\\{f[j-1]+sum[i]-sum[j-1],j{\\in}[i-k,i)\\} $$\n\n\n\n$$ g(x) = f[x-1]-sum[x-1] $$\n\n\n\n$$ f[i] = \\max\\{g(j),j{\\in}[i-k,i)\\}+sum[i] $$\n\n `k + 1`  $g(j)$ $O(1)$ \n\n\n\n$$ f[i] = \\max(\\max\\{f[j-1]-sum(j-1),j{\\in}[i-k,i)\\}+sum[i],f[i-1]) $$\n\n\n\n1. $E_i$ `int` `long long` \n2. \n\n~~~~\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <deque>\n\nconst int MAXN = 100000;\n\ntemplate <typename T>\nstruct MonotoneQueue {\n\tstd::deque<T> q, m;\n\n\tvoid push(const T &x) {\n\t\tq.push_back(x);\n\t\twhile (!m.empty() && m.back() < x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\n\tvoid pop() {\n\t\tT x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n\n\tsize_t size() {\n\t\treturn q.size();\n\t}\n\n\tT top() {\n\t\treturn m.front();\n\t}\n};\n\nint n, k, a[MAXN];\nlong long prefixSum[MAXN], f[MAXN + 1];\n\ninline void makePrefixSum() {\n\tprefixSum[0] = a[0];\n\tfor (int i = 0; i < n; i++) {\n\t\tprefixSum[i] = prefixSum[i - 1] + a[i];\n\t}\n}\n\ninline long long sum(int i, int j) {\n\tif (i > j) return 0;\n\treturn i == 1 ? prefixSum[j - 1] : prefixSum[j - 1] - prefixSum[i - 1 - 1];\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tmakePrefixSum();\n\n\tMonotoneQueue<long long> q;\n\tq.push(0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (q.size() == k + 1) q.pop();\n\n\t\tq.push((i == 1 ? 0 : f[i - 1 - 1]) - prefixSum[i + 1 - 1 - 1]);\n\n\t\tf[i - 1] = q.top() + prefixSum[i - 1];\n\t\tif (i != 1) f[i - 1] = std::max(f[i - 1], f[i - 1 - 1]);\n\t}\n\n\tprintf(\"%lld\\n\", f[n - 1]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2442","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d4r01gyc2xln2gav8z2"},{"title":"BZOJ 2438 - ","date":"2016-06-25T08:31:00.000Z","_content":"\n $ N $ \n\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 2438](http://www.lydsy.com/JudgeOnline/problem.php?id=2438)\n\n### \n\n\n\n\n\n\n $ 1 $\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 100000;\n\nstruct Node;\nstruct Edge;\nstruct SCC;\n\nstruct Node {\n\tEdge *e, *in, *c;\n\tbool visited, pushed, inStack;\n\tint dfn, low, inDegree;\n\tSCC *scc;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint s;\n} S[MAXN];\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n}\n\nint n, m;\n\ninline int tarjan() {\n\tint time = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->dfn = v->low = time++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tif (v->c->t->inStack) v->low = std::min(v->low, v->c->t->dfn);\n\t\t\t\telse if (v->c->t->pushed == false) s.push(v->c->t), v->c->t->pushed = true, v->c->t->in = v->c;\n\t\t\t\tv->c = v->c->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tNode *u;\n\t\t\t\t\tSCC *scc = &S[cnt++];\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = scc;\n\t\t\t\t\t\tu->scc->s++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->in) v->in->s->low = std::min(v->in->s->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\tif (e->s->scc != e->t->scc) {\n\t\t\t\te->s->scc->v.e = new Edge(&e->s->scc->v, &e->t->scc->v);\n\t\t\t\te->t->scc->v.inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t), s--, t--;\n\t\taddEdge(s, t);\n\t}\n\n\tint cnt = tarjan();\n\tcontract();\n\n\tint k = 0;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].v.inDegree == 0) k++;\n\t}\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].v.inDegree == 0 && S[i].s == 1) {\n\t\t\tbool flag = false;\n\t\t\tfor (Edge *e = S[i].v.e; e; e = e->next) {\n\t\t\t\tif (e->t->inDegree <= 1) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) {\n\t\t\t\tk--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.6lf\\n\", static_cast<double>(n - k) / n);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2438.md","raw":"title: BZOJ 2438 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - Tarjan\n  - \npermalink: bzoj-2438\ndate: 2016-06-25 16:31:00\n---\n\n $ N $ \n\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 2438](http://www.lydsy.com/JudgeOnline/problem.php?id=2438)\n\n### \n\n\n\n\n\n\n $ 1 $\n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 100000;\n\nstruct Node;\nstruct Edge;\nstruct SCC;\n\nstruct Node {\n\tEdge *e, *in, *c;\n\tbool visited, pushed, inStack;\n\tint dfn, low, inDegree;\n\tSCC *scc;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t) : s(s), t(t), next(s->e) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint s;\n} S[MAXN];\n\ninline void addEdge(const int s, const int t) {\n\tN[s].e = new Edge(&N[s], &N[t]);\n}\n\nint n, m;\n\ninline int tarjan() {\n\tint time = 0, cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (N[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\t\ts.push(&N[i]);\n\t\tN[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->c = v->e;\n\t\t\t\tv->dfn = v->low = time++;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->c) {\n\t\t\t\tif (v->c->t->inStack) v->low = std::min(v->low, v->c->t->dfn);\n\t\t\t\telse if (v->c->t->pushed == false) s.push(v->c->t), v->c->t->pushed = true, v->c->t->in = v->c;\n\t\t\t\tv->c = v->c->next;\n\t\t\t} else {\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tNode *u;\n\t\t\t\t\tSCC *scc = &S[cnt++];\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = scc;\n\t\t\t\t\t\tu->scc->s++;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->in) v->in->s->low = std::min(v->in->s->low, v->low);\n\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cnt;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = N[i].e; e; e = e->next) {\n\t\t\tif (e->s->scc != e->t->scc) {\n\t\t\t\te->s->scc->v.e = new Edge(&e->s->scc->v, &e->t->scc->v);\n\t\t\t\te->t->scc->v.inDegree++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t), s--, t--;\n\t\taddEdge(s, t);\n\t}\n\n\tint cnt = tarjan();\n\tcontract();\n\n\tint k = 0;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].v.inDegree == 0) k++;\n\t}\n\n\tfor (int i = 0; i < cnt; i++) {\n\t\tif (S[i].v.inDegree == 0 && S[i].s == 1) {\n\t\t\tbool flag = false;\n\t\t\tfor (Edge *e = S[i].v.e; e; e = e->next) {\n\t\t\t\tif (e->t->inDegree <= 1) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) {\n\t\t\t\tk--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.6lf\\n\", static_cast<double>(n - k) / n);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2438","published":1,"updated":"2016-06-25T08:31:49.077Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d5001h6c2xls8ponbne"},{"title":"BZOJ 2296 - ","date":"2016-04-01T14:59:45.000Z","_content":"\n $ x $$ 0 \\leq x \\leq 10 ^ 6 $ $ n $ \n\n1. $ n $  0 ~ 9 \n2. $ n ~ {\\rm mod} ~ x = 0 $\n3. $ 0 \\leq n \\leq 10 ^ {16} $\n\n<!-- more -->\n\n### \n[BZOJ 2296](http://www.lydsy.com/JudgeOnline/problem.php?id=2296)\n\n### \n 1 n  10  $ 9876543210 $ 6 \n\n $ d = 9876543210 \\times 10 ^ 6 ~ {\\rm mod} ~ x $ $ 9876543210 $  $ d $ $ n = 9876543210 \\times 10 ^ 6 + x - d $ \n\n 0 \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXT = 100;\nconst int MAXX = 1e6;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tlong long base = 9876543210 * 1e6;\n\tfor (int i = 0; i < t; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tprintf(\"%lld\\n\", x == 0 ? -1LL : base + (x - base % x));\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2296.md","raw":"title: BZOJ 2296 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \npermalink: bzoj-2296\ndate: 2016-04-01 22:59:45\n---\n\n $ x $$ 0 \\leq x \\leq 10 ^ 6 $ $ n $ \n\n1. $ n $  0 ~ 9 \n2. $ n ~ {\\rm mod} ~ x = 0 $\n3. $ 0 \\leq n \\leq 10 ^ {16} $\n\n<!-- more -->\n\n### \n[BZOJ 2296](http://www.lydsy.com/JudgeOnline/problem.php?id=2296)\n\n### \n 1 n  10  $ 9876543210 $ 6 \n\n $ d = 9876543210 \\times 10 ^ 6 ~ {\\rm mod} ~ x $ $ 9876543210 $  $ d $ $ n = 9876543210 \\times 10 ^ 6 + x - d $ \n\n 0 \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXT = 100;\nconst int MAXX = 1e6;\n\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\n\tlong long base = 9876543210 * 1e6;\n\tfor (int i = 0; i < t; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tprintf(\"%lld\\n\", x == 0 ? -1LL : base + (x - base % x));\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2296","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d5701hcc2xlkulsg2tk"},{"title":"BZOJ 2194 - FFT","date":"2016-06-10T01:32:00.000Z","_content":"\n $ n $  $ A $$ B $ $ n $  $ C $ $ C_k = \\sum\\limits_{i = k} ^ {n - 1} A_i \\times B_{i - k} $\n\n<!-- more -->\n\n### \n[BZOJ 2194](http://www.lydsy.com/JudgeOnline/problem.php?id=2194)\n\n### \n $ A $  $ A' $\n\n$$\n\\begin{align*}\nC_k &= \\sum\\limits_{i = k} ^ {n - 1} A_i \\times B_{i - k} \\\\\n&= \\sum\\limits_{i = k} ^ {n - 1} A'_{n - i - 1} \\times B_{i - k}\n\\end{align*}\n$$\n\n $ i $  $ 0 $ \n\n$$\nC_k = \\sum\\limits_{i = 0} ^ {n - k - 1} A'_{n - k - 1 - i} \\times B_{i}\n$$\n\n\n\n$$ c_t = \\sum\\limits_{i = 0} ^ {t} a_{t - i} b_{i} $$\n\n $ t = n - k - 1 $\n\n$$\nC_{n - t - 1} = \\sum\\limits_{i = 0} ^ {t} A'_{t - i} B_{i}\n$$\n\n $ C $  $ C' $\n\n$$\nC'_{t} = \\sum\\limits_{i = 0} ^ {t} A'_{t - i} B_{i}\n$$\n\n $ A' $  $ B $  $ C' $ $ n $  $ C $\n\n FFT $ O(n \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <complex>\n\nconst int MAXN = 131072 * 2;\nconst double PI = acos(-1);\n\nstruct FastFourierTransform {\n\tstd::complex<double> omega[MAXN], omegaInverse[MAXN];\n\n\tvoid init(const int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tomega[i] = std::complex<double>(cos(2 * PI / n * i), sin(2 * PI / n * i));\n\t\t\tomegaInverse[i] = std::conj(omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << (k - j - 1))) t |= (1 << j);\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t}\n\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tconst int m = l / 2;\n\t\t\tfor (std::complex<double> *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tconst std::complex<double> t = omega[n / l * i] * p[i + m];\n\t\t\t\t\tp[i + m] = p[i] - t;\n\t\t\t\t\tp[i] += t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(std::complex<double> *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(std::complex<double> *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tfor (int i = 0; i < n; i++) a[i] /= n;\n\t}\n\n\tvoid operator()(const int *a, const int n1, const int *b, const int n2, int *c) {\n\t\tfor (int k = 0; k < n1 + n2; k++) {\n\t\t\tfor (int i = 0; i <= k; i++) {\n\t\t\t\tc[k] += a[i] * b[k - i];\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\n\t\tstatic std::complex<double> ca[MAXN], cb[MAXN];\n\n\t\tint n = 1;\n\t\twhile (n < (n1 + n2)) n *= 2;\n\n\t\tfor (int i = 0; i < n; i++) ca[i] = std::complex<double>(i < n1 ? a[i] : 0, 0);\n\t\tfor (int i = 0; i < n; i++) cb[i] = std::complex<double>(i < n2 ? b[i] : 0, 0);\n\n\t\tinit(n);\n\t\tdft(ca, n);\n\t\tdft(cb, n);\n\n\t\tfor (int i = 0; i < n; i++) ca[i] *= cb[i];\n\n\t\tidft(ca, n);\n\n\t\tfor (int i = 0; i < n; i++) c[i] = static_cast<int>(floor(ca[i].real() + 0.5));\n\t}\n} fft;\n\ninline void force(const int *a, const int *b, int *c, const int n) {\n\t/*\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = k; i < n; i++) {\n\t\t\tc[k] += a[n - i - 1] * b[i - k];\n\t\t}\n\t}\n\n\treturn;\n\t*/\n\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = 0; i < n - k; i++) {\n\t\t\tc[k] += a[n - k - 1 - i] * b[i];\n\t\t}\n\t}\n}\n\n\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN], b[MAXN], c[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[n - i - 1], &b[i]);\n\n\t// force(a, b, c, n);\n\tfft(a, n, b, n, c);\n\n\tfor (int i = 0; i < n; i++) printf(\"%d\\n\", c[n - i - 1]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2194.md","raw":"title: BZOJ 2194 - FFT\ncategories: OI\ntags: \n  - BZOJ\n  - \n  - FFT\npermalink: bzoj-2194\ndate: 2016-06-10 09:32:00\n---\n\n $ n $  $ A $$ B $ $ n $  $ C $ $ C_k = \\sum\\limits_{i = k} ^ {n - 1} A_i \\times B_{i - k} $\n\n<!-- more -->\n\n### \n[BZOJ 2194](http://www.lydsy.com/JudgeOnline/problem.php?id=2194)\n\n### \n $ A $  $ A' $\n\n$$\n\\begin{align*}\nC_k &= \\sum\\limits_{i = k} ^ {n - 1} A_i \\times B_{i - k} \\\\\n&= \\sum\\limits_{i = k} ^ {n - 1} A'_{n - i - 1} \\times B_{i - k}\n\\end{align*}\n$$\n\n $ i $  $ 0 $ \n\n$$\nC_k = \\sum\\limits_{i = 0} ^ {n - k - 1} A'_{n - k - 1 - i} \\times B_{i}\n$$\n\n\n\n$$ c_t = \\sum\\limits_{i = 0} ^ {t} a_{t - i} b_{i} $$\n\n $ t = n - k - 1 $\n\n$$\nC_{n - t - 1} = \\sum\\limits_{i = 0} ^ {t} A'_{t - i} B_{i}\n$$\n\n $ C $  $ C' $\n\n$$\nC'_{t} = \\sum\\limits_{i = 0} ^ {t} A'_{t - i} B_{i}\n$$\n\n $ A' $  $ B $  $ C' $ $ n $  $ C $\n\n FFT $ O(n \\log n) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <complex>\n\nconst int MAXN = 131072 * 2;\nconst double PI = acos(-1);\n\nstruct FastFourierTransform {\n\tstd::complex<double> omega[MAXN], omegaInverse[MAXN];\n\n\tvoid init(const int n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tomega[i] = std::complex<double>(cos(2 * PI / n * i), sin(2 * PI / n * i));\n\t\t\tomegaInverse[i] = std::conj(omega[i]);\n\t\t}\n\t}\n\n\tvoid transform(std::complex<double> *a, const int n, const std::complex<double> *omega) {\n\t\tint k = 0;\n\t\twhile ((1 << k) != n) k++;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint t = 0;\n\t\t\tfor (int j = 0; j < k; j++) if (i & (1 << (k - j - 1))) t |= (1 << j);\n\t\t\tif (t > i) std::swap(a[i], a[t]);\n\t\t}\n\n\t\tfor (int l = 2; l <= n; l *= 2) {\n\t\t\tconst int m = l / 2;\n\t\t\tfor (std::complex<double> *p = a; p != a + n; p += l) {\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tconst std::complex<double> t = omega[n / l * i] * p[i + m];\n\t\t\t\t\tp[i + m] = p[i] - t;\n\t\t\t\t\tp[i] += t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dft(std::complex<double> *a, const int n) {\n\t\ttransform(a, n, omega);\n\t}\n\n\tvoid idft(std::complex<double> *a, const int n) {\n\t\ttransform(a, n, omegaInverse);\n\t\tfor (int i = 0; i < n; i++) a[i] /= n;\n\t}\n\n\tvoid operator()(const int *a, const int n1, const int *b, const int n2, int *c) {\n\t\tfor (int k = 0; k < n1 + n2; k++) {\n\t\t\tfor (int i = 0; i <= k; i++) {\n\t\t\t\tc[k] += a[i] * b[k - i];\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\n\t\tstatic std::complex<double> ca[MAXN], cb[MAXN];\n\n\t\tint n = 1;\n\t\twhile (n < (n1 + n2)) n *= 2;\n\n\t\tfor (int i = 0; i < n; i++) ca[i] = std::complex<double>(i < n1 ? a[i] : 0, 0);\n\t\tfor (int i = 0; i < n; i++) cb[i] = std::complex<double>(i < n2 ? b[i] : 0, 0);\n\n\t\tinit(n);\n\t\tdft(ca, n);\n\t\tdft(cb, n);\n\n\t\tfor (int i = 0; i < n; i++) ca[i] *= cb[i];\n\n\t\tidft(ca, n);\n\n\t\tfor (int i = 0; i < n; i++) c[i] = static_cast<int>(floor(ca[i].real() + 0.5));\n\t}\n} fft;\n\ninline void force(const int *a, const int *b, int *c, const int n) {\n\t/*\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = k; i < n; i++) {\n\t\t\tc[k] += a[n - i - 1] * b[i - k];\n\t\t}\n\t}\n\n\treturn;\n\t*/\n\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = 0; i < n - k; i++) {\n\t\t\tc[k] += a[n - k - 1 - i] * b[i];\n\t\t}\n\t}\n}\n\n\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN], b[MAXN], c[MAXN];\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d\", &a[n - i - 1], &b[i]);\n\n\t// force(a, b, c, n);\n\tfft(a, n, b, n, c);\n\n\tfor (int i = 0; i < n; i++) printf(\"%d\\n\", c[n - i - 1]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2194","published":1,"updated":"2016-06-11T13:32:41.781Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d5d01hhc2xlapd4rgr5"},{"title":"BZOJ 2152 - ","date":"2016-06-14T14:09:00.000Z","_content":"\n $ n $  $ 3 $ \n\n<!-- more -->\n\n### \n[BZOJ 2152](http://www.lydsy.com/JudgeOnline/problem.php?id=2152)\n\n### \n $ \\bmod 3 $  $ i $  $ f(i) $\n\n $ f(1) \\times f(2) \\times 2 $   \n $ f(0) $  $ \\frac{ f(0) \\times (f(0) - 1) }{2} $ $ 2 $ $ f ^ 2(0) $\n\n $ f ^ 2(0) + f(1) \\times f(2) \\times 2 $ \n\n $ n ^ 2 $\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint size, dist, max;\n\tbool solved, visited;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\ta[cnt++] = v;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(start->size - a[i]->max, a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->parent = NULL;\n\troot->dist = dist;\n\t\n\tint a[3] = { 0, 0, 0 }, cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tcnt++;\n\t\ta[v->dist %= 3]++;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\treturn a[0] * a[0] + a[1] * a[2] * 2;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint res = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\tres += calc(root);\n\t\troot->solved = true;\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tres -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--, w %= 3;\n\t\taddEdge(u, v, w);\n\t}\n\n\tint cnt = solve(), sum = n * n, g = std::__gcd(cnt, sum);\n\tprintf(\"%d/%d\\n\", cnt / g, sum / g);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2152.md","raw":"title: BZOJ 2152 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \npermalink: bzoj-2152\ndate: 2016-06-14 22:09:00\n---\n\n $ n $  $ 3 $ \n\n<!-- more -->\n\n### \n[BZOJ 2152](http://www.lydsy.com/JudgeOnline/problem.php?id=2152)\n\n### \n $ \\bmod 3 $  $ i $  $ f(i) $\n\n $ f(1) \\times f(2) \\times 2 $   \n $ f(0) $  $ \\frac{ f(0) \\times (f(0) - 1) }{2} $ $ 2 $ $ f ^ 2(0) $\n\n $ f ^ 2(0) + f(1) \\times f(2) \\times 2 $ \n\n $ n ^ 2 $\n\n### \n```c++\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint size, dist, max;\n\tbool solved, visited;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\tv->visited = true;\n\t\t\ta[cnt++] = v;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\t\te->t->visited = false;\n\t\t\t\te->t->parent = v;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(start->size - a[i]->max, a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->parent = NULL;\n\troot->dist = dist;\n\t\n\tint a[3] = { 0, 0, 0 }, cnt = 0;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\tcnt++;\n\t\ta[v->dist %= 3]++;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\treturn a[0] * a[0] + a[1] * a[2] * 2;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint res = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\n\t\tNode *root = center(v);\n\t\tres += calc(root);\n\t\troot->solved = true;\n\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tres -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--, w %= 3;\n\t\taddEdge(u, v, w);\n\t}\n\n\tint cnt = solve(), sum = n * n, g = std::__gcd(cnt, sum);\n\tprintf(\"%d/%d\\n\", cnt / g, sum / g);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2152","published":1,"updated":"2016-06-16T10:10:15.564Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d5j01hmc2xllrirotgb"},{"title":"BZOJ 2143 - ","date":"2016-03-22T11:50:15.000Z","_content":"\n $ N * M $  $ i $  $ j $  $ A_{ij} $  $ B_{ij} $  $ 1 $ $ (i,j) $  $ A_{ij} $   $ B_{ij} $ \n\n XYZ $ 3 $ \n\n<!-- more -->\n\n### \n[BZOJ 2143](http://www.lydsy.com/JudgeOnline/problem.php?id=2143)\n\n### \n 40% $ B_{ij} $ $ B_{ij} $  $ A_{ij} $  0 Dijkstra \n\n   Dijkstra \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cstdlib>\n#include <queue>\n\nconst int MAXN = 150;\nconst int MAXM = 150;\n\nstruct Node {\n\tint dist;\n} nodes[MAXN][MAXM][MAXN + MAXM + 1];\n\nint n, m, a[MAXN][MAXM], b[MAXN][MAXM];\n\nstruct Point {\n\tint x, y, k;\n\n\tPoint(int x = 0, int y = 0, int k = 0) : x(x), y(y), k(k) {}\n\n\tNode *operator->() const {\n\t\treturn &nodes[x][y][k];\n\t}\n\n\tPoint up(int k) {\n\t\treturn Point(x, y, k);\n\t}\n\n\tPoint move(int x, int y) {\n\t\treturn Point(this->x + x, this->y + y, k - 1);\n\t}\n\n\tbool isValid() {\n\t\treturn x >= 0 && x < n && y >= 0 && y < m && k >= 0;\n\t}\n\n\tint a() {\n\t\treturn ::a[x][y];\n\t}\n\n\tint b() {\n\t\treturn ::b[x][y];\n\t}\n\n\tstruct Compare {\n\t\tbool operator()(const Point &a, const Point &b) {\n\t\t\treturn a->dist > b->dist;\n\t\t}\n\t};\n} p[3];\n\nvoid dijkstra(const Point &start) {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k <= n + m; k++) {\n\t\t\t\tnodes[i][j][k].dist = INT_MAX;\n\t\t\t}\n\t\t}\n\t}\n\n\tstart->dist = 0;\n\n\tstd::priority_queue<Point, std::vector<Point>, Point::Compare> q;\n\tq.push(start);\n\n\twhile (!q.empty()) {\n\t\tPoint p = q.top();\n\t\tq.pop();\n\n\t\tif (p->dist > ::p[0]->dist && p->dist > ::p[1]->dist && p->dist > ::p[2]->dist) continue;\n\n\t\tif (p.k == 0) {\n\t\t\tPoint up = p.up(p.b());\n\t\t\tif (up->dist > p->dist + p.a()) up->dist = p->dist + p.a(), q.push(up);\n\t\t} else {\n\t\t\tPoint side;\n\t\t\tif ((side = p.move(0, 1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, -1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(-1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t}\n\t}\n\n\t// puts(\">_<\");\n}\n\nint main() {\n\t// freopen(\"fly.in\", \"r\", stdin);\n\t// freopen(\"fly.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &b[i][j]);\n\t\t\tif (b[i][j] > n + m) b[i][j] = n + m;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 3; i++) scanf(\"%d %d\", &p[i].x, &p[i].y), p[i].x--, p[i].y--;\n\n\tint dist[3][3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tdijkstra(p[i]);\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tdist[i][j] = p[j]->dist;\n\t\t}\n\t}\n\n\tint ans = INT_MAX;\n\tchar ansPos = '\\0';\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (dist[0][i] == INT_MAX || dist[1][i] == INT_MAX || dist[2][i] == INT_MAX) continue;\n\t\tint tmp = dist[0][i] + dist[1][i] + dist[2][i];\n\t\tif (tmp < ans) ans = tmp, ansPos = 'X' + i;\n\t}\n\n\tif (ans == INT_MAX) puts(\"NO\");\n\telse printf(\"%c\\n%d\\n\", ansPos, ans);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2143.md","raw":"title: BZOJ 2143 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - Dijkstra\n  - \npermalink: bzoj-2143\ndate: 2016-03-22 19:50:15\n---\n\n $ N * M $  $ i $  $ j $  $ A_{ij} $  $ B_{ij} $  $ 1 $ $ (i,j) $  $ A_{ij} $   $ B_{ij} $ \n\n XYZ $ 3 $ \n\n<!-- more -->\n\n### \n[BZOJ 2143](http://www.lydsy.com/JudgeOnline/problem.php?id=2143)\n\n### \n 40% $ B_{ij} $ $ B_{ij} $  $ A_{ij} $  0 Dijkstra \n\n   Dijkstra \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <cstdlib>\n#include <queue>\n\nconst int MAXN = 150;\nconst int MAXM = 150;\n\nstruct Node {\n\tint dist;\n} nodes[MAXN][MAXM][MAXN + MAXM + 1];\n\nint n, m, a[MAXN][MAXM], b[MAXN][MAXM];\n\nstruct Point {\n\tint x, y, k;\n\n\tPoint(int x = 0, int y = 0, int k = 0) : x(x), y(y), k(k) {}\n\n\tNode *operator->() const {\n\t\treturn &nodes[x][y][k];\n\t}\n\n\tPoint up(int k) {\n\t\treturn Point(x, y, k);\n\t}\n\n\tPoint move(int x, int y) {\n\t\treturn Point(this->x + x, this->y + y, k - 1);\n\t}\n\n\tbool isValid() {\n\t\treturn x >= 0 && x < n && y >= 0 && y < m && k >= 0;\n\t}\n\n\tint a() {\n\t\treturn ::a[x][y];\n\t}\n\n\tint b() {\n\t\treturn ::b[x][y];\n\t}\n\n\tstruct Compare {\n\t\tbool operator()(const Point &a, const Point &b) {\n\t\t\treturn a->dist > b->dist;\n\t\t}\n\t};\n} p[3];\n\nvoid dijkstra(const Point &start) {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int k = 0; k <= n + m; k++) {\n\t\t\t\tnodes[i][j][k].dist = INT_MAX;\n\t\t\t}\n\t\t}\n\t}\n\n\tstart->dist = 0;\n\n\tstd::priority_queue<Point, std::vector<Point>, Point::Compare> q;\n\tq.push(start);\n\n\twhile (!q.empty()) {\n\t\tPoint p = q.top();\n\t\tq.pop();\n\n\t\tif (p->dist > ::p[0]->dist && p->dist > ::p[1]->dist && p->dist > ::p[2]->dist) continue;\n\n\t\tif (p.k == 0) {\n\t\t\tPoint up = p.up(p.b());\n\t\t\tif (up->dist > p->dist + p.a()) up->dist = p->dist + p.a(), q.push(up);\n\t\t} else {\n\t\t\tPoint side;\n\t\t\tif ((side = p.move(0, 1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, -1)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(-1, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t\tif ((side = p.move(0, 0)).isValid() && side->dist > p->dist) side->dist = p->dist, q.push(side);\n\t\t}\n\t}\n\n\t// puts(\">_<\");\n}\n\nint main() {\n\t// freopen(\"fly.in\", \"r\", stdin);\n\t// freopen(\"fly.out\", \"w\", stdout);\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &b[i][j]);\n\t\t\tif (b[i][j] > n + m) b[i][j] = n + m;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 3; i++) scanf(\"%d %d\", &p[i].x, &p[i].y), p[i].x--, p[i].y--;\n\n\tint dist[3][3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tdijkstra(p[i]);\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tdist[i][j] = p[j]->dist;\n\t\t}\n\t}\n\n\tint ans = INT_MAX;\n\tchar ansPos = '\\0';\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (dist[0][i] == INT_MAX || dist[1][i] == INT_MAX || dist[2][i] == INT_MAX) continue;\n\t\tint tmp = dist[0][i] + dist[1][i] + dist[2][i];\n\t\tif (tmp < ans) ans = tmp, ansPos = 'X' + i;\n\t}\n\n\tif (ans == INT_MAX) puts(\"NO\");\n\telse printf(\"%c\\n%d\\n\", ansPos, ans);\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2143","published":1,"updated":"2016-06-14T07:16:00.611Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d5p01hrc2xl55zu2uwq"},{"title":"BZOJ 2132 - ","date":"2016-06-23T08:56:00.000Z","_content":"\n $ i $  $ j $  $ A_{i,\\ j} $  $ B_{i,\\ j} $  $ (i,\\ j) $  $ K $  $ K $  $ 4 $ $ (i,\\ j) $  $ K \\times C_{i,\\ j} $ \n\n<!-- more -->\n\n### \n[BZOJ 2132](http://www.lydsy.com/JudgeOnline/problem.php?id=2132)\n\n### \n $ X $  $ A_{i,\\ j} $ $ Y $  $ B_{i,\\ j} $ $ X $  $ B_{i,\\ j} $ $ Y $  $ A_{i,\\ j} $\n\n $ C_{i_1,\\ j_1} + C_{i_2,\\ j_2} $ \n\n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], rc);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j) { return (i - 1) * m + j; }\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tint sum = 0;\n\tconst int s = 0, t = n * m + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tsum += x;\n\t\t\t\n\t\t\tif ((i + j) % 2 == 0) addEdge(s, id(i, j), x);\n\t\t\telse addEdge(id(i, j), t, x);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tsum += x;\n\n\t\t\tif ((i + j) % 2 != 0) addEdge(s, id(i, j), x);\n\t\t\telse addEdge(id(i, j), t, x);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tif (i != 1) addEdge(id(i - 1, j), id(i, j), x, x), sum += x;\n\t\t\tif (i != n) addEdge(id(i + 1, j), id(i, j), x, x), sum += x;\n\t\t\tif (j != 1) addEdge(id(i, j - 1), id(i, j), x, x), sum += x;\n\t\t\tif (j != m) addEdge(id(i, j + 1), id(i, j), x, x), sum += x;\n\t\t}\n\t}\n\n\tconst int maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2132.md","raw":"title: BZOJ 2132 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - Dinic\n  - \npermalink: bzoj-2132\ndate: 2016-06-23 16:56:00\n---\n\n $ i $  $ j $  $ A_{i,\\ j} $  $ B_{i,\\ j} $  $ (i,\\ j) $  $ K $  $ K $  $ 4 $ $ (i,\\ j) $  $ K \\times C_{i,\\ j} $ \n\n<!-- more -->\n\n### \n[BZOJ 2132](http://www.lydsy.com/JudgeOnline/problem.php?id=2132)\n\n### \n $ X $  $ A_{i,\\ j} $ $ Y $  $ B_{i,\\ j} $ $ X $  $ B_{i,\\ j} $ $ Y $  $ A_{i,\\ j} $\n\n $ C_{i_1,\\ j_1} + C_{i_2,\\ j_2} $ \n\n\n\n\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c, const int rc = 0) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], rc);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint n, m;\n\ninline int id(const int i, const int j) { return (i - 1) * m + j; }\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tint sum = 0;\n\tconst int s = 0, t = n * m + 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tsum += x;\n\t\t\t\n\t\t\tif ((i + j) % 2 == 0) addEdge(s, id(i, j), x);\n\t\t\telse addEdge(id(i, j), t, x);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tsum += x;\n\n\t\t\tif ((i + j) % 2 != 0) addEdge(s, id(i, j), x);\n\t\t\telse addEdge(id(i, j), t, x);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\n\t\t\tif (i != 1) addEdge(id(i - 1, j), id(i, j), x, x), sum += x;\n\t\t\tif (i != n) addEdge(id(i + 1, j), id(i, j), x, x), sum += x;\n\t\t\tif (j != 1) addEdge(id(i, j - 1), id(i, j), x, x), sum += x;\n\t\t\tif (j != m) addEdge(id(i, j + 1), id(i, j), x, x), sum += x;\n\t\t}\n\t}\n\n\tconst int maxFlow = dinic(s, t, n * m + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2132","published":1,"updated":"2016-06-23T08:56:59.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d5x01hyc2xl1frzaouw"},{"title":"BZOJ 2127happiness - ","date":"2016-06-21T09:41:00.000Z","_content":"\n $ n \\times m $ ********\n\n<!-- more -->\n\n### \n[BZOJ 2127](http://www.lydsy.com/JudgeOnline/problem.php?id=2127)\n\n### \n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + MAXN * (MAXN - 1) * 4 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN][MAXN], b[MAXN][MAXN], aDown[MAXN - 1][MAXN], bDown[MAXN - 1][MAXN], aRight[MAXN][MAXN - 1], bRight[MAXN][MAXN - 1], vID[MAXN][MAXN], eID[MAXN][MAXN][2][2];\n\tconst int DOWN = 0, RIGHT = 1;\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &a[i][j]), sum += a[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &b[i][j]);\n\t\n\tfor (int i = 0; i < n - 1; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &aDown[i][j]), sum += aDown[i][j];\n\tfor (int i = 0; i < n - 1; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &bDown[i][j]);\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m - 1; j++) scanf(\"%d\", &aRight[i][j]), sum += aRight[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m - 1; j++) scanf(\"%d\", &bRight[i][j]);\n\n\tint id = 1;\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) vID[i][j] = id++;\n\n\t// printf(\"eID starts from %d\\n\", id);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i != n - 1) eID[i][j][DOWN][0] = id++, eID[i][j][DOWN][1] = id++;\n\t\t\tif (j != m - 1) eID[i][j][RIGHT][0] = id++, eID[i][j][RIGHT][1] = id++;\n\t\t}\n\t}\n\n\tconst int s = 0, t = n * m + (n * (m - 1) + m * (n - 1)) * 2 + 1;\n\n\t// printf(\"%d %d\\n\", id, t);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint x = b[i][j] - a[i][j];\n\t\t\tif (x > 0) addEdge(s, vID[i][j], x), sum += x;\n\t\t\telse addEdge(vID[i][j], t, -x);\n\n\t\t\tif (i != n - 1) {\n\t\t\t\taddEdge(eID[i][j][DOWN][0], t, aDown[i][j]);\n\t\t\t\taddEdge(s, eID[i][j][DOWN][1], bDown[i][j]), sum += bDown[i][j];\n\n\t\t\t\taddEdge(vID[i][j], eID[i][j][DOWN][0], INT_MAX);\n\t\t\t\taddEdge(vID[i + 1][j], eID[i][j][DOWN][0], INT_MAX);\n\n\t\t\t\taddEdge(eID[i][j][DOWN][1], vID[i][j], INT_MAX);\n\t\t\t\taddEdge(eID[i][j][DOWN][1], vID[i + 1][j], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != m - 1) {\n\t\t\t\taddEdge(eID[i][j][RIGHT][0], t, aRight[i][j]);\n\t\t\t\taddEdge(s, eID[i][j][RIGHT][1], bRight[i][j]), sum += bRight[i][j];\n\n\t\t\t\taddEdge(vID[i][j], eID[i][j][RIGHT][0], INT_MAX);\n\t\t\t\taddEdge(vID[i][j + 1], eID[i][j][RIGHT][0], INT_MAX);\n\n\t\t\t\taddEdge(eID[i][j][RIGHT][1], vID[i][j], INT_MAX);\n\t\t\t\taddEdge(eID[i][j][RIGHT][1], vID[i][j + 1], INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m + (n * (m - 1) + m * (n - 1)) * 2 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2127.md","raw":"title: BZOJ 2127happiness - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - Dinic\n  - \npermalink: bzoj-2127\ndate: 2016-06-21 17:41:00\n---\n\n $ n \\times m $ ********\n\n<!-- more -->\n\n### \n[BZOJ 2127](http://www.lydsy.com/JudgeOnline/problem.php?id=2127)\n\n### \n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXN + MAXN * (MAXN - 1) * 4 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m, sum = 0;\n\tscanf(\"%d %d\", &n, &m);\n\n\tstatic int a[MAXN][MAXN], b[MAXN][MAXN], aDown[MAXN - 1][MAXN], bDown[MAXN - 1][MAXN], aRight[MAXN][MAXN - 1], bRight[MAXN][MAXN - 1], vID[MAXN][MAXN], eID[MAXN][MAXN][2][2];\n\tconst int DOWN = 0, RIGHT = 1;\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &a[i][j]), sum += a[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &b[i][j]);\n\t\n\tfor (int i = 0; i < n - 1; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &aDown[i][j]), sum += aDown[i][j];\n\tfor (int i = 0; i < n - 1; i++) for (int j = 0; j < m; j++) scanf(\"%d\", &bDown[i][j]);\n\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m - 1; j++) scanf(\"%d\", &aRight[i][j]), sum += aRight[i][j];\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m - 1; j++) scanf(\"%d\", &bRight[i][j]);\n\n\tint id = 1;\n\tfor (int i = 0; i < n; i++) for (int j = 0; j < m; j++) vID[i][j] = id++;\n\n\t// printf(\"eID starts from %d\\n\", id);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i != n - 1) eID[i][j][DOWN][0] = id++, eID[i][j][DOWN][1] = id++;\n\t\t\tif (j != m - 1) eID[i][j][RIGHT][0] = id++, eID[i][j][RIGHT][1] = id++;\n\t\t}\n\t}\n\n\tconst int s = 0, t = n * m + (n * (m - 1) + m * (n - 1)) * 2 + 1;\n\n\t// printf(\"%d %d\\n\", id, t);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tint x = b[i][j] - a[i][j];\n\t\t\tif (x > 0) addEdge(s, vID[i][j], x), sum += x;\n\t\t\telse addEdge(vID[i][j], t, -x);\n\n\t\t\tif (i != n - 1) {\n\t\t\t\taddEdge(eID[i][j][DOWN][0], t, aDown[i][j]);\n\t\t\t\taddEdge(s, eID[i][j][DOWN][1], bDown[i][j]), sum += bDown[i][j];\n\n\t\t\t\taddEdge(vID[i][j], eID[i][j][DOWN][0], INT_MAX);\n\t\t\t\taddEdge(vID[i + 1][j], eID[i][j][DOWN][0], INT_MAX);\n\n\t\t\t\taddEdge(eID[i][j][DOWN][1], vID[i][j], INT_MAX);\n\t\t\t\taddEdge(eID[i][j][DOWN][1], vID[i + 1][j], INT_MAX);\n\t\t\t}\n\n\t\t\tif (j != m - 1) {\n\t\t\t\taddEdge(eID[i][j][RIGHT][0], t, aRight[i][j]);\n\t\t\t\taddEdge(s, eID[i][j][RIGHT][1], bRight[i][j]), sum += bRight[i][j];\n\n\t\t\t\taddEdge(vID[i][j], eID[i][j][RIGHT][0], INT_MAX);\n\t\t\t\taddEdge(vID[i][j + 1], eID[i][j][RIGHT][0], INT_MAX);\n\n\t\t\t\taddEdge(eID[i][j][RIGHT][1], vID[i][j], INT_MAX);\n\t\t\t\taddEdge(eID[i][j][RIGHT][1], vID[i][j + 1], INT_MAX);\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * m + (n * (m - 1) + m * (n - 1)) * 2 + 2);\n\tprintf(\"%d\\n\", sum - maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2127","published":1,"updated":"2016-06-22T08:25:36.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d6401i4c2xlza4mf0wc"},{"title":"BZOJ 2038Z - ","date":"2016-04-01T14:15:45.000Z","_content":"\n $ x_1 $ ~ $ x_n $ $ m $  $ x_i $ ~ $ x_j $ \n\n<!-- more -->\n\n### \n $ \\sqrt n $ \n\n $ x_i $ ~ $ x_j $ \n\n $ x $  $ c_i $ \n\n$$ \\sum_{i = l}^{r} \\frac{c_{a_i} \\times (c_{a_i} - 1)}{2} $$\n\n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nlong long gcd(const long long a, const long long b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n\nstruct Fraction {\n\tlong long a, b;\n\n\tvoid print() const {\n\t\tconst long long g = gcd(a, b);\n\t\tprintf(\"%lld/%lld\\n\", a / g, b / g);\n\t}\n};\n\nstruct Query {\n\tint id, l, r;\n\tFraction ans;\n} Q[MAXM];\n\nint n, m;\nint a[MAXN];\n\nbool compareByBlock(const Query &a, const Query &b) {\n\tstatic int s = floor(sqrt(m) + 1);\n\tif (a.l / s == b.l / s) return a.r < b.r;\n\telse return a.l / s < b.l / s;\n}\n\nbool compareById(const Query &a, const Query &b) {\n\treturn a.id < b.id;\n}\n\ninline long long calc(const long long x) {\n\treturn x * (x - 1);\n}\n\ninline void work() {\n\tstatic int cnt[MAXN];\n\tbool flag = false;\n\tlong long x = 0;\n\tfor (int i = 0, l, r; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tq.l--, q.r--;\n\t\tif (!flag) {\n\t\t\tl = q.l, r = q.r, flag = true;\n\t\t\tfor (int i = l; i <= r; i++) x -= calc(cnt[a[i]]), x += calc(++cnt[a[i]]);\n\t\t} else {\n\t\t\twhile (q.l < l) l--, x -= calc(cnt[a[l]]), x += calc(++cnt[a[l]]);\n\t\t\twhile (q.r > r) r++, x -= calc(cnt[a[r]]), x += calc(++cnt[a[r]]);\n\t\t\twhile (q.l > l) x -= calc(cnt[a[l]]), x += calc(--cnt[a[l]]), l++;\n\t\t\twhile (q.r < r) x -= calc(cnt[a[r]]), x += calc(--cnt[a[r]]), r--;\n\t\t}\n\n\t\tq.ans.a = x, q.ans.b = calc(q.r - q.l + 1);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), a[i]--;\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d\", &Q[i].l, &Q[i].r), Q[i].id = i;\n\n\tstd::sort(Q, Q + m, &compareByBlock);\n\twork();\n\tstd::sort(Q, Q + m, &compareById);\n\n\tfor (int i = 0; i < m; i++) Q[i].ans.print();\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-2038.md","raw":"title: BZOJ 2038Z - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - \npermalink: bzoj-2038\ndate: 2016-04-01 22:15:45\n---\n\n $ x_1 $ ~ $ x_n $ $ m $  $ x_i $ ~ $ x_j $ \n\n<!-- more -->\n\n### \n $ \\sqrt n $ \n\n $ x_i $ ~ $ x_j $ \n\n $ x $  $ c_i $ \n\n$$ \\sum_{i = l}^{r} \\frac{c_{a_i} \\times (c_{a_i} - 1)}{2} $$\n\n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 50000;\n\nlong long gcd(const long long a, const long long b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n\nstruct Fraction {\n\tlong long a, b;\n\n\tvoid print() const {\n\t\tconst long long g = gcd(a, b);\n\t\tprintf(\"%lld/%lld\\n\", a / g, b / g);\n\t}\n};\n\nstruct Query {\n\tint id, l, r;\n\tFraction ans;\n} Q[MAXM];\n\nint n, m;\nint a[MAXN];\n\nbool compareByBlock(const Query &a, const Query &b) {\n\tstatic int s = floor(sqrt(m) + 1);\n\tif (a.l / s == b.l / s) return a.r < b.r;\n\telse return a.l / s < b.l / s;\n}\n\nbool compareById(const Query &a, const Query &b) {\n\treturn a.id < b.id;\n}\n\ninline long long calc(const long long x) {\n\treturn x * (x - 1);\n}\n\ninline void work() {\n\tstatic int cnt[MAXN];\n\tbool flag = false;\n\tlong long x = 0;\n\tfor (int i = 0, l, r; i < m; i++) {\n\t\tQuery &q = Q[i];\n\t\tq.l--, q.r--;\n\t\tif (!flag) {\n\t\t\tl = q.l, r = q.r, flag = true;\n\t\t\tfor (int i = l; i <= r; i++) x -= calc(cnt[a[i]]), x += calc(++cnt[a[i]]);\n\t\t} else {\n\t\t\twhile (q.l < l) l--, x -= calc(cnt[a[l]]), x += calc(++cnt[a[l]]);\n\t\t\twhile (q.r > r) r++, x -= calc(cnt[a[r]]), x += calc(++cnt[a[r]]);\n\t\t\twhile (q.l > l) x -= calc(cnt[a[l]]), x += calc(--cnt[a[l]]), l++;\n\t\t\twhile (q.r < r) x -= calc(cnt[a[r]]), x += calc(--cnt[a[r]]), r--;\n\t\t}\n\n\t\tq.ans.a = x, q.ans.b = calc(q.r - q.l + 1);\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), a[i]--;\n\tfor (int i = 0; i < m; i++) scanf(\"%d %d\", &Q[i].l, &Q[i].r), Q[i].id = i;\n\n\tstd::sort(Q, Q + m, &compareByBlock);\n\twork();\n\tstd::sort(Q, Q + m, &compareById);\n\n\tfor (int i = 0; i < m; i++) Q[i].ans.print();\n\n\treturn 0;\n}\n```\n","slug":"bzoj-2038","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d6b01ibc2xlaiop41hs"},{"title":"BZOJ 1756 - ","id":"38","updated":"2016-01-24T15:24:35.000Z","date":"2016-01-24T15:19:48.000Z","_content":"\n `n`  `a`  `b`  `a``b` \n\n<!-- more -->\n\n### \n[BZOJ 1756](http://www.lydsy.com/JudgeOnline/problem.php?id=1756)\n\n### \n\n\n\n\n1. \n2. \n3. ****\n4. ****\n\n\n\n****\n\n\n\n `a``b`  `a`  `b` \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 100000;\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tint value, sum, lsum, rsum, maxSum;\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild) {}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (lchild) sum += lchild->sum;\n\t\t\tif (rchild) sum += rchild->sum;\n\n\t\t\tlsum = rsum = sum;\n\t\t\tif (lchild) {\n\t\t\t\tlsum = std::max(lsum, lchild->lsum);\n\t\t\t\tif (rchild) lsum = std::max(lsum, lchild->sum + rchild->lsum);\n\t\t\t}\n\t\t\tif (rchild) {\n\t\t\t\trsum = std::max(rsum, rchild->rsum);\n\t\t\t\tif (lchild) rsum = std::max(rsum, rchild->sum + lchild->rsum);\n\t\t\t}\n\n\t\t\tmaxSum = sum;\n\t\t\tmaxSum = std::max(maxSum, lsum);\n\t\t\tmaxSum = std::max(maxSum, rsum);\n\t\t\tif (lchild) maxSum = std::max(maxSum, lchild->maxSum);\n\t\t\tif (rchild) maxSum = std::max(maxSum, rchild->maxSum);\n\t\t\tif (lchild && rchild) maxSum = std::max(maxSum, lchild->rsum + rchild->lsum);\n\t\t}\n\n\t\tvoid query(int l, int r, int &sum, int &lsum, int &rsum, int &maxSum) {\n\t\t\tif (this->l > r || this->r < l) throw;\n\t\t\telse if (this->l >= l && this->r <= r) {\n\t\t\t\tsum = this->sum;\n\t\t\t\tlsum = this->lsum;\n\t\t\t\trsum = this->rsum;\n\t\t\t\tmaxSum = this->maxSum;\n\t\t\t} else {\n\t\t\t\tint mid = this->l + ((this->r - this->l) >> 1);\n\t\t\t\tif (r <= mid) return lchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\tif (l >= mid + 1) return rchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\telse {\n\t\t\t\t\tint suml, lsuml, rsuml, maxSuml;\n\t\t\t\t\tint sumr, lsumr, rsumr, maxSumr;\n\t\t\t\t\tlchild->query(l, r, suml, lsuml, rsuml, maxSuml);\n\t\t\t\t\trchild->query(l, r, sumr, lsumr, rsumr, maxSumr);\n\n\t\t\t\t\tmaxSum = sum = suml + sumr;\n\t\t\t\t\tlsum = std::max(lsuml, suml + lsumr);\n\t\t\t\t\trsum = std::max(rsumr, sumr + rsuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSumr);\n\t\t\t\t\tmaxSum = std::max(maxSum, lsumr + rsuml);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid update(int pos, int value) {\n\t\t\tif (this->l > pos || this->r < pos) return;\n\t\t\telse if (this->l == pos && this->r == pos) this->value = value, maintain();\n\t\t\telse {\n\t\t\t\tif (lchild) lchild->update(pos, value);\n\t\t\t\tif (rchild) rchild->update(pos, value);\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tvoid update(int pos, int value) {\n\t\troot->update(pos, value);\n\t}\n\n\tint query(int l, int r) {\n\t\tint sum, lsum, rsum, maxSum;\n\t\troot->query(l, r, sum, lsum, rsum, maxSum);\n\t\treturn maxSum;\n\t}\n};\n\nint main() {\n\tint n, m;\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tSegmentTree *segment = new SegmentTree(1, n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsegment->update(i, x);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\tif (k == 1) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", segment->query(std::min(l, r), std::max(l, r)));\n\t\t} else {\n\t\t\tint p, s;\n\t\t\tscanf(\"%d %d\", &p, &s);\n\t\t\tsegment->update(p, s);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1756.md","raw":"title: BZOJ 1756 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \n  - \n  - DP\npermalink: bzoj-1756\nid: 38\nupdated: '2016-01-24 23:24:35'\ndate: 2016-01-24 23:19:48\n---\n\n `n`  `a`  `b`  `a``b` \n\n<!-- more -->\n\n### \n[BZOJ 1756](http://www.lydsy.com/JudgeOnline/problem.php?id=1756)\n\n### \n\n\n\n\n1. \n2. \n3. ****\n4. ****\n\n\n\n****\n\n\n\n `a``b`  `a`  `b` \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 100000;\n\nstruct SegmentTree {\n\tstruct Node {\n\t\tNode *lchild, *rchild;\n\t\tint l, r;\n\t\tint value, sum, lsum, rsum, maxSum;\n\n\t\tNode(int l, int r, Node *lchild, Node *rchild) : l(l), r(r), lchild(lchild), rchild(rchild) {}\n\n\t\tvoid maintain() {\n\t\t\tsum = value;\n\t\t\tif (lchild) sum += lchild->sum;\n\t\t\tif (rchild) sum += rchild->sum;\n\n\t\t\tlsum = rsum = sum;\n\t\t\tif (lchild) {\n\t\t\t\tlsum = std::max(lsum, lchild->lsum);\n\t\t\t\tif (rchild) lsum = std::max(lsum, lchild->sum + rchild->lsum);\n\t\t\t}\n\t\t\tif (rchild) {\n\t\t\t\trsum = std::max(rsum, rchild->rsum);\n\t\t\t\tif (lchild) rsum = std::max(rsum, rchild->sum + lchild->rsum);\n\t\t\t}\n\n\t\t\tmaxSum = sum;\n\t\t\tmaxSum = std::max(maxSum, lsum);\n\t\t\tmaxSum = std::max(maxSum, rsum);\n\t\t\tif (lchild) maxSum = std::max(maxSum, lchild->maxSum);\n\t\t\tif (rchild) maxSum = std::max(maxSum, rchild->maxSum);\n\t\t\tif (lchild && rchild) maxSum = std::max(maxSum, lchild->rsum + rchild->lsum);\n\t\t}\n\n\t\tvoid query(int l, int r, int &sum, int &lsum, int &rsum, int &maxSum) {\n\t\t\tif (this->l > r || this->r < l) throw;\n\t\t\telse if (this->l >= l && this->r <= r) {\n\t\t\t\tsum = this->sum;\n\t\t\t\tlsum = this->lsum;\n\t\t\t\trsum = this->rsum;\n\t\t\t\tmaxSum = this->maxSum;\n\t\t\t} else {\n\t\t\t\tint mid = this->l + ((this->r - this->l) >> 1);\n\t\t\t\tif (r <= mid) return lchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\tif (l >= mid + 1) return rchild->query(l, r, sum, lsum, rsum, maxSum);\n\t\t\t\telse {\n\t\t\t\t\tint suml, lsuml, rsuml, maxSuml;\n\t\t\t\t\tint sumr, lsumr, rsumr, maxSumr;\n\t\t\t\t\tlchild->query(l, r, suml, lsuml, rsuml, maxSuml);\n\t\t\t\t\trchild->query(l, r, sumr, lsumr, rsumr, maxSumr);\n\n\t\t\t\t\tmaxSum = sum = suml + sumr;\n\t\t\t\t\tlsum = std::max(lsuml, suml + lsumr);\n\t\t\t\t\trsum = std::max(rsumr, sumr + rsuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSuml);\n\t\t\t\t\tmaxSum = std::max(maxSum, maxSumr);\n\t\t\t\t\tmaxSum = std::max(maxSum, lsumr + rsuml);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid update(int pos, int value) {\n\t\t\tif (this->l > pos || this->r < pos) return;\n\t\t\telse if (this->l == pos && this->r == pos) this->value = value, maintain();\n\t\t\telse {\n\t\t\t\tif (lchild) lchild->update(pos, value);\n\t\t\t\tif (rchild) rchild->update(pos, value);\n\t\t\t\tmaintain();\n\t\t\t}\n\t\t}\n\t} *root;\n\n\tSegmentTree(int l, int r) {\n\t\troot = build(l, r);\n\t}\n\n\tNode *build(int l, int r) {\n\t\tif (l > r) return NULL;\n\t\telse if (l == r) return new Node(l, r, NULL, NULL);\n\t\telse return new Node(l, r, build(l, l + ((r - l) >> 1)), build(l + ((r - l) >> 1) + 1, r));\n\t}\n\n\tvoid update(int pos, int value) {\n\t\troot->update(pos, value);\n\t}\n\n\tint query(int l, int r) {\n\t\tint sum, lsum, rsum, maxSum;\n\t\troot->query(l, r, sum, lsum, rsum, maxSum);\n\t\treturn maxSum;\n\t}\n};\n\nint main() {\n\tint n, m;\n\n\tscanf(\"%d %d\", &n, &m);\n\n\tSegmentTree *segment = new SegmentTree(1, n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tsegment->update(i, x);\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\tif (k == 1) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", segment->query(std::min(l, r), std::max(l, r)));\n\t\t} else {\n\t\t\tint p, s;\n\t\t\tscanf(\"%d %d\", &p, &s);\n\t\t\tsegment->update(p, s);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1756","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d6i01ihc2xlgy6da0el"},{"title":"BZOJ 1711Dining - ","date":"2016-06-21T14:17:00.000Z","_content":"\n $ F $$ 1 \\leq F \\leq 100 $ $ D $$ 1 \\leq D \\leq 100 $$ N $$ 1 \\leq N \\leq 100 $\n\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1711](http://www.lydsy.com/JudgeOnline/problem.php?id=1711)\n\n### \n $ A $  $ A' $ $ A $  $ A' $ \n\n\n\n $ 1 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * 2 + MAXM * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m1, m2;\n\tscanf(\"%d %d %d\", &n, &m1, &m2);\n\n\tconst int s = 0, t = n * 2 + m1 + m2 + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1);\n\tfor (int i = n + n + 1; i <= n + n + m1; i++) addEdge(s, i, 1);\n\tfor (int i = n + n + m1 + 1; i <= n + n + m1 + m2; i++) addEdge(i, t, 1);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint k1, k2;\n\t\tscanf(\"%d %d\", &k1, &k2);\n\n\t\tfor (int j = 0; j < k1; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(n + n + x, i, 1);\n\t\t}\n\n\t\tfor (int j = 0; j < k2; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(i + n, n + n + m1 + x, 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * 2 + m1 + m2 + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1711.md","raw":"title: BZOJ 1711Dining - \ndate: 2016-06-21 22:17:00\ncategories: OI\ntags:\n  - BZOJ\n  - USACO\n  - \n  - Dinic\npermalink: bzoj-1711\n---\n\n $ F $$ 1 \\leq F \\leq 100 $ $ D $$ 1 \\leq D \\leq 100 $$ N $$ 1 \\leq N \\leq 100 $\n\n\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1711](http://www.lydsy.com/JudgeOnline/problem.php?id=1711)\n\n### \n $ A $  $ A' $ $ A $  $ A' $ \n\n\n\n $ 1 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100;\nconst int MAXM = 100;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * 2 + MAXM * 2 + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->f < e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->f < e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c - e->f));\n\t\t\tif (f) {\n\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint s, t;\n\nint main() {\n\tint n, m1, m2;\n\tscanf(\"%d %d %d\", &n, &m1, &m2);\n\n\tconst int s = 0, t = n * 2 + m1 + m2 + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1);\n\tfor (int i = n + n + 1; i <= n + n + m1; i++) addEdge(s, i, 1);\n\tfor (int i = n + n + m1 + 1; i <= n + n + m1 + m2; i++) addEdge(i, t, 1);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tint k1, k2;\n\t\tscanf(\"%d %d\", &k1, &k2);\n\n\t\tfor (int j = 0; j < k1; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(n + n + x, i, 1);\n\t\t}\n\n\t\tfor (int j = 0; j < k2; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\taddEdge(i + n, n + n + m1 + x, 1);\n\t\t}\n\t}\n\n\tint maxFlow = dinic(s, t, n * 2 + m1 + m2 + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1711","published":1,"updated":"2016-10-08T09:04:46.235Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d6q01ioc2xlm4phfqr2"},{"title":"BZOJ 1706 - ","date":"2016-10-07T23:11:00.000Z","_content":"\n $ s $  $ t $  $ k $ \n\n<!-- more -->\n\n### \n[BZOJ 1586](www.lydsy.com/JudgeOnline/problem.php?id=1586)  \n[COGS 1470](http://cogs.pro/cogs/problem/problem.php?pid=1470)\n\n### \n $ k $  $ k $ \n\n $ 0 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 100;\nconst int MAXN_SMALL = 200;\nconst int MAXK = 1000000;\n\nstruct Matrix {\n\tint a[MAXN_SMALL][MAXN_SMALL];\n\n\tMatrix(const bool unit = false) {\n\t\tfor (int i = 0; i < MAXN_SMALL; i++) for (int j = 0; j < MAXN_SMALL; j++) a[i][j] = INT_MAX;\n\t\tif (unit) for (int i = 0; i < MAXN_SMALL; i++) a[i][i] = 0;\n\t}\n\n\tint &operator()(const int i, const int j) { return a[i][j]; }\n\tconst int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXN_SMALL; i++) for (int j = 0; j < MAXN_SMALL; j++) for (int k = 0; k < MAXN_SMALL; k++) if (a(i, k) != INT_MAX && b(k, j) != INT_MAX) res(i, j) = std::min(res(i, j), a(i, k) + b(k, j));\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"relays.in\", \"r\", stdin);\n\tfreopen(\"relays.out\", \"w\", stdout);\n\n\tint n, m, s, t, cnt;\n\tstatic int set[MAXM * 2];\n\tscanf(\"%d %d %d %d\", &n, &m, &s, &t);\n\n\tstatic struct {\n\t\tint u, v, w;\n\t} E[MAXM];\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d\", &E[i].w, &E[i].u, &E[i].v);\n\t\tset[i] = E[i].u;\n\t\tset[i + m] = E[i].v;\n\t}\n\n\tstd::sort(set, set + m * 2);\n\tint *end = std::unique(set, set + m * 2);\n\tcnt = end - set;\n\n\tMatrix g(false);\n\tfor (int i = 0; i < m; i++) {\n\t\tE[i].u = std::lower_bound(set, end, E[i].u) - set;\n\t\tE[i].v = std::lower_bound(set, end, E[i].v) - set;\n\t\tg(E[i].u, E[i].v) = g(E[i].v, E[i].u) = E[i].w;\n\t}\n\ts = std::lower_bound(set, end, s) - set;\n\tt = std::lower_bound(set, end, t) - set;\n\n\tMatrix res = pow(g, n);\n\t/*\n\tMatrix res(true);\n\tfor (int i = 0; i < n; i++) {\n\t\tres = res * g;\n\t\tfor (int i = 0; i < cnt; i++) for (int j = 0; j < cnt; j++) printf(\"%d%c\", res(i, j), j == cnt - 1 ? '\\n' : ' ');\n\t\tputs(\"-------------------\");\n\t}\n\t*/\n\n\tprintf(\"%d\\n\", res(s, t));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-1706.md","raw":"title: BZOJ 1706 - \ndate: 2016-10-08 07:11:00\ncategories: OI\ntags:\n  - BZOJ\n  - COGS\n  - USACO\n  - \npermalink: bzoj-1706\n---\n\n $ s $  $ t $  $ k $ \n\n<!-- more -->\n\n### \n[BZOJ 1586](www.lydsy.com/JudgeOnline/problem.php?id=1586)  \n[COGS 1470](http://cogs.pro/cogs/problem/problem.php?pid=1470)\n\n### \n $ k $  $ k $ \n\n $ 0 $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 1000;\nconst int MAXM = 100;\nconst int MAXN_SMALL = 200;\nconst int MAXK = 1000000;\n\nstruct Matrix {\n\tint a[MAXN_SMALL][MAXN_SMALL];\n\n\tMatrix(const bool unit = false) {\n\t\tfor (int i = 0; i < MAXN_SMALL; i++) for (int j = 0; j < MAXN_SMALL; j++) a[i][j] = INT_MAX;\n\t\tif (unit) for (int i = 0; i < MAXN_SMALL; i++) a[i][i] = 0;\n\t}\n\n\tint &operator()(const int i, const int j) { return a[i][j]; }\n\tconst int &operator()(const int i, const int j) const { return a[i][j]; }\n};\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < MAXN_SMALL; i++) for (int j = 0; j < MAXN_SMALL; j++) for (int k = 0; k < MAXN_SMALL; k++) if (a(i, k) != INT_MAX && b(k, j) != INT_MAX) res(i, j) = std::min(res(i, j), a(i, k) + b(k, j));\n\treturn res;\n}\n\nMatrix pow(Matrix a, int n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\n\nint main() {\n\tfreopen(\"relays.in\", \"r\", stdin);\n\tfreopen(\"relays.out\", \"w\", stdout);\n\n\tint n, m, s, t, cnt;\n\tstatic int set[MAXM * 2];\n\tscanf(\"%d %d %d %d\", &n, &m, &s, &t);\n\n\tstatic struct {\n\t\tint u, v, w;\n\t} E[MAXM];\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d\", &E[i].w, &E[i].u, &E[i].v);\n\t\tset[i] = E[i].u;\n\t\tset[i + m] = E[i].v;\n\t}\n\n\tstd::sort(set, set + m * 2);\n\tint *end = std::unique(set, set + m * 2);\n\tcnt = end - set;\n\n\tMatrix g(false);\n\tfor (int i = 0; i < m; i++) {\n\t\tE[i].u = std::lower_bound(set, end, E[i].u) - set;\n\t\tE[i].v = std::lower_bound(set, end, E[i].v) - set;\n\t\tg(E[i].u, E[i].v) = g(E[i].v, E[i].u) = E[i].w;\n\t}\n\ts = std::lower_bound(set, end, s) - set;\n\tt = std::lower_bound(set, end, t) - set;\n\n\tMatrix res = pow(g, n);\n\t/*\n\tMatrix res(true);\n\tfor (int i = 0; i < n; i++) {\n\t\tres = res * g;\n\t\tfor (int i = 0; i < cnt; i++) for (int j = 0; j < cnt; j++) printf(\"%d%c\", res(i, j), j == cnt - 1 ? '\\n' : ' ');\n\t\tputs(\"-------------------\");\n\t}\n\t*/\n\n\tprintf(\"%d\\n\", res(s, t));\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```","slug":"bzoj-1706","published":1,"updated":"2016-10-07T23:18:48.043Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d6z01iuc2xl49p5bf0a"},{"title":"BZOJ 1692 -  + ","date":"2016-09-29T13:33:00.000Z","_content":"\n $ S $ $ T $  $ T $\n\n<!-- more -->\n\n### \n[BZOJ 1692](http://www.lydsy.com/JudgeOnline/problem.php?id=1692)\n\n### \n\n\n\n\n 80 \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 50000;\nconst int MAXLEN = 100000;\n\nstruct Trie {\n\tstruct Node {\n\t\tstd::map<int, Node *> c;\n\t\tNode *fail, *next;\n\t\tint wordCnt, ts, ans;\n\n\t\tNode(const int wordCnt = 0) : fail(NULL), next(NULL), wordCnt(wordCnt), ts(0), ans(0) {}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"insert: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tNode **v = &root;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(1);\n\t\telse /*assert((*v)->isWord == false), */(*v)->wordCnt++;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (std::map<int, Node *>::iterator it = v->c.begin(); it != v->c.end(); it++) {\n\t\t\t\tNode *&c = it->second, *u = v->fail;\n\t\t\t\twhile (u != root && u->c.find(it->first) == u->c.end()) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c.find(it->first) != u->c.end() ? u->c[it->first] : root;\n\t\t\t\tc->next = c->fail->wordCnt ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tint exec(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"exec: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tstatic int ts = 0;\n\t\t++ts;\n\t\tNode *v = root;\n\t\tint ans = 0;\n\t\tstatic int sumAns = 0;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\twhile (v != root && v->c.find(*p) == v->c.end()) v = v->fail;\n\t\t\tstd::map<int, Node *>::iterator it;\n\t\t\tif ((it = v->c.find(*p)) != v->c.end()) v = it->second;\n\t\t\t// if (it != v->c.end()) v = it->second;\n\t\t\tNode *u = v->wordCnt ? v : v->next;\n\t\t\twhile (u) {\n#ifdef DBG\n\t\t\t\tprintf(\"apply(%lu)\\n\", u);\n#endif\n\t\t\t\tif (u->ts != ts) {\n\t\t\t\t\tu->ts = ts;\n\t\t\t\t\tu->ans++;\n\t\t\t\t\tans += u->wordCnt;\n\t\t\t\t\tsumAns++;\n\t\t\t\t\t// printf(\"- %d %d\\n\", u->ans, ans);\n\t\t\t\t\tu = u->next;\n\t\t\t\t} else break;\n\t\t\t}\n\t\t}\n\t\t// printf(\"sumAns = %d\\n\", sumAns);\n\t\treturn ans;\n\t}\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int buf[MAXN * 2 + MAXLEN], set[MAXLEN];\n\tint cnt = 0;\n\tfor (int i = 0, tot = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n#ifdef DBG\n\t\t\tprintf(\"--- %d ---\\n\", l);\n#endif\n\t\t\tbuf[tot++] = l;\n\t\t\tfor (int k = 0; k < l; k++) {\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tbuf[tot++] = set[cnt++] = x;\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(set, set + cnt);\n\tint *end = std::unique(set, set + cnt);\n\n\tstatic Trie::Node *a[MAXM];\n\tfor (int i = 0; i < m; i++) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\t\tstatic int buf[MAXLEN];\n\t\tbool invalid = false;\n\t\tfor (int j = 0; j < l; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\t/*\n\t\t\tif (i == 1354 - 1) {\n\t\t\t\tprintf(\"(%d)\\n\", x);\n\t\t\t}\n\t\t\t*/\n\t\t\tint *p = std::lower_bound(set, end, x);\n\t\t\tif (p == end || *p != x) {\n\t\t\t\tinvalid = true;\n\t\t\t}\n\t\t\tbuf[j] = p - set;\n\t\t}\n\t\tif (!invalid) a[i] = t.insert(buf, buf + l);\n\t\telse a[i] = NULL;\n\t\t/*\n\t\tif (i == 1354 - 1) {\n\t\t\tprintf(\"1354: \");\n\t\t\tfor (int i = 0; i < l; i++) printf(\"%d%c\", buf[i], i == l - 1 ? '\\n' : ' ');\n\t\t}\n\t\t*/\n\t}\n\n\tt.build();\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0, pos = 0; i < n; i++) {\n\t\tstatic int buf2[MAXLEN + 1];\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (j == 1) buf2[cnt++] = -1;\n\t\t\tint l = buf[pos++];\n\t\t\t// printf(\"- \");\n\t\t\tfor (int k = 0; k < l; k++) buf2[cnt++] = std::lower_bound(set, end, buf[pos++]) - set; // , printf(\"%d \", buf2[cnt - 1]);\n\t\t\t// putchar('\\n');\n\t\t}\n\t\tans[i] = t.exec(buf2, buf2 + cnt);\n\t}\n\n\tint sum1 = 0, sum2 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tsum1 += a[i] ? a[i]->ans : 0;\n\t\t// if (i == 1354 - 1) putchar('*');\n\t\tprintf(\"%d\\n\", a[i] ? a[i]->ans : 0);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsum2 += ans[i];\n\t\tprintf(\"%d%c\", ans[i], i == n - 1 ? '\\n' : ' ');\n\t}\n\n\t// printf(\"%d %d\\n\", sum1, sum2);\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-1692.md","raw":"title: BZOJ 1692 -  + \ncategories: OI\ntags: \n  - BZOJ\n  - USACO\n  - \n  - \n  - \npermalink: bzoj-1692\ndate: 2016-09-29 21:33:00\n---\n\n $ S $ $ T $  $ T $\n\n<!-- more -->\n\n### \n[BZOJ 1692](http://www.lydsy.com/JudgeOnline/problem.php?id=1692)\n\n### \n\n\n\n\n 80 \n\n### \n```c++\n#include <cstdio>\n#include <cassert>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 20000;\nconst int MAXM = 50000;\nconst int MAXLEN = 100000;\n\nstruct Trie {\n\tstruct Node {\n\t\tstd::map<int, Node *> c;\n\t\tNode *fail, *next;\n\t\tint wordCnt, ts, ans;\n\n\t\tNode(const int wordCnt = 0) : fail(NULL), next(NULL), wordCnt(wordCnt), ts(0), ans(0) {}\n\t} *root;\n\n\tTrie() : root(NULL) {}\n\n\tNode *insert(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"insert: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tNode **v = &root;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(1);\n\t\telse /*assert((*v)->isWord == false), */(*v)->wordCnt++;\n\t\treturn *v;\n\t}\n\n\tvoid build() {\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root, root->next = NULL;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (std::map<int, Node *>::iterator it = v->c.begin(); it != v->c.end(); it++) {\n\t\t\t\tNode *&c = it->second, *u = v->fail;\n\t\t\t\twhile (u != root && u->c.find(it->first) == u->c.end()) u = u->fail;\n\t\t\t\tc->fail = v != root && u->c.find(it->first) != u->c.end() ? u->c[it->first] : root;\n\t\t\t\tc->next = c->fail->wordCnt ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tint exec(const int *begin, const int *end) {\n#ifdef DBG\n\t\tputs(\"exec: \");\n\t\tfor (const int *p = begin; p != end; p++) printf(\"%d%c\", *p, p == end - 1 ? '\\n' : ' ');\n#endif\n\t\tstatic int ts = 0;\n\t\t++ts;\n\t\tNode *v = root;\n\t\tint ans = 0;\n\t\tstatic int sumAns = 0;\n\t\tfor (const int *p = begin; p != end; p++) {\n\t\t\twhile (v != root && v->c.find(*p) == v->c.end()) v = v->fail;\n\t\t\tstd::map<int, Node *>::iterator it;\n\t\t\tif ((it = v->c.find(*p)) != v->c.end()) v = it->second;\n\t\t\t// if (it != v->c.end()) v = it->second;\n\t\t\tNode *u = v->wordCnt ? v : v->next;\n\t\t\twhile (u) {\n#ifdef DBG\n\t\t\t\tprintf(\"apply(%lu)\\n\", u);\n#endif\n\t\t\t\tif (u->ts != ts) {\n\t\t\t\t\tu->ts = ts;\n\t\t\t\t\tu->ans++;\n\t\t\t\t\tans += u->wordCnt;\n\t\t\t\t\tsumAns++;\n\t\t\t\t\t// printf(\"- %d %d\\n\", u->ans, ans);\n\t\t\t\t\tu = u->next;\n\t\t\t\t} else break;\n\t\t\t}\n\t\t}\n\t\t// printf(\"sumAns = %d\\n\", sumAns);\n\t\treturn ans;\n\t}\n} t;\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tstatic int buf[MAXN * 2 + MAXLEN], set[MAXLEN];\n\tint cnt = 0;\n\tfor (int i = 0, tot = 0; i < n; i++) {\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tint l;\n\t\t\tscanf(\"%d\", &l);\n#ifdef DBG\n\t\t\tprintf(\"--- %d ---\\n\", l);\n#endif\n\t\t\tbuf[tot++] = l;\n\t\t\tfor (int k = 0; k < l; k++) {\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tbuf[tot++] = set[cnt++] = x;\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(set, set + cnt);\n\tint *end = std::unique(set, set + cnt);\n\n\tstatic Trie::Node *a[MAXM];\n\tfor (int i = 0; i < m; i++) {\n\t\tint l;\n\t\tscanf(\"%d\", &l);\n\t\tstatic int buf[MAXLEN];\n\t\tbool invalid = false;\n\t\tfor (int j = 0; j < l; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\t/*\n\t\t\tif (i == 1354 - 1) {\n\t\t\t\tprintf(\"(%d)\\n\", x);\n\t\t\t}\n\t\t\t*/\n\t\t\tint *p = std::lower_bound(set, end, x);\n\t\t\tif (p == end || *p != x) {\n\t\t\t\tinvalid = true;\n\t\t\t}\n\t\t\tbuf[j] = p - set;\n\t\t}\n\t\tif (!invalid) a[i] = t.insert(buf, buf + l);\n\t\telse a[i] = NULL;\n\t\t/*\n\t\tif (i == 1354 - 1) {\n\t\t\tprintf(\"1354: \");\n\t\t\tfor (int i = 0; i < l; i++) printf(\"%d%c\", buf[i], i == l - 1 ? '\\n' : ' ');\n\t\t}\n\t\t*/\n\t}\n\n\tt.build();\n\n\tstatic int ans[MAXN];\n\tfor (int i = 0, pos = 0; i < n; i++) {\n\t\tstatic int buf2[MAXLEN + 1];\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < 2; j++) {\n\t\t\tif (j == 1) buf2[cnt++] = -1;\n\t\t\tint l = buf[pos++];\n\t\t\t// printf(\"- \");\n\t\t\tfor (int k = 0; k < l; k++) buf2[cnt++] = std::lower_bound(set, end, buf[pos++]) - set; // , printf(\"%d \", buf2[cnt - 1]);\n\t\t\t// putchar('\\n');\n\t\t}\n\t\tans[i] = t.exec(buf2, buf2 + cnt);\n\t}\n\n\tint sum1 = 0, sum2 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tsum1 += a[i] ? a[i]->ans : 0;\n\t\t// if (i == 1354 - 1) putchar('*');\n\t\tprintf(\"%d\\n\", a[i] ? a[i]->ans : 0);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tsum2 += ans[i];\n\t\tprintf(\"%d%c\", ans[i], i == n - 1 ? '\\n' : ' ');\n\t}\n\n\t// printf(\"%d %d\\n\", sum1, sum2);\n\n\treturn 0;\n}\n```","slug":"bzoj-1692","published":1,"updated":"2016-09-29T13:45:54.344Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d7601j0c2xlmzabz6k6"},{"title":"BZOJ 1597 -  DP","date":"2016-05-18T09:04:00.000Z","_content":"\n John  $ N $$ 1 \\leq N \\leq 50000 $$ 1 \\leq $  $ \\leq 1000000 $ FJ  FJ  $ 3 \\times 5 $  $ 5 \\times 3 $  $ 5 \\times 5 = 25 $FJ \n\n<!-- more -->\n\n### \n[BZOJ 1597](http://www.lydsy.com/JudgeOnline/problem.php?id=1597)\n\n### \n\n\n $ w(i) $  $ h(i) $  $ f(i) $  $ i $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + w(j + 1) \\times h(i) \\} $$\n\n $ a $$ b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\nf(a) + w(a + 1) \\times h(i) & < f(b) + w(b + 1) \\times h(i) \\\\\nf(a) + f(b) & < (w(b + 1) - w(a + 1)) \\times h(i) \\\\\nf(a) + f(b) \\over w(b + 1) - w(a + 1) & < h(i) \\\\\n\\end{align*}\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <utility>\n#include <functional>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 50000;\n\nstd::pair<int, int> A[MAXN];\nstd::vector< std::pair<int, int>* > vec;\n\nint n;\nlong long f[MAXN + 1];\n\ninline void prepare() {\n    std::sort(A, A + n, std::greater< std::pair<int, int> >());\n\n    std::pair<int, int> *last = NULL;\n    for (int i = 0; i < n; i++) {\n        if (!last || A[i].second > last->second) {\n            vec.push_back(&A[i]);\n            last = &A[i];\n        }\n    }\n\n    n = vec.size();\n}\n\ninline long long w(const int i) { return static_cast<long long>(vec[i - 1]->first); }\ninline long long h(const int i) { return static_cast<long long>(vec[i - 1]->second); }\n\ninline void force() {\n    f[0] = 0;\n    std::fill(f + 1, f + n + 1, LLONG_MAX);\n    for (int i = 1; i <= n; i++) {\n        int _j = -1;\n        for (int j = 0; j < i; j++) {\n            if (f[i] > f[j] + w(j + 1) * h(i)) {\n                f[i] = f[j] + w(j + 1) * h(i);\n                _j = j;\n            }\n        }\n        // printf(\"%d --> %d\\n\", i, _j);\n    }\n}\n\ninline double slope(const int a, const int b) {\n    return double(f[a] - f[b])\n         / double(w(b + 1) - w(a + 1));\n}\n\ninline void dp() {\n    f[0] = 0;\n    std::fill(f + 1, f + n + 1, LLONG_MAX);\n\n    static int q[MAXN + 1];\n    int *l = &q[0], *r = &q[0];\n    *r = 0;\n\n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) < h(i)) l++;\n\n        int tmp = *l;\n        f[i] = f[tmp] + w(tmp + 1) * h(i);\n        // printf(\"%d --> %d\\n\", i, tmp);\n\n        if (i != n) {\n            while (l < r && slope(*r, *(r - 1)) > slope(*r, i)) r--;\n            *++r = i;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) scanf(\"%d %d\", &A[i].first, &A[i].second);\n\n    prepare();\n    // for (int i = 0; i < n; i++) printf(\"%d %d\\n\", vec[i]->first, vec[i]->second);\n\n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n\n    return 0;\n}\n```\n","source":"_posts/bzoj-1597.md","raw":"title: BZOJ 1597 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - DP\n  - \n  - \npermalink: bzoj-1597\ndate: 2016-05-18 17:04:00\n---\n\n John  $ N $$ 1 \\leq N \\leq 50000 $$ 1 \\leq $  $ \\leq 1000000 $ FJ  FJ  $ 3 \\times 5 $  $ 5 \\times 3 $  $ 5 \\times 5 = 25 $FJ \n\n<!-- more -->\n\n### \n[BZOJ 1597](http://www.lydsy.com/JudgeOnline/problem.php?id=1597)\n\n### \n\n\n $ w(i) $  $ h(i) $  $ f(i) $  $ i $  $ i $ \n\n$$ f(i) = \\min\\limits_{j = 0} ^ {i - 1} \\{ f(j) + w(j + 1) \\times h(i) \\} $$\n\n $ a $$ b $ $ a $  $ b $ \n\n$$\n\\begin{align*}\nf(a) + w(a + 1) \\times h(i) & < f(b) + w(b + 1) \\times h(i) \\\\\nf(a) + f(b) & < (w(b + 1) - w(a + 1)) \\times h(i) \\\\\nf(a) + f(b) \\over w(b + 1) - w(a + 1) & < h(i) \\\\\n\\end{align*}\n$$\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <utility>\n#include <functional>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 50000;\n\nstd::pair<int, int> A[MAXN];\nstd::vector< std::pair<int, int>* > vec;\n\nint n;\nlong long f[MAXN + 1];\n\ninline void prepare() {\n    std::sort(A, A + n, std::greater< std::pair<int, int> >());\n\n    std::pair<int, int> *last = NULL;\n    for (int i = 0; i < n; i++) {\n        if (!last || A[i].second > last->second) {\n            vec.push_back(&A[i]);\n            last = &A[i];\n        }\n    }\n\n    n = vec.size();\n}\n\ninline long long w(const int i) { return static_cast<long long>(vec[i - 1]->first); }\ninline long long h(const int i) { return static_cast<long long>(vec[i - 1]->second); }\n\ninline void force() {\n    f[0] = 0;\n    std::fill(f + 1, f + n + 1, LLONG_MAX);\n    for (int i = 1; i <= n; i++) {\n        int _j = -1;\n        for (int j = 0; j < i; j++) {\n            if (f[i] > f[j] + w(j + 1) * h(i)) {\n                f[i] = f[j] + w(j + 1) * h(i);\n                _j = j;\n            }\n        }\n        // printf(\"%d --> %d\\n\", i, _j);\n    }\n}\n\ninline double slope(const int a, const int b) {\n    return double(f[a] - f[b])\n         / double(w(b + 1) - w(a + 1));\n}\n\ninline void dp() {\n    f[0] = 0;\n    std::fill(f + 1, f + n + 1, LLONG_MAX);\n\n    static int q[MAXN + 1];\n    int *l = &q[0], *r = &q[0];\n    *r = 0;\n\n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) < h(i)) l++;\n\n        int tmp = *l;\n        f[i] = f[tmp] + w(tmp + 1) * h(i);\n        // printf(\"%d --> %d\\n\", i, tmp);\n\n        if (i != n) {\n            while (l < r && slope(*r, *(r - 1)) > slope(*r, i)) r--;\n            *++r = i;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) scanf(\"%d %d\", &A[i].first, &A[i].second);\n\n    prepare();\n    // for (int i = 0; i < n; i++) printf(\"%d %d\\n\", vec[i]->first, vec[i]->second);\n\n    // force();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n\n    return 0;\n}\n```\n","slug":"bzoj-1597","published":1,"updated":"2016-10-24T23:38:54.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d7e01j7c2xlgu6jo6vq"},{"title":"BZOJ 1585Earthquake Damage 2 - ","date":"2016-06-22T08:14:00.000Z","_content":"\n $ P $  $ C $  $ i $  $ A_i $  $ B_i $ $ A_i $ $ B_i $ $ A_i $  $ B_i $ Farmer John  $ 1 $ $ C $  $ N $  $ i $  $ R_i $ $ R_i $  $ R_i $  $ 1 $  Farmer John \n\n<!-- more -->\n\n### \n[BZOJ 1585](http://www.lydsy.com/JudgeOnline/problem.php?id=1585)\n\n### \n $ 1 $ $ R_i $ $ 1 $ \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 3000;\nconst int MAXM = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tconst int s = 0, t = n + n + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u + n, v, INT_MAX);\n\t\taddEdge(v + n, u, INT_MAX);\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint u;\n\t\tscanf(\"%d\", &u);\n\n\t\taddEdge(s, u + n, INT_MAX);\n\t}\n\n\taddEdge(1, t, INT_MAX);\n\n\tint maxFlow = dinic(s, t, n + n + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1585.md","raw":"title: BZOJ 1585Earthquake Damage 2 - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - Dinic\n  - \n  - USACO\npermalink: bzoj-1585\ndate: 2016-06-22 16:14:00\n---\n\n $ P $  $ C $  $ i $  $ A_i $  $ B_i $ $ A_i $ $ B_i $ $ A_i $  $ B_i $ Farmer John  $ 1 $ $ C $  $ N $  $ i $  $ R_i $ $ R_i $  $ R_i $  $ 1 $  Farmer John \n\n<!-- more -->\n\n### \n[BZOJ 1585](http://www.lydsy.com/JudgeOnline/problem.php?id=1585)\n\n### \n $ 1 $ $ R_i $ $ 1 $ \n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 3000;\nconst int MAXM = 20000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * 2 + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->l && e->c) {\n\t\t\t\te->t->l = v->l + 1;\n\t\t\t\tif (e->t == t) return true;\n\t\t\t\telse q.push(e->t);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\n\t\tfor (Edge *&e = s->c; e; e = e->next) if (e->t->l == s->l + 1 && e->c) {\n\t\t\tint f = findPath(e->t, t, std::min(limit, e->c));\n\t\t\tif (f) {\n\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) res += f;\n\t\t}\n\n\t\treturn res;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\t(N[s].e->r = N[t].e)->r = N[s].e;\n}\n\nint main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\n\tconst int s = 0, t = n + n + 1;\n\n\tfor (int i = 1; i <= n; i++) addEdge(i, i + n, 1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\n\t\taddEdge(u + n, v, INT_MAX);\n\t\taddEdge(v + n, u, INT_MAX);\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint u;\n\t\tscanf(\"%d\", &u);\n\n\t\taddEdge(s, u + n, INT_MAX);\n\t}\n\n\taddEdge(1, t, INT_MAX);\n\n\tint maxFlow = dinic(s, t, n + n + 2);\n\tprintf(\"%d\\n\", maxFlow);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1585","published":1,"updated":"2016-06-22T08:14:52.252Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d7l01jdc2xl017bwp1z"},{"title":"BZOJ 1477 - ","date":"2016-01-23T15:20:01.000Z","_content":"\n A  B 0  1  A  x B  y A  m  B  n  L \n\n<!-- more -->\n\n### \n[BZOJ 1477](http://www.lydsy.com/JudgeOnline/problem.php?id=1477)  \n[Tyvj 2366](http://tyvj.cn/p/2366)\n\n### \n $t$ \n\n$$ \\cases{x+tm=k_{1}*L \\\\ y+tn=k_{2}*L} $$\n\n $k=k_{1}-k_{2}$\n\n$$ (x+tm)-(y+tn)=kL $$\n\n\n$$\n(x-y)+(m-n)t=kL \\\\\n(m-n)t+(-L)k=y-x\n$$\n\n****\n\n\n\n### \n```cpp\n#include <cstdio>\n\nconst long long MAXX = 2000000000;\nconst long long MAXY = 2000000000;\nconst long long MAXN = 2000000000;\nconst long long MAXM = 2000000000;\nconst long long MAXL = 2100000000;\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\ninline bool solve(long long a, long long b, long long c, long long &x, long long &y) {\n\tif (b < 0) a = -a, b = -b, c = -c;\n\tlong long g;\n\texgcd(a, b, g, x, y);\n\tif (c % g != 0) return false;\n\tx = x * c / g;\n\ty = y * c / g;\n\tlong long newx = ((x % b) + b) % b;\n\ty = y - ((newx - x) / (b / g)) * (a / g);\n\tx = newx;\n\treturn true;\n}\n\nint main() {\n\tlong long x, y, m, n, l;\n\tscanf(\"%lld %lld %lld %lld %lld\", &x, &y, &m, &n, &l);\n\n\tlong long t, k;\n\n\tif (!solve(m - n, -l, y - x, t, k)) puts(\"Impossible\");\n\telse printf(\"%lld\\n\", t);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1477.md","raw":"title: BZOJ 1477 - \ncategories: OI\ntags: \n  - BZOJ\n  - Tyvj\n  - EXGCD\n  - \npermalink: bzoj-1477\ndate: 2016-01-23 23:20:01\n---\n\n A  B 0  1  A  x B  y A  m  B  n  L \n\n<!-- more -->\n\n### \n[BZOJ 1477](http://www.lydsy.com/JudgeOnline/problem.php?id=1477)  \n[Tyvj 2366](http://tyvj.cn/p/2366)\n\n### \n $t$ \n\n$$ \\cases{x+tm=k_{1}*L \\\\ y+tn=k_{2}*L} $$\n\n $k=k_{1}-k_{2}$\n\n$$ (x+tm)-(y+tn)=kL $$\n\n\n$$\n(x-y)+(m-n)t=kL \\\\\n(m-n)t+(-L)k=y-x\n$$\n\n****\n\n\n\n### \n```cpp\n#include <cstdio>\n\nconst long long MAXX = 2000000000;\nconst long long MAXY = 2000000000;\nconst long long MAXN = 2000000000;\nconst long long MAXM = 2000000000;\nconst long long MAXL = 2100000000;\n\nvoid exgcd(long long a, long long b, long long &g, long long &x, long long &y) {\n\tif (b == 0) {\n\t\tg = a;\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, g, y, x);\n\t\ty -= x * (a / b);\n\t}\n}\n\ninline bool solve(long long a, long long b, long long c, long long &x, long long &y) {\n\tif (b < 0) a = -a, b = -b, c = -c;\n\tlong long g;\n\texgcd(a, b, g, x, y);\n\tif (c % g != 0) return false;\n\tx = x * c / g;\n\ty = y * c / g;\n\tlong long newx = ((x % b) + b) % b;\n\ty = y - ((newx - x) / (b / g)) * (a / g);\n\tx = newx;\n\treturn true;\n}\n\nint main() {\n\tlong long x, y, m, n, l;\n\tscanf(\"%lld %lld %lld %lld %lld\", &x, &y, &m, &n, &l);\n\n\tlong long t, k;\n\n\tif (!solve(m - n, -l, y - x, t, k)) puts(\"Impossible\");\n\telse printf(\"%lld\\n\", t);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1477","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d7t01jkc2xlucsd71jl"},{"title":"BZOJ 1468Tree - ","date":"2016-06-14T13:59:00.000Z","_content":"\n Tree Tree  $ K $\n\n<!-- more -->\n\n### \n[BZOJ 1468](http://www.lydsy.com/JudgeOnline/problem.php?id=1468)\n\n### \n****\n\n $ K $ \n\n $ a_i $ $ a_i + a_j \\leq K $  $ a_j $  $ i $ $ j $  $ i $  $ j $ $ a_i + a_j \\leq K $ $ [i + 1,\\ j] $  $ j - i $\n\n****\n\n $ O(n \\log ^ 2 n) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tbool solved, visited;\n\tint size, dist, max;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\n// int cnt_root, cnt_calc;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\t// cnt_root++;\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstatic int a[MAXN];\n\tint cnt = 0;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->dist = dist;\n\troot->parent = NULL;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\ta[cnt++] = v->dist;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tint res = 0;\n\tstd::sort(a, a + cnt);\n\tfor (int i = 0, j = cnt - 1; i < j; i++) {\n\t\twhile (i < j && a[i] + a[j] > k) j--;\n\t\tres += j - i;\n\t}\n\n\t// cnt_calc++;\n\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\t\t// printf(\"work(%ld)\\n\", v - N + 1);\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tans -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tscanf(\"%d\", &k);\n\n\tprintf(\"%d\\n\", solve());\n\t// printf(\"cnt_root = %d, cnt_calc = %d\\n\", cnt_root, cnt_calc);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1468.md","raw":"title: BZOJ 1468Tree - \ncategories: OI\ntags: \n  - BZOJ\n  - \n  - \npermalink: bzoj-1468\ndate: 2016-06-14 21:59:00\n---\n\n Tree Tree  $ K $\n\n<!-- more -->\n\n### \n[BZOJ 1468](http://www.lydsy.com/JudgeOnline/problem.php?id=1468)\n\n### \n****\n\n $ K $ \n\n $ a_i $ $ a_i + a_j \\leq K $  $ a_j $  $ i $ $ j $  $ i $  $ j $ $ a_i + a_j \\leq K $ $ [i + 1,\\ j] $  $ j - i $\n\n****\n\n $ O(n \\log ^ 2 n) $\n\n### \n```c++\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 40000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tbool solved, visited;\n\tint size, dist, max;\n\tNode *parent;\n} N[MAXN];\n\nstruct Edge {\n\tNode *s, *t;\n\tint w;\n\tEdge *next;\n\n\tEdge(Node *s, Node *t, const int w) : s(s), t(t), w(w), next(s->e) {}\n};\n\ninline void addEdge(const int s, const int t, const int w) {\n\tN[s].e = new Edge(&N[s], &N[t], w);\n\tN[t].e = new Edge(&N[t], &N[s], w);\n}\n\nint n, k;\n// int cnt_root, cnt_calc;\n\ninline Node *center(Node *start) {\n\tstd::stack<Node *> s;\n\ts.push(start);\n\tstart->visited = false;\n\tstart->parent = NULL;\n\n\tstatic Node *a[MAXN];\n\tint cnt = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\tif (!v->visited) {\n\t\t\ta[cnt++] = v;\n\t\t\tv->visited = true;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t != v->parent && !e->t->solved) {\n\t\t\t\te->t->parent = v;\n\t\t\t\te->t->visited = false;\n\t\t\t\ts.push(e->t);\n\t\t\t}\n\t\t} else {\n\t\t\tv->size = 1;\n\t\t\tv->max = 0;\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t->parent == v) {\n\t\t\t\tv->size += e->t->size;\n\t\t\t\tv->max = std::max(v->max, e->t->size);\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tNode *res = NULL;\n\tfor (int i = 0; i < cnt; i++) {\n\t\ta[i]->max = std::max(a[i]->max, start->size - a[i]->max);\n\t\tif (!res || res->max > a[i]->max) res = a[i];\n\t}\n\n\t// printf(\"root(%ld) = %ld\\n\", start - N + 1, res - N + 1);\n\t// cnt_root++;\n\treturn res;\n}\n\ninline int calc(Node *root, const int dist = 0) {\n\tstatic int a[MAXN];\n\tint cnt = 0;\n\n\tstd::queue<Node *> q;\n\tq.push(root);\n\troot->dist = dist;\n\troot->parent = NULL;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\t\ta[cnt++] = v->dist;\n\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->solved && e->t != v->parent) {\n\t\t\te->t->parent = v;\n\t\t\te->t->dist = v->dist + e->w;\n\t\t\tq.push(e->t);\n\t\t}\n\t}\n\n\tint res = 0;\n\tstd::sort(a, a + cnt);\n\tfor (int i = 0, j = cnt - 1; i < j; i++) {\n\t\twhile (i < j && a[i] + a[j] > k) j--;\n\t\tres += j - i;\n\t}\n\n\t// cnt_calc++;\n\n\treturn res;\n}\n\ninline int solve() {\n\tstd::stack<Node *> s;\n\ts.push(&N[0]);\n\n\tint ans = 0;\n\twhile (!s.empty()) {\n\t\tNode *v = s.top();\n\t\ts.pop();\n\t\t// printf(\"work(%ld)\\n\", v - N + 1);\n\n\t\tNode *root = center(v);\n\t\troot->solved = true;\n\n\t\tans += calc(root);\n\t\tfor (Edge *e = root->e; e; e = e->next) if (!e->t->solved) {\n\t\t\tans -= calc(e->t, e->w);\n\t\t\ts.push(e->t);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w), u--, v--;\n\t\taddEdge(u, v, w);\n\t}\n\n\tscanf(\"%d\", &k);\n\n\tprintf(\"%d\\n\", solve());\n\t// printf(\"cnt_root = %d, cnt_calc = %d\\n\", cnt_root, cnt_calc);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1468","published":1,"updated":"2016-06-16T10:09:57.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d8001jqc2xleot5r6xn"},{"title":"BZOJ 1334Elect -  DP","date":"2016-07-11T14:50:00.000Z","_content":"\n$ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1334](http://www.lydsy.com/JudgeOnline/problem.php?id=1334)\n\n### \n\n\n $ f(i) $  $ i $ \n\n DP  $ i - f(i) \\leq \\frac{m}{2} $  $ i $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = 100000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN + 1];\n\tint m = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), m += a[i];\n\n\tstatic int f[MAXM + 1];\n\tf[0] = INT_MAX;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = m; j >= a[i]; j--) {\n\t\t\tf[j] = std::max(f[j], std::min(f[j - a[i]], a[i]));\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = m; i >= 0; i--) {\n\t\tif (i - f[i] <= m / 2) {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1334.md","raw":"title: BZOJ 1334Elect -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - DP\n  -  DP\npermalink: bzoj-1334\ndate: 2016-07-11 22:50:00\n---\n\n$ N $ \n\n<!-- more -->\n\n### \n[BZOJ 1334](http://www.lydsy.com/JudgeOnline/problem.php?id=1334)\n\n### \n\n\n $ f(i) $  $ i $ \n\n DP  $ i - f(i) \\leq \\frac{m}{2} $  $ i $ \n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXM = 100000;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tstatic int a[MAXN + 1];\n\tint m = 0;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]), m += a[i];\n\n\tstatic int f[MAXM + 1];\n\tf[0] = INT_MAX;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = m; j >= a[i]; j--) {\n\t\t\tf[j] = std::max(f[j], std::min(f[j - a[i]], a[i]));\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = m; i >= 0; i--) {\n\t\tif (i - f[i] <= m / 2) {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1334","published":1,"updated":"2016-10-24T23:33:15.812Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d8601jvc2xlflpbj4e2"},{"title":"BZOJ 1251 - Splay","id":"27","updated":"2016-01-19T13:02:18.000Z","date":"2016-01-18T13:44:15.000Z","_content":"\n `N` \n\n1.  `[L,R]`  `V`\n2.  `[L,R]`  `1 2 3 4`  `4 3 2 1`\n3.  `[L,R]`   `0`\n\n<!-- more -->\n\n### \n[BZOJ 1251](http://www.lydsy.com/JudgeOnline/problem.php?id=1251)  \n[CodeVS 4655](http://codevs.cn/problem/4655/)\n\n### \nSplay \n\n `lazy-tag` `pushDown()` \n\n `maintain()` \n\n \n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\n\nvoid print();\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, max, lazy;\n\t\tint size;\n\t\tbool reversed, bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), lazy(0), max(value), reversed(false), root(root), bound(bound), size(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\n\t\t\tsize = 1;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\tstd::swap(child[L], child[R]);\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->lazy += lazy, child[L]->value += lazy, child[L]->max += lazy;\n\t\t\t\tif (child[R]) child[R]->lazy += lazy, child[R]->value += lazy, child[R]->max += lazy;\n\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid build(const T *a, int n) {\n\t\troot = buildRange(a, 1, n, NULL);\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tNode *buildRange(const T *a, int l, int r, Node *parent) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tif (l != r) {\n\t\t\tv->child[L] = buildRange(a, l, mid - 1, v);\n\t\t\tv->child[R] = buildRange(a, mid + 1, r, v);\n\t\t}\n\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\t\t*v = new Node(parent, 0, &root, true);\n\t\t(*v)->maintain();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\t//v->pushDown();\n\t\twhile (v->pushDown(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + 1;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t\t//printf(\"select(k = %d)\\n\", k);\n\t\t\t//print();\n\t\t\t//v->pushDown();\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid update(int l, int r, const T &addition) {\n\t\tNode *range = select(l, r);\n\t\trange->value += addition, range->lazy += addition, range->max += addition;\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\treturn range->max;\n\t}\n\n\tvoid reverse(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfsFetch(a, root);\n\t}\n\n\tvoid dfsFetch(T *&a, Node *v) {\n\t\tif (!v) return;\n\t\tv->pushDown(), v->maintain();\n\t\tdfsFetch(a, v->child[L]);\n\t\tif (!v->bound) *a++ = v->value;\n\t\tdfsFetch(a, v->child[R]);\n\t}\n};\n\nint n, m, a[MAXN];\nSplay<int> splay;\n\nvoid dfs(Splay<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[Splay<int>::L], depth + 1);\n\tv->pushDown(), v->maintain();\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d : %d\\n\", v->value, v->size);\n\tdfs(v->child[Splay<int>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tmemset(a, 0, sizeof(int) * n);\n\tsplay.build(a, n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint command;\n\t\tscanf(\"%d\", &command);\n\t\tif (command == 1) {\n\t\t\tint l, r, addition;\n\t\t\tscanf(\"%d %d %d\", &l, &r, &addition);\n\t\t\tsplay.update(l, r, addition);\n\t\t} else if (command == 2) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tsplay.reverse(l, r);\n\t\t} else if (command == 3) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", splay.queryMax(l, r));\n\t\t} else throw;\n\t}\n\n\t//print();\n\n\treturn 0;\n}\n```","source":"_posts/bzoj-1251.md","raw":"title: BZOJ 1251 - Splay\ncategories: OI\ntags: \n  - Splay\n  - BZOJ\n  - CodeVS\n  - \npermalink: bzoj-1251\nid: 27\nupdated: '2016-01-19 21:02:18'\ndate: 2016-01-18 21:44:15\n---\n\n `N` \n\n1.  `[L,R]`  `V`\n2.  `[L,R]`  `1 2 3 4`  `4 3 2 1`\n3.  `[L,R]`   `0`\n\n<!-- more -->\n\n### \n[BZOJ 1251](http://www.lydsy.com/JudgeOnline/problem.php?id=1251)  \n[CodeVS 4655](http://codevs.cn/problem/4655/)\n\n### \nSplay \n\n `lazy-tag` `pushDown()` \n\n `maintain()` \n\n \n\n### \n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXN = 50000;\nconst int MAXM = 100000;\n\nvoid print();\n\ntemplate <typename T>\nstruct Splay {\n\tenum Relation {\n\t\tL = 0, R = 1\n\t};\n\n\tstruct Node {\n\t\tNode *child[2], *parent, **root;\n\t\tT value, max, lazy;\n\t\tint size;\n\t\tbool reversed, bound;\n\n\t\tNode(Node *parent, const T &value, Node **root, bool bound = false) : parent(parent), value(value), lazy(0), max(value), reversed(false), root(root), bound(bound), size(1) {\n\t\t\tchild[L] = child[R] = NULL;\n\t\t}\n\n\t\t~Node() {\n\t\t\tif (child[L]) delete child[L];\n\t\t\tif (child[R]) delete child[R];\n\t\t}\n\n\t\tRelation relation() {\n\t\t\treturn this == parent->child[L] ? L : R;\n\t\t}\n\n\t\tvoid maintain() {\n\t\t\tpushDown();\n\n\t\t\tsize = 1;\n\t\t\tif (child[L]) size += child[L]->size;\n\t\t\tif (child[R]) size += child[R]->size;\n\n\t\t\tmax = value;\n\t\t\tif (child[L]) max = std::max(max, child[L]->max);\n\t\t\tif (child[R]) max = std::max(max, child[R]->max);\n\t\t}\n\n\t\tvoid pushDown() {\n\t\t\tif (reversed) {\n\t\t\t\tif (child[L]) child[L]->reversed ^= 1;\n\t\t\t\tif (child[R]) child[R]->reversed ^= 1;\n\t\t\t\tstd::swap(child[L], child[R]);\n\n\t\t\t\treversed = false;\n\t\t\t}\n\n\t\t\tif (lazy) {\n\t\t\t\tif (child[L]) child[L]->lazy += lazy, child[L]->value += lazy, child[L]->max += lazy;\n\t\t\t\tif (child[R]) child[R]->lazy += lazy, child[R]->value += lazy, child[R]->max += lazy;\n\n\t\t\t\tlazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid rotate() {\n\t\t\tif (parent->parent) parent->parent->pushDown();\n\t\t\tparent->pushDown(), pushDown();\n\n\t\t\tRelation x = relation();\n\t\t\tNode *oldParent = parent;\n\n\t\t\tif (oldParent->parent) oldParent->parent->child[oldParent->relation()] = this;\n\t\t\tparent = oldParent->parent;\n\n\t\t\toldParent->child[x] = child[x ^ 1];\n\t\t\tif (child[x ^ 1]) child[x ^ 1]->parent = oldParent;\n\n\t\t\tchild[x ^ 1] = oldParent;\n\t\t\toldParent->parent = this;\n\n\t\t\toldParent->maintain(), maintain();\n\n\t\t\tif (!parent) *root = this;\n\t\t}\n\n\t\tvoid splay(Node *targetParent = NULL) {\n\t\t\twhile (parent != targetParent) {\n\t\t\t\tif (parent->parent == targetParent) rotate();\n\t\t\t\telse {\n\t\t\t\t\tparent->parent->pushDown(), parent->pushDown();\n\t\t\t\t\tif (parent->relation() == relation()) parent->rotate(), rotate();\n\t\t\t\t\telse rotate(), rotate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint rank() {\n\t\t\treturn !child[L] ? 0 : child[L]->size;\n\t\t}\n\t} *root;\n\n\tSplay() : root(NULL) {}\n\n\t~Splay() {\n\t\tif (root) delete root;\n\t}\n\n\tvoid build(const T *a, int n) {\n\t\troot = buildRange(a, 1, n, NULL);\n\t\tbuildBound(L), buildBound(R);\n\t}\n\n\tNode *buildRange(const T *a, int l, int r, Node *parent) {\n\t\tif (l > r) return NULL;\n\t\tint mid = l + ((r - l) >> 1);\n\n\t\tNode *v = new Node(parent, a[mid - 1], &root);\n\t\tif (l != r) {\n\t\t\tv->child[L] = buildRange(a, l, mid - 1, v);\n\t\t\tv->child[R] = buildRange(a, mid + 1, r, v);\n\t\t}\n\n\t\tv->maintain();\n\t\treturn v;\n\t}\n\n\tvoid buildBound(Relation x) {\n\t\tNode **v = &root, *parent = NULL;\n\t\twhile (*v) {\n\t\t\tparent = *v;\n\t\t\tparent->size++;\n\t\t\tv = &parent->child[x];\n\t\t}\n\t\t*v = new Node(parent, 0, &root, true);\n\t\t(*v)->maintain();\n\t}\n\n\tNode *select(int k) {\n\t\tk++;\n\t\tNode *v = root;\n\t\t//v->pushDown();\n\t\twhile (v->pushDown(), k != v->rank() + 1) {\n\t\t\tif (k < v->rank() + 1) {\n\t\t\t\tv = v->child[L];\n\t\t\t} else {\n\t\t\t\tk -= v->rank() + 1;\n\t\t\t\tv = v->child[R];\n\t\t\t}\n\t\t\t//printf(\"select(k = %d)\\n\", k);\n\t\t\t//print();\n\t\t\t//v->pushDown();\n\t\t}\n\t\tv->splay();\n\t\treturn v;\n\t}\n\n\tNode *select(int l, int r) {\n\t\tNode *lbound = select(l - 1);\n\t\tNode *rbound = select(r + 1);\n\n\t\tlbound->splay();\n\t\trbound->splay(lbound);\n\n\t\treturn rbound->child[L];\n\t}\n\n\tvoid update(int l, int r, const T &addition) {\n\t\tNode *range = select(l, r);\n\t\trange->value += addition, range->lazy += addition, range->max += addition;\n\t}\n\n\tconst T &queryMax(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\treturn range->max;\n\t}\n\n\tvoid reverse(int l, int r) {\n\t\tNode *range = select(l, r);\n\t\trange->reversed ^= 1;\n\t}\n\n\tvoid fetch(T *a) {\n\t\tdfsFetch(a, root);\n\t}\n\n\tvoid dfsFetch(T *&a, Node *v) {\n\t\tif (!v) return;\n\t\tv->pushDown(), v->maintain();\n\t\tdfsFetch(a, v->child[L]);\n\t\tif (!v->bound) *a++ = v->value;\n\t\tdfsFetch(a, v->child[R]);\n\t}\n};\n\nint n, m, a[MAXN];\nSplay<int> splay;\n\nvoid dfs(Splay<int>::Node *v, int depth) {\n\tif (!v) return;\n\tdfs(v->child[Splay<int>::L], depth + 1);\n\tv->pushDown(), v->maintain();\n\tfor (int i = 0; i < depth; i++) {\n\t\tputchar(' ');\n\t}\n\tprintf(\"%d : %d\\n\", v->value, v->size);\n\tdfs(v->child[Splay<int>::R], depth + 1);\n}\n\nvoid print() {\n\tdfs(splay.root, 0);\n\tputs(\"--------------------------------------------------\");\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tmemset(a, 0, sizeof(int) * n);\n\tsplay.build(a, n);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint command;\n\t\tscanf(\"%d\", &command);\n\t\tif (command == 1) {\n\t\t\tint l, r, addition;\n\t\t\tscanf(\"%d %d %d\", &l, &r, &addition);\n\t\t\tsplay.update(l, r, addition);\n\t\t} else if (command == 2) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tsplay.reverse(l, r);\n\t\t} else if (command == 3) {\n\t\t\tint l, r;\n\t\t\tscanf(\"%d %d\", &l, &r);\n\t\t\tprintf(\"%d\\n\", splay.queryMax(l, r));\n\t\t} else throw;\n\t}\n\n\t//print();\n\n\treturn 0;\n}\n```","slug":"bzoj-1251","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d8c01k0c2xltbszxjbq"},{"title":"BZOJ 1176Mokia - CDQ","date":"2016-06-20T11:48:00.000Z","_content":"\n $ N \\times N $$ N \\leq 2000000 $ $ S $\n\n $ \\leq 160000 $ $ \\leq 10000 $\n\n<!-- more -->\n\n### \n[BZOJ 1176](http://www.lydsy.com/JudgeOnline/problem.php?id=1176)\n\n### \n $ Q(x1,\\ y1,\\ x2,\\ y2) $  $ [x1,\\ y1] $  $ [x2,\\ y2] $ \n\n$$\n\\begin{aligned}\nQ(x1,\\ y1,\\ x2,\\ y2) = &  Q(0,\\ 0,\\ x2,\\ y2) \\\\\n& - Q(0,\\ 0,\\ x1 - 1,\\ y2) - Q(0,\\ 0,\\ x2,\\ y1 - 1) \\\\\n& + Q(0,\\ 0,\\ x1,\\ y1)\n\\end{aligned}\n$$\n\n$ x $$ y $ $ x $  $ y $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 2000000 + 1;\nconst int MAXQ = 10000;\nconst int MAXM = 160000 + MAXQ * 4;\n\nstruct Triple {\n\tint id, x, y, d, delta, *ans;\n\n\tTriple() {}\n\tTriple(const int x, const int y, const int d, int *ans) : x(x), y(y), d(d), delta(0), ans(ans) { setID(); }\n\tTriple(const int x, const int y, const int delta) : x(x), y(y), d(0), delta(delta), ans(NULL) { setID(); }\n\n\tvoid setID() {\n\t\tstatic int id = 0;\n\t\tthis->id = id++;\n\t}\n\n\tbool isQuery() const { return d != 0; }\n} a[MAXM];\n\nint s, n, m, cnt, ans[MAXQ];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXM];\n\tfor (Triple *p = tmp, *p1 = l, *p2 = mid + 1; p <= tmp + (r - l); p++) {\n\t\tif ((p1->x <= p2->x && p1 <= mid) || p2 > r) {\n\t\t\t*p = *p1++;\n\t\t\tif (!p->isQuery()) bit.update(p->y, p->delta);\n\t\t} else {\n\t\t\t*p = *p2++;\n\t\t\tif (p->isQuery()) *p->ans += bit.query(p->y) * p->d;\n\t\t}\n\t}\n\n\tfor (Triple *p = tmp, *q = l; q <= r; p++, q++) {\n\t\tif (q <= mid && !q->isQuery()) bit.clear(q->y);\n\t\t*q = *p;\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &s, &n), n++;\n\t\n\tint qcnt = 0;\n\twhile (true) {\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 3) break;\n\t\telse if (t == 2) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2), x1++, y1++, x2++, y2++;\n\n\t\t\tint *p = &ans[qcnt++];\n\t\t\t*p = (y2 - y1 + 1) * (x2 - x1 + 1) * s;\n\t\t\ta[cnt++] = Triple(x2, y2, 1, p);\n\t\t\ta[cnt++] = Triple(x1 - 1, y2, -1, p);\n\t\t\ta[cnt++] = Triple(x2, y1 - 1, -1, p);\n\t\t\ta[cnt++] = Triple(x1 - 1, y1 - 1, 1, p);\n\t\t} else if (t == 1) {\n\t\t\tint x, y, delta;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &delta), x++, y++;\n\t\t\ta[cnt++] = Triple(x, y, delta);\n\t\t}\n\t}\n\n\t/*\n\tfor (int i = 0; i < cnt; i++) {\n\t\tprintf(\"Triple(x = %d, y = %d, d = %d, delta = %d)\\n\", a[i].x, a[i].y, a[i].d, a[i].delta);\n\t}\n\t*/\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < qcnt; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1176.md","raw":"title: BZOJ 1176Mokia - CDQ\ncategories: OI\ntags: \n  - BZOJ\n  - CDQ\n  - \n  - \n  - \npermalink: bzoj-1176\ndate: 2016-06-20 19:48:00\n---\n\n $ N \\times N $$ N \\leq 2000000 $ $ S $\n\n $ \\leq 160000 $ $ \\leq 10000 $\n\n<!-- more -->\n\n### \n[BZOJ 1176](http://www.lydsy.com/JudgeOnline/problem.php?id=1176)\n\n### \n $ Q(x1,\\ y1,\\ x2,\\ y2) $  $ [x1,\\ y1] $  $ [x2,\\ y2] $ \n\n$$\n\\begin{aligned}\nQ(x1,\\ y1,\\ x2,\\ y2) = &  Q(0,\\ 0,\\ x2,\\ y2) \\\\\n& - Q(0,\\ 0,\\ x1 - 1,\\ y2) - Q(0,\\ 0,\\ x2,\\ y1 - 1) \\\\\n& + Q(0,\\ 0,\\ x1,\\ y1)\n\\end{aligned}\n$$\n\n$ x $$ y $ $ x $  $ y $ \n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 2000000 + 1;\nconst int MAXQ = 10000;\nconst int MAXM = 160000 + MAXQ * 4;\n\nstruct Triple {\n\tint id, x, y, d, delta, *ans;\n\n\tTriple() {}\n\tTriple(const int x, const int y, const int d, int *ans) : x(x), y(y), d(d), delta(0), ans(ans) { setID(); }\n\tTriple(const int x, const int y, const int delta) : x(x), y(y), d(0), delta(delta), ans(NULL) { setID(); }\n\n\tvoid setID() {\n\t\tstatic int id = 0;\n\t\tthis->id = id++;\n\t}\n\n\tbool isQuery() const { return d != 0; }\n} a[MAXM];\n\nint s, n, m, cnt, ans[MAXQ];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(const int x) { return x & -x; }\n\n\tint query(const int x) const {\n\t\tint ans = 0;\n\t\tfor (int i = x; i > 0; i -= lowbit(i)) ans += a[i - 1];\n\t\treturn ans;\n\t}\n\n\tvoid update(const int x, const int delta) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tvoid clear(const int x) {\n\t\tfor (int i = x; i <= n; i += lowbit(i)) {\n\t\t\tif (a[i - 1]) a[i - 1] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n} bit;\n\ninline void cdq(Triple *l, Triple *r) {\n\tif (l == r) return;\n\n\tTriple *mid = l + (r - l) / 2;\n\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\n\tstatic Triple tmp[MAXM];\n\tfor (Triple *p = tmp, *p1 = l, *p2 = mid + 1; p <= tmp + (r - l); p++) {\n\t\tif ((p1->x <= p2->x && p1 <= mid) || p2 > r) {\n\t\t\t*p = *p1++;\n\t\t\tif (!p->isQuery()) bit.update(p->y, p->delta);\n\t\t} else {\n\t\t\t*p = *p2++;\n\t\t\tif (p->isQuery()) *p->ans += bit.query(p->y) * p->d;\n\t\t}\n\t}\n\n\tfor (Triple *p = tmp, *q = l; q <= r; p++, q++) {\n\t\tif (q <= mid && !q->isQuery()) bit.clear(q->y);\n\t\t*q = *p;\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &s, &n), n++;\n\t\n\tint qcnt = 0;\n\twhile (true) {\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 3) break;\n\t\telse if (t == 2) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2), x1++, y1++, x2++, y2++;\n\n\t\t\tint *p = &ans[qcnt++];\n\t\t\t*p = (y2 - y1 + 1) * (x2 - x1 + 1) * s;\n\t\t\ta[cnt++] = Triple(x2, y2, 1, p);\n\t\t\ta[cnt++] = Triple(x1 - 1, y2, -1, p);\n\t\t\ta[cnt++] = Triple(x2, y1 - 1, -1, p);\n\t\t\ta[cnt++] = Triple(x1 - 1, y1 - 1, 1, p);\n\t\t} else if (t == 1) {\n\t\t\tint x, y, delta;\n\t\t\tscanf(\"%d %d %d\", &x, &y, &delta), x++, y++;\n\t\t\ta[cnt++] = Triple(x, y, delta);\n\t\t}\n\t}\n\n\t/*\n\tfor (int i = 0; i < cnt; i++) {\n\t\tprintf(\"Triple(x = %d, y = %d, d = %d, delta = %d)\\n\", a[i].x, a[i].y, a[i].d, a[i].delta);\n\t}\n\t*/\n\n\tcdq(a, a + cnt - 1);\n\n\tfor (int i = 0; i < qcnt; i++) printf(\"%d\\n\", ans[i]);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1176","published":1,"updated":"2016-06-20T14:11:06.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d8k01k6c2xl8tee8a63"},{"title":"HNOI2008 - ","date":"2016-04-06T13:04:45.000Z","_content":"\n $ 1  N $  $ N $ M\n\n<!-- more -->\n\n### \n[BZOJ 1008](http://www.lydsy.com/JudgeOnline/problem.php?id=1008)\n\n### \n\n\n $ N $  $ M $  $ M ^ N $\n\n $ M $  $ M - 1 $  $ M * (M - 1) ^ {N - 1} $\n\n $ M ^ N - M * (M - 1) ^ {N - 1} $\n\n### \n```c++\n#include <cstdio>\n\nconst long long MAXN = 1e12;\nconst long long MAXM = 1e8;\nconst long long MOD = 100003;\n\ninline long long pow(const long long x, const long long n) {\n\tlong long ans = 1;\n\tfor (long long num = x % MOD, k = n; k; num = num * num % MOD, k >>= 1) if (k & 1) ans = ans * num % MOD;\n\t// for (int i = 0; i < n; i++) ans = ans * x % MOD;\n\treturn ans;\n}\n\nint main() {\n\tlong long m, n;\n\tscanf(\"%lld %lld\", &m, &n);\n\n\tlong long ans = pow(m, n) - m * pow(m - 1, n - 1);\n\tprintf(\"%lld\\n\", (ans % MOD + MOD) % MOD);\n\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1008.md","raw":"title: HNOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - HNOI\n  - \n  - \npermalink: bzoj-1008\ndate: 2016-04-06 21:04:45\n---\n\n $ 1  N $  $ N $ M\n\n<!-- more -->\n\n### \n[BZOJ 1008](http://www.lydsy.com/JudgeOnline/problem.php?id=1008)\n\n### \n\n\n $ N $  $ M $  $ M ^ N $\n\n $ M $  $ M - 1 $  $ M * (M - 1) ^ {N - 1} $\n\n $ M ^ N - M * (M - 1) ^ {N - 1} $\n\n### \n```c++\n#include <cstdio>\n\nconst long long MAXN = 1e12;\nconst long long MAXM = 1e8;\nconst long long MOD = 100003;\n\ninline long long pow(const long long x, const long long n) {\n\tlong long ans = 1;\n\tfor (long long num = x % MOD, k = n; k; num = num * num % MOD, k >>= 1) if (k & 1) ans = ans * num % MOD;\n\t// for (int i = 0; i < n; i++) ans = ans * x % MOD;\n\treturn ans;\n}\n\nint main() {\n\tlong long m, n;\n\tscanf(\"%lld %lld\", &m, &n);\n\n\tlong long ans = pow(m, n) - m * pow(m - 1, n - 1);\n\tprintf(\"%lld\\n\", (ans % MOD + MOD) % MOD);\n\n\treturn 0;\n}\n```\n","slug":"bzoj-1008","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d8s01kdc2xlau85znt7"},{"title":"BeiJing2006 - ","date":"2016-04-03T14:46:25.000Z","_content":"\n $ (1, 1) $ $ (N, M) $\n\n1. $ (x, y) \\Leftrightarrow (x + 1, y) $\n2. $ (x, y) \\Leftrightarrow (x, y + 1) $\n3. $ (x, y) \\Leftrightarrow (x + 1, y + 1) $\n\n $ (1, 1) $  $ (N, M) $  $ K $ $ K $ .\n\n<!-- more -->\n\n### \n[BZOJ 1001](http://www.lydsy.com/JudgeOnline/problem.php?id=1001)\n\n### \nDinic  \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *n, *r;\n\t\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), n(s->e) {}\n};\n\ninline void addEdge(int s, int t, int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], c);\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct Dinic {\n\tint augment(Node *s, Node *t, const int h = INT_MAX) {\n\t\tif (s == t) return h;\n\t\tfor (Edge *&e = s->c; e; e = e->n) {\n\t\t\tif (e->c > 0 && e->t->l == s->l + 1) {\n\t\t\t\tint f = augment(e->t, t, std::min(e->c, h));\n\t\t\t\tif (f) {\n\t\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tint operator()(const int s, const int t, const int n) {\n\t\tint r = 0;\n\t\twhile (1) {\n\t\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\t\tbool f = false;\n\t\t\tstd::queue<Node *> q;\n\t\t\tq.push(&N[s]), N[s].l = 1;\n\t\t\twhile (!q.empty()) {\n\t\t\t\tNode *v = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor (Edge *e = v->e; e; e = e->n)\n\t\t\t\t\tif (!e->t->l && e->c > 0) {\n\t\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\t\tif (e->t == &N[t]) {\n\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else q.push(e->t);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f) return r;\n\t\t\t\n\t\t\tfor (int f; f = augment(&N[s], &N[t]); r += f);\n\t\t}\n\t}\n} dinic;\n\nint n, m;\n\ninline int id(const int i, const int j) {\n\treturn (i - 1) * m + j;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tconst int s = 0, t = n * m + 1;\n\taddEdge(s, id(1, 1), INT_MAX), addEdge(id(n, m), t, INT_MAX);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m - 1; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i, j + 1), c);\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i + 1, j), c);\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tfor (int j = 1; j <= m - 1; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i + 1, j + 1), c);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", dinic(s, t, n * m + 2));\n\t\n\treturn 0;\n}\n```\n","source":"_posts/bzoj-1001.md","raw":"title: BeiJing2006 - \ncategories: OI\ntags: \n  - BZOJ\n  - Dinic\n  - \n  - \npermalink: bzoj-1001\ndate: 2016-04-03 22:46:25\n---\n\n $ (1, 1) $ $ (N, M) $\n\n1. $ (x, y) \\Leftrightarrow (x + 1, y) $\n2. $ (x, y) \\Leftrightarrow (x, y + 1) $\n3. $ (x, y) \\Leftrightarrow (x + 1, y + 1) $\n\n $ (1, 1) $  $ (N, M) $  $ K $ $ K $ .\n\n<!-- more -->\n\n### \n[BZOJ 1001](http://www.lydsy.com/JudgeOnline/problem.php?id=1001)\n\n### \nDinic  \n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 1000;\nconst int MAXM = 1000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN * MAXM + 2];\n\nstruct Edge {\n\tNode *t;\n\tint c;\n\tEdge *n, *r;\n\t\n\tEdge(Node *s, Node *t, const int c) : t(t), c(c), n(s->e) {}\n};\n\ninline void addEdge(int s, int t, int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], c);\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct Dinic {\n\tint augment(Node *s, Node *t, const int h = INT_MAX) {\n\t\tif (s == t) return h;\n\t\tfor (Edge *&e = s->c; e; e = e->n) {\n\t\t\tif (e->c > 0 && e->t->l == s->l + 1) {\n\t\t\t\tint f = augment(e->t, t, std::min(e->c, h));\n\t\t\t\tif (f) {\n\t\t\t\t\te->c -= f, e->r->c += f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tint operator()(const int s, const int t, const int n) {\n\t\tint r = 0;\n\t\twhile (1) {\n\t\t\tfor (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;\n\n\t\t\tbool f = false;\n\t\t\tstd::queue<Node *> q;\n\t\t\tq.push(&N[s]), N[s].l = 1;\n\t\t\twhile (!q.empty()) {\n\t\t\t\tNode *v = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor (Edge *e = v->e; e; e = e->n)\n\t\t\t\t\tif (!e->t->l && e->c > 0) {\n\t\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\t\tif (e->t == &N[t]) {\n\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else q.push(e->t);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f) return r;\n\t\t\t\n\t\t\tfor (int f; f = augment(&N[s], &N[t]); r += f);\n\t\t}\n\t}\n} dinic;\n\nint n, m;\n\ninline int id(const int i, const int j) {\n\treturn (i - 1) * m + j;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tconst int s = 0, t = n * m + 1;\n\taddEdge(s, id(1, 1), INT_MAX), addEdge(id(n, m), t, INT_MAX);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= m - 1; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i, j + 1), c);\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i + 1, j), c);\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tfor (int j = 1; j <= m - 1; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\taddEdge(id(i, j), id(i + 1, j + 1), c);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", dinic(s, t, n * m + 2));\n\t\n\treturn 0;\n}\n```\n","slug":"bzoj-1001","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d8z01kjc2xl73w1n3zy"},{"title":" BSGS","date":"2016-06-13T03:52:00.000Z","_content":"\n $ a $$ b $$ p $  $ x $\n\n$$ a ^ x \\equiv b \\pmod p $$\n\n $ x $  $ b $  $ p $  $ a $ ****\n\n<!-- more -->\n\n### \n\n\n$$\n\\begin{aligned}\n\\log_g x + \\log_g y &\\equiv \\log_g xy \\pmod p \\\\\n\\log_g x ^ y &\\equiv y \\log_g x \\pmod p\n\\end{aligned}\n$$\n\n### BSGS\n BSGSBaby-Step Giant-Step\n\n$ p $ \n\n$$ a ^ x \\equiv b \\pmod p $$\n\n $ m = \\lceil \\sqrt p \\rceil $  \n $ a ^ {p - 1} \\equiv 1 \\pmod p $ $ 0 \\leq x < p - 1 $\n\n $ x = im + j $ $ 0 \\leq i,\\ j \\leq m $\n\n\n\n$$\n\\begin{align*}\na ^ {x} &\\equiv b \\pmod p \\\\\na ^ {im + j} &\\equiv b \\pmod p \\\\\na ^ {j} &\\equiv b \\times a ^ {-im} \\pmod p \\\\\na ^ {j} &\\equiv b \\times (a ^ {-m}) ^ i \\pmod p\n\\end{align*}\n$$\n\n $ i $$ j $ \n\n $ j $ $ a ^ j \\bmod p $  $ (a ^ j \\bmod p) \\mapsto j $ \n\n $ a ^ m \\bmod p $  $ a ^ {-m} \\bmod p $ $ i $ $ b \\times (a ^ {-m}) ^ i $ $ j $$ x = im + j $ \n\n $ O(\\sqrt p) $\n\n#### \n```c++\ntemplate <typename T>\ninline void exgcd(const T a, const T b, T &g, T &x, T &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ntemplate <typename T>\ninline T inv(const T x, const T p) {\n\tT g, r, y;\n\texgcd(x, p, g, r, y);\n\treturn (r % p + p) % p;\n}\n\ntemplate <typename T>\ninline T bsgs(const T a, const T b, const T p) {\n\tstd::tr1::unordered_map<T, T> map;\n\n\tT m = ceil(sqrt(static_cast<double>(p))), t = 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!map.count(t)) map[t] = i;\n\t\tt = t * a % p;\n\t}\n\n\tT k = inv(t, p), w = b;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (map.count(w)) return i * m + map[w];\n\t\tw = w * k % p;\n\t}\n\n\treturn -1;\n}\n```\n\n### EXBSGS\n BSGS  $ p $  $ a $  $ \\gcd(a,\\ p) = 1 $ \n\n\n\n$$ a ^ x \\equiv b \\pmod p $$\n\n\n\n$$ a ^ x = b + kp $$\n\n $ d = \\gcd(a,\\ p) $ $ d \\mid b $\n\n$$ a ^ {x - 1} \\frac{a}{d} = \\frac{b}{d} + k \\frac{p}{d} $$\n\n\n\n$$ a ^ {x - 1} \\frac{a}{d} \\equiv \\frac{b}{d} \\pmod { \\frac{p}{d} } $$\n\n $ \\gcd(\\frac{a}{d},\\ \\frac{p}{d}) = 1 $ $ \\frac{a}{d} $ \n\n$$ a ^ {x - 1} \\equiv \\frac{b}{d} \\times (\\frac{a}{d}) ^ {-1} \\pmod { \\frac{p}{d} } $$\n\n $ d = 1 $  BSGS  $ d \\not \\mid b $  $ b = 1 $  $ 0 $ $ 1 $\n\n#### \n```c++\ntemplate <typename T>\ninline T exbsgs(const T a, const T b, const T p) {\n\tT _b = b, _p = p, t, c = 0;\n\twhile ((t = std::__gcd(a, _p)) != 1) {\n\t\tif (_b == 1) return c;\n\t\tif (_b % t != 0) return -1;\n\t\t_p /= t;\n\t\t_b = _b / t * inv(a / t, _p) % _p;\n\t\tc++;\n\t}\n\n\tT r = bsgs(a, _b, _p);\n\tif (r == -1) return -1;\n\telse return r + c;\n}\n```\n","source":"_posts/bsgs-notes.md","raw":"title:  BSGS\ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - BSGS\npermalink: bsgs-notes\ndate: 2016-06-13 11:52:00\n---\n\n $ a $$ b $$ p $  $ x $\n\n$$ a ^ x \\equiv b \\pmod p $$\n\n $ x $  $ b $  $ p $  $ a $ ****\n\n<!-- more -->\n\n### \n\n\n$$\n\\begin{aligned}\n\\log_g x + \\log_g y &\\equiv \\log_g xy \\pmod p \\\\\n\\log_g x ^ y &\\equiv y \\log_g x \\pmod p\n\\end{aligned}\n$$\n\n### BSGS\n BSGSBaby-Step Giant-Step\n\n$ p $ \n\n$$ a ^ x \\equiv b \\pmod p $$\n\n $ m = \\lceil \\sqrt p \\rceil $  \n $ a ^ {p - 1} \\equiv 1 \\pmod p $ $ 0 \\leq x < p - 1 $\n\n $ x = im + j $ $ 0 \\leq i,\\ j \\leq m $\n\n\n\n$$\n\\begin{align*}\na ^ {x} &\\equiv b \\pmod p \\\\\na ^ {im + j} &\\equiv b \\pmod p \\\\\na ^ {j} &\\equiv b \\times a ^ {-im} \\pmod p \\\\\na ^ {j} &\\equiv b \\times (a ^ {-m}) ^ i \\pmod p\n\\end{align*}\n$$\n\n $ i $$ j $ \n\n $ j $ $ a ^ j \\bmod p $  $ (a ^ j \\bmod p) \\mapsto j $ \n\n $ a ^ m \\bmod p $  $ a ^ {-m} \\bmod p $ $ i $ $ b \\times (a ^ {-m}) ^ i $ $ j $$ x = im + j $ \n\n $ O(\\sqrt p) $\n\n#### \n```c++\ntemplate <typename T>\ninline void exgcd(const T a, const T b, T &g, T &x, T &y) {\n\tif (!b) g = a, x = 1, y = 0;\n\telse exgcd(b, a % b, g, y, x), y -= x * (a / b);\n}\n\ntemplate <typename T>\ninline T inv(const T x, const T p) {\n\tT g, r, y;\n\texgcd(x, p, g, r, y);\n\treturn (r % p + p) % p;\n}\n\ntemplate <typename T>\ninline T bsgs(const T a, const T b, const T p) {\n\tstd::tr1::unordered_map<T, T> map;\n\n\tT m = ceil(sqrt(static_cast<double>(p))), t = 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!map.count(t)) map[t] = i;\n\t\tt = t * a % p;\n\t}\n\n\tT k = inv(t, p), w = b;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (map.count(w)) return i * m + map[w];\n\t\tw = w * k % p;\n\t}\n\n\treturn -1;\n}\n```\n\n### EXBSGS\n BSGS  $ p $  $ a $  $ \\gcd(a,\\ p) = 1 $ \n\n\n\n$$ a ^ x \\equiv b \\pmod p $$\n\n\n\n$$ a ^ x = b + kp $$\n\n $ d = \\gcd(a,\\ p) $ $ d \\mid b $\n\n$$ a ^ {x - 1} \\frac{a}{d} = \\frac{b}{d} + k \\frac{p}{d} $$\n\n\n\n$$ a ^ {x - 1} \\frac{a}{d} \\equiv \\frac{b}{d} \\pmod { \\frac{p}{d} } $$\n\n $ \\gcd(\\frac{a}{d},\\ \\frac{p}{d}) = 1 $ $ \\frac{a}{d} $ \n\n$$ a ^ {x - 1} \\equiv \\frac{b}{d} \\times (\\frac{a}{d}) ^ {-1} \\pmod { \\frac{p}{d} } $$\n\n $ d = 1 $  BSGS  $ d \\not \\mid b $  $ b = 1 $  $ 0 $ $ 1 $\n\n#### \n```c++\ntemplate <typename T>\ninline T exbsgs(const T a, const T b, const T p) {\n\tT _b = b, _p = p, t, c = 0;\n\twhile ((t = std::__gcd(a, _p)) != 1) {\n\t\tif (_b == 1) return c;\n\t\tif (_b % t != 0) return -1;\n\t\t_p /= t;\n\t\t_b = _b / t * inv(a / t, _p) % _p;\n\t\tc++;\n\t}\n\n\tT r = bsgs(a, _b, _p);\n\tif (r == -1) return -1;\n\telse return r + c;\n}\n```\n","slug":"bsgs-notes","published":1,"updated":"2016-09-10T05:55:06.471Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d9601kpc2xlbqcd2x9f"},{"title":"","date":"2016-03-14T13:34:42.000Z","_content":"\n \n \n\n<!-- more -->\n\n```cpp\n#include <cstring>\n#include <iostream>\n#include <vector>\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), \nx.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] \n+ '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); \ni++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n```\n","source":"_posts/bigint-template.md","raw":"title: \ncategories: OI\ntags: \n  - \n  - \npermalink: bigint-template\ndate: 2016-03-14 21:34:42\n---\n\n \n \n\n<!-- more -->\n\n```cpp\n#include <cstring>\n#include <iostream>\n#include <vector>\n\nstruct BigInt {\n\tstd::vector<char> v;\n\n\tBigInt() {\n\t\t*this = 0;\n\t}\n\n\tBigInt(int x) {\n\t\t*this = x;\n\t}\n\n\tBigInt &operator=(int x) {\n\t\tv.clear();\n\t\tdo v.push_back(x % 10); while (x /= 10);\n\t\treturn *this;\n\t}\n\n\tBigInt &operator=(const BigInt &x) {\n\t\tv.resize(x.v.size());\n\t\tmemcpy(const_cast<char *>(v.data()), x.v.data(), \nx.v.size() * sizeof(char));\n\t\treturn *this;\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const BigInt &x) {\n\tfor (int i = x.v.size() - 1; i >= 0; i--) out << (char)(x.v[i] \n+ '0');\n\treturn out;\n}\n\nBigInt operator+(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)std::max(a.v.size(), b.v.size()); \ni++) {\n\t\tint tmp = 0;\n\t\tif (i < (int)a.v.size()) tmp += a.v[i];\n\t\tif (i < (int)b.v.size()) tmp += b.v[i];\n\t\tif (flag) tmp++, flag = false;\n\t\tif (tmp >= 10) tmp -= 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\tif (flag) result.v.push_back(1);\n\n\treturn result;\n}\n\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n\treturn a = a + b;\n}\n\nBigInt operator-(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.clear();\n\tbool flag = false;\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tint tmp = a.v[i];\n\t\tif (i < (int)b.v.size()) tmp -= b.v[i];\n\t\tif (flag) tmp--, flag = false;\n\t\tif (tmp < 0) tmp += 10, flag = true;\n\t\tresult.v.push_back(tmp);\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n\nBigInt operator*(const BigInt &a, const BigInt &b) {\n\tBigInt result;\n\tresult.v.resize(a.v.size() + b.v.size());\n\tfor (int i = 0; i < (int)a.v.size(); i++) {\n\t\tfor (int j = 0; j < (int)b.v.size(); j++){\n\t\t\tresult.v[i + j] += a.v[i] * b.v[j];\n\t\t\tresult.v[i + j + 1] += result.v[i + j] / 10;\n\t\t\tresult.v[i + j] %= 10;\n\t\t}\n\t}\n\n\tint size = result.v.size();\n\twhile (size > 1 && result.v[size - 1] == 0) size--;\n\tresult.v.resize(size);\n\n\treturn result;\n}\n```\n","slug":"bigint-template","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d9f01kxc2xls2kespyk"},{"title":"   NOI2016 ","date":"2016-08-30T18:42:00.000Z","_content":"\n<div style=\"width: 100%; text-align: center; \">\n<div id=\"aplayer\" class=\"aplayer\" style=\"width: 100%; max-width: 550px; text-align: left; display: inline-block; background: #fff; \"></div>\n</div>\n<style>\n.post .post-content .aplayer {\n\tmargin-top: 20px;\n}\n</style>\n<script>\nvar ap = new APlayer({\n    element: document.getElementById('aplayer'),\n    narrow: false,\n    autoplay: false,\n    showlrc: 3,\n    mutex: true,\n    theme: '#615754',\n    music: {\n        title: '',\n        author: 'KOKIA',\n        url: 'https://dn-menci.qbox.me/music/mzr.ogg',\n        pic: 'https://dn-menci.qbox.me/music/mzr.jpg',\n        lrc: '/at-the-cross-of-time/mzr.lrc'\n    }\n});\n</script>\n\n OIer NOI \n\n<!-- more -->\n\nNOI   \n\n\n\n OIer     \n\n  \n    \n\n  \n\n\n    \n\n\n\n\n\n****\n\n OIer \n\n\n\n\n\n OI \n","source":"_posts/at-the-cross-of-time.md","raw":"title:    NOI2016 \ncategories: \n  - Diary\npermalink: at-the-cross-of-time\ndate: 2016-08-31 02:42:00\n---\n\n<div style=\"width: 100%; text-align: center; \">\n<div id=\"aplayer\" class=\"aplayer\" style=\"width: 100%; max-width: 550px; text-align: left; display: inline-block; background: #fff; \"></div>\n</div>\n<style>\n.post .post-content .aplayer {\n\tmargin-top: 20px;\n}\n</style>\n<script>\nvar ap = new APlayer({\n    element: document.getElementById('aplayer'),\n    narrow: false,\n    autoplay: false,\n    showlrc: 3,\n    mutex: true,\n    theme: '#615754',\n    music: {\n        title: '',\n        author: 'KOKIA',\n        url: 'https://dn-menci.qbox.me/music/mzr.ogg',\n        pic: 'https://dn-menci.qbox.me/music/mzr.jpg',\n        lrc: '/at-the-cross-of-time/mzr.lrc'\n    }\n});\n</script>\n\n OIer NOI \n\n<!-- more -->\n\nNOI   \n\n\n\n OIer     \n\n  \n    \n\n  \n\n\n    \n\n\n\n\n\n****\n\n OIer \n\n\n\n\n\n OI \n","slug":"at-the-cross-of-time","published":1,"updated":"2016-11-20T15:48:58.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d9m01l1c2xlvxcyo4eu"},{"title":"APIO2010 -  DP","date":"2016-05-13T12:16:00.000Z","_content":"\n $ n $  $ 1 $  $ n $ \n\n $ i $  $ x_i $  $ x $  $ x' = Ax ^ 2 + Bx + C $ $ A $$ B $$ C $ $ A < 0 $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1911](http://www.lydsy.com/JudgeOnline/problem.php?id=1911)\n\n### \n $ f[i] $  $ i $ $ s_i $ \n\n $ j $ $ j + 1 $  $ i $ \n\n$$ f[i] = \\max\\limits_{j = 0} ^ {i - 1} \\{ f[j] + A(s_i - s_j) ^ 2 + B(s_i - s_j) + C \\} $$\n\n $ O(n ^ 2) $\n\n $ j = a $$ j = b $$ a > b $ $ a $  $ b $ \n\n$$\nf[a] + A(s_i - s_a) ^ 2 + B(s_i - s_a) + C > f[b] + A(s_i - s_b) ^ 2 + B(s_i - s_b) + C \\\\\nf[a] + A(s_i ^ 2 + s_a ^ 2 - 2 s_i s_a) + B(s_i - s_a) + C > f[b] + A(s_i ^ 2 + s_b ^ 2 - 2 s_i s_b) + B(s_i - s_b) + C \\\\\nf[a] + A s_i ^ 2 + A s_a ^ 2 - 2 A s_i s_a + B s_i - B s_a + C > f[b] + A s_i ^ 2 + A s_b ^ 2 - 2 A s_i s_b + B s_i - B s_b + C \\\\\nf[a] + A s_a ^ 2 - 2 A s_i s_a - B s_a > f[b] + A s_b ^ 2 - 2 A s_i s_b - B s_b \\\\\nf[a] - f[b] + A s_a ^ 2 - A s_b ^ 2 - B s_a + B s_b > 2 A s_a s_i + 2 A s_b s_i \\\\\n(f[a] + A s_a ^ 2 - B s_a) - (f[b] + A s_b ^ 2 - B s_b) > 2 A s_i(s_a - s_b) \\\\\n{ {(f[a] + A s_a ^ 2 - B s_a) - (f[b] + A s_b ^ 2 - B s_b)} \\over {s_a - s_b} } > 2 A s_i \\\\\n$$\n\n\n\n $ 2 A s_i $\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000000;\n\nint n;\nlong long a[MAXN], A, B, C;\nlong long s[MAXN + 1], f[MAXN + 1];\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline long long y(const int a) {\n    return f[a] + A * sqr(s[a]) - B * s[a];\n}\n\ninline long long x(const int a) {\n    return s[a];\n}\n\ninline long long g(const int i) {\n    return 2 * A * s[i];\n}\n\ninline double slope(const int a, const int b) {\n    return static_cast<double>(y(a) - y(b))\n         / static_cast<double>(x(a) - x(b));\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    scanf(\"%lld %lld %lld\", &A, &B, &C);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i - 1];\n    \n    static long long q[MAXN + 1];\n    \n    long long *l = q, *r = q;\n    *r = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) > g(i)) l++;\n        \n        int j = *l;\n        \n        // int _j = -1;\n        // for (int j = 0; j < i; j++) {\n        //     if (_j == -1 || f[j] + A * sqr(s[i] - s[j]) + B * (s[i] - s[j]) + C > f[_j] + A * sqr(s[i] - s[_j]) + B * (s[i] - s[_j]) + C) _j = j;\n        // }\n        // j = _j;\n        \n        // printf(\"i = %d, j = %d\\n\", i, j);\n        f[i] = f[j] + A * sqr(s[i] - s[j]) + B * (s[i] - s[j]) + C;\n        \n        // printf(\"i = %d, _j = %d\\n\", i, _j);\n        \n        while (l < r && slope(*r, *(r - 1)) < slope(i, *r)) r--;\n        \n        *++r = i;\n    }\n    \n    printf(\"%lld\\n\", f[n]);\n    \n    return 0;\n}\n```\n","source":"_posts/apio2010-commando.md","raw":"title: APIO2010 -  DP\ncategories: OI\ntags: \n  - BZOJ\n  - APIO\n  - DP\n  - \n  - \npermalink: apio2010-commando\ndate: 2016-05-13 20:16:00\n---\n\n $ n $  $ 1 $  $ n $ \n\n $ i $  $ x_i $  $ x $  $ x' = Ax ^ 2 + Bx + C $ $ A $$ B $$ C $ $ A < 0 $\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1911](http://www.lydsy.com/JudgeOnline/problem.php?id=1911)\n\n### \n $ f[i] $  $ i $ $ s_i $ \n\n $ j $ $ j + 1 $  $ i $ \n\n$$ f[i] = \\max\\limits_{j = 0} ^ {i - 1} \\{ f[j] + A(s_i - s_j) ^ 2 + B(s_i - s_j) + C \\} $$\n\n $ O(n ^ 2) $\n\n $ j = a $$ j = b $$ a > b $ $ a $  $ b $ \n\n$$\nf[a] + A(s_i - s_a) ^ 2 + B(s_i - s_a) + C > f[b] + A(s_i - s_b) ^ 2 + B(s_i - s_b) + C \\\\\nf[a] + A(s_i ^ 2 + s_a ^ 2 - 2 s_i s_a) + B(s_i - s_a) + C > f[b] + A(s_i ^ 2 + s_b ^ 2 - 2 s_i s_b) + B(s_i - s_b) + C \\\\\nf[a] + A s_i ^ 2 + A s_a ^ 2 - 2 A s_i s_a + B s_i - B s_a + C > f[b] + A s_i ^ 2 + A s_b ^ 2 - 2 A s_i s_b + B s_i - B s_b + C \\\\\nf[a] + A s_a ^ 2 - 2 A s_i s_a - B s_a > f[b] + A s_b ^ 2 - 2 A s_i s_b - B s_b \\\\\nf[a] - f[b] + A s_a ^ 2 - A s_b ^ 2 - B s_a + B s_b > 2 A s_a s_i + 2 A s_b s_i \\\\\n(f[a] + A s_a ^ 2 - B s_a) - (f[b] + A s_b ^ 2 - B s_b) > 2 A s_i(s_a - s_b) \\\\\n{ {(f[a] + A s_a ^ 2 - B s_a) - (f[b] + A s_b ^ 2 - B s_b)} \\over {s_a - s_b} } > 2 A s_i \\\\\n$$\n\n\n\n $ 2 A s_i $\n\n $ O(n) $\n\n### \n```c++\n#include <cstdio>\n\nconst int MAXN = 1000000;\n\nint n;\nlong long a[MAXN], A, B, C;\nlong long s[MAXN + 1], f[MAXN + 1];\n\ntemplate <typename T> inline T sqr(const T &x) { return x * x; }\n\ninline long long y(const int a) {\n    return f[a] + A * sqr(s[a]) - B * s[a];\n}\n\ninline long long x(const int a) {\n    return s[a];\n}\n\ninline long long g(const int i) {\n    return 2 * A * s[i];\n}\n\ninline double slope(const int a, const int b) {\n    return static_cast<double>(y(a) - y(b))\n         / static_cast<double>(x(a) - x(b));\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    scanf(\"%lld %lld %lld\", &A, &B, &C);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &a[i]);\n    for (int i = 1; i <= n; i++) s[i] = s[i - 1] + a[i - 1];\n    \n    static long long q[MAXN + 1];\n    \n    long long *l = q, *r = q;\n    *r = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*(l + 1), *l) > g(i)) l++;\n        \n        int j = *l;\n        \n        // int _j = -1;\n        // for (int j = 0; j < i; j++) {\n        //     if (_j == -1 || f[j] + A * sqr(s[i] - s[j]) + B * (s[i] - s[j]) + C > f[_j] + A * sqr(s[i] - s[_j]) + B * (s[i] - s[_j]) + C) _j = j;\n        // }\n        // j = _j;\n        \n        // printf(\"i = %d, j = %d\\n\", i, j);\n        f[i] = f[j] + A * sqr(s[i] - s[j]) + B * (s[i] - s[j]) + C;\n        \n        // printf(\"i = %d, _j = %d\\n\", i, _j);\n        \n        while (l < r && slope(*r, *(r - 1)) < slope(i, *r)) r--;\n        \n        *++r = i;\n    }\n    \n    printf(\"%lld\\n\", f[n]);\n    \n    return 0;\n}\n```\n","slug":"apio2010-commando","published":1,"updated":"2016-10-24T23:33:06.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6d9s01l3c2xlqxqopyqq"},{"title":"APIO2009 - ","date":"2016-03-10T11:57:45.000Z","_content":"\n ATM  ATM \n\n ATM  ATM  ATM \n\n<!-- more -->\n\n### \n[CodeVS 1611](http://codevs.cn/problem/1611/)  \n[BZOJ 1179](http://www.lydsy.com/JudgeOnline/problem.php?id=1179)\n\n### \nTarjan  DAG DAG \n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\nstruct SCC;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge, *currentEdge;\n\tint dfn, low, w, dist;\n\tbool inStack, pushed, visited, isBar, inQueue;\n\tSCC *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint size;\n} sccs[MAXN];\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\telse if (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\te = e->next;\n\t\t\t} else  {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tNode *u;\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t\tu->scc->v.w += u->w;\n\t\t\t\t\t\tu->scc->v.isBar |= u->isBar;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\tNode *from = &e->from->scc->v, *to = &e->to->scc->v;\n\t\t\t\tfrom->firstEdge = new Edge(from, to);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void bellmanford(int start) {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[start].scc->v);\n\tnodes[start].scc->v.dist = nodes[start].scc->v.w;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\tv->inQueue = false;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist < v->dist + e->to->w) {\n\t\t\t\te->to->dist = v->dist + e->to->w;\n\t\t\t\t\n\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &nodes[i].w);\n\t}\n\n\tint s, p;\n\tscanf(\"%d %d\", &s, &p), s--;\n\n\tfor (int i = 0; i < p; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x), x--;\n\t\tnodes[x].isBar = true;\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tbellmanford(s);\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.isBar) ans = std::max(ans, sccs[i].v.dist);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n\n### \n Dijkstra   Dijkstra \n\n()  Dijkstra\n\n('-')  Bellman-Ford  WA  \n\n \n\n OvO \n\n### \n _\n\n|             | |  | |\n| ---------------- |:--:|:--------:|:--------:|\n| large-dag-0.in   | AC | 42504kB  | 423ms    |\n| large-dag-1.in   | AC | 51052kB  | 476ms    |\n| large-path-0.in  | AC | 55288kB  | 491ms    |\n| large-path-1.in  | AC | 53096kB  | 494ms    |\n| large-tree-0.in  | AC | 49512kB  | 430ms    |\n| large-tree-1.in  | AC | 49772kB  | 406ms    |\n| medium-dag-0.in  | AC | 364kB    | 2ms      |\n| medium-dag-1.in  | AC | 492kB    | 2ms      |\n| medium-path-0.in | AC | 488kB    | 2ms      |\n| medium-path-1.in | AC | 492kB    | 2ms      |\n| medium-tree-0.in | AC | 360kB    | 2ms      |\n| medium-tree-1.in | AC | 492kB    | 1ms      |\n| small-dag-0.in   | AC | 128kB    | 1ms      |\n| small-path-0.in  | AC | 128kB    | 1ms      |\n| small-tree-0.in  | AC | 256kB    | 1ms      |\n","source":"_posts/apio2009-atm.md","raw":"title: APIO2009 - \ncategories: OI\ntags: \n  - BZOJ\n  - APIO\n  - \n  - Tarjan\n  - \n  - DAG\n  - \n  - Bellman-Ford\npermalink: apio2009-atm\ndate: 2016-03-10 19:57:45\n---\n\n ATM  ATM \n\n ATM  ATM  ATM \n\n<!-- more -->\n\n### \n[CodeVS 1611](http://codevs.cn/problem/1611/)  \n[BZOJ 1179](http://www.lydsy.com/JudgeOnline/problem.php?id=1179)\n\n### \nTarjan  DAG DAG \n\n### \n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\nstruct SCC;\n\nstruct Node {\n\tEdge *firstEdge, *inEdge, *currentEdge;\n\tint dfn, low, w, dist;\n\tbool inStack, pushed, visited, isBar, inQueue;\n\tSCC *scc;\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct SCC {\n\tNode v;\n\tint size;\n} sccs[MAXN];\n\ninline void addEdge(int from, int to) {\n\tnodes[from].firstEdge = new Edge(&nodes[from], &nodes[to]);\n}\n\nint n;\n\ninline int tarjan() {\n\tint timeStamp = 0, count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (nodes[i].visited) continue;\n\n\t\tstd::stack<Node *> s, t;\n\n\t\ts.push(&nodes[i]);\n\t\tnodes[i].pushed = true;\n\n\t\twhile (!s.empty()) {\n\t\t\tNode *v = s.top();\n\n\t\t\tif (!v->visited) {\n\t\t\t\tv->visited = true;\n\t\t\t\tv->dfn = v->low = timeStamp++;\n\t\t\t\tv->currentEdge = v->firstEdge;\n\t\t\t\tv->inStack = true;\n\t\t\t\tt.push(v);\n\t\t\t}\n\n\t\t\tif (v->currentEdge) {\n\t\t\t\tEdge *&e = v->currentEdge;\n\t\t\t\tif (e->to->inStack) v->low = std::min(v->low, e->to->dfn);\n\t\t\t\telse if (!e->to->pushed) s.push(e->to), e->to->pushed = true, e->to->inEdge = e;\n\t\t\t\te = e->next;\n\t\t\t} else  {\n\t\t\t\ts.pop();\n\n\t\t\t\tif (v->dfn == v->low) {\n\t\t\t\t\tNode *u;\n\t\t\t\t\tv->scc = &sccs[count++];\n\t\t\t\t\tdo {\n\t\t\t\t\t\tu = t.top();\n\t\t\t\t\t\tt.pop();\n\t\t\t\t\t\tu->inStack = false;\n\t\t\t\t\t\tu->scc = v->scc;\n\t\t\t\t\t\tu->scc->size++;\n\t\t\t\t\t\tu->scc->v.w += u->w;\n\t\t\t\t\t\tu->scc->v.isBar |= u->isBar;\n\t\t\t\t\t} while (u != v);\n\t\t\t\t}\n\n\t\t\t\tif (v->inEdge) v->inEdge->from->low = std::min(v->inEdge->from->low, v->low);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\ninline void contract() {\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (Edge *e = nodes[i].firstEdge; e; e = e->next) {\n\t\t\tif (e->from->scc != e->to->scc) {\n\t\t\t\tNode *from = &e->from->scc->v, *to = &e->to->scc->v;\n\t\t\t\tfrom->firstEdge = new Edge(from, to);\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void bellmanford(int start) {\n\tstd::queue<Node *> q;\n\n\tq.push(&nodes[start].scc->v);\n\tnodes[start].scc->v.dist = nodes[start].scc->v.w;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\tv->inQueue = false;\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->dist < v->dist + e->to->w) {\n\t\t\t\te->to->dist = v->dist + e->to->w;\n\t\t\t\t\n\t\t\t\tif (!e->to->inQueue) {\n\t\t\t\t\te->to->inQueue = true;\n\t\t\t\t\tq.push(e->to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint from, to;\n\t\tscanf(\"%d %d\", &from, &to), from--, to--;\n\n\t\taddEdge(from, to);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &nodes[i].w);\n\t}\n\n\tint s, p;\n\tscanf(\"%d %d\", &s, &p), s--;\n\n\tfor (int i = 0; i < p; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x), x--;\n\t\tnodes[x].isBar = true;\n\t}\n\n\tint count = tarjan();\n\tcontract();\n\n\tbellmanford(s);\n\n\tint ans = 0;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (sccs[i].v.isBar) ans = std::max(ans, sccs[i].v.dist);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n```\n\n### \n Dijkstra   Dijkstra \n\n()  Dijkstra\n\n('-')  Bellman-Ford  WA  \n\n \n\n OvO \n\n### \n _\n\n|             | |  | |\n| ---------------- |:--:|:--------:|:--------:|\n| large-dag-0.in   | AC | 42504kB  | 423ms    |\n| large-dag-1.in   | AC | 51052kB  | 476ms    |\n| large-path-0.in  | AC | 55288kB  | 491ms    |\n| large-path-1.in  | AC | 53096kB  | 494ms    |\n| large-tree-0.in  | AC | 49512kB  | 430ms    |\n| large-tree-1.in  | AC | 49772kB  | 406ms    |\n| medium-dag-0.in  | AC | 364kB    | 2ms      |\n| medium-dag-1.in  | AC | 492kB    | 2ms      |\n| medium-path-0.in | AC | 488kB    | 2ms      |\n| medium-path-1.in | AC | 492kB    | 2ms      |\n| medium-tree-0.in | AC | 360kB    | 2ms      |\n| medium-tree-1.in | AC | 492kB    | 1ms      |\n| small-dag-0.in   | AC | 128kB    | 1ms      |\n| small-path-0.in  | AC | 128kB    | 1ms      |\n| small-tree-0.in  | AC | 256kB    | 1ms      |\n","slug":"apio2009-atm","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6da201lbc2xlo3xjecw6"},{"title":"AHOI2014 - ","date":"2016-04-08T09:57:21.000Z","_content":"\n $ N $  $ 1 $  $ N $  $ i $  $ K_i $  $ 0 $ $ i $ \n\n $ 1 $  $ 1 $  $ 1 $ \n\n<!-- more -->\n\n### \n[BZOJ 3876](http://www.lydsy.com/JudgeOnline/problem.php?id=3876)\n\n### \n DAG 1  1  DAG \n\n\n\n $ (u, v, w) $ $ (u, v, [1, \\infty], w) $  $ 1 $  $ u $ $ (u, 1, \\infty, 0) $  $ 1 $ \n\n $ (u, v, w) $ $ (S, v, 1, w) $ $ (u, T, 1, 0) $  $ v $ \n\n$ (u, T, 1, 0) $  $ (u, T, k_i, 0) $\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXK = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint f, d;\n\tbool q;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tT *alloc() {\n\t\tif (cur == buf + (SIZE * sizeof(T))) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn (T *)p;\n\t\t}\n\t}\n};\n\nMemoryPool<Edge, MAXN * MAXK * 5> pool;\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = &(*(pool.alloc()) = Edge(&N[s], &N[t], c, w));\n\tN[t].e = &(*(pool.alloc()) = Edge(&N[t], &N[s], 0, -w));\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t}\n\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\t\te->t->in = e;\n\t\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\t\tif (!e->t->q) {\n\t\t\t\t\t\te->t->q = true;\n\t\t\t\t\t\tq.push(e->t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tflow += N[t].f, cost += N[t].d * N[t].f;\n\t}\n}\n\nint n;\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int u = 1, k; u <= n; u++) {\n\t\tscanf(\"%d\", &k);\n\n\t\tfor (int j = 0, v, w; j < k; j++) {\n\t\t\tscanf(\"%d %d\", &v, &w);\n\n\t\t\taddEdge(u, v, INT_MAX, w);\n\t\t\taddEdge(s, v, 1, w);\n\t\t}\n\n\t\taddEdge(u, t, k, 0);\n\t\tif (u != 1) addEdge(u, 1, INT_MAX, 0);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\treturn 0;\n}\n```\n","source":"_posts/ahoi2014-story.md","raw":"title: AHOI2014 - \ncategories: OI\ntags: \n  - BZOJ\n  - AHOI\n  - \n  - \n  - \n  - Edmonds-Karp\npermalink: ahoi2014-story\ndate: 2016-04-08 17:57:21\n---\n\n $ N $  $ 1 $  $ N $  $ i $  $ K_i $  $ 0 $ $ i $ \n\n $ 1 $  $ 1 $  $ 1 $ \n\n<!-- more -->\n\n### \n[BZOJ 3876](http://www.lydsy.com/JudgeOnline/problem.php?id=3876)\n\n### \n DAG 1  1  DAG \n\n\n\n $ (u, v, w) $ $ (u, v, [1, \\infty], w) $  $ 1 $  $ u $ $ (u, 1, \\infty, 0) $  $ 1 $ \n\n $ (u, v, w) $ $ (S, v, 1, w) $ $ (u, T, 1, 0) $  $ v $ \n\n$ (u, T, 1, 0) $  $ (u, T, k_i, 0) $\n\n### \n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 300;\nconst int MAXK = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *in;\n\tint f, d;\n\tbool q;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *s, *t;\n\tint f, c, w;\n\tEdge *next, *r;\n\n\tEdge(Node *const s, Node *const t, const int c, const int w) : s(s), t(t), f(0), c(c), w(w), next(s->e) {}\n};\n\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n\tchar buf[SIZE * sizeof(T)], *cur;\n\n\tMemoryPool() : cur(buf) {}\n\n\tT *alloc() {\n\t\tif (cur == buf + (SIZE * sizeof(T))) return (T *)malloc(sizeof(T));\n\t\telse {\n\t\t\tchar *p = cur;\n\t\t\tcur += sizeof(T);\n\t\t\treturn (T *)p;\n\t\t}\n\t}\n};\n\nMemoryPool<Edge, MAXN * MAXK * 5> pool;\ninline void addEdge(const int s, const int t, const int c, const int w) {\n\tN[s].e = &(*(pool.alloc()) = Edge(&N[s], &N[t], c, w));\n\tN[t].e = &(*(pool.alloc()) = Edge(&N[t], &N[s], 0, -w));\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\ninline void edmondskarp(const int s, const int t, const int n, int &flow, int &cost) {\n\tflow = cost = 0;\n\twhile (1) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tN[i].q = false;\n\t\t\tN[i].in = NULL;\n\t\t\tN[i].f = 0;\n\t\t\tN[i].d = INT_MAX;\n\t\t}\n\n\t\tN[s].f = INT_MAX, N[s].d = 0;\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[s]);\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\tv->q = false;\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->d > v->d + e->w) {\n\t\t\t\t\te->t->d = v->d + e->w;\n\t\t\t\t\te->t->in = e;\n\t\t\t\t\te->t->f = std::min(v->f, e->c - e->f);\n\t\t\t\t\tif (!e->t->q) {\n\t\t\t\t\t\te->t->q = true;\n\t\t\t\t\t\tq.push(e->t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (N[t].d == INT_MAX) return;\n\n\t\tfor (Edge *e = N[t].in; e; e = e->s->in) {\n\t\t\te->f += N[t].f;\n\t\t\te->r->f -= N[t].f;\n\t\t}\n\n\t\tflow += N[t].f, cost += N[t].d * N[t].f;\n\t}\n}\n\nint n;\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tconst int s = 0, t = n + 1;\n\tfor (int u = 1, k; u <= n; u++) {\n\t\tscanf(\"%d\", &k);\n\n\t\tfor (int j = 0, v, w; j < k; j++) {\n\t\t\tscanf(\"%d %d\", &v, &w);\n\n\t\t\taddEdge(u, v, INT_MAX, w);\n\t\t\taddEdge(s, v, 1, w);\n\t\t}\n\n\t\taddEdge(u, t, k, 0);\n\t\tif (u != 1) addEdge(u, 1, INT_MAX, 0);\n\t}\n\n\tint flow, cost;\n\tedmondskarp(s, t, n + 2, flow, cost);\n\n\tprintf(\"%d\\n\", cost);\n\n\treturn 0;\n}\n```\n","slug":"ahoi2014-story","published":1,"updated":"2016-12-25T01:57:05.190Z","_id":"cix2l6dai01loc2xlnrj4he67","comments":1,"layout":"post","photos":[],"link":""},{"title":"AHOI2013 - ","date":"2016-09-29T13:07:00.000Z","_content":"\n $ n $  $ T_i $  $ i $ \n\n$$ \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{len}(T_i) + \\mathrm{len}(T_j) - 2 \\times \\mathrm{lcp}(T_i, T_j) $$\n\n<!-- more -->\n\n### \n[BZOJ 3238](http://www.lydsy.com/JudgeOnline/problem.php?id=3238)\n\n### \n\n\n$$ \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{len}(T_i) + \\mathrm{len}(T_j) = \\sum\\limits_{i = 2} ^ n \\frac{i(i - 1)}{2} + i(i - 1) $$\n\n\n\n$$ -2 \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{lcp}(T_i, T_j) $$\n\n LCP \n\n $ \\mathrm{height}[] $  $ a_i $ \n\n $ a_i $ ********$ a_i $ \n\n $ a_i $  $ l_i $  $ a_i $  $ r_i $  $ a_i $ \n\n$$ (l_i + 1) \\times (r_i + 1) \\times a_i $$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 500000;\n\nint n, sa[MAXN], rk[MAXN], ht[MAXN];\nunsigned long long l[MAXN], r[MAXN];\nchar s[MAXN];\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = i + t >= n ? -1 : rk[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tint j = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%s\\n\", &s[sa[i]]);\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n}\n\n/*\ninline int lcp(const int i, const int j) {\n\t/ *\n\tint a = rk[i], b = rk[j], ans = n;\n\tif (a > b) std::swap(a, b);\n\tfor (int i = a + 1; i <= b; i++) ans = std::min(ans, ht[i]);\n\t// printf(\"- %d %d => %d\\n\", a + 1, b, ans);\n\treturn ans;\n\t* /\n\n\tint ans = 0;\n\twhile (s[i + ans] == s[j + ans] && i + ans < n && j + ans < n) ans++;\n\treturn ans;\n}\n*/\n\ninline void prepare() {\n\tstd::stack<int> s;\n\tfor (int i = 1; i < n; i++) {\n\t\twhile (!s.empty() && ht[s.top()] > ht[i]) s.pop();\n\t\tl[i] = s.empty() ? i - 1 : i - s.top() - 1;\n\t\ts.push(i);\n\t}\n\twhile (!s.empty()) s.pop();\n\n\tfor (int i = n - 1; i >= 1; i--) {\n\t\twhile (!s.empty() && ht[s.top()] >= ht[i]) s.pop();\n\t\tr[i] = s.empty() ? n - i - 1 : s.top() - i - 1;\n\t\ts.push(i);\n\t}\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tsuffixArray();\n\n\tunsigned long long sumLcp = 0;\n\t/*\n\tfor (int i = 1; i < n; i++) for (int j = i; j < n; j++) {\n\t\tint min = n;\n\t\tfor (int k = i; k <= j; k++) min = std::min(min, ht[k]);\n\t\tsumLcp += min;\n\t}\n\t*/\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tsumLcp += lcp(i, j);\n\t\t}\n\t}\n\t*/\n\n\tprepare();\n\t// /*\n\tfor (int i = 1; i < n; i++) {\n\t\t// printf(\"%d: %d %d\\n\", i, l[i], r[i]);\n\t\tsumLcp += static_cast<unsigned long long>(l[i] + 2) * (r[i] + 1) * ht[i];\n\t}\n\t// */\n\n\tunsigned long long sum = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tunsigned long long t = static_cast<unsigned long long>(1 + (i - 1)) * (i - 1) / 2 + static_cast<unsigned long long>(i) * (i - 1);\n\t\t// printf(\"- %lld\\n\", t);\n\t\tsum += t;\n\t\t// printf(\"sum = %llu\\n\", sum);\n\t}\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t// printf(\"- %d %d\\n\", n - i, n - j);\n\t\t\tsum += n - i + n - j;\n\t\t}\n\t}\n\t*/\n\n\tprintf(\"%llu\\n\", sum - 2 * sumLcp);\n\n\treturn 0;\n}\n```","source":"_posts/ahoi2013-diff.md","raw":"title: AHOI2013 - \ncategories: OI\ntags: \n  - BZOJ\n  - AHOI\n  - \n  - \n  - \npermalink: ahoi2013-diff\ndate: 2016-09-29 21:07:00\n---\n\n $ n $  $ T_i $  $ i $ \n\n$$ \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{len}(T_i) + \\mathrm{len}(T_j) - 2 \\times \\mathrm{lcp}(T_i, T_j) $$\n\n<!-- more -->\n\n### \n[BZOJ 3238](http://www.lydsy.com/JudgeOnline/problem.php?id=3238)\n\n### \n\n\n$$ \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{len}(T_i) + \\mathrm{len}(T_j) = \\sum\\limits_{i = 2} ^ n \\frac{i(i - 1)}{2} + i(i - 1) $$\n\n\n\n$$ -2 \\sum\\limits_{1 \\leq i < j \\leq n} \\mathrm{lcp}(T_i, T_j) $$\n\n LCP \n\n $ \\mathrm{height}[] $  $ a_i $ \n\n $ a_i $ ********$ a_i $ \n\n $ a_i $  $ l_i $  $ a_i $  $ r_i $  $ a_i $ \n\n$$ (l_i + 1) \\times (r_i + 1) \\times a_i $$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n\nconst int MAXN = 500000;\n\nint n, sa[MAXN], rk[MAXN], ht[MAXN];\nunsigned long long l[MAXN], r[MAXN];\nchar s[MAXN];\n\ninline void suffixArray() {\n\tstatic int set[MAXN], a[MAXN];\n\tfor (int i = 0; i < n; i++) set[i] = s[i];\n\tstd::sort(set, set + n);\n\tint *end = std::unique(set, set + n);\n\tfor (int i = 0; i < n; i++) a[i] = std::lower_bound(set, end, s[i]) - set;\n\n\tstatic int fir[MAXN], sec[MAXN], tmp[MAXN], _buc[MAXN + 1], *buc = _buc + 1;\n\tfor (int i = 0; i < n; i++) buc[a[i]]++;\n\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\tfor (int i = 0; i < n; i++) rk[i] = buc[a[i] - 1];\n\tfor (int t = 1; t < n; t *= 2) {\n\t\tfor (int i = 0; i < n; i++) fir[i] = rk[i];\n\t\tfor (int i = 0; i < n; i++) sec[i] = i + t >= n ? -1 : rk[i + t];\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[sec[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) tmp[n - buc[sec[i]]--] = i;\n\n\t\tstd::fill(buc - 1, buc + n, 0);\n\t\tfor (int i = 0; i < n; i++) buc[fir[i]]++;\n\t\tfor (int i = 0; i < n; i++) buc[i] += buc[i - 1];\n\t\tfor (int i = 0; i < n; i++) sa[--buc[fir[tmp[i]]]] = tmp[i];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!i) rk[sa[i]] = 0;\n\t\t\telse if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) rk[sa[i]] = rk[sa[i - 1]];\n\t\t\telse rk[sa[i]] = rk[sa[i - 1]] + 1;\n\t\t}\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", rk[i], i == n - 1 ? '\\n' : ' ');\n\t\n\tfor (int i = 0, k = 0; i < n; i++) {\n\t\tint j = sa[rk[i] - 1];\n\t\tif (k) k--;\n\t\twhile (i + k < n && j + k < n && a[i + k] == a[j + k]) k++;\n\t\tht[rk[i]] = k;\n\t}\n\n\t// for (int i = 0; i < n; i++) printf(\"%s\\n\", &s[sa[i]]);\n\t// for (int i = 0; i < n; i++) printf(\"%d%c\", ht[i], i == n - 1 ? '\\n' : ' ');\n}\n\n/*\ninline int lcp(const int i, const int j) {\n\t/ *\n\tint a = rk[i], b = rk[j], ans = n;\n\tif (a > b) std::swap(a, b);\n\tfor (int i = a + 1; i <= b; i++) ans = std::min(ans, ht[i]);\n\t// printf(\"- %d %d => %d\\n\", a + 1, b, ans);\n\treturn ans;\n\t* /\n\n\tint ans = 0;\n\twhile (s[i + ans] == s[j + ans] && i + ans < n && j + ans < n) ans++;\n\treturn ans;\n}\n*/\n\ninline void prepare() {\n\tstd::stack<int> s;\n\tfor (int i = 1; i < n; i++) {\n\t\twhile (!s.empty() && ht[s.top()] > ht[i]) s.pop();\n\t\tl[i] = s.empty() ? i - 1 : i - s.top() - 1;\n\t\ts.push(i);\n\t}\n\twhile (!s.empty()) s.pop();\n\n\tfor (int i = n - 1; i >= 1; i--) {\n\t\twhile (!s.empty() && ht[s.top()] >= ht[i]) s.pop();\n\t\tr[i] = s.empty() ? n - i - 1 : s.top() - i - 1;\n\t\ts.push(i);\n\t}\n}\n\nint main() {\n\tscanf(\"%s\", s);\n\tn = strlen(s);\n\tsuffixArray();\n\n\tunsigned long long sumLcp = 0;\n\t/*\n\tfor (int i = 1; i < n; i++) for (int j = i; j < n; j++) {\n\t\tint min = n;\n\t\tfor (int k = i; k <= j; k++) min = std::min(min, ht[k]);\n\t\tsumLcp += min;\n\t}\n\t*/\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tsumLcp += lcp(i, j);\n\t\t}\n\t}\n\t*/\n\n\tprepare();\n\t// /*\n\tfor (int i = 1; i < n; i++) {\n\t\t// printf(\"%d: %d %d\\n\", i, l[i], r[i]);\n\t\tsumLcp += static_cast<unsigned long long>(l[i] + 2) * (r[i] + 1) * ht[i];\n\t}\n\t// */\n\n\tunsigned long long sum = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tunsigned long long t = static_cast<unsigned long long>(1 + (i - 1)) * (i - 1) / 2 + static_cast<unsigned long long>(i) * (i - 1);\n\t\t// printf(\"- %lld\\n\", t);\n\t\tsum += t;\n\t\t// printf(\"sum = %llu\\n\", sum);\n\t}\n\t/*\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t// printf(\"- %d %d\\n\", n - i, n - j);\n\t\t\tsum += n - i + n - j;\n\t\t}\n\t}\n\t*/\n\n\tprintf(\"%llu\\n\", sum - 2 * sumLcp);\n\n\treturn 0;\n}\n```","slug":"ahoi2013-diff","published":1,"updated":"2016-09-29T13:25:07.464Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6das01lxc2xlc6w1mh62"},{"title":"AHOI2008 - ","date":"2016-03-07T12:36:46.000Z","_content":"\n\n\n<!-- more -->\n\n### \n[BZOJ 1787](http://www.lydsy.com/JudgeOnline/problem.php?id=1787)\n\n### \n LCA \n\n LCA  LCA   qwq\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXLOGN = 19; // log(500000, 2) = 18.931568569324174\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, depth;\n\t\n\tstruct SparseTable {\n\t\tint dist;\n\t\tNode *v;\n\t} st[MAXLOGN + 1];\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int u, int v) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v]);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u]);\n}\n\ninline void makeSparseTable() {\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->depth == 0) {\n\t\t\t\te->to->depth = v->depth + 1;\n\n\t\t\t\te->to->st[0].v = v;\n\t\t\t\te->to->st[0].dist = 1;\n\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tnodes[0].st[0].v = &nodes[0];\n\tnodes[0].st[0].dist = 0;\n\n\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].st[j].v = nodes[i].st[j - 1].v->st[j - 1].v;\n\t\t\tnodes[i].st[j].dist = nodes[i].st[j - 1].dist + nodes[i].st[j - 1].v->st[j - 1].dist;\n\t\t}\n\t}\n}\n\ninline int query(const int a, const int b, Node **lca = NULL) {\n\tNode *u = &nodes[a], *v = &nodes[b];\n\tint dist = 0;\n\n\tif (u->depth < v->depth) {\n\t\tstd::swap(u, v);\n\t}\n\n\tif (u->depth != v->depth) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != NULL && u->st[i].v->depth >= v->depth) {\n\t\t\t\tdist += u->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (u != v) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != v->st[i].v) {\n\t\t\t\tdist += u->st[i].dist + v->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t\tv = v->st[i].v;\n\t\t\t}\n\t\t}\n\n\t\tdist += u->st[0].dist + v->st[0].dist;\n\t\t\n\t\tif (lca) *lca = u->st[0].v;\n\t\treturn dist;\n\t}\n\n\tif (lca) *lca = u;\n\treturn dist;\n}\n\ninline int solve(int a, int b, int c) {\n\tNode *ab, *bc, *ca;\n\tint distAB, distBC, distCA;\n\n\tquery(a, b, &ab);\n\tquery(b, c, &bc);\n\tquery(c, a, &ca);\n\n\t// printf(\"%d, %d, %d\\n\", ab->id, bc->id, ca->id);\n\n\tNode *v;\n\tif (ab == bc) {\n\t\tv = ca;\n\t} else if (bc == ca) {\n\t\tv = ab;\n\t} else if (ca == ab) {\n\t\tv = bc;\n\t}\n\n\tassert(v != NULL);\n\treturn v->id;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\n\t\taddEdge(u, v);\n\t}\n\n\tmakeSparseTable();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c), a--, b--, c--;\n\n\t\tint id = solve(a, b, c);\n\t\tint dist = query(a, id - 1) + query(b, id - 1) + query(c, id - 1);\n\n\t\tprintf(\"%d %d\\n\", id, dist);\n\t}\n\n\treturn 0;\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct UnionFindSet {\n\tint a[MAXN];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) a[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn a[x] == x ? x : a[x] = find(a[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\ta[find(x)] = find(y);\n\t}\n};\n\ninline int rand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tint x = rand();\n\tsrand((time(NULL) << 16) | ((clock() << 16) >> 16) ^ x ^ MAGIC_NUMBER);\n\treturn (rand() ^ x) % (r - l + 1) + l;\n}\n\nint main() {\n\tint n = MAXN, m = MAXM;\n\n\tstatic UnionFindSet ufs;\n\tufs.init(n);\n\n\tprintf(\"%d %d\\n\", n, m);\n\n\tfor (int i = 0; i < n - 1; ) {\n\t\tint u, v;\n\t\tu = rand(1, n), v = rand(1, n);\n\n\t\tif (ufs.find(u - 1) != ufs.find(v - 1)) {\n\t\t\tufs.merge(u - 1, v - 1);\n\t\t\tprintf(\"%d %d\\n\", u, v);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\ta = rand(1, n), b = rand(1, n), c = rand(1, n);\n\n\t\tprintf(\"%d %d %d\\n\", a, b, c);\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/ahoi2008-meet.md","raw":"title: AHOI2008 - \ncategories: OI\ntags: \n  - BZOJ\n  - AHOI\n  - \n  - \n  - \npermalink: ahoi2008-meet\ndate: 2016-03-07 20:36:46\n---\n\n\n\n<!-- more -->\n\n### \n[BZOJ 1787](http://www.lydsy.com/JudgeOnline/problem.php?id=1787)\n\n### \n LCA \n\n LCA  LCA   qwq\n\n### \n```cpp\n#include <cstdio>\n#include <climits>\n#include <cassert>\n#include <algorithm>\n#include <queue>\n\nconst int MAXN = 500000;\nconst int MAXLOGN = 19; // log(500000, 2) = 18.931568569324174\nconst int MAXM = 500000;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *firstEdge;\n\tint id, depth;\n\t\n\tstruct SparseTable {\n\t\tint dist;\n\t\tNode *v;\n\t} st[MAXLOGN + 1];\n} nodes[MAXN];\n\nstruct Edge {\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nint n, m;\n\ninline void addEdge(int u, int v) {\n\tnodes[u].firstEdge = new Edge(&nodes[u], &nodes[v]);\n\tnodes[v].firstEdge = new Edge(&nodes[v], &nodes[u]);\n}\n\ninline void makeSparseTable() {\n\tstd::queue<Node *> q;\n\tq.push(&nodes[0]);\n\tnodes[0].depth = 1;\n\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\n\n\t\tfor (Edge *e = v->firstEdge; e; e = e->next) {\n\t\t\tif (e->to->depth == 0) {\n\t\t\t\te->to->depth = v->depth + 1;\n\n\t\t\t\te->to->st[0].v = v;\n\t\t\t\te->to->st[0].dist = 1;\n\n\t\t\t\tq.push(e->to);\n\t\t\t}\n\t\t}\n\t}\n\n\tnodes[0].st[0].v = &nodes[0];\n\tnodes[0].st[0].dist = 0;\n\n\tfor (int j = 1; (1 << j) <= n; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnodes[i].st[j].v = nodes[i].st[j - 1].v->st[j - 1].v;\n\t\t\tnodes[i].st[j].dist = nodes[i].st[j - 1].dist + nodes[i].st[j - 1].v->st[j - 1].dist;\n\t\t}\n\t}\n}\n\ninline int query(const int a, const int b, Node **lca = NULL) {\n\tNode *u = &nodes[a], *v = &nodes[b];\n\tint dist = 0;\n\n\tif (u->depth < v->depth) {\n\t\tstd::swap(u, v);\n\t}\n\n\tif (u->depth != v->depth) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != NULL && u->st[i].v->depth >= v->depth) {\n\t\t\t\tdist += u->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (u != v) {\n\t\tfor (int i = MAXLOGN; i >= 0; i--) {\n\t\t\tif (u->st[i].v != v->st[i].v) {\n\t\t\t\tdist += u->st[i].dist + v->st[i].dist;\n\t\t\t\tu = u->st[i].v;\n\t\t\t\tv = v->st[i].v;\n\t\t\t}\n\t\t}\n\n\t\tdist += u->st[0].dist + v->st[0].dist;\n\t\t\n\t\tif (lca) *lca = u->st[0].v;\n\t\treturn dist;\n\t}\n\n\tif (lca) *lca = u;\n\treturn dist;\n}\n\ninline int solve(int a, int b, int c) {\n\tNode *ab, *bc, *ca;\n\tint distAB, distBC, distCA;\n\n\tquery(a, b, &ab);\n\tquery(b, c, &bc);\n\tquery(c, a, &ca);\n\n\t// printf(\"%d, %d, %d\\n\", ab->id, bc->id, ca->id);\n\n\tNode *v;\n\tif (ab == bc) {\n\t\tv = ca;\n\t} else if (bc == ca) {\n\t\tv = ab;\n\t} else if (ca == ab) {\n\t\tv = bc;\n\t}\n\n\tassert(v != NULL);\n\treturn v->id;\n}\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\n\tfor (int i = 0; i < n; i++) nodes[i].id = i + 1;\n\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\n\t\taddEdge(u, v);\n\t}\n\n\tmakeSparseTable();\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c), a--, b--, c--;\n\n\t\tint id = solve(a, b, c);\n\t\tint dist = query(a, id - 1) + query(b, id - 1) + query(c, id - 1);\n\n\t\tprintf(\"%d %d\\n\", id, dist);\n\t}\n\n\treturn 0;\n}\n```\n\n### \n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n\nconst int MAXN = 500000;\nconst int MAXM = 500000;\n\nstruct UnionFindSet {\n\tint a[MAXN];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++) a[i] = i;\n\t}\n\n\tint find(int x) {\n\t\treturn a[x] == x ? x : a[x] = find(a[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\ta[find(x)] = find(y);\n\t}\n};\n\ninline int rand(int l, int r) {\n\tconst int MAGIC_NUMBER = 20000528;\n\tint x = rand();\n\tsrand((time(NULL) << 16) | ((clock() << 16) >> 16) ^ x ^ MAGIC_NUMBER);\n\treturn (rand() ^ x) % (r - l + 1) + l;\n}\n\nint main() {\n\tint n = MAXN, m = MAXM;\n\n\tstatic UnionFindSet ufs;\n\tufs.init(n);\n\n\tprintf(\"%d %d\\n\", n, m);\n\n\tfor (int i = 0; i < n - 1; ) {\n\t\tint u, v;\n\t\tu = rand(1, n), v = rand(1, n);\n\n\t\tif (ufs.find(u - 1) != ufs.find(v - 1)) {\n\t\t\tufs.merge(u - 1, v - 1);\n\t\t\tprintf(\"%d %d\\n\", u, v);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\ta = rand(1, n), b = rand(1, n), c = rand(1, n);\n\n\t\tprintf(\"%d %d %d\\n\", a, b, c);\n\t}\n\n\treturn 0;\n}\n```\n","slug":"ahoi2008-meet","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6db101m5c2xl8o2hxcgz"},{"title":"AC ","date":"2016-09-18T23:04:00.000Z","_content":"\nAC \n\n<!-- more -->\n\n### \n>  Trie  Trie \n\n Trie  KMP  $ O(n) $ \n\n### \n KMP  $ i $  $ j $ $ \\mathrm{fail}(i) = j $\n\n $ \\mathrm{fail}(i) = j $    $ j $  $ i $ ****\n\n Trie  $ j $ $ j $  $ i $ ****\n\n### \n![AC ](/home/Menci/Hexo/source/_posts/acam-notes/acam.svg?3)\n\n $ i $  $ i' $$ i $  $ c $\n\n $ \\mathrm{fail}(i') $  $ c $  $ \\mathrm{fail}(i) $  \n $ \\mathrm{fail}(7) = 1, \\mathrm{fail}(8) = 2 $\n\n $ \\mathrm{fail}(i') $  $ c $  $ \\mathrm{fail}(\\mathrm{fail}(i')) $   $ \\mathrm{fail}(i) $   \n $ \\mathrm{fail}(3) = 0 $\n\n### \n $ i $ $ c $ $ i $  $ c $ $ \\mathrm{fail}(i) $  $ c $ \n\n $ i $ $ \\mathrm{fail}(i) $ \n\n`a`  `bac`  AC \n![AC ](/home/Menci/Hexo/source/_posts/acam-notes/acam2.svg)\n\n 3  1 `ba`  3 1   $ \\mathrm{next}(i) $  $ i $  $ \\mathrm{next}(3) = 1 $\n\n\n\n   $ \\mathrm{fail}(i) $  $ \\mathrm{next}(i) = \\mathrm{fail}(i) $ $ \\mathrm{next}(i) = \\mathrm{next}(\\mathrm{fail}(i)) $\n\n### \n\n\n****\n\n $ i $ $ c $  $ c $  $ \\mathrm{fail}(i) $  Trie **Trie **\n\n### \n\n\n 2016  12  27 \n\n![zyz ](acam-notes/zyz.png)\n\n```c++\nconst int CHARSET_SIZE = 'z' - 'a' + 1; // \nconst char BASE_CHAR = 'a'; // \n\nstruct Trie\n{\n\tstruct Node\n\t{\n\t\tNode *c[CHARSET_SIZE], *next, *fail;\n\t\tbool isWord;\n\t\tint ans;\n\n\t\tNode(bool isWord = false) : next(NULL), fail(NULL), isWord(isWord)\n\t\t{\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply()\n\t\t{\n\t\t\tans++;\n\t\t\tif (next) next->apply();\n\t\t}\n\t} *root;\n\n\tTrie() : root(new Node()) {}\n\n\tNode *insert(const char *begin, const char *end)\n\t{\n\t\t//  Splay\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++)\n\t\t{\n\t\t\t// \n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build()\n\t{\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root; // \n\t\troot->next = NULL;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++)\n\t\t\t{\n\t\t\t\t// \n\t\t\t\tNode *&c = v->c[i];\n\n\t\t\t\t//  Trie \n\t\t\t\tif (!c)\n\t\t\t\t{\n\t\t\t\t\t//  v == root v->fail == rootc  v->fail->c[i] \n                    c = v == root ? root : v->fail->c[i];\n                    continue;\n                }\n\t\t\t\tNode *u = v->fail;\n\n\t\t\t\t//  KMP \n\t\t\t\t// while (u != root && !u->c[i]) u = u->fail; //  Trie \n\n\t\t\t\t//  v == root\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\n\t\t\t\t//  fail \n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end)\n\t{\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++)\n\t\t{\n\t\t\t// \n\t\t\tv = v->c[*p];\n\n\t\t\t// \n\t\t\tif (v->isWord) v->apply();\n\t\t\telse if (v->next) v->next->apply(); //  else if\n\t\t}\n\t}\n};\n```\n","source":"_posts/acam-notes.md","raw":"title: AC \ncategories: OI\ntags: \n  - AC \n  - \n  - \n  - \npermalink: acam-notes\ndate: 2016-09-19 07:04:00\n---\n\nAC \n\n<!-- more -->\n\n### \n>  Trie  Trie \n\n Trie  KMP  $ O(n) $ \n\n### \n KMP  $ i $  $ j $ $ \\mathrm{fail}(i) = j $\n\n $ \\mathrm{fail}(i) = j $    $ j $  $ i $ ****\n\n Trie  $ j $ $ j $  $ i $ ****\n\n### \n![AC ](/home/Menci/Hexo/source/_posts/acam-notes/acam.svg?3)\n\n $ i $  $ i' $$ i $  $ c $\n\n $ \\mathrm{fail}(i') $  $ c $  $ \\mathrm{fail}(i) $  \n $ \\mathrm{fail}(7) = 1, \\mathrm{fail}(8) = 2 $\n\n $ \\mathrm{fail}(i') $  $ c $  $ \\mathrm{fail}(\\mathrm{fail}(i')) $   $ \\mathrm{fail}(i) $   \n $ \\mathrm{fail}(3) = 0 $\n\n### \n $ i $ $ c $ $ i $  $ c $ $ \\mathrm{fail}(i) $  $ c $ \n\n $ i $ $ \\mathrm{fail}(i) $ \n\n`a`  `bac`  AC \n![AC ](/home/Menci/Hexo/source/_posts/acam-notes/acam2.svg)\n\n 3  1 `ba`  3 1   $ \\mathrm{next}(i) $  $ i $  $ \\mathrm{next}(3) = 1 $\n\n\n\n   $ \\mathrm{fail}(i) $  $ \\mathrm{next}(i) = \\mathrm{fail}(i) $ $ \\mathrm{next}(i) = \\mathrm{next}(\\mathrm{fail}(i)) $\n\n### \n\n\n****\n\n $ i $ $ c $  $ c $  $ \\mathrm{fail}(i) $  Trie **Trie **\n\n### \n\n\n 2016  12  27 \n\n![zyz ](acam-notes/zyz.png)\n\n```c++\nconst int CHARSET_SIZE = 'z' - 'a' + 1; // \nconst char BASE_CHAR = 'a'; // \n\nstruct Trie\n{\n\tstruct Node\n\t{\n\t\tNode *c[CHARSET_SIZE], *next, *fail;\n\t\tbool isWord;\n\t\tint ans;\n\n\t\tNode(bool isWord = false) : next(NULL), fail(NULL), isWord(isWord)\n\t\t{\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n\t\t}\n\n\t\tvoid apply()\n\t\t{\n\t\t\tans++;\n\t\t\tif (next) next->apply();\n\t\t}\n\t} *root;\n\n\tTrie() : root(new Node()) {}\n\n\tNode *insert(const char *begin, const char *end)\n\t{\n\t\t//  Splay\n\t\tNode **v = &root;\n\t\tfor (const char *p = begin; p != end; p++)\n\t\t{\n\t\t\t// \n\t\t\tif (!*v) *v = new Node;\n\t\t\tv = &(*v)->c[*p];\n\t\t}\n\t\tif (!*v) *v = new Node(true);\n\t\telse (*v)->isWord = true;\n\t\treturn *v;\n\t}\n\n\tvoid build()\n\t{\n\t\tstd::queue<Node *> q;\n\t\tq.push(root);\n\t\troot->fail = root; // \n\t\troot->next = NULL;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < CHARSET_SIZE; i++)\n\t\t\t{\n\t\t\t\t// \n\t\t\t\tNode *&c = v->c[i];\n\n\t\t\t\t//  Trie \n\t\t\t\tif (!c)\n\t\t\t\t{\n\t\t\t\t\t//  v == root v->fail == rootc  v->fail->c[i] \n                    c = v == root ? root : v->fail->c[i];\n                    continue;\n                }\n\t\t\t\tNode *u = v->fail;\n\n\t\t\t\t//  KMP \n\t\t\t\t// while (u != root && !u->c[i]) u = u->fail; //  Trie \n\n\t\t\t\t//  v == root\n\t\t\t\tc->fail = v != root && u->c[i] ? u->c[i] : root;\n\n\t\t\t\t//  fail \n\t\t\t\tc->next = c->fail->isWord ? c->fail : c->fail->next;\n\t\t\t\tq.push(c);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid exec(const char *begin, const char *end)\n\t{\n\t\tNode *v = root;\n\t\tfor (const char *p = begin; p != end; p++)\n\t\t{\n\t\t\t// \n\t\t\tv = v->c[*p];\n\n\t\t\t// \n\t\t\tif (v->isWord) v->apply();\n\t\t\telse if (v->next) v->next->apply(); //  else if\n\t\t}\n\t}\n};\n```\n","slug":"acam-notes","published":1,"updated":"2016-12-27T02:41:19.683Z","_id":"cix2l6dba01mcc2xly70b6g77","comments":1,"layout":"post","photos":[],"link":""},{"title":" 2016Play with array - ","date":"2016-05-27T15:55:00.000Z","_content":"\n $ n $ \n\n1.  $ a_r $  $ a_l $ \n2.  $ [l,\\ r] $  $ k $ \n\n<!-- more -->\n\n### \n $ O(\\sqrt n) $ \n\n $ [l,\\ r] $  $ [1,\\ r] $  $ [1,\\ l - 1] $ \n\n $ O(n \\sqrt n) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <list>\n#include <vector>\n#include <algorithm>\n#include <stack>\n\n#define dprintf(format, ...) fprintf(stderr, format, __VA_ARGS__)\n\nconst int MAXN = 100000;\nconst int MAXN_SQRT = 316 + 1;\nconst int MAXM = 100000;\n\nint n, m, a[MAXN];\n\nstruct BlockList {\n\tstruct Block {\n\t\tstd::list<int> l;\n\t\tstd::vector<int> sum;\n\n\t\tBlock() : sum(n) {}\n\n\t\tinline int left(const int k, const int pos) {\n\t\t\tint res = 0;\n\t\t\tstd::list<int>::const_iterator it = l.begin();\n\t\t\tfor (int i = 0; i <= pos; i++) if (*it++ == k) res++;\n\t\t\treturn res;\n\t\t}\n\t};\n\tstd::list<Block> blocks;\n\tint blockCount, blockSize;\n\n\tinline void build(const int *a, const int n) {\n\t\tblockCount = floor(sqrt(n) + 1), blockSize = ceil(static_cast<double>(n) / blockCount);\n\t\t// dprintf(\"BlockList::build(): blockCount = %d, blockSize = %d\\n\", blockCount, blockSize);\n\t\tblocks.resize(blockCount);\n\t\tstd::list<Block>::iterator b = blocks.begin();\n\t\tfor (int i = 0, j = 0; i < blockCount; i++, b++) {\n\t\t\tfor (int k = 0; k <= blockSize && j < n; k++, j++) {\n\t\t\t\tb->sum[a[j]]++;\n\t\t\t\tb->l.push_back(a[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tinline int erase(int pos) {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tstd::list<int>::iterator it = b->l.begin();\n\t\t\t\tstd::advance(it, pos);\n\t\t\t\tconst int x = *it;\n\t\t\t\tb->sum[*it]--;\n\t\t\t\tb->l.erase(it);\n\t\t\t\treturn x;\n\t\t\t} else pos -= b->l.size();\n\t\t}\n\t\tthrow;\n\t}\n\n\tinline void insert(int pos, const int x) {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tstd::list<int>::iterator it = b->l.begin();\n\t\t\t\tstd::advance(it, pos);\n\t\t\t\tb->sum[x]++;\n\t\t\t\tb->l.insert(it, x);\n\t\t\t\treturn;\n\t\t\t} else pos -= b->l.size();\n\t\t}\n\t\tthrow;\n\t}\n\n\tinline int query(int pos, const int k) {\n\t\tint ans = 0;\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tans += b->left(k, pos);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tpos -= b->l.size();\n\t\t\t\tans += b->sum[k];\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tinline void mergeNext(std::list<Block>::iterator b) {\n\t\tstd::list<Block>::iterator next = b;\n\t\tnext++;\n\t\tif (next == blocks.end()) return;\n\t\tfor (std::list<int>::const_iterator it = next->l.begin(); it != next->l.end(); it++) {\n\t\t\tb->l.push_back(*it);\n\t\t\tb->sum[*it]++;\n\t\t}\n\t\tblocks.erase(next);\n\t}\n\n\tinline void split(std::list<Block>::iterator b) {\n\t\tstd::list<Block>::iterator newBlock = blocks.insert(b, Block());\n\t\tfor (int i = 0; i < b->l.size() / 2; i++) {\n\t\t\tconst int &x = b->l.front();\n\t\t\tnewBlock->l.push_back(x);\n\t\t\tnewBlock->sum[x]++;\n\t\t\tb->sum[x]--;\n\t\t\tb->l.pop_front();\n\t\t}\n\t}\n\n\tinline void maintain() {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (b->l.size() <= blockSize / 2) mergeNext(b);\n\t\t\telse if (b->l.size() >= blockSize * 2) split(b);\n\t\t}\n\t}\n\n\tinline void print() {\n\t\tfor (std::list<Block>::const_iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tdprintf(\"blockSize = %d\\n\", b->l.size());\n\t\t}\n\n\t\treturn;\n\t\tfor (std::list<Block>::const_iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tfor (std::list<int>::const_iterator it = b->l.begin(); it != b->l.end(); it++) {\n\t\t\t\tdprintf(\"%d \", *it + 1);\n\t\t\t}\n\t\t}\n\t\tdprintf(\"%c\", '\\n');\n\t}\n} list;\n\nint main() {\n\t// freopen(\"array.in\", \"r\", stdin);\n\t// freopen(\"array.out\", \"w\", stdout);\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]), a[i]--;\n\t}\n\n\tlist.build(a, n);\n\n\t// list.print();\n\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tint t, l, r;\n\t\tscanf(\"%d %d %d\", &t, &l, &r), l--, r--;\n\t\tif (t == 1) {\n\t\t\tint x = list.erase(r);\n\t\t\tlist.insert(l, x);\n\t\t\t// list.print();\n\t\t\tlist.maintain();\n\t\t\t// list.print();\n\t\t\t// dprintf(\"%c\", '\\n');\n\t\t} else {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k), k--;\n\t\t\tint R = list.query(r, k), L = l == 0 ? 0 : list.query(l - 1, k);\n\t\t\tprintf(\"%d\\n\", R - L);\n\t\t}\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\t// list.print();\n\n\treturn 0;\n}\n```\n","source":"_posts/20160527-array.md","raw":"title:  2016Play with array - \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \npermalink: 20160527-array\ndate: 2016-05-27 23:55:00\n---\n\n $ n $ \n\n1.  $ a_r $  $ a_l $ \n2.  $ [l,\\ r] $  $ k $ \n\n<!-- more -->\n\n### \n $ O(\\sqrt n) $ \n\n $ [l,\\ r] $  $ [1,\\ r] $  $ [1,\\ l - 1] $ \n\n $ O(n \\sqrt n) $\n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <list>\n#include <vector>\n#include <algorithm>\n#include <stack>\n\n#define dprintf(format, ...) fprintf(stderr, format, __VA_ARGS__)\n\nconst int MAXN = 100000;\nconst int MAXN_SQRT = 316 + 1;\nconst int MAXM = 100000;\n\nint n, m, a[MAXN];\n\nstruct BlockList {\n\tstruct Block {\n\t\tstd::list<int> l;\n\t\tstd::vector<int> sum;\n\n\t\tBlock() : sum(n) {}\n\n\t\tinline int left(const int k, const int pos) {\n\t\t\tint res = 0;\n\t\t\tstd::list<int>::const_iterator it = l.begin();\n\t\t\tfor (int i = 0; i <= pos; i++) if (*it++ == k) res++;\n\t\t\treturn res;\n\t\t}\n\t};\n\tstd::list<Block> blocks;\n\tint blockCount, blockSize;\n\n\tinline void build(const int *a, const int n) {\n\t\tblockCount = floor(sqrt(n) + 1), blockSize = ceil(static_cast<double>(n) / blockCount);\n\t\t// dprintf(\"BlockList::build(): blockCount = %d, blockSize = %d\\n\", blockCount, blockSize);\n\t\tblocks.resize(blockCount);\n\t\tstd::list<Block>::iterator b = blocks.begin();\n\t\tfor (int i = 0, j = 0; i < blockCount; i++, b++) {\n\t\t\tfor (int k = 0; k <= blockSize && j < n; k++, j++) {\n\t\t\t\tb->sum[a[j]]++;\n\t\t\t\tb->l.push_back(a[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tinline int erase(int pos) {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tstd::list<int>::iterator it = b->l.begin();\n\t\t\t\tstd::advance(it, pos);\n\t\t\t\tconst int x = *it;\n\t\t\t\tb->sum[*it]--;\n\t\t\t\tb->l.erase(it);\n\t\t\t\treturn x;\n\t\t\t} else pos -= b->l.size();\n\t\t}\n\t\tthrow;\n\t}\n\n\tinline void insert(int pos, const int x) {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tstd::list<int>::iterator it = b->l.begin();\n\t\t\t\tstd::advance(it, pos);\n\t\t\t\tb->sum[x]++;\n\t\t\t\tb->l.insert(it, x);\n\t\t\t\treturn;\n\t\t\t} else pos -= b->l.size();\n\t\t}\n\t\tthrow;\n\t}\n\n\tinline int query(int pos, const int k) {\n\t\tint ans = 0;\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (pos < b->l.size()) {\n\t\t\t\tans += b->left(k, pos);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tpos -= b->l.size();\n\t\t\t\tans += b->sum[k];\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tinline void mergeNext(std::list<Block>::iterator b) {\n\t\tstd::list<Block>::iterator next = b;\n\t\tnext++;\n\t\tif (next == blocks.end()) return;\n\t\tfor (std::list<int>::const_iterator it = next->l.begin(); it != next->l.end(); it++) {\n\t\t\tb->l.push_back(*it);\n\t\t\tb->sum[*it]++;\n\t\t}\n\t\tblocks.erase(next);\n\t}\n\n\tinline void split(std::list<Block>::iterator b) {\n\t\tstd::list<Block>::iterator newBlock = blocks.insert(b, Block());\n\t\tfor (int i = 0; i < b->l.size() / 2; i++) {\n\t\t\tconst int &x = b->l.front();\n\t\t\tnewBlock->l.push_back(x);\n\t\t\tnewBlock->sum[x]++;\n\t\t\tb->sum[x]--;\n\t\t\tb->l.pop_front();\n\t\t}\n\t}\n\n\tinline void maintain() {\n\t\tfor (std::list<Block>::iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tif (b->l.size() <= blockSize / 2) mergeNext(b);\n\t\t\telse if (b->l.size() >= blockSize * 2) split(b);\n\t\t}\n\t}\n\n\tinline void print() {\n\t\tfor (std::list<Block>::const_iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tdprintf(\"blockSize = %d\\n\", b->l.size());\n\t\t}\n\n\t\treturn;\n\t\tfor (std::list<Block>::const_iterator b = blocks.begin(); b != blocks.end(); b++) {\n\t\t\tfor (std::list<int>::const_iterator it = b->l.begin(); it != b->l.end(); it++) {\n\t\t\t\tdprintf(\"%d \", *it + 1);\n\t\t\t}\n\t\t}\n\t\tdprintf(\"%c\", '\\n');\n\t}\n} list;\n\nint main() {\n\t// freopen(\"array.in\", \"r\", stdin);\n\t// freopen(\"array.out\", \"w\", stdout);\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &a[i]), a[i]--;\n\t}\n\n\tlist.build(a, n);\n\n\t// list.print();\n\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tint t, l, r;\n\t\tscanf(\"%d %d %d\", &t, &l, &r), l--, r--;\n\t\tif (t == 1) {\n\t\t\tint x = list.erase(r);\n\t\t\tlist.insert(l, x);\n\t\t\t// list.print();\n\t\t\tlist.maintain();\n\t\t\t// list.print();\n\t\t\t// dprintf(\"%c\", '\\n');\n\t\t} else {\n\t\t\tint k;\n\t\t\tscanf(\"%d\", &k), k--;\n\t\t\tint R = list.query(r, k), L = l == 0 ? 0 : list.query(l - 1, k);\n\t\t\tprintf(\"%d\\n\", R - L);\n\t\t}\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\t// list.print();\n\n\treturn 0;\n}\n```\n","slug":"20160527-array","published":1,"updated":"2016-05-27T16:14:44.525Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6dbl01mic2xl2lxtrjh7"},{"title":" - ","date":"2016-04-04T02:35:52.000Z","_content":"\n $ 1 \\to n $\n\n<!-- more -->\n\n### \n\n\n\n\n### 40 + DP\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 100;\nconst int MAXT = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint id, depth;\n\tbool visited;\n\t\n\tstruct TreeDPAnswer {\n\t\tbool calced;\n\t\tint val;\n\t} ans[2];\n} N[2][MAXN];\n\nstruct Edge {\n\tNode *t;\n\tEdge *next;\n\t\n\tEdge(Node *s, Node *t) : t(t), next(s->e) {}\n};\n\ninline void addEdge(const int i, const int u, const int v) {\n\tN[i][u].e = new Edge(&N[i][u], &N[i][v]);\n\tN[i][v].e = new Edge(&N[i][v], &N[i][u]);\n}\n\nint n, a[MAXN], f[MAXN], ans;\nstd::pair<int, int> E[2][MAXN - 1];\n\ninline int check() {\n\tint start = -1, tot = 0, sum = 0;\n\tfor (int i = 0; i < n; i++) if (f[i]) start = i, tot++, N[0][i].visited = N[1][i].visited = false, sum += a[i];\n\t\n\tfor (int i = 0; i < 2; i++) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i][start]);\n\t\tN[i][start].visited = true;\n\n\t\tint cnt = 1;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (f[e->t->id] && !e->t->visited) e->t->visited = true, q.push(e->t), cnt++;\n\t\t}\n\t\t\n\t\t// printf(\"cnt = %d, tot = %d, sum = %d\\n\", cnt, tot, sum);\n\t\tif (cnt < tot) return -1;\n\t}\n\t\n\treturn sum;\n}\n\ninline void search(int i = 0) {\n\tif (i == n) {\n\t\tans = std::max(ans, check());\n\t\treturn;\n\t}\n\t\n\tf[i] = true;\n\tsearch(i + 1);\n\tf[i] = false;\n\tsearch(i + 1);\n}\n\ninline void bfsDepth() {\n\tstd::queue<Node *> q;\n\tq.push(&N[0][0]);\n\tN[0][0].depth = 1;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\t\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->depth) e->t->depth = v->depth + 1, q.push(e->t);\n\t}\n}\n\nint dp(Node *v, const bool flag) {\n\tint &ans = v->ans[flag].val;\n\tif (v->ans[flag].calced) return ans;\n\tv->ans[flag].calced = true;\n\t\n\tans = 0;\n\tif (flag) {\n\t\tint sum = 0;\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->depth == v->depth + 1) {\n\t\t\t// ans = std::max(ans, dp(e->t, false));\n\t\t\tint t = dp(e->t, true);\n\t\t\tif (t > 0) sum += t;\n\t\t}\n\t\tsum += a[v->id];\n\t\tans = std::max(ans, sum);\n\t} else {\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->depth == v->depth + 1) {\n\t\t\tans = std::max(ans, dp(e->t, false));\n\t\t}\n\t\tans = std::max(ans, dp(v, true));\n\t}\n\t// printf(\"dp(%d[with `w` = %d], %d) = %d\\n\", v->id, a[v->id], flag ? 1 : 0, ans);\n\treturn ans;\n}\n\ninline int solve(const bool useTreeDP) {\n\tif (!useTreeDP) {\n\t\tans = 0;\n\t\tsearch();\n\t\treturn ans;\n\t} else {\n\t\tbfsDepth();\n\t\treturn dp(&N[0][0], false);\n\t}\n}\n\ninline void cleanUp() {\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < n; j++) {\n\t\tN[i][j].id = j;\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i][j].e; e; next = e->next, delete e, e = next);\n\t\t\n\t\tN[i][j].depth = 0;\n\t\tN[i][j].ans[0].calced = N[i][j].ans[1].calced = false;\n\t\tN[i][j].ans[0].val = N[i][j].ans[1].val = 0;\n\t}\n\tstd::fill(a, a + n, 0);\n}\n\nint main() {\n\tfreopen(\"theory.in\", \"r\", stdin);\n\tfreopen(\"theory.out\", \"w\", stdout);\n\t\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) {\n\t\tscanf(\"%d\", &n);\n\t\tcleanUp();\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\t\tfor (int i = 0; i < 2; i++) for (int j = 0, u, v; j < n - 1; j++) {\n\t\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\tE[i][j] = std::make_pair(std::min(u, v), std::max(u, v));\n\t\t\taddEdge(i, u, v);\n\t\t}\n\t\tstd::sort(E[0], E[0] + n - 1);\n\t\tstd::sort(E[1], E[1] + n - 1);\n\t\t\n\t\tbool useTreeDP = std::equal(E[0], E[0] + n - 1, E[1]);\n\t\t\n\t\tprintf(\"%d\\n\", solve(useTreeDP));\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 100;\nconst int MAXT = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].c = N[i].e, N[i].l = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->l == 0) {\n\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\tif (e->t == t) return true;\n\t\t\t\t\telse q.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\t\tint f = findPath(e->t, t, std::min(e->c - e->f, limit));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct TreeNode;\nstruct TreeEdge;\n\nint n, a[MAXN];\n\nstruct TreeNode {\n\tTreeEdge *e;\n\tint id;\n\tbool visited;\n\n\tint w() const { return a[id]; }\n} T[2][MAXN];\n\nstruct TreeEdge {\n\tTreeNode *t;\n\tTreeEdge *next;\n\n\tTreeEdge(TreeNode *s, TreeNode *t) : t(t), next(s->e) {}\n};\n\ninline void addTreeEdge(const int x, const int u, const int v) {\n\tT[x][u].e = new TreeEdge(&T[x][u], &T[x][v]);\n\tT[x][v].e = new TreeEdge(&T[x][v], &T[x][u]);\n}\n\ninline void cleanUpNetwork() {\n\tfor (int i = 0; i < n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\ninline int solve(const int root) {\n\tconst int s = 0, t = n + 1;\n\tint sum = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] > 0) addEdge(s, i + 1, a[i]), sum += a[i];\n\t\telse addEdge(i + 1, t, -a[i]);\n\t}\n\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < n; j++) T[i][j].visited = (j == root) ? true : false;\n\n\t\tstd::queue<TreeNode *> q;\n\t\tq.push(&T[i][root]);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tTreeNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (TreeEdge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->visited) {\n\t\t\t\t\te->t->visited = true;\n\t\t\t\t\taddEdge(e->t->id + 1, v->id + 1, INT_MAX);\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = sum - dinic(s, t, n + 2);\n\tcleanUpNetwork();\n\n\treturn ans;\n}\n\ninline void cleanUp() {\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < n; j++) {\n\t\tTreeEdge *next;\n\t\tfor (TreeEdge *&e = T[i][j].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tfreopen(\"theory.in\", \"r\", stdin);\n\t// freopen(\"theory.out\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), T[0][i].id = T[1][i].id = i;\n\n\t\tfor (int i = 0; i < 2; i++) for (int j = 0, u, v; j < n - 1; j++) {\n\t\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\t// printf(\"(%d, %d)\\n\", u, v);\n\t\t\taddTreeEdge(i, u, v);\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) ans = std::max(ans, solve(i));\n\t\tprintf(\"%d\\n\", ans);\n\n\t\tcleanUp();\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/20160404-theory.md","raw":"title:  - \ncategories: OI\ntags: \n  - \n  -  DP\n  - \n  - \n  - Dinic\n  - \npermalink: 20160404-theory\ndate: 2016-04-04 10:35:52\n---\n\n $ 1 \\to n $\n\n<!-- more -->\n\n### \n\n\n\n\n### 40 + DP\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <utility>\n\nconst int MAXN = 100;\nconst int MAXT = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e;\n\tint id, depth;\n\tbool visited;\n\t\n\tstruct TreeDPAnswer {\n\t\tbool calced;\n\t\tint val;\n\t} ans[2];\n} N[2][MAXN];\n\nstruct Edge {\n\tNode *t;\n\tEdge *next;\n\t\n\tEdge(Node *s, Node *t) : t(t), next(s->e) {}\n};\n\ninline void addEdge(const int i, const int u, const int v) {\n\tN[i][u].e = new Edge(&N[i][u], &N[i][v]);\n\tN[i][v].e = new Edge(&N[i][v], &N[i][u]);\n}\n\nint n, a[MAXN], f[MAXN], ans;\nstd::pair<int, int> E[2][MAXN - 1];\n\ninline int check() {\n\tint start = -1, tot = 0, sum = 0;\n\tfor (int i = 0; i < n; i++) if (f[i]) start = i, tot++, N[0][i].visited = N[1][i].visited = false, sum += a[i];\n\t\n\tfor (int i = 0; i < 2; i++) {\n\t\tstd::queue<Node *> q;\n\t\tq.push(&N[i][start]);\n\t\tN[i][start].visited = true;\n\n\t\tint cnt = 1;\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\t\t\t\n\t\t\tfor (Edge *e = v->e; e; e = e->next) if (f[e->t->id] && !e->t->visited) e->t->visited = true, q.push(e->t), cnt++;\n\t\t}\n\t\t\n\t\t// printf(\"cnt = %d, tot = %d, sum = %d\\n\", cnt, tot, sum);\n\t\tif (cnt < tot) return -1;\n\t}\n\t\n\treturn sum;\n}\n\ninline void search(int i = 0) {\n\tif (i == n) {\n\t\tans = std::max(ans, check());\n\t\treturn;\n\t}\n\t\n\tf[i] = true;\n\tsearch(i + 1);\n\tf[i] = false;\n\tsearch(i + 1);\n}\n\ninline void bfsDepth() {\n\tstd::queue<Node *> q;\n\tq.push(&N[0][0]);\n\tN[0][0].depth = 1;\n\twhile (!q.empty()) {\n\t\tNode *v = q.front();\n\t\tq.pop();\n\t\t\n\t\tfor (Edge *e = v->e; e; e = e->next) if (!e->t->depth) e->t->depth = v->depth + 1, q.push(e->t);\n\t}\n}\n\nint dp(Node *v, const bool flag) {\n\tint &ans = v->ans[flag].val;\n\tif (v->ans[flag].calced) return ans;\n\tv->ans[flag].calced = true;\n\t\n\tans = 0;\n\tif (flag) {\n\t\tint sum = 0;\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->depth == v->depth + 1) {\n\t\t\t// ans = std::max(ans, dp(e->t, false));\n\t\t\tint t = dp(e->t, true);\n\t\t\tif (t > 0) sum += t;\n\t\t}\n\t\tsum += a[v->id];\n\t\tans = std::max(ans, sum);\n\t} else {\n\t\tfor (Edge *e = v->e; e; e = e->next) if (e->t->depth == v->depth + 1) {\n\t\t\tans = std::max(ans, dp(e->t, false));\n\t\t}\n\t\tans = std::max(ans, dp(v, true));\n\t}\n\t// printf(\"dp(%d[with `w` = %d], %d) = %d\\n\", v->id, a[v->id], flag ? 1 : 0, ans);\n\treturn ans;\n}\n\ninline int solve(const bool useTreeDP) {\n\tif (!useTreeDP) {\n\t\tans = 0;\n\t\tsearch();\n\t\treturn ans;\n\t} else {\n\t\tbfsDepth();\n\t\treturn dp(&N[0][0], false);\n\t}\n}\n\ninline void cleanUp() {\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < n; j++) {\n\t\tN[i][j].id = j;\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i][j].e; e; next = e->next, delete e, e = next);\n\t\t\n\t\tN[i][j].depth = 0;\n\t\tN[i][j].ans[0].calced = N[i][j].ans[1].calced = false;\n\t\tN[i][j].ans[0].val = N[i][j].ans[1].val = 0;\n\t}\n\tstd::fill(a, a + n, 0);\n}\n\nint main() {\n\tfreopen(\"theory.in\", \"r\", stdin);\n\tfreopen(\"theory.out\", \"w\", stdout);\n\t\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) {\n\t\tscanf(\"%d\", &n);\n\t\tcleanUp();\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\t\tfor (int i = 0; i < 2; i++) for (int j = 0, u, v; j < n - 1; j++) {\n\t\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\tE[i][j] = std::make_pair(std::min(u, v), std::max(u, v));\n\t\t\taddEdge(i, u, v);\n\t\t}\n\t\tstd::sort(E[0], E[0] + n - 1);\n\t\tstd::sort(E[1], E[1] + n - 1);\n\t\t\n\t\tbool useTreeDP = std::equal(E[0], E[0] + n - 1, E[1]);\n\t\t\n\t\tprintf(\"%d\\n\", solve(useTreeDP));\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\nconst int MAXN = 100;\nconst int MAXT = 50;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n\tEdge *e, *c;\n\tint l;\n} N[MAXN + 2];\n\nstruct Edge {\n\tNode *t;\n\tint f, c;\n\tEdge *next, *r;\n\n\tEdge(Node *s, Node *t, const int c) : t(t), f(0), c(c), next(s->e) {}\n};\n\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, const int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].c = N[i].e, N[i].l = 0;\n\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\ts->l = 1;\n\n\t\twhile (!q.empty()) {\n\t\t\tNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (Edge *e = v->e; e; e = e->next) {\n\t\t\t\tif (e->f < e->c && e->t->l == 0) {\n\t\t\t\t\te->t->l = v->l + 1;\n\t\t\t\t\tif (e->t == t) return true;\n\t\t\t\t\telse q.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tint findPath(Node *s, Node *t, const int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (Edge *&e = s->c; e; e = e->next) {\n\t\t\tif (e->f < e->c && e->t->l == s->l + 1) {\n\t\t\t\tint f = findPath(e->t, t, std::min(e->c - e->f, limit));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\te->f += f, e->r->f -= f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint operator()(const int s, const int t, const int n) {\n\t\tint ans = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tint f;\n\t\t\twhile ((f = findPath(&N[s], &N[t])) > 0) ans += f;\n\t\t}\n\n\t\treturn ans;\n\t}\n} dinic;\n\ninline void addEdge(const int s, const int t, const int c) {\n\tN[s].e = new Edge(&N[s], &N[t], c);\n\tN[t].e = new Edge(&N[t], &N[s], 0);\n\tN[s].e->r = N[t].e, N[t].e->r = N[s].e;\n}\n\nstruct TreeNode;\nstruct TreeEdge;\n\nint n, a[MAXN];\n\nstruct TreeNode {\n\tTreeEdge *e;\n\tint id;\n\tbool visited;\n\n\tint w() const { return a[id]; }\n} T[2][MAXN];\n\nstruct TreeEdge {\n\tTreeNode *t;\n\tTreeEdge *next;\n\n\tTreeEdge(TreeNode *s, TreeNode *t) : t(t), next(s->e) {}\n};\n\ninline void addTreeEdge(const int x, const int u, const int v) {\n\tT[x][u].e = new TreeEdge(&T[x][u], &T[x][v]);\n\tT[x][v].e = new TreeEdge(&T[x][v], &T[x][u]);\n}\n\ninline void cleanUpNetwork() {\n\tfor (int i = 0; i < n + 2; i++) {\n\t\tEdge *next;\n\t\tfor (Edge *&e = N[i].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\ninline int solve(const int root) {\n\tconst int s = 0, t = n + 1;\n\tint sum = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] > 0) addEdge(s, i + 1, a[i]), sum += a[i];\n\t\telse addEdge(i + 1, t, -a[i]);\n\t}\n\n\tfor (int i = 0; i < 2; i++) {\n\t\tfor (int j = 0; j < n; j++) T[i][j].visited = (j == root) ? true : false;\n\n\t\tstd::queue<TreeNode *> q;\n\t\tq.push(&T[i][root]);\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tTreeNode *v = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor (TreeEdge *e = v->e; e; e = e->next) {\n\t\t\t\tif (!e->t->visited) {\n\t\t\t\t\te->t->visited = true;\n\t\t\t\t\taddEdge(e->t->id + 1, v->id + 1, INT_MAX);\n\t\t\t\t\tq.push(e->t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = sum - dinic(s, t, n + 2);\n\tcleanUpNetwork();\n\n\treturn ans;\n}\n\ninline void cleanUp() {\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < n; j++) {\n\t\tTreeEdge *next;\n\t\tfor (TreeEdge *&e = T[i][j].e; e; next = e->next, delete e, e = next);\n\t}\n}\n\nint main() {\n\tfreopen(\"theory.in\", \"r\", stdin);\n\t// freopen(\"theory.out\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d\", &a[i]), T[0][i].id = T[1][i].id = i;\n\n\t\tfor (int i = 0; i < 2; i++) for (int j = 0, u, v; j < n - 1; j++) {\n\t\t\tscanf(\"%d %d\", &u, &v), u--, v--;\n\t\t\t// printf(\"(%d, %d)\\n\", u, v);\n\t\t\taddTreeEdge(i, u, v);\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) ans = std::max(ans, solve(i));\n\t\tprintf(\"%d\\n\", ans);\n\n\t\tcleanUp();\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"20160404-theory","published":1,"updated":"2016-10-24T23:32:53.565Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6dbu01mqc2xludpdiukd"},{"title":" - DP","date":"2016-04-01T13:24:45.000Z","_content":"\n $ N $  $ M $  $ K $  $ M $ \n\n<!-- more -->\n\n### \n $ f_{i, j} $  i  j \n\n$$ f_{i, j} = f_{i - 1, j - 1} + f_{i, j - 1} + 1 $$\n\n $ 10 ^ 5 $  $ (N, K) $  $ f_K $  $ N $ \n\n $ K = 1, 2, 3 $ \n\n $ K = 1 $  $ N $  \n $ K = 2 $  $ x $\n\n$$\nN = \\frac{x(x + 1)}{2} \\\\\nx = \\lceil \\frac{\\sqrt{8n + 1} - 1}{2} \\rceil\n$$\n\n $ K = 3 $  1 ~ 3  $ f $  $ 2 \\times 10 ^ 6 $ \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXT = 100000;\nconst unsigned long long MAXN = 1e18;\nconst int LIM = 100000;\nconst int LIM2 = LIM * 20;\nconst int MAXK = 64;\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T x) {\n\tchar s[20];\n\tregister int cnt = 0;\n\tdo s[cnt++] = x % 10; while (x /= 10);\n\twhile (cnt--) putchar(s[cnt] + '0');\n\tputchar('\\n');\n}\n\nunsigned long long f[MAXK + 1][LIM + 1], f2[3 + 1][LIM2 + 1];\nint cnt[MAXK + 1];\n\nint main() {\n\tfreopen(\"naive.in\", \"r\", stdin);\n\t// freopen(\"naive.out\", \"w\", stdout);\n\n\tfor (int i = 1; i <= MAXK; i++) {\n\t\tcnt[i] = LIM;\n\t\tfor (int j = 1; j <= LIM; j++) {\n\t\t\tf[i][j] = f[i - 1][j - 1] + f[i][j - 1] + 1;\n\t\t\tif (f[i][j] >= MAXN) {\n\t\t\t\tcnt[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= 3; i++) {\n\t\tcnt[i] = LIM2;\n\t\tfor (int j = 1; j <= LIM2; j++) {\n\t\t\tf2[i][j] = f2[i - 1][j - 1] + f2[i][j - 1] + 1;\n\t\t\tif (f2[i][j] >= MAXN) {\n\t\t\t\tcnt[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// for (int i = 1; i <= 10; i++) write(cnt[i]);\n\t\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tunsigned long long n;\n\t\tint k;\n\t\tread(n), read(k);\n\t\t\n\t\tif (k == 1) write(n);\n\t\telse if (k == 2) write((long long)ceil((sqrt(8 * n + 1) - 1) / 2));\n\t\telse if (k == 3) {\n\t\t\tint ans = std::lower_bound(f2[k], f2[k] + cnt[k], n) - f2[k];\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t} else {\n\t\t\tint ans = std::lower_bound(f[k], f[k] + cnt[k], n) - f[k];\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n","source":"_posts/20160331-naive.md","raw":"title:  - DP\ncategories: OI\ntags: \n  - \n  - DP\n  - \npermalink: 20160331-naive\ndate: 2016-04-01 21:24:45\n---\n\n $ N $  $ M $  $ K $  $ M $ \n\n<!-- more -->\n\n### \n $ f_{i, j} $  i  j \n\n$$ f_{i, j} = f_{i - 1, j - 1} + f_{i, j - 1} + 1 $$\n\n $ 10 ^ 5 $  $ (N, K) $  $ f_K $  $ N $ \n\n $ K = 1, 2, 3 $ \n\n $ K = 1 $  $ N $  \n $ K = 2 $  $ x $\n\n$$\nN = \\frac{x(x + 1)}{2} \\\\\nx = \\lceil \\frac{\\sqrt{8n + 1} - 1}{2} \\rceil\n$$\n\n $ K = 3 $  1 ~ 3  $ f $  $ 2 \\times 10 ^ 6 $ \n\n### \n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXT = 100000;\nconst unsigned long long MAXN = 1e18;\nconst int LIM = 100000;\nconst int LIM2 = LIM * 20;\nconst int MAXK = 64;\n\ntemplate <typename T>\ninline void read(T &x) {\n\tx = 0;\n\tregister char ch;\n\twhile (ch = getchar(), !(ch >= '0' && ch <= '9'));\n\tdo x = x * 10 + (ch - '0'); while (ch = getchar(), (ch >= '0' && ch <= '9'));\n}\n\ntemplate <typename T>\ninline void write(T x) {\n\tchar s[20];\n\tregister int cnt = 0;\n\tdo s[cnt++] = x % 10; while (x /= 10);\n\twhile (cnt--) putchar(s[cnt] + '0');\n\tputchar('\\n');\n}\n\nunsigned long long f[MAXK + 1][LIM + 1], f2[3 + 1][LIM2 + 1];\nint cnt[MAXK + 1];\n\nint main() {\n\tfreopen(\"naive.in\", \"r\", stdin);\n\t// freopen(\"naive.out\", \"w\", stdout);\n\n\tfor (int i = 1; i <= MAXK; i++) {\n\t\tcnt[i] = LIM;\n\t\tfor (int j = 1; j <= LIM; j++) {\n\t\t\tf[i][j] = f[i - 1][j - 1] + f[i][j - 1] + 1;\n\t\t\tif (f[i][j] >= MAXN) {\n\t\t\t\tcnt[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= 3; i++) {\n\t\tcnt[i] = LIM2;\n\t\tfor (int j = 1; j <= LIM2; j++) {\n\t\t\tf2[i][j] = f2[i - 1][j - 1] + f2[i][j - 1] + 1;\n\t\t\tif (f2[i][j] >= MAXN) {\n\t\t\t\tcnt[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// for (int i = 1; i <= 10; i++) write(cnt[i]);\n\t\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tunsigned long long n;\n\t\tint k;\n\t\tread(n), read(k);\n\t\t\n\t\tif (k == 1) write(n);\n\t\telse if (k == 2) write((long long)ceil((sqrt(8 * n + 1) - 1) / 2));\n\t\telse if (k == 3) {\n\t\t\tint ans = std::lower_bound(f2[k], f2[k] + cnt[k], n) - f2[k];\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t} else {\n\t\t\tint ans = std::lower_bound(f[k], f[k] + cnt[k], n) - f[k];\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\t\n\treturn 0;\n}\n```\n","slug":"20160331-naive","published":1,"updated":"2016-05-11T09:33:24.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6dc501mzc2xl7egw8gbw"},{"title":" - ","date":"2016-03-20T14:50:45.000Z","_content":"\n $ n $  $ S $ $ a + b $$ a $$ b $  $ S $ $ k $  $ S $ \n\n<!-- more -->\n\n### \n$ m1 $ $ m2 $ $ s $ \n\n$$\n\\left(\n  \\begin{array}{ccc}\n    m1 + m2 \\\\\n    m1 \\\\\n    s + m1 + m2 \\\\\n  \\end{array}\n\\right)\n= \\left(\n  \\begin{array}{ccc}\n    1 & 1 & 0 \\\\\n    1 & 0 & 0 \\\\\n    1 & 1 & 1 \\\\\n  \\end{array}\n\\right)\n* \\left(\n  \\begin{array}{ccc}\n    m1 \\\\\n    m2 \\\\\n    s \\\\\n  \\end{array}\n\\right)\n$$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\nconst int MAXK = 1000000000;\nconst int MOD = 10000007;\n\ntemplate<typename T>\nstruct Matrix {\n\tT a[3][3];\n\n\tMatrix(T x1 = 1, T x2 = 0, T x3 = 0, T x4 = 0, T x5 = 1, T x6 = 0, T x7 = 0, T x8 = 0, T x9 = 1) {\n\t\ta[0][0] = x1, a[0][1] = x2, a[0][2] = x3;\n\t\ta[1][0] = x4, a[1][1] = x5, a[1][2] = x6;\n\t\ta[2][0] = x7, a[2][1] = x8, a[2][2] = x9;\n\t}\n\n\tconst T &operator()(int i, int j) const {\n\t\treturn a[i][j];\n\t}\n\t\n\tT &operator()(int i, int j) {\n\t\treturn a[i][j];\n\t}\n\t\n\tvoid print() {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tprintf(\"[ \");\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tprintf(\"%lld \", a[i][j]);\n\t\t\t}\n\t\t\tprintf(\"] \");\n\t\t}\n\t\tputchar('\\n');\n\t}\n};\n\ntemplate <typename T>\nMatrix<T> operator*(const Matrix<T> &a, const Matrix<T> &b) {\n\tMatrix<T> r(\n\t\t0, 0, 0,\n\t\t0, 0, 0,\n\t\t0, 0, 0\n\t);\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tr(i, j) = (r(i, j) + (a(i, k) * b(k, j)) % MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\t// r.print();\n\treturn r;\n}\n\ntemplate <typename T>\nMatrix<T> pow(Matrix<T> m, int x) {\n\tMatrix<T> ans;\n\t/*for (int i = 0; i < x - 1; i++) ans = ans * m;\n\treturn ans;*/\n\t\n\tfor (; x; x >>= 1, m = m * m){\n\t\t// printf(\"x = %d\\n\", x);\n\t\tif (x & 1) ans = ans * m;\n\t}\n\treturn ans;\n}\n\nint max = INT_MIN, max2 = INT_MIN, sum;\n\nint main() {\n\t// freopen(\"set.in\", \"r\", stdin);\n\t// freopen(\"set.out\", \"w\", stdout);\n\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint num;\n\t\tscanf(\"%d\", &num);\n\t\t\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\t\n\twhile (max2 < 0) {\n\t\tk--;\n\t\tint num = max + max2;\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\n\tMatrix<long long> base(\n\t\t1, 1, 0,\n\t\t1, 0, 0,\n\t\t1, 1, 1\n\t);\n\t\n\tMatrix<long long> init(\n\t\tmax % MOD, 0, 0,\n\t\tmax2 % MOD, 0, 0,\n\t\tsum % MOD, 0, 0\n\t);\n\t\t\n\tMatrix<long long> result = pow(base, k) * init;\n\n\t// printf(\"%d\\n\", (sum + (result(2, 0) * max) % MOD + (result(2, 1) * max2) % MOD) % MOD);\n\tprintf(\"%d\\n\", (result(2, 0) + MOD) % MOD);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/20160319-set.md","raw":"title:  - \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \npermalink: 20160319-set\ndate: 2016-03-20 22:50:45\n---\n\n $ n $  $ S $ $ a + b $$ a $$ b $  $ S $ $ k $  $ S $ \n\n<!-- more -->\n\n### \n$ m1 $ $ m2 $ $ s $ \n\n$$\n\\left(\n  \\begin{array}{ccc}\n    m1 + m2 \\\\\n    m1 \\\\\n    s + m1 + m2 \\\\\n  \\end{array}\n\\right)\n= \\left(\n  \\begin{array}{ccc}\n    1 & 1 & 0 \\\\\n    1 & 0 & 0 \\\\\n    1 & 1 & 1 \\\\\n  \\end{array}\n\\right)\n* \\left(\n  \\begin{array}{ccc}\n    m1 \\\\\n    m2 \\\\\n    s \\\\\n  \\end{array}\n\\right)\n$$\n\n\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n\nconst int MAXN = 100000;\nconst int MAXK = 1000000000;\nconst int MOD = 10000007;\n\ntemplate<typename T>\nstruct Matrix {\n\tT a[3][3];\n\n\tMatrix(T x1 = 1, T x2 = 0, T x3 = 0, T x4 = 0, T x5 = 1, T x6 = 0, T x7 = 0, T x8 = 0, T x9 = 1) {\n\t\ta[0][0] = x1, a[0][1] = x2, a[0][2] = x3;\n\t\ta[1][0] = x4, a[1][1] = x5, a[1][2] = x6;\n\t\ta[2][0] = x7, a[2][1] = x8, a[2][2] = x9;\n\t}\n\n\tconst T &operator()(int i, int j) const {\n\t\treturn a[i][j];\n\t}\n\t\n\tT &operator()(int i, int j) {\n\t\treturn a[i][j];\n\t}\n\t\n\tvoid print() {\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tprintf(\"[ \");\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tprintf(\"%lld \", a[i][j]);\n\t\t\t}\n\t\t\tprintf(\"] \");\n\t\t}\n\t\tputchar('\\n');\n\t}\n};\n\ntemplate <typename T>\nMatrix<T> operator*(const Matrix<T> &a, const Matrix<T> &b) {\n\tMatrix<T> r(\n\t\t0, 0, 0,\n\t\t0, 0, 0,\n\t\t0, 0, 0\n\t);\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\tr(i, j) = (r(i, j) + (a(i, k) * b(k, j)) % MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\t// r.print();\n\treturn r;\n}\n\ntemplate <typename T>\nMatrix<T> pow(Matrix<T> m, int x) {\n\tMatrix<T> ans;\n\t/*for (int i = 0; i < x - 1; i++) ans = ans * m;\n\treturn ans;*/\n\t\n\tfor (; x; x >>= 1, m = m * m){\n\t\t// printf(\"x = %d\\n\", x);\n\t\tif (x & 1) ans = ans * m;\n\t}\n\treturn ans;\n}\n\nint max = INT_MIN, max2 = INT_MIN, sum;\n\nint main() {\n\t// freopen(\"set.in\", \"r\", stdin);\n\t// freopen(\"set.out\", \"w\", stdout);\n\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint num;\n\t\tscanf(\"%d\", &num);\n\t\t\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\t\n\twhile (max2 < 0) {\n\t\tk--;\n\t\tint num = max + max2;\n\t\tsum = (sum + num) % MOD;\n\t\tif (num > max) max2 = max, max = num;\n\t\telse if (num > max2) max2 = num;\n\t}\n\n\tMatrix<long long> base(\n\t\t1, 1, 0,\n\t\t1, 0, 0,\n\t\t1, 1, 1\n\t);\n\t\n\tMatrix<long long> init(\n\t\tmax % MOD, 0, 0,\n\t\tmax2 % MOD, 0, 0,\n\t\tsum % MOD, 0, 0\n\t);\n\t\t\n\tMatrix<long long> result = pow(base, k) * init;\n\n\t// printf(\"%d\\n\", (sum + (result(2, 0) * max) % MOD + (result(2, 1) * max2) % MOD) % MOD);\n\tprintf(\"%d\\n\", (result(2, 0) + MOD) % MOD);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"20160319-set","published":1,"updated":"2016-05-11T09:33:24.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6dce01n5c2xlby8s0qzs"},{"title":" -  + ","date":"2016-03-20T14:58:12.000Z","_content":"\n $ N $ \n\n<!-- more -->\n\n### \n\n\n\n\n\n\n\n\n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <list>\n\nconst int MAXT = 3;\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Candy {\n\tint xOrigin, yOrigin;\n\tint x, y;\n\tint color;\n\tstd::list<Candy>::iterator p;\n} candies[MAXN];\n\nbool compareByY(const Candy &a, const Candy &b) {\n\treturn a.y < b.y;\n}\n\nbool compareByX(const Candy &a, const Candy &b) {\n\treturn a.x < b.x;\n}\n\nint n, k, xSet[MAXN], ySet[MAXN], cx, cy;\nstd::list<Candy> list[MAXK];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(int pos, int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tint sum(int pos) {\n\t\tint result = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) result += a[i - 1];\n\t\treturn result;\n\t}\n\n\tint query(int l, int r) {\n\t\t// printf(\"query(%d, %d) = %d\\n\", l, r, sum(r) - sum(l - 1));\n\t\treturn sum(r) - sum(l - 1);\n\t}\n\n\tvoid clear() {\n\t\tmemset(a, 0, sizeof(a));\n\t}\n} bit;\n\ninline int solve() {\n\tbit.clear();\n\tfor (int i = 0; i < k; i++) list[i].clear();\n\n\tstd::sort(candies, candies + n, &compareByX);\n\tfor (int i = 0; i < n; i++) {\n\t\tcandies[i].p = list[candies[i].color].insert(list[candies[i].color].end(), candies[i]);\n\t\tbit.update(candies[i].x, 1);\n\t}\n\n\tstd::sort(candies, candies + n, &compareByY);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint last = 0;\n\t\tfor (std::list<Candy>::const_iterator p = list[i].begin(); p != list[i].end(); p++) {\n\t\t\tans = std::max(ans, bit.query(last + 1, p->x - 1));\n\t\t\tlast = p->x;\n\t\t}\n\n\t\tans = std::max(ans, bit.query(last + 1, n));\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0 || candies[i].y != candies[i - 1].y) {\n\t\t\tfor (int j = i; j < n && candies[j].y == candies[i].y; j++) {\n\t\t\t\tbit.update(candies[j].x, -1);\n\t\t\t}\n\t\t}\n\n\t\tint l, r;\n\n\t\tstd::list<Candy>::iterator &p = candies[i].p;\n\t\tif (p != list[candies[i].color].begin()) {\n\t\t\tstd::list<Candy>::const_iterator prev = p;\n\t\t\tprev--;\n\t\t\tl = prev->x + 1;\n\t\t} else l = 1;\n\n\t\tstd::list<Candy>::const_iterator next = p;\n\t\tnext++;\n\n\t\tif (next != list[candies[i].color].end()) {\n\t\t\tr = next->x - 1;\n\t\t} else r = n;\n\n\t\tans = std::max(ans, bit.query(l, r));\n\n\t\tlist[candies[i].color].erase(p);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"candy.in\", \"r\", stdin);\n\t// freopen(\"candy.out\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%d %d\", &n, &k);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &candies[i].xOrigin, &candies[i].yOrigin, &candies[i].color), candies[i].color--;\n\t\t\txSet[i] = candies[i].xOrigin;\n\t\t\tySet[i] = candies[i].yOrigin;\n\t\t}\n\n\t\tint *xEnd, *yEnd;\n\t\tstd::sort(xSet, xSet + n);\n\t\tstd::sort(ySet, ySet + n);\n\t\txEnd = std::unique(xSet, xSet + n);\n\t\tyEnd = std::unique(ySet, ySet + n);\n\n\t\tcx = xEnd - xSet;\n\t\tcy = yEnd - ySet;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcandies[i].x = std::lower_bound(xSet, xEnd, candies[i].xOrigin) - xSet + 1;\n\t\t\tcandies[i].y = std::lower_bound(ySet, yEnd, candies[i].yOrigin) - ySet + 1;\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tans = std::max(ans, solve());\n\t\tfor (int i = 0; i < n; i++) candies[i].y = -candies[i].y;\n\t\tans = std::max(ans, solve());\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","source":"_posts/20160319-candy.md","raw":"title:  -  + \ncategories: OI\ntags: \n  - \n  - \n  - \n  - \n  - \npermalink: 20160319-candy\ndate: 2016-03-20 22:58:12\n---\n\n $ N $ \n\n<!-- more -->\n\n### \n\n\n\n\n\n\n\n\n\n\n\n\n### \n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <list>\n\nconst int MAXT = 3;\nconst int MAXN = 100000;\nconst int MAXK = 100000;\n\nstruct Candy {\n\tint xOrigin, yOrigin;\n\tint x, y;\n\tint color;\n\tstd::list<Candy>::iterator p;\n} candies[MAXN];\n\nbool compareByY(const Candy &a, const Candy &b) {\n\treturn a.y < b.y;\n}\n\nbool compareByX(const Candy &a, const Candy &b) {\n\treturn a.x < b.x;\n}\n\nint n, k, xSet[MAXN], ySet[MAXN], cx, cy;\nstd::list<Candy> list[MAXK];\n\nstruct BinaryIndexedTree {\n\tint a[MAXN];\n\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\n\tvoid update(int pos, int delta) {\n\t\tfor (int i = pos; i <= n; i += lowbit(i)) a[i - 1] += delta;\n\t}\n\n\tint sum(int pos) {\n\t\tint result = 0;\n\t\tfor (int i = pos; i > 0; i -= lowbit(i)) result += a[i - 1];\n\t\treturn result;\n\t}\n\n\tint query(int l, int r) {\n\t\t// printf(\"query(%d, %d) = %d\\n\", l, r, sum(r) - sum(l - 1));\n\t\treturn sum(r) - sum(l - 1);\n\t}\n\n\tvoid clear() {\n\t\tmemset(a, 0, sizeof(a));\n\t}\n} bit;\n\ninline int solve() {\n\tbit.clear();\n\tfor (int i = 0; i < k; i++) list[i].clear();\n\n\tstd::sort(candies, candies + n, &compareByX);\n\tfor (int i = 0; i < n; i++) {\n\t\tcandies[i].p = list[candies[i].color].insert(list[candies[i].color].end(), candies[i]);\n\t\tbit.update(candies[i].x, 1);\n\t}\n\n\tstd::sort(candies, candies + n, &compareByY);\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < k; i++) {\n\t\tint last = 0;\n\t\tfor (std::list<Candy>::const_iterator p = list[i].begin(); p != list[i].end(); p++) {\n\t\t\tans = std::max(ans, bit.query(last + 1, p->x - 1));\n\t\t\tlast = p->x;\n\t\t}\n\n\t\tans = std::max(ans, bit.query(last + 1, n));\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0 || candies[i].y != candies[i - 1].y) {\n\t\t\tfor (int j = i; j < n && candies[j].y == candies[i].y; j++) {\n\t\t\t\tbit.update(candies[j].x, -1);\n\t\t\t}\n\t\t}\n\n\t\tint l, r;\n\n\t\tstd::list<Candy>::iterator &p = candies[i].p;\n\t\tif (p != list[candies[i].color].begin()) {\n\t\t\tstd::list<Candy>::const_iterator prev = p;\n\t\t\tprev--;\n\t\t\tl = prev->x + 1;\n\t\t} else l = 1;\n\n\t\tstd::list<Candy>::const_iterator next = p;\n\t\tnext++;\n\n\t\tif (next != list[candies[i].color].end()) {\n\t\t\tr = next->x - 1;\n\t\t} else r = n;\n\n\t\tans = std::max(ans, bit.query(l, r));\n\n\t\tlist[candies[i].color].erase(p);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\t// freopen(\"candy.in\", \"r\", stdin);\n\t// freopen(\"candy.out\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile (t--) {\n\t\tscanf(\"%d %d\", &n, &k);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%d %d %d\", &candies[i].xOrigin, &candies[i].yOrigin, &candies[i].color), candies[i].color--;\n\t\t\txSet[i] = candies[i].xOrigin;\n\t\t\tySet[i] = candies[i].yOrigin;\n\t\t}\n\n\t\tint *xEnd, *yEnd;\n\t\tstd::sort(xSet, xSet + n);\n\t\tstd::sort(ySet, ySet + n);\n\t\txEnd = std::unique(xSet, xSet + n);\n\t\tyEnd = std::unique(ySet, ySet + n);\n\n\t\tcx = xEnd - xSet;\n\t\tcy = yEnd - ySet;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcandies[i].x = std::lower_bound(xSet, xEnd, candies[i].xOrigin) - xSet + 1;\n\t\t\tcandies[i].y = std::lower_bound(ySet, yEnd, candies[i].yOrigin) - ySet + 1;\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tans = std::max(ans, solve());\n\t\tfor (int i = 0; i < n; i++) candies[i].y = -candies[i].y;\n\t\tans = std::max(ans, solve());\n\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\tfclose(stdin);\n\tfclose(stdout);\n\n\treturn 0;\n}\n```\n","slug":"20160319-candy","published":1,"updated":"2016-05-11T09:33:24.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix2l6dcm01nbc2xlmry79v3w"},{"title":"","date":"2015-12-27T14:48:11.000Z","_content":"\n 2016  12  28 \n\n\n\n![zyz ](tree-chain-split-notes/zyz.png)\n\n<!-- more -->\n\n### \n[CodeVS 2460](http://codevs.cn/problem/2460/)  \n[BZOJ 1036](http://www.lydsy.com/JudgeOnline/problem.php?id=1036)  \n\n****\n\n### \n![](tree-chain-split-notes/1.svg)\n\n********\n\n****  $ O(\\log n) $\n\n### \n```c++\nstruct Node\n{\n\tstruct Edge *firstEdge;\n\tstruct Chain *chain;  // \n    // maxChild \n\tNode *fa, *maxChild; \n    // size \n    // pos \n\tint size, dfn, pos, depth;\n\tbool vis;\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Chain\n{\n\tNode *top; // \n    // \n    int len;\n\n\tChain(Node *top) : top(top), len(0) {}\n};\n```\n\n $ v $$ \\text{depth}(v) $ $ \\text{size}(v) $ $ \\text{max-child}(v) $ \n\n $ c $  $ \\text{top}(c) $$ \\text{pos}(v) $  $ v $  $ \\text{pos} $  $ 1 $ $ \\text{pos}(\\text{top}(c)) = 1 $\n\n### \n```c++\ninline void split()\n{\n\tN[1].depth = 1; //  1\n\tdfs1(&N[1]);\n\tdfs2(&N[1]);\n}\n```\n\n DFS  DFS  $ v $  $ \\text{size}(v) $  $ \\text{max-child}(v) $\n\n```c++\ninline void dfs1(Node *v)\n{\n\tv->vis = true;\n\tv->size = 1; //  1\n\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n    {\n\t\tif (!e->to->vis)\n        {\n\t\t\te->to->fa = v;\n\t\t\te->to->depth = v->depth + 1;\n            \n\t\t\tdfs1(e->to);\n            \n            // \n\t\t\tv->size += e->to->size;\n            \n            // \n            // \n\t\t\tif (!v->maxChild || v->maxChild->size < e->to->size) v->maxChild = e->to;\n\t\t}\n\t}\n}\n```\n\n DFS\n\n$ \\text{max-child} $\n\n DFS  $ \\text{dfn}(v) $ DFS  DFS  $ \\text{max-child} $\n\n```c++\ninline void dfs2(Node *v)\n{\n\tstatic int ts = 0; // \n\tv->dfn = ++ts;     //  DFS \n\n\t// \n\tif (!v->fa || v != v->fa->maxChild) v->chain = new Chain(v);\n\telse v->chain = v->fa->chain; // \n\n\t// \n    //  DFS \n\tif (v->maxChild) dfs2(v->maxChild); \n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n    {\n    \t// // \n\t\tif (e->to->fa == v && e->to != v->maxChild)\n        {\n\t\t\tdfs2(e->to);\n\t\t}\n\t}\n}\n```\n\n### \n DFS \n\n```c++\nsegt = SegmentTree::build(1, n);\n```\n\n### \n DFS \n\n DFS \n\n```cpp\ninline void update(int u, int x) {\n\tsegt->update(N[u].dfn, x);\n}\n```\n\n### \n $ u $  $ v $ \n\n1.  $ u $  $ v $  $ u $ **** $ u $ $ \\text{top}(\\text{chain}(u)) $ $ u $  $ u $ ****\n2.  $ u $  $ v $ \n\n DFS \n\n```cpp\ninline int querySum(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = 0;\n\twhile (u->chain != v->chain)\n    {\n    \t//  u \n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres += segt->querySum(u->chain->top->dfn, u->dfn);\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres += segt->querySum(u->dfn, v->dfn);\n\n\treturn res;\n}\n\ninline int queryMax(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = INT_MIN; // \n\twhile (u->chain != v->chain)\n    {\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres = std::max(res, segt->queryMax(u->chain->top->dfn, u->dfn));\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres = std::max(res, segt->queryMax(u->dfn, v->dfn));\n\n\treturn res;\n}\n```\n\n### \n LCA\n\n```c++\ninline Node *lca(Node *u, Node *v)\n{\n\twhile (u->chain != v->chain)\n\t{\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tu = u->chain->top->fa;\n\t}\n\t\n\tif (u->depth > v->depth) std::swap(u, v);\n\treturn u;\n}\n```\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 30000;\n\nstruct Node\n{\n\tstruct Edge *firstEdge;\n\tstruct Chain *chain;\n\tNode *fa, *maxChild;\n\tint size, dfn, depth;\n\tbool vis;\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Chain\n{\n\tNode *top;\n\n\tChain(Node *top) : top(top) {}\n};\n\ninline void addEdge(int from, int to)\n{\n\tN[from].firstEdge = new Edge(&N[from], &N[to]);\n\tN[to].firstEdge = new Edge(&N[to], &N[from]);\n}\n\ninline void dfs1(Node *v)\n{\n\tv->vis = true;\n\tv->size = 1;\n\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (!e->to->vis)\n\t\t{\n\t\t\te->to->fa = v;\n\t\t\te->to->depth = v->depth + 1;\n\t\t\tdfs1(e->to);\n\t\t\tv->size += e->to->size;\n\t\t\tif (!v->maxChild || v->maxChild->size < e->to->size) v->maxChild = e->to;\n\t\t}\n\t}\n}\n\ninline void dfs2(Node *v)\n{\n\tstatic int ts = 0;\n\tv->dfn = ++ts;\n\n\tif (!v->fa || v != v->fa->maxChild) v->chain = new Chain(v);\n\telse v->chain = v->fa->chain;\n\n\tif (v->maxChild) dfs2(v->maxChild);\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (e->to->fa == v && e->to != v->maxChild)\n\t\t{\n\t\t\tdfs2(e->to);\n\t\t}\n\t}\n}\n\ninline void split()\n{\n\tN[1].depth = 1;\n\tdfs1(&N[1]);\n\tdfs2(&N[1]);\n}\n\nstruct SegmentTree\n{\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tint sum, max;\n\n\tSegmentTree(int l, int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), sum(0), max(INT_MIN) {}\n\n\tvoid maintain()\n\t{\n\t\tsum = lc->sum + rc->sum;\n\t\tmax = std::max(lc->max, rc->max);\n\t}\n\n\tvoid update(int pos, int x)\n\t{\n\t\tif (l == r) sum = max = x;\n\t\telse\n\t\t{\n\t\t\tif (pos <= mid) lc->update(pos, x);\n\t\t\telse rc->update(pos, x);\n\n\t\t\tmaintain();\n\t\t}\n\t}\n\n\tint querySum(int l, int r)\n\t{\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse return lc->querySum(l, r) + rc->querySum(l, r);\n\t}\n\n\tint queryMax(int l, int r)\n\t{\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return max;\n\t\telse return std::max(lc->queryMax(l, r), rc->queryMax(l, r));\n\t}\n\n\tstatic SegmentTree *build(int l, int r)\n\t{\n\t\tif (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\telse\n\t\t{\n\t\t\tint mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segt;\n\ninline void update(int u, int x)\n{\n\tsegt->update(N[u].dfn, x);\n}\n\ninline int querySum(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = 0;\n\twhile (u->chain != v->chain)\n\t{\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres += segt->querySum(u->chain->top->dfn, u->dfn);\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres += segt->querySum(u->dfn, v->dfn);\n\n\treturn res;\n}\n\ninline int queryMax(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = INT_MIN;\n\twhile (u->chain != v->chain)\n\t{\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres = std::max(res, segt->queryMax(u->chain->top->dfn, u->dfn));\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres = std::max(res, segt->queryMax(u->dfn, v->dfn));\n\n\treturn res;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n - 1; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tsplit();\n\n\tsegt = SegmentTree::build(1, n);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tupdate(i, x);\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--)\n\t{\n\t\tchar cmd[sizeof(\"CHANGE\")];\n\t\tint a, b;\n\t\tscanf(\"%s %d %d\", cmd, &a, &b);\n\n\t\tif (cmd[1] == 'H')\n\t\t{\n\t\t\tupdate(a, b);\n\t\t}\n\t\telse if (cmd[1] == 'S')\n\t\t{\n\t\t\tprintf(\"%d\\n\", querySum(a, b));\n\t\t}\n\t\telse if (cmd[1] == 'M')\n\t\t{\n\t\t\tprintf(\"%d\\n\", queryMax(a, b));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","source":"_posts/tree-chain-split-notes.md","raw":"title: \ncategories: OI\ntags: \n  - BZOJ\n  - CodeVS\n  - \n  - \n  - \n  -   \npermalink: tree-chain-split-notes\ndate: 2015-12-27 22:48:11\n---\n\n 2016  12  28 \n\n\n\n![zyz ](tree-chain-split-notes/zyz.png)\n\n<!-- more -->\n\n### \n[CodeVS 2460](http://codevs.cn/problem/2460/)  \n[BZOJ 1036](http://www.lydsy.com/JudgeOnline/problem.php?id=1036)  \n\n****\n\n### \n![](tree-chain-split-notes/1.svg)\n\n********\n\n****  $ O(\\log n) $\n\n### \n```c++\nstruct Node\n{\n\tstruct Edge *firstEdge;\n\tstruct Chain *chain;  // \n    // maxChild \n\tNode *fa, *maxChild; \n    // size \n    // pos \n\tint size, dfn, pos, depth;\n\tbool vis;\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Chain\n{\n\tNode *top; // \n    // \n    int len;\n\n\tChain(Node *top) : top(top), len(0) {}\n};\n```\n\n $ v $$ \\text{depth}(v) $ $ \\text{size}(v) $ $ \\text{max-child}(v) $ \n\n $ c $  $ \\text{top}(c) $$ \\text{pos}(v) $  $ v $  $ \\text{pos} $  $ 1 $ $ \\text{pos}(\\text{top}(c)) = 1 $\n\n### \n```c++\ninline void split()\n{\n\tN[1].depth = 1; //  1\n\tdfs1(&N[1]);\n\tdfs2(&N[1]);\n}\n```\n\n DFS  DFS  $ v $  $ \\text{size}(v) $  $ \\text{max-child}(v) $\n\n```c++\ninline void dfs1(Node *v)\n{\n\tv->vis = true;\n\tv->size = 1; //  1\n\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n    {\n\t\tif (!e->to->vis)\n        {\n\t\t\te->to->fa = v;\n\t\t\te->to->depth = v->depth + 1;\n            \n\t\t\tdfs1(e->to);\n            \n            // \n\t\t\tv->size += e->to->size;\n            \n            // \n            // \n\t\t\tif (!v->maxChild || v->maxChild->size < e->to->size) v->maxChild = e->to;\n\t\t}\n\t}\n}\n```\n\n DFS\n\n$ \\text{max-child} $\n\n DFS  $ \\text{dfn}(v) $ DFS  DFS  $ \\text{max-child} $\n\n```c++\ninline void dfs2(Node *v)\n{\n\tstatic int ts = 0; // \n\tv->dfn = ++ts;     //  DFS \n\n\t// \n\tif (!v->fa || v != v->fa->maxChild) v->chain = new Chain(v);\n\telse v->chain = v->fa->chain; // \n\n\t// \n    //  DFS \n\tif (v->maxChild) dfs2(v->maxChild); \n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n    {\n    \t// // \n\t\tif (e->to->fa == v && e->to != v->maxChild)\n        {\n\t\t\tdfs2(e->to);\n\t\t}\n\t}\n}\n```\n\n### \n DFS \n\n```c++\nsegt = SegmentTree::build(1, n);\n```\n\n### \n DFS \n\n DFS \n\n```cpp\ninline void update(int u, int x) {\n\tsegt->update(N[u].dfn, x);\n}\n```\n\n### \n $ u $  $ v $ \n\n1.  $ u $  $ v $  $ u $ **** $ u $ $ \\text{top}(\\text{chain}(u)) $ $ u $  $ u $ ****\n2.  $ u $  $ v $ \n\n DFS \n\n```cpp\ninline int querySum(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = 0;\n\twhile (u->chain != v->chain)\n    {\n    \t//  u \n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres += segt->querySum(u->chain->top->dfn, u->dfn);\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres += segt->querySum(u->dfn, v->dfn);\n\n\treturn res;\n}\n\ninline int queryMax(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = INT_MIN; // \n\twhile (u->chain != v->chain)\n    {\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres = std::max(res, segt->queryMax(u->chain->top->dfn, u->dfn));\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres = std::max(res, segt->queryMax(u->dfn, v->dfn));\n\n\treturn res;\n}\n```\n\n### \n LCA\n\n```c++\ninline Node *lca(Node *u, Node *v)\n{\n\twhile (u->chain != v->chain)\n\t{\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tu = u->chain->top->fa;\n\t}\n\t\n\tif (u->depth > v->depth) std::swap(u, v);\n\treturn u;\n}\n```\n\n### \n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 30000;\n\nstruct Node\n{\n\tstruct Edge *firstEdge;\n\tstruct Chain *chain;\n\tNode *fa, *maxChild;\n\tint size, dfn, depth;\n\tbool vis;\n} N[MAXN + 1];\n\nstruct Edge\n{\n\tNode *from, *to;\n\tEdge *next;\n\n\tEdge(Node *from, Node *to) : from(from), to(to), next(from->firstEdge) {}\n};\n\nstruct Chain\n{\n\tNode *top;\n\n\tChain(Node *top) : top(top) {}\n};\n\ninline void addEdge(int from, int to)\n{\n\tN[from].firstEdge = new Edge(&N[from], &N[to]);\n\tN[to].firstEdge = new Edge(&N[to], &N[from]);\n}\n\ninline void dfs1(Node *v)\n{\n\tv->vis = true;\n\tv->size = 1;\n\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (!e->to->vis)\n\t\t{\n\t\t\te->to->fa = v;\n\t\t\te->to->depth = v->depth + 1;\n\t\t\tdfs1(e->to);\n\t\t\tv->size += e->to->size;\n\t\t\tif (!v->maxChild || v->maxChild->size < e->to->size) v->maxChild = e->to;\n\t\t}\n\t}\n}\n\ninline void dfs2(Node *v)\n{\n\tstatic int ts = 0;\n\tv->dfn = ++ts;\n\n\tif (!v->fa || v != v->fa->maxChild) v->chain = new Chain(v);\n\telse v->chain = v->fa->chain;\n\n\tif (v->maxChild) dfs2(v->maxChild);\n\tfor (Edge *e = v->firstEdge; e; e = e->next)\n\t{\n\t\tif (e->to->fa == v && e->to != v->maxChild)\n\t\t{\n\t\t\tdfs2(e->to);\n\t\t}\n\t}\n}\n\ninline void split()\n{\n\tN[1].depth = 1;\n\tdfs1(&N[1]);\n\tdfs2(&N[1]);\n}\n\nstruct SegmentTree\n{\n\tint l, r, mid;\n\tSegmentTree *lc, *rc;\n\tint sum, max;\n\n\tSegmentTree(int l, int r, SegmentTree *lc, SegmentTree *rc) : l(l), r(r), mid(l + (r - l) / 2), lc(lc), rc(rc), sum(0), max(INT_MIN) {}\n\n\tvoid maintain()\n\t{\n\t\tsum = lc->sum + rc->sum;\n\t\tmax = std::max(lc->max, rc->max);\n\t}\n\n\tvoid update(int pos, int x)\n\t{\n\t\tif (l == r) sum = max = x;\n\t\telse\n\t\t{\n\t\t\tif (pos <= mid) lc->update(pos, x);\n\t\t\telse rc->update(pos, x);\n\n\t\t\tmaintain();\n\t\t}\n\t}\n\n\tint querySum(int l, int r)\n\t{\n\t\tif (l > this->r || r < this->l) return 0;\n\t\telse if (l <= this->l && r >= this->r) return sum;\n\t\telse return lc->querySum(l, r) + rc->querySum(l, r);\n\t}\n\n\tint queryMax(int l, int r)\n\t{\n\t\tif (l > this->r || r < this->l) return INT_MIN;\n\t\telse if (l <= this->l && r >= this->r) return max;\n\t\telse return std::max(lc->queryMax(l, r), rc->queryMax(l, r));\n\t}\n\n\tstatic SegmentTree *build(int l, int r)\n\t{\n\t\tif (l == r) return new SegmentTree(l, r, NULL, NULL);\n\t\telse\n\t\t{\n\t\t\tint mid = l + (r - l) / 2;\n\t\t\treturn new SegmentTree(l, r, build(l, mid), build(mid + 1, r));\n\t\t}\n\t}\n} *segt;\n\ninline void update(int u, int x)\n{\n\tsegt->update(N[u].dfn, x);\n}\n\ninline int querySum(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = 0;\n\twhile (u->chain != v->chain)\n\t{\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres += segt->querySum(u->chain->top->dfn, u->dfn);\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres += segt->querySum(u->dfn, v->dfn);\n\n\treturn res;\n}\n\ninline int queryMax(int a, int b)\n{\n\tNode *u = &N[a], *v = &N[b];\n\tint res = INT_MIN;\n\twhile (u->chain != v->chain)\n\t{\n\t\tif (u->chain->top->depth < v->chain->top->depth) std::swap(u, v);\n\t\tres = std::max(res, segt->queryMax(u->chain->top->dfn, u->dfn));\n\t\tu = u->chain->top->fa;\n\t}\n\n\tif (u->depth > v->depth) std::swap(u, v);\n\tres = std::max(res, segt->queryMax(u->dfn, v->dfn));\n\n\treturn res;\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n - 1; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\n\tsplit();\n\n\tsegt = SegmentTree::build(1, n);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tupdate(i, x);\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile (q--)\n\t{\n\t\tchar cmd[sizeof(\"CHANGE\")];\n\t\tint a, b;\n\t\tscanf(\"%s %d %d\", cmd, &a, &b);\n\n\t\tif (cmd[1] == 'H')\n\t\t{\n\t\t\tupdate(a, b);\n\t\t}\n\t\telse if (cmd[1] == 'S')\n\t\t{\n\t\t\tprintf(\"%d\\n\", querySum(a, b));\n\t\t}\n\t\telse if (cmd[1] == 'M')\n\t\t{\n\t\t\tprintf(\"%d\\n\", queryMax(a, b));\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n","slug":"tree-chain-split-notes","published":1,"updated":"2016-12-28T02:31:23.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cix8bsb1s0000wcxlej6q489r"},{"title":"RMQ ","date":"2016-12-30T01:18:00.000Z","_content":"\nRMQ Sparse Table\n\n![zyz ](rmq-template/zyz.png)\n\n<!-- more -->\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(100000) = 16.609640474436812\n\nint n, a[MAXN + 1], st[MAXN + 1][MAXN_LOG + 1], logx[MAXN + 1]; //  log\n\ninline void sparseTable()\n{\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint t = 0;\n\t\twhile ((1 << (t + 1)) <= i) t++;\n\t\tlogx[i] = t;\n\t}\n\n\tfor (int i = 1; i <= n; i++) st[i][0] = a[i]; //  2 ^ 0 = 1 \n\n\tfor (int j = 1; j <= logx[n]; j++)\n\t{\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\t// \n\t\t\tif (i + (1 << (j - 1)) <= n) st[i][j] = std::max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\telse st[i][j] = st[i][j - 1];\n\t\t}\n\t}\n}\n\ninline int rmq(int l, int r)\n{\n\tint t = logx[r - l];\n\treturn std::max(st[l][t], st[r - (1 << t) + 1][t]); // \n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tsparseTable();\n\n\tint m;\n\tscanf(\"%d\", &m);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint l, r;\n\t\tscanf(\"%d %d\", &l, &r);\n\t\tprintf(\"%d\\n\", rmq(l, r));\n\t}\n\n\treturn 0;\n}\n```","source":"_posts/rmq-template.md","raw":"title: RMQ \ncategories: OI\ntags: \n  - RMQ\n  - \n  - \npermalink: rmq-template\ndate: 2016-12-30 09:18:00\n---\n\nRMQ Sparse Table\n\n![zyz ](rmq-template/zyz.png)\n\n<!-- more -->\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100000;\nconst int MAXN_LOG = 17; // Math.log2(100000) = 16.609640474436812\n\nint n, a[MAXN + 1], st[MAXN + 1][MAXN_LOG + 1], logx[MAXN + 1]; //  log\n\ninline void sparseTable()\n{\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint t = 0;\n\t\twhile ((1 << (t + 1)) <= i) t++;\n\t\tlogx[i] = t;\n\t}\n\n\tfor (int i = 1; i <= n; i++) st[i][0] = a[i]; //  2 ^ 0 = 1 \n\n\tfor (int j = 1; j <= logx[n]; j++)\n\t{\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\t// \n\t\t\tif (i + (1 << (j - 1)) <= n) st[i][j] = std::max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n\t\t\telse st[i][j] = st[i][j - 1];\n\t\t}\n\t}\n}\n\ninline int rmq(int l, int r)\n{\n\tint t = logx[r - l];\n\treturn std::max(st[l][t], st[r - (1 << t) + 1][t]); // \n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tsparseTable();\n\n\tint m;\n\tscanf(\"%d\", &m);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint l, r;\n\t\tscanf(\"%d %d\", &l, &r);\n\t\tprintf(\"%d\\n\", rmq(l, r));\n\t}\n\n\treturn 0;\n}\n```","slug":"rmq-template","published":1,"updated":"2016-12-30T01:19:12.231Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixb433bv0000vsxl40ulnzgy"}],"PostAsset":[{"_id":"source/_posts/virtualbox-archlinux/hotkey.png","post":"cix2l6bue0034c2xl1ourfi98","slug":"hotkey.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/network.png","post":"cix2l6bue0034c2xl1ourfi98","slug":"network.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/port.png","post":"cix2l6bue0034c2xl1ourfi98","slug":"port.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/screenfetch.png","post":"cix2l6bue0034c2xl1ourfi98","slug":"screenfetch.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/share.png","post":"cix2l6bue0034c2xl1ourfi98","slug":"share.png","modified":1},{"_id":"source/_posts/virtualbox-archlinux/terminal.png","post":"cix2l6bue0034c2xl1ourfi98","slug":"terminal.png","modified":1},{"_id":"source/_posts/uva-11538/cells.png","post":"cix2l6bvk0041c2xl9qn1uwdf","slug":"cells.png","modified":1},{"_id":"source/_posts/splay-template/zyz.png","post":"cix2l6by10082c2xlwm1twirx","slug":"zyz.png","modified":1},{"_id":"source/_posts/splay-notes-1/splay.png","post":"cix2l6byq008lc2xlii69cjiz","slug":"splay.png","modified":1},{"_id":"source/_posts/sdoi2016-game/line.png","post":"cix2l6c0k00bpc2xl1fk96gdo","slug":"line.png","modified":1},{"_id":"source/_posts/sdoi2016-game/tree.png","post":"cix2l6c0k00bpc2xl1fk96gdo","slug":"tree.png","modified":1},{"_id":"source/_posts/noip2016-running/linear-backward1.svg","post":"cix2l6c6l00jyc2xlw2fnj5q9","slug":"linear-backward1.svg","modified":1},{"_id":"source/_posts/noip2016-running/linear-forward1.svg","post":"cix2l6c6l00jyc2xlw2fnj5q9","slug":"linear-forward1.svg","modified":1},{"_id":"source/_posts/noip2016-running/linear-forward2.svg","post":"cix2l6c6l00jyc2xlw2fnj5q9","slug":"linear-forward2.svg","modified":1},{"_id":"source/_posts/noi2008-candy/1.svg","post":"cix2l6cck00rdc2xlc04v9w81","slug":"1.svg","modified":1},{"_id":"source/_posts/noi2008-candy/2.ggb","post":"cix2l6cck00rdc2xlc04v9w81","slug":"2.ggb","modified":1},{"_id":"source/_posts/noi2008-candy/2.svg","post":"cix2l6cck00rdc2xlc04v9w81","slug":"2.svg","modified":1},{"_id":"source/_posts/noi2008-candy/3.ggb","post":"cix2l6cck00rdc2xlc04v9w81","slug":"3.ggb","modified":1},{"_id":"source/_posts/noi2008-candy/3.svg","post":"cix2l6cck00rdc2xlc04v9w81","slug":"3.svg","modified":1},{"_id":"source/_posts/noi2008-candy/4.ggb","post":"cix2l6cck00rdc2xlc04v9w81","slug":"4.ggb","modified":1},{"_id":"source/_posts/noi2008-candy/4.svg","post":"cix2l6cck00rdc2xlc04v9w81","slug":"4.svg","modified":1},{"_id":"source/_posts/noi2008-candy/5.ggb","post":"cix2l6cck00rdc2xlc04v9w81","slug":"5.ggb","modified":1},{"_id":"source/_posts/noi2008-candy/5.svg","post":"cix2l6cck00rdc2xlc04v9w81","slug":"5.svg","modified":1},{"_id":"source/_posts/noi2008-candy/6.ggb","post":"cix2l6cck00rdc2xlc04v9w81","slug":"6.ggb","modified":1},{"_id":"source/_posts/noi2008-candy/6.svg","post":"cix2l6cck00rdc2xlc04v9w81","slug":"6.svg","modified":1},{"_id":"source/_posts/noi2008-candy/7.ggb","post":"cix2l6cck00rdc2xlc04v9w81","slug":"7.ggb","modified":1},{"_id":"source/_posts/noi2008-candy/7.svg","post":"cix2l6cck00rdc2xlc04v9w81","slug":"7.svg","modified":1},{"_id":"source/_posts/node-devide-notes/tree1.svg","post":"cix2l6cea00shc2xlzm3j55me","slug":"tree1.svg","modified":1},{"_id":"source/_posts/node-devide-notes/tree2.svg","post":"cix2l6cea00shc2xlzm3j55me","slug":"tree2.svg","modified":1},{"_id":"source/_posts/lyoi-pingfan/pfzl.lrc","post":"cix2l6cfn00tlc2xlx761f4p6","slug":"pfzl.lrc","modified":1},{"_id":"source/_posts/haoi2006-sequence/1.svg","post":"cix2l6cqn013hc2xlvdz4s7k4","slug":"1.svg","modified":1},{"_id":"source/_posts/haoi2006-sequence/2.svg","post":"cix2l6cqn013hc2xlvdz4s7k4","slug":"2.svg","modified":1},{"_id":"source/_posts/docker-sandbox-judger/image.svg","post":"cix2l6cs70151c2xles9j0qa2","slug":"image.svg","modified":1},{"_id":"source/_posts/cf-716e/example.svg","post":"cix2l6cyx01btc2xlgexlzpn6","slug":"example.svg","modified":1},{"_id":"source/_posts/bzoj-2683/cdq.png","post":"cix2l6d3y01gbc2xlf2gf6nh1","slug":"cdq.png","modified":1},{"_id":"source/_posts/at-the-cross-of-time/mzr.lrc","post":"cix2l6d9m01l1c2xlvxcyo4eu","slug":"mzr.lrc","modified":1},{"_id":"source/_posts/acam-notes/acam.svg","post":"cix2l6dba01mcc2xly70b6g77","slug":"acam.svg","modified":1},{"_id":"source/_posts/acam-notes/acam2.svg","post":"cix2l6dba01mcc2xly70b6g77","slug":"acam2.svg","modified":1},{"_id":"source/_posts/kmp-notes/zyz.png","slug":"zyz.png","post":"cix2l6cg200tvc2xldrn3l8co","modified":1},{"_id":"source/_posts/acam-notes/zyz.png","slug":"zyz.png","post":"cix2l6dba01mcc2xly70b6g77","modified":1},{"_id":"source/_posts/tree-chain-split-notes/1.svg","post":"cix8bsb1s0000wcxlej6q489r","slug":"1.svg","modified":1},{"_id":"source/_posts/tree-chain-split-notes/zyz.png","post":"cix8bsb1s0000wcxlej6q489r","slug":"zyz.png","modified":1},{"_id":"source/_posts/tarjan-cut-notes/zyz.png","slug":"zyz.png","post":"cix2l6bxg0071c2xlyuso9bu9","modified":1},{"_id":"source/_posts/rmq-template/zyz.png","post":"cixb433bv0000vsxl40ulnzgy","slug":"zyz.png","modified":1}],"PostCategory":[{"post_id":"cix2l6brk0000c2xlfe4nxt7l","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6brz0007c2xlwnuwo6zl"},{"post_id":"cix2l6bse000gc2xlqobyapd6","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bsg000hc2xll05i6hx7"},{"post_id":"cix2l6bsm000qc2xlna0eomn7","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bsp000rc2xlp2hvoq96"},{"post_id":"cix2l6bt00012c2xlt1rs3zv1","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bt10013c2xl9okbxkpy"},{"post_id":"cix2l6bt6001ac2xlgj1u2cir","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bt9001bc2xlq0d9aloq"},{"post_id":"cix2l6btc001gc2xl29n5zsfs","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6btd001hc2xlfnouf1qm"},{"post_id":"cix2l6bth001mc2xl8pg2lfsl","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6btj001nc2xl7ix2rq2o"},{"post_id":"cix2l6bto001xc2xlmookj6g2","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6btp001yc2xlqcl4uenx"},{"post_id":"cix2l6btt0027c2xlndsrl4r5","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6btw0028c2xlo7j6i4t1"},{"post_id":"cix2l6btz002ic2xlzpejtfyv","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bu1002jc2xl6vmxmqlv"},{"post_id":"cix2l6bu4002oc2xlq9cdw8vy","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bu5002pc2xleqnu0pr8"},{"post_id":"cix2l6bu9002wc2xlllzj716i","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bub002xc2xl6o0xa8oi"},{"post_id":"cix2l6bue0034c2xl1ourfi98","category_id":"cix2l6buf0035c2xl5d1a7yl0","_id":"cix2l6buh003cc2xlz8b64x29"},{"post_id":"cix2l6bvb003jc2xl99n86m4q","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bvb003kc2xl824xw4xt"},{"post_id":"cix2l6bvg003tc2xlxq8umis0","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bvh003uc2xl7wrfwlyz"},{"post_id":"cix2l6bvk0041c2xl9qn1uwdf","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bvm0042c2xlcdkrk1vu"},{"post_id":"cix2l6bvx0047c2xlb4wcbgaw","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bvz0048c2xlj7f83uhy"},{"post_id":"cix2l6bw3004fc2xlhnehj6fi","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bw4004gc2xlousyze4n"},{"post_id":"cix2l6bw7004nc2xlooynpv96","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bw9004oc2xlbth4qxqh"},{"post_id":"cix2l6bwd004zc2xlezvta4ib","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bwe0050c2xlz08d6qje"},{"post_id":"cix2l6bwg0057c2xlf1vl8ful","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bwi0058c2xlt0okykev"},{"post_id":"cix2l6bwl005fc2xl4445crj9","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bwm005gc2xlb29e3pd9"},{"post_id":"cix2l6bws005rc2xlo2896nrc","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bwu005sc2xl77jwwz45"},{"post_id":"cix2l6bwx0060c2xlw6q2naa2","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bwy0061c2xllbdy9rdh"},{"post_id":"cix2l6bx10068c2xl0hniccz4","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bx20069c2xli8aeg80z"},{"post_id":"cix2l6bx5006gc2xlw3kpv4jw","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bx8006hc2xlwj30k6wb"},{"post_id":"cix2l6bxb006qc2xl3n527i9r","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bxc006rc2xluufeqoqf"},{"post_id":"cix2l6bxj0079c2xlkqk26ysx","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bxk007ac2xlrpbamrd0"},{"post_id":"cix2l6bxn007hc2xlvkjf70g7","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bxo007ic2xl3qfnuekx"},{"post_id":"cix2l6bxr007qc2xl5tc05r1b","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bxt007rc2xl11ou8p0y"},{"post_id":"cix2l6bxy007wc2xlbfr6msqp","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bxz007xc2xlassm6qux"},{"post_id":"cix2l6by10082c2xlwm1twirx","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6by30083c2xl16vfs8th"},{"post_id":"cix2l6byn008ec2xlcm86l0z4","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6byo008fc2xl1t6l95wz"},{"post_id":"cix2l6byw008sc2xlihfle7ic","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6byy008tc2xl5ax8pqx6"},{"post_id":"cix2l6bz0008yc2xl5ned3wmd","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bz1008zc2xlvcr7aaev"},{"post_id":"cix2l6bz30095c2xlfqney5g0","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bz50096c2xldf1w7452"},{"post_id":"cix2l6bz7009ac2xlytb1inkm","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bz8009bc2xler2idk3i"},{"post_id":"cix2l6bza009fc2xlq7y3j4dd","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bzb009gc2xlq0a7c991"},{"post_id":"cix2l6bzf009nc2xl1qv01htn","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bzg009oc2xl3jqew2ur"},{"post_id":"cix2l6bzj009uc2xlzsl9e2y3","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bzk009vc2xl81hf1f1b"},{"post_id":"cix2l6bzn00a4c2xl7y3lfduh","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bzp00a5c2xlni5ad9yw"},{"post_id":"cix2l6bzu00agc2xlqu7taing","category_id":"cix2l6bzw00ahc2xlhdb7ev07","_id":"cix2l6bzx00aic2xl4iwd35i0"},{"post_id":"cix2l6bzx00ajc2xlml35kc7l","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6bzz00akc2xlkvc1mtqq"},{"post_id":"cix2l6c0400atc2xlxateai4p","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c0500auc2xlfwxzyp2c"},{"post_id":"cix2l6c0b00b8c2xlr2vz42nv","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c0c00b9c2xlpxwcxjns"},{"post_id":"cix2l6c0f00bgc2xlirfamzo8","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c0h00bhc2xl574bttwt"},{"post_id":"cix2l6c0k00bpc2xl1fk96gdo","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c0l00bqc2xlqovmogmk"},{"post_id":"cix2l6c0t00c0c2xl4nsx8oc0","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c0u00c1c2xlqh77xvwk"},{"post_id":"cix2l6c0x00cac2xle8ywib7a","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c0z00cbc2xlr26pglf9"},{"post_id":"cix2l6c1500coc2xlua0rrkkv","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c1700cpc2xl9e78825f"},{"post_id":"cix2l6c1a00cuc2xlsd79jq5o","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c1c00cvc2xlu57xotxw"},{"post_id":"cix2l6c1o00d5c2xl0hilvwi2","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c1p00d6c2xlas578jh3"},{"post_id":"cix2l6c1t00dfc2xlczjqoznc","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c1v00dgc2xl69zu5u3g"},{"post_id":"cix2l6c1y00dnc2xlepo0bnx5","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c1z00doc2xlz2srpdtt"},{"post_id":"cix2l6c2100dsc2xl2mo6co45","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c2300dtc2xloehby5yr"},{"post_id":"cix2l6c2500dzc2xlygy30xcd","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c2700e0c2xlcgyr3u53"},{"post_id":"cix2l6c2a00e5c2xlm66wx5rj","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c2b00e6c2xlre7515hl"},{"post_id":"cix2l6c2f00egc2xl0ksuclev","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c2g00ehc2xl0q8on3tv"},{"post_id":"cix2l6c2j00eqc2xln0f47hrk","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c2l00erc2xlb60yh8da"},{"post_id":"cix2l6c2o00ezc2xlkuv05dqx","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c2s00f0c2xllklhk59l"},{"post_id":"cix2l6c2x00f9c2xl6rd90nt6","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c2z00fac2xl164pp8dn"},{"post_id":"cix2l6c3200fhc2xlie3l1pnf","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c3300fic2xlneic2ju8"},{"post_id":"cix2l6c3700fpc2xllyop1drz","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c3900fqc2xljvotm067"},{"post_id":"cix2l6c3c00fvc2xleuwccy1p","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c3d00fwc2xlj81cicfo"},{"post_id":"cix2l6c3i00g5c2xlx7ymxp67","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c3j00g6c2xlbi11uwtx"},{"post_id":"cix2l6c3n00gfc2xlur06igll","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c3o00ggc2xlw5io4uzl"},{"post_id":"cix2l6c3q00glc2xlxho77mpr","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c3r00gmc2xlisf5fckk"},{"post_id":"cix2l6c3t00grc2xljphzz9oq","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c3v00gsc2xl9sdzs3cs"},{"post_id":"cix2l6c3y00h0c2xl2sz697zb","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c4000h1c2xl1dktumyz"},{"post_id":"cix2l6c4400h8c2xlvdbx87ds","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c4600h9c2xlzm3fjnv1"},{"post_id":"cix2l6c4900hhc2xlz1u499la","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c4a00hic2xl0851vzyo"},{"post_id":"cix2l6c4d00hnc2xlu1hlazam","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c4f00hoc2xlst0r5bny"},{"post_id":"cix2l6c4h00htc2xlqm9a4iz0","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c4j00huc2xlxjngou5k"},{"post_id":"cix2l6c4m00i1c2xlblomrgol","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c4p00i2c2xls3e3rnpb"},{"post_id":"cix2l6c4u00icc2xl4cdjx76c","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c4v00idc2xlr2xbslgq"},{"post_id":"cix2l6c4z00ikc2xlg02derhw","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c5000ilc2xlmk2d3xyg"},{"post_id":"cix2l6c5300isc2xlbxq2fkht","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c5600itc2xlt9h3xh23"},{"post_id":"cix2l6c5900izc2xlfffxuvd0","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c5b00j0c2xl0yoq1qra"},{"post_id":"cix2l6c5e00j6c2xlx83fmb1t","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c5g00j7c2xlsg7jzfx6"},{"post_id":"cix2l6c5j00jdc2xlk4a4ott5","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c5k00jec2xlvet7o0ue"},{"post_id":"cix2l6c6500jjc2xl9q7yy1u2","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c6c00jkc2xlrhbw79tb"},{"post_id":"cix2l6c6f00jrc2xl7rm6u4go","category_id":"cix2l6bzw00ahc2xlhdb7ev07","_id":"cix2l6c6g00jsc2xlyuu3ag7e"},{"post_id":"cix2l6c6h00jtc2xlylaght2n","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c6i00juc2xl6qpsvstq"},{"post_id":"cix2l6c6l00jyc2xlw2fnj5q9","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c6m00jzc2xluerp7kc7"},{"post_id":"cix2l6c6u00k4c2xlc9y0x3gz","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c6w00k5c2xlngs99oed"},{"post_id":"cix2l6c6y00kac2xlsvcveua9","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c6z00kbc2xly81y5ct9"},{"post_id":"cix2l6c7100kfc2xlshvblmw1","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c7600kgc2xllj751k72"},{"post_id":"cix2l6c7900kmc2xlata0f22v","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c7a00knc2xldctiwfo5"},{"post_id":"cix2l6c7e00kuc2xl2i7m7a1c","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c7f00kvc2xlbq4pn1h1"},{"post_id":"cix2l6c7h00l0c2xl01ii0mf9","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c7j00l1c2xli3iead9j"},{"post_id":"cix2l6c7l00l5c2xlia9o9uzg","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c7m00l6c2xl6xkp24np"},{"post_id":"cix2l6c7p00lbc2xl2fmd6frl","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c7q00lcc2xlrjc91gcr"},{"post_id":"cix2l6c7u00ljc2xlqe4ely8k","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c7v00lkc2xlmduwrlpj"},{"post_id":"cix2l6c7y00lqc2xl0ywbc2ig","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c8000lrc2xld83s5hfu"},{"post_id":"cix2l6c8300lzc2xll9nv803j","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c8500m0c2xltcbcakw0"},{"post_id":"cix2l6c8800m6c2xlonsw0kmd","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c8a00m7c2xlp5aabrsn"},{"post_id":"cix2l6c8c00mbc2xl8o61il2q","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c8d00mcc2xlq89r64jx"},{"post_id":"cix2l6c8h00mjc2xl5a0hda7m","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c8j00mkc2xlff5fsvs8"},{"post_id":"cix2l6c8l00moc2xlujgm0ar7","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c8m00mpc2xlh0sok2b6"},{"post_id":"cix2l6c8r00myc2xl3qc96ysa","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c8s00mzc2xl2kbbiz6n"},{"post_id":"cix2l6c8v00n5c2xlsmh6mqzd","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c8x00n6c2xlxydzzxpi"},{"post_id":"cix2l6c9500nhc2xl568izctq","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c9700nic2xlmuf4372a"},{"post_id":"cix2l6c9a00npc2xlq3jhcl52","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c9c00nqc2xlom2nnyg9"},{"post_id":"cix2l6c9j00nwc2xlb0vtong6","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c9l00nxc2xlfb5m5b2x"},{"post_id":"cix2l6c9p00o5c2xljftollwe","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c9r00o6c2xlh3om09xx"},{"post_id":"cix2l6c9v00odc2xlc5u61jl9","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6c9x00oec2xl6ucck3d2"},{"post_id":"cix2l6ca000ojc2xlpt1gw5qo","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6ca100okc2xl8ovs69d0"},{"post_id":"cix2l6ca500opc2xlm4k8cd1c","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6ca700oqc2xlpfloueyh"},{"post_id":"cix2l6caa00owc2xl0wb51qrs","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cac00oxc2xleg7116sl"},{"post_id":"cix2l6cag00p2c2xlewpaymrt","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6caj00p3c2xlfc6sjy6u"},{"post_id":"cix2l6car00p9c2xlcfkmm59g","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cat00pac2xlmjcuy9lt"},{"post_id":"cix2l6cb200plc2xl5b9caggl","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cb400pmc2xl8a7dlds3"},{"post_id":"cix2l6cb900ptc2xlqa5g371x","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cba00puc2xl6rahw6vt"},{"post_id":"cix2l6cbg00q2c2xlfl2zijy5","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cbi00q3c2xlsef0037o"},{"post_id":"cix2l6cbn00qbc2xl7v5sx37n","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cbp00qcc2xlg3grlqo0"},{"post_id":"cix2l6cbt00qic2xlhyboh5bi","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cbv00qjc2xl6gyshn2d"},{"post_id":"cix2l6cby00qoc2xlwc42qho2","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cbz00qpc2xlyl9w7bd7"},{"post_id":"cix2l6cc300quc2xliza3k2sd","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cc500qvc2xlapgdcq5k"},{"post_id":"cix2l6cc900r1c2xl5prwgqg9","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6ccb00r2c2xl81cnz0ib"},{"post_id":"cix2l6cce00r7c2xl14zkxu1u","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cch00r8c2xltzn6rd56"},{"post_id":"cix2l6cck00rdc2xlc04v9w81","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6ccm00rec2xlmu9ojv9d"},{"post_id":"cix2l6cdh00rmc2xl7v3m0v3k","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cdj00rnc2xll8krljsv"},{"post_id":"cix2l6cdq00rxc2xlay02lzkk","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cds00ryc2xl2adp595v"},{"post_id":"cix2l6cdx00s5c2xl39w35ogs","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cdz00s6c2xl1ubfsc3j"},{"post_id":"cix2l6ce300scc2xla2jph1yg","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6ce600sdc2xllulivrwc"},{"post_id":"cix2l6cea00shc2xlzm3j55me","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6ced00sic2xlk01pkj69"},{"post_id":"cix2l6cem00soc2xls64g54ho","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6ceo00spc2xlvoujxygz"},{"post_id":"cix2l6cer00svc2xln823gqim","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6ceu00swc2xl48vx0f9m"},{"post_id":"cix2l6cey00t2c2xl1uqvp0r4","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cf300t3c2xlmd8qz4ml"},{"post_id":"cix2l6cf800t8c2xlmfscwldu","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cfb00t9c2xl7cr8veg3"},{"post_id":"cix2l6cfn00tlc2xlx761f4p6","category_id":"cix2l6bzw00ahc2xlhdb7ev07","_id":"cix2l6cfr00tmc2xlx0fe8t1d"},{"post_id":"cix2l6cfu00tnc2xlvjxdiny8","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cfx00toc2xlkcnu2w0q"},{"post_id":"cix2l6cg900u2c2xl5k11bdgb","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cgb00u3c2xl118vmwhc"},{"post_id":"cix2l6cgk00uac2xloq8g88ro","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cgm00ubc2xly0zns47v"},{"post_id":"cix2l6cgs00uhc2xlltiuxm68","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cgu00uic2xleq7x8geh"},{"post_id":"cix2l6ch100urc2xlvr7fw9x4","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6ch400usc2xlufxy26k9"},{"post_id":"cix2l6chb00v0c2xl0ekuj2ko","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6che00v1c2xl45d6zkkv"},{"post_id":"cix2l6chj00v6c2xlqpdg3ocj","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6chn00v7c2xl1ykq618l"},{"post_id":"cix2l6chs00vdc2xlb6u1m4b9","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6chv00vec2xl1ohdy99v"},{"post_id":"cix2l6chz00vkc2xlhma496vk","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6ci200vlc2xlsfufj6ib"},{"post_id":"cix2l6ci600vqc2xlsfb6onqi","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6ci900vrc2xlr3g05ul2"},{"post_id":"cix2l6cid00vwc2xllxfci3g6","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cig00vxc2xlw7fzm6w8"},{"post_id":"cix2l6cij00w1c2xldyt70jjs","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cim00w2c2xl5w1378ux"},{"post_id":"cix2l6cit00w8c2xlh1zqq49r","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6ciw00w9c2xlhevc6qgo"},{"post_id":"cix2l6cj100wfc2xlu4w1h8ti","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cj400wgc2xlsw9o0qr4"},{"post_id":"cix2l6cj900wlc2xl1sj7zor5","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cjc00wmc2xldnspy5ma"},{"post_id":"cix2l6cji00wsc2xlwhl44dm1","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cjl00wtc2xl8mwbt4hr"},{"post_id":"cix2l6cjt00x0c2xly13ge6ou","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cjw00x1c2xl6jn7bey1"},{"post_id":"cix2l6ck400x9c2xlitwh7tcv","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6ck700xac2xlrngtly17"},{"post_id":"cix2l6ckd00xfc2xlcm2srjss","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6ckg00xgc2xlnx70ksqx"},{"post_id":"cix2l6ckm00xnc2xl09mej7dn","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6ckq00xoc2xlmzvc6hca"},{"post_id":"cix2l6ckz00xvc2xl4owzq48v","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cl300xwc2xlshnbcwzp"},{"post_id":"cix2l6cl800y2c2xlfkyejj2n","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6clc00y3c2xl2yoqejoi"},{"post_id":"cix2l6clh00y8c2xl0vbm2av4","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cll00y9c2xlcfevdtpc"},{"post_id":"cix2l6cly00ygc2xlcboq51r6","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cm100yhc2xluk094epp"},{"post_id":"cix2l6cm600ypc2xlixlhq2v8","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cma00yqc2xl6jvgf5ku"},{"post_id":"cix2l6cmj00yxc2xlx6xxhlrm","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cmm00yyc2xl0se0ef1j"},{"post_id":"cix2l6cmu00z6c2xls3xstv2v","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cmx00z7c2xlgda75ccn"},{"post_id":"cix2l6cn200zec2xlr7qp5cyz","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cn400zfc2xlthdgeylr"},{"post_id":"cix2l6cn800zlc2xlepdlk3wo","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cna00zmc2xl5tecvjcl"},{"post_id":"cix2l6cne00zsc2xlvj3qizzw","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cnf00ztc2xlzmkbvt5j"},{"post_id":"cix2l6cnk00zzc2xlnwjx8ega","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cnl0100c2xlx0udw0sa"},{"post_id":"cix2l6cns010ac2xl973cjb8b","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cnu010bc2xlrwrfzhhl"},{"post_id":"cix2l6cny010hc2xlcnsxg74l","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6co0010ic2xlsoospfjp"},{"post_id":"cix2l6co3010mc2xlaoa85tvp","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6co5010nc2xlm8cs8lr8"},{"post_id":"cix2l6co7010rc2xlf2ck7v97","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6co9010sc2xlwytbxdfy"},{"post_id":"cix2l6coe010zc2xlo3rb9c3n","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6coh0110c2xlzf2fmfoa"},{"post_id":"cix2l6cok0116c2xl16ozicb9","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6com0117c2xl3kd9n9hl"},{"post_id":"cix2l6cos011gc2xl4xw2ftu1","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cou011hc2xlsci85ivj"},{"post_id":"cix2l6cox011mc2xlvejxcxpg","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6coz011nc2xlv1a8b6c3"},{"post_id":"cix2l6cp3011tc2xlff8p9t24","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cp5011uc2xl51mc1dcu"},{"post_id":"cix2l6cp8011zc2xlhd4h0stw","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cpa0120c2xlwev6pi25"},{"post_id":"cix2l6cpe0125c2xl8n6yz5ql","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cpg0126c2xl7w8wmv1v"},{"post_id":"cix2l6cpl012dc2xl1wt67ql5","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cpm012ec2xl5iahr4c2"},{"post_id":"cix2l6cpp012ic2xlrnikueyi","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cpt012jc2xlyoqj6q99"},{"post_id":"cix2l6cpw012nc2xltzkkizpe","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cpy012oc2xlgyl6b9kp"},{"post_id":"cix2l6cq1012sc2xlrr6wbnho","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cq3012tc2xlcmnadaql"},{"post_id":"cix2l6cq6012zc2xl9xz9zejh","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cq90130c2xlcszh9pty"},{"post_id":"cix2l6cqc0135c2xl7dqjqzy1","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cqe0136c2xl1r8qzfuo"},{"post_id":"cix2l6cqi013bc2xl858kef5z","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cqk013cc2xlniryxwzt"},{"post_id":"cix2l6cqn013hc2xlvdz4s7k4","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cqp013ic2xlpcenrzdi"},{"post_id":"cix2l6cqx013mc2xlnvvv4hr8","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cqz013nc2xl5xcucygt"},{"post_id":"cix2l6cr3013tc2xlgml7050a","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cr5013uc2xlowosyeid"},{"post_id":"cix2l6cr90140c2xl3gt869k0","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6crb0141c2xl9pywbu97"},{"post_id":"cix2l6crf0146c2xlscbb7cvw","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cri0147c2xllg3a81e1"},{"post_id":"cix2l6crn014fc2xl5q3vdtrh","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6crp014gc2xl986cm0js"},{"post_id":"cix2l6crt014mc2xl4olmhzgw","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6crv014nc2xlinhmf02g"},{"post_id":"cix2l6cs70151c2xles9j0qa2","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cs90152c2xl0lblo81b"},{"post_id":"cix2l6csk015ec2xlkjzbnick","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6csn015fc2xloc7th89i"},{"post_id":"cix2l6csz015rc2xls7mzmm9b","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6ct2015sc2xlotfs3bmm"},{"post_id":"cix2l6ctb0162c2xlkgdjun96","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6ctd0163c2xltvrqsywd"},{"post_id":"cix2l6cth0168c2xl4k26qh9t","category_id":"cix2l6bzw00ahc2xlhdb7ev07","_id":"cix2l6ctj0169c2xl71q28xk9"},{"post_id":"cix2l6ctk016ac2xlkmlipq5s","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6ctn016bc2xlu4byv6nu"},{"post_id":"cix2l6ctr016hc2xldh2b6iv3","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6ctu016ic2xlzkrk4stk"},{"post_id":"cix2l6cty016oc2xlpke52uts","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cu0016pc2xlbaw2tcs8"},{"post_id":"cix2l6cu5016wc2xlumk55knn","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cu7016xc2xlal8ed2zf"},{"post_id":"cix2l6cub0172c2xlvt6c4qr5","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cud0173c2xleqygpcu0"},{"post_id":"cix2l6cuj017bc2xlky1mii1p","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cul017cc2xln634god5"},{"post_id":"cix2l6cuq017jc2xlcfbch6uh","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cus017kc2xlaip3hkfr"},{"post_id":"cix2l6cux017rc2xln2220k5d","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cuz017sc2xlizf00yxx"},{"post_id":"cix2l6cv50180c2xl5hotor5q","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cv70181c2xln96kac4f"},{"post_id":"cix2l6cvc0188c2xl2o3l0h16","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cve0189c2xl54elp8d6"},{"post_id":"cix2l6cvj018gc2xl8sc8taqf","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cvl018hc2xlqrphx30t"},{"post_id":"cix2l6cvq018oc2xluiysn7mv","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cvs018pc2xl05x6sydm"},{"post_id":"cix2l6cvx018vc2xlo3qz61yo","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cvz018wc2xlm0wia736"},{"post_id":"cix2l6cw30192c2xlhihsc9gg","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cw60193c2xl7kv03t04"},{"post_id":"cix2l6cwb019ac2xll827ieda","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cwe019bc2xl60ohvcd0"},{"post_id":"cix2l6cwj019ic2xla8jsi931","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cwn019jc2xllmjf34z5"},{"post_id":"cix2l6cwt019rc2xlb0u387nq","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cwv019sc2xl8sbt4mok"},{"post_id":"cix2l6cwy019wc2xls4ucr3xb","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cx1019xc2xl7i9xflt7"},{"post_id":"cix2l6cx601a4c2xlyrt4c2en","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cx901a5c2xlg01s0l2t"},{"post_id":"cix2l6cxc01a9c2xl2h3i18hx","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cxe01aac2xlyoev6c0g"},{"post_id":"cix2l6cxi01afc2xlcm2f8ysy","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cxk01agc2xlrz6pwdmg"},{"post_id":"cix2l6cxp01amc2xlo2dpurq8","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cxr01anc2xl7dqx5cls"},{"post_id":"cix2l6cxw01atc2xlmtjmku4s","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cxy01auc2xltmgpkx8d"},{"post_id":"cix2l6cy201azc2xlks3fmfmk","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cy401b0c2xlpne5pt4n"},{"post_id":"cix2l6cy901b7c2xljqpcfsx5","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cyc01b8c2xlfxv8g9wb"},{"post_id":"cix2l6cyg01bdc2xluekyf0f3","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cyi01bec2xlfpxloy4o"},{"post_id":"cix2l6cyq01bnc2xl0a9o9024","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cyt01boc2xl70d2u6mn"},{"post_id":"cix2l6cyx01btc2xlgexlzpn6","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6cyz01buc2xlpzwhdhf0"},{"post_id":"cix2l6cza01c2c2xl6g35bgwb","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6czc01c3c2xl3rh5nxr5"},{"post_id":"cix2l6czf01c7c2xl31nuewiw","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6czi01c8c2xl8k7051b5"},{"post_id":"cix2l6czl01cdc2xlczfe3g86","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6czo01cec2xli6h0onvq"},{"post_id":"cix2l6czt01clc2xlc3rmt97a","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6czw01cmc2xl73xeq5wz"},{"post_id":"cix2l6d0401cvc2xle8wmyb2e","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d0701cwc2xlmyye6r1m"},{"post_id":"cix2l6d0b01d1c2xlodmx85zc","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d0d01d2c2xlv77hc5ew"},{"post_id":"cix2l6d0g01d6c2xltmret6t5","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d0i01d7c2xlb1i1z3i1"},{"post_id":"cix2l6d0m01dbc2xlvjjay1lq","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d0o01dcc2xlrscapg66"},{"post_id":"cix2l6d0w01dlc2xl0e0xhez1","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d0y01dmc2xlq3p21u5v"},{"post_id":"cix2l6d1201dsc2xllj5nwbfo","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d1501dtc2xll2ag3mp0"},{"post_id":"cix2l6d1901dyc2xlmy00aokl","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d1b01dzc2xl4ignneoh"},{"post_id":"cix2l6d1f01e3c2xlu1xl80px","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d1h01e4c2xltsotbb3i"},{"post_id":"cix2l6d1m01eac2xlti16uxm8","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d1o01ebc2xlgds82gkv"},{"post_id":"cix2l6d1t01ehc2xl1oiu6to6","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d1v01eic2xlbxycw0iv"},{"post_id":"cix2l6d1z01emc2xlddjbdlva","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d2101enc2xl29h16bhs"},{"post_id":"cix2l6d2501esc2xlsrkezl16","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d2801etc2xlj0z89c3l"},{"post_id":"cix2l6d2d01f0c2xlyynqa9kv","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d2f01f1c2xleh9jrgte"},{"post_id":"cix2l6d2l01f7c2xlnbgi70cq","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d2n01f8c2xlyqd6r6ud"},{"post_id":"cix2l6d2s01fec2xlo6134k3k","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d2v01ffc2xlvfp0jtoc"},{"post_id":"cix2l6d2y01fjc2xl3eio6kpp","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d3101fkc2xl9d381h6x"},{"post_id":"cix2l6d3601frc2xlr32why36","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d3901fsc2xlxph3grrm"},{"post_id":"cix2l6d3i01fxc2xlf210bu7p","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d3m01fyc2xlp653kevv"},{"post_id":"cix2l6d3r01g4c2xl6g233gn3","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d3u01g5c2xlqdnndtn6"},{"post_id":"cix2l6d3y01gbc2xlf2gf6nh1","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d4101gcc2xlht0k5erp"},{"post_id":"cix2l6d4801gic2xlg10r6hhy","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d4a01gjc2xl0kugukmn"},{"post_id":"cix2l6d4g01gpc2xld6lpuze4","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d4i01gqc2xlgbet3pi9"},{"post_id":"cix2l6d4m01guc2xl6mpt9qv4","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d4o01gvc2xlgriv7zlg"},{"post_id":"cix2l6d4r01gyc2xln2gav8z2","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d4u01gzc2xlprudxlud"},{"post_id":"cix2l6d5001h6c2xls8ponbne","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d5301h7c2xljw2akupj"},{"post_id":"cix2l6d5701hcc2xlkulsg2tk","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d5901hdc2xll2dr5fh4"},{"post_id":"cix2l6d5d01hhc2xlapd4rgr5","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d5f01hic2xltst91ze5"},{"post_id":"cix2l6d5j01hmc2xllrirotgb","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d5l01hnc2xlk8hm6yfg"},{"post_id":"cix2l6d5p01hrc2xl55zu2uwq","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d5s01hsc2xlvxk75wms"},{"post_id":"cix2l6d5x01hyc2xl1frzaouw","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d6001hzc2xl1fnivw3k"},{"post_id":"cix2l6d6401i4c2xlza4mf0wc","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d6701i5c2xlo98al3cw"},{"post_id":"cix2l6d6b01ibc2xlaiop41hs","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d6e01icc2xl96062m3d"},{"post_id":"cix2l6d6i01ihc2xlgy6da0el","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d6l01iic2xl4chfp4ir"},{"post_id":"cix2l6d6q01ioc2xlm4phfqr2","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d6t01ipc2xlc6gw1lr1"},{"post_id":"cix2l6d6z01iuc2xl49p5bf0a","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d7201ivc2xlmuzefw3r"},{"post_id":"cix2l6d7601j0c2xlmzabz6k6","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d7901j1c2xlmsmmr9go"},{"post_id":"cix2l6d7e01j7c2xlgu6jo6vq","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d7h01j8c2xl8ibqzyjn"},{"post_id":"cix2l6d7l01jdc2xl017bwp1z","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d7o01jec2xl8vbtw390"},{"post_id":"cix2l6d7t01jkc2xlucsd71jl","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d7w01jlc2xla6czz2x0"},{"post_id":"cix2l6d8001jqc2xleot5r6xn","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d8201jrc2xlz45nqejr"},{"post_id":"cix2l6d8601jvc2xlflpbj4e2","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d8801jwc2xl0cawyeld"},{"post_id":"cix2l6d8c01k0c2xltbszxjbq","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d8g01k1c2xlopv3ile6"},{"post_id":"cix2l6d8k01k6c2xl8tee8a63","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d8n01k7c2xldnaiaexh"},{"post_id":"cix2l6d8s01kdc2xlau85znt7","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d8v01kec2xlcvt7wasb"},{"post_id":"cix2l6d8z01kjc2xl73w1n3zy","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d9201kkc2xl5wayclhx"},{"post_id":"cix2l6d9601kpc2xlbqcd2x9f","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d9901kqc2xl1p3i93qm"},{"post_id":"cix2l6d9f01kxc2xls2kespyk","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d9i01kyc2xluk6x5ioo"},{"post_id":"cix2l6d9m01l1c2xlvxcyo4eu","category_id":"cix2l6bzw00ahc2xlhdb7ev07","_id":"cix2l6d9q01l2c2xlcb0ze0b5"},{"post_id":"cix2l6d9s01l3c2xlqxqopyqq","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6d9v01l4c2xlu21idx1q"},{"post_id":"cix2l6da201lbc2xlo3xjecw6","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6da601lcc2xll0q9hx3b"},{"post_id":"cix2l6das01lxc2xlc6w1mh62","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6dav01lyc2xljn2ejqyi"},{"post_id":"cix2l6db101m5c2xl8o2hxcgz","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6db401m6c2xlyrug3lxn"},{"post_id":"cix2l6dbl01mic2xl2lxtrjh7","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6dbo01mjc2xlj5ep8iff"},{"post_id":"cix2l6dbu01mqc2xludpdiukd","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6dbx01mrc2xl6vnqqily"},{"post_id":"cix2l6dc501mzc2xl7egw8gbw","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6dc801n0c2xl0ocor93r"},{"post_id":"cix2l6dce01n5c2xlby8s0qzs","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6dch01n6c2xlqzclpbyf"},{"post_id":"cix2l6dcm01nbc2xlmry79v3w","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix2l6dcp01ncc2xl40fvaatv"},{"post_id":"cix2l6cse0157c2xlubh2j54s","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix38yxqh00006rxlbv6hcvvx"},{"post_id":"cix2l6dai01loc2xlnrj4he67","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix41y60f0001vgxl6s76kmwa"},{"post_id":"cix2l6cs0014tc2xlbdr5e22e","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix42os0p000079xla1lx08h2"},{"post_id":"cix2l6cg200tvc2xldrn3l8co","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix6wi3z00000zexl4axltphv"},{"post_id":"cix2l6dba01mcc2xly70b6g77","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix6wp3ce00006gxlf9ryk8i7"},{"post_id":"cix2l6byh0088c2xl22ay970e","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix76zgms0000gaxlnt4258iq"},{"post_id":"cix2l6byq008lc2xlii69cjiz","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix76zgn60001gaxl2vpond2j"},{"post_id":"cix8bsb1s0000wcxlej6q489r","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cix8bsb200001wcxl4rj5ryzt"},{"post_id":"cix2l6bxg0071c2xlyuso9bu9","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cixa0lju10000vbxlqsnogyld"},{"post_id":"cixb433bv0000vsxl40ulnzgy","category_id":"cix2l6brs0001c2xl0l3y9lrn","_id":"cixb433c50001vsxlhshutx97"}],"PostTag":[{"post_id":"cix2l6brk0000c2xlfe4nxt7l","tag_id":"cix2l6brs0002c2xlkjhralkg","_id":"cix2l6brz0008c2xl5koa4iw5"},{"post_id":"cix2l6brk0000c2xlfe4nxt7l","tag_id":"cix2l6brx0003c2xl4mq6xsp7","_id":"cix2l6bs00009c2xls6g1koaf"},{"post_id":"cix2l6brk0000c2xlfe4nxt7l","tag_id":"cix2l6bry0004c2xlbo1rvuu2","_id":"cix2l6bs0000ac2xly2idzoc5"},{"post_id":"cix2l6brk0000c2xlfe4nxt7l","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6bs0000bc2xlk4evj9t8"},{"post_id":"cix2l6brk0000c2xlfe4nxt7l","tag_id":"cix2l6bry0006c2xlm8gllv7h","_id":"cix2l6bs0000cc2xlhywpyzhj"},{"post_id":"cix2l6bse000gc2xlqobyapd6","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6bsh000mc2xlzcpvuui2"},{"post_id":"cix2l6bse000gc2xlqobyapd6","tag_id":"cix2l6bsh000jc2xl80byapp7","_id":"cix2l6bsi000nc2xllmuvpcz8"},{"post_id":"cix2l6bse000gc2xlqobyapd6","tag_id":"cix2l6bsh000kc2xlm1grmv1m","_id":"cix2l6bsi000oc2xlfvx53msf"},{"post_id":"cix2l6bse000gc2xlqobyapd6","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6bsi000pc2xl1tqie9yd"},{"post_id":"cix2l6bsm000qc2xlna0eomn7","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6bst000wc2xlepirgwl8"},{"post_id":"cix2l6bsm000qc2xlna0eomn7","tag_id":"cix2l6bsh000jc2xl80byapp7","_id":"cix2l6bsw000xc2xlsjoi1fdr"},{"post_id":"cix2l6bsm000qc2xlna0eomn7","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6bsw000yc2xlxlib9exe"},{"post_id":"cix2l6bsm000qc2xlna0eomn7","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6bsw000zc2xlwra6tp18"},{"post_id":"cix2l6bsm000qc2xlna0eomn7","tag_id":"cix2l6bsr000uc2xlhetrx95o","_id":"cix2l6bsw0010c2xl1vanccfu"},{"post_id":"cix2l6bsm000qc2xlna0eomn7","tag_id":"cix2l6bst000vc2xl1kukczvd","_id":"cix2l6bsw0011c2xlkj7ga9mr"},{"post_id":"cix2l6bt00012c2xlt1rs3zv1","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6bt20015c2xl2sl60rsq"},{"post_id":"cix2l6bt00012c2xlt1rs3zv1","tag_id":"cix2l6bsh000jc2xl80byapp7","_id":"cix2l6bt30016c2xldjfuv915"},{"post_id":"cix2l6bt00012c2xlt1rs3zv1","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6bt30017c2xlhsn1yshx"},{"post_id":"cix2l6bt00012c2xlt1rs3zv1","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6bt30018c2xl5ngxm8ny"},{"post_id":"cix2l6bt00012c2xlt1rs3zv1","tag_id":"cix2l6bt20014c2xlf6zchc9m","_id":"cix2l6bt40019c2xl1jybi4wm"},{"post_id":"cix2l6bt6001ac2xlgj1u2cir","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6bta001dc2xlphrg439t"},{"post_id":"cix2l6bt6001ac2xlgj1u2cir","tag_id":"cix2l6bsh000jc2xl80byapp7","_id":"cix2l6btb001ec2xletwznzpv"},{"post_id":"cix2l6bt6001ac2xlgj1u2cir","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6btb001fc2xlww3h6dqx"},{"post_id":"cix2l6btc001gc2xl29n5zsfs","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6bte001jc2xlggdo4qnf"},{"post_id":"cix2l6btc001gc2xl29n5zsfs","tag_id":"cix2l6bsh000jc2xl80byapp7","_id":"cix2l6btf001kc2xlqso4gecz"},{"post_id":"cix2l6btc001gc2xl29n5zsfs","tag_id":"cix2l6bte001ic2xld1gajghb","_id":"cix2l6btf001lc2xlgp36qber"},{"post_id":"cix2l6bth001mc2xl8pg2lfsl","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6btl001rc2xlcccqees4"},{"post_id":"cix2l6bth001mc2xl8pg2lfsl","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6btl001sc2xl50pb12gx"},{"post_id":"cix2l6bth001mc2xl8pg2lfsl","tag_id":"cix2l6bsh000jc2xl80byapp7","_id":"cix2l6btm001tc2xlm98v73ag"},{"post_id":"cix2l6bth001mc2xl8pg2lfsl","tag_id":"cix2l6btk001pc2xlq2nvh5we","_id":"cix2l6btm001uc2xly62sss5t"},{"post_id":"cix2l6bth001mc2xl8pg2lfsl","tag_id":"cix2l6btl001qc2xlzz6m02ox","_id":"cix2l6btm001vc2xl07vhbvo9"},{"post_id":"cix2l6bth001mc2xl8pg2lfsl","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6btm001wc2xldi5m1q9n"},{"post_id":"cix2l6bto001xc2xlmookj6g2","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6btr0021c2xlstw28wlx"},{"post_id":"cix2l6bto001xc2xlmookj6g2","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6btr0022c2xlo6ki72ey"},{"post_id":"cix2l6bto001xc2xlmookj6g2","tag_id":"cix2l6bsh000jc2xl80byapp7","_id":"cix2l6btr0023c2xln6t7kqtk"},{"post_id":"cix2l6bto001xc2xlmookj6g2","tag_id":"cix2l6btq001zc2xl1xyp27mz","_id":"cix2l6btr0024c2xlr603jzuf"},{"post_id":"cix2l6bto001xc2xlmookj6g2","tag_id":"cix2l6btq0020c2xlllnmvl4u","_id":"cix2l6btr0025c2xlz4otpkf1"},{"post_id":"cix2l6bto001xc2xlmookj6g2","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6btr0026c2xlwzxtlzsu"},{"post_id":"cix2l6btt0027c2xlndsrl4r5","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6btx002cc2xlmrvu2h5w"},{"post_id":"cix2l6btt0027c2xlndsrl4r5","tag_id":"cix2l6bsh000jc2xl80byapp7","_id":"cix2l6btx002dc2xld3iqiqzq"},{"post_id":"cix2l6btt0027c2xlndsrl4r5","tag_id":"cix2l6btw0029c2xlus1ynht7","_id":"cix2l6btx002ec2xl91bomkc1"},{"post_id":"cix2l6btt0027c2xlndsrl4r5","tag_id":"cix2l6btx002ac2xls5nn914i","_id":"cix2l6bty002fc2xl9kcqdwnj"},{"post_id":"cix2l6btt0027c2xlndsrl4r5","tag_id":"cix2l6btx002bc2xlii39i8qq","_id":"cix2l6bty002gc2xla9acxtkc"},{"post_id":"cix2l6btt0027c2xlndsrl4r5","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6bty002hc2xlo164wspd"},{"post_id":"cix2l6btz002ic2xlzpejtfyv","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6bu2002lc2xlfj23vblb"},{"post_id":"cix2l6btz002ic2xlzpejtfyv","tag_id":"cix2l6bsh000jc2xl80byapp7","_id":"cix2l6bu2002mc2xlupe4zudb"},{"post_id":"cix2l6btz002ic2xlzpejtfyv","tag_id":"cix2l6bu1002kc2xlpyrkma70","_id":"cix2l6bu2002nc2xlgjjv4wf1"},{"post_id":"cix2l6bu4002oc2xlq9cdw8vy","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6bu6002rc2xl8z6wt2e6"},{"post_id":"cix2l6bu4002oc2xlq9cdw8vy","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6bu7002sc2xleidb4v5w"},{"post_id":"cix2l6bu4002oc2xlq9cdw8vy","tag_id":"cix2l6bsh000jc2xl80byapp7","_id":"cix2l6bu7002tc2xlz4kk7t8w"},{"post_id":"cix2l6bu4002oc2xlq9cdw8vy","tag_id":"cix2l6bu6002qc2xl8k4xwvuw","_id":"cix2l6bu7002uc2xlyy2j793f"},{"post_id":"cix2l6bu4002oc2xlq9cdw8vy","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6bu8002vc2xlb7fb9qkk"},{"post_id":"cix2l6bu9002wc2xlllzj716i","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6buc002zc2xlsgl935f1"},{"post_id":"cix2l6bu9002wc2xlllzj716i","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6bud0030c2xls1ze6qdp"},{"post_id":"cix2l6bu9002wc2xlllzj716i","tag_id":"cix2l6bsh000jc2xl80byapp7","_id":"cix2l6bud0031c2xl5ogvmijh"},{"post_id":"cix2l6bu9002wc2xlllzj716i","tag_id":"cix2l6bub002yc2xlx0vn80a9","_id":"cix2l6bud0032c2xlmke2axjm"},{"post_id":"cix2l6bu9002wc2xlllzj716i","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6bud0033c2xlioxsv3oo"},{"post_id":"cix2l6bue0034c2xl1ourfi98","tag_id":"cix2l6buf0036c2xl9e1mzymh","_id":"cix2l6bui003dc2xlkcb3u98o"},{"post_id":"cix2l6bue0034c2xl1ourfi98","tag_id":"cix2l6bug0037c2xlpfgfsh0i","_id":"cix2l6bui003ec2xlkjutr15u"},{"post_id":"cix2l6bue0034c2xl1ourfi98","tag_id":"cix2l6bug0038c2xlqtc61ja0","_id":"cix2l6bui003fc2xlybbzlxt3"},{"post_id":"cix2l6bue0034c2xl1ourfi98","tag_id":"cix2l6bug0039c2xlmf6x273a","_id":"cix2l6bui003gc2xlfr7jxlnd"},{"post_id":"cix2l6bue0034c2xl1ourfi98","tag_id":"cix2l6bug003ac2xlqigs1bh1","_id":"cix2l6bui003hc2xlvdpj1av9"},{"post_id":"cix2l6bue0034c2xl1ourfi98","tag_id":"cix2l6buh003bc2xlaft5jc5z","_id":"cix2l6bui003ic2xls5bpgsy1"},{"post_id":"cix2l6bvb003jc2xl99n86m4q","tag_id":"cix2l6bvc003lc2xlj5v9rb9j","_id":"cix2l6bve003oc2xlkekaf58d"},{"post_id":"cix2l6bvb003jc2xl99n86m4q","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6bvf003pc2xllixmfwx3"},{"post_id":"cix2l6bvb003jc2xl99n86m4q","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6bvf003qc2xl3ubjuowe"},{"post_id":"cix2l6bvb003jc2xl99n86m4q","tag_id":"cix2l6bvc003mc2xlzsn1jrh3","_id":"cix2l6bvf003rc2xlt6izanke"},{"post_id":"cix2l6bvb003jc2xl99n86m4q","tag_id":"cix2l6bvd003nc2xlzttr1jkp","_id":"cix2l6bvf003sc2xlvlu6mntj"},{"post_id":"cix2l6bvg003tc2xlxq8umis0","tag_id":"cix2l6bvc003lc2xlj5v9rb9j","_id":"cix2l6bvi003xc2xle725nmo5"},{"post_id":"cix2l6bvg003tc2xlxq8umis0","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6bvi003yc2xl5n8uva82"},{"post_id":"cix2l6bvg003tc2xlxq8umis0","tag_id":"cix2l6bvh003vc2xlhv94n7t9","_id":"cix2l6bvi003zc2xlxqx4vat0"},{"post_id":"cix2l6bvg003tc2xlxq8umis0","tag_id":"cix2l6bvi003wc2xl9jvtord9","_id":"cix2l6bvi0040c2xlfmmalt79"},{"post_id":"cix2l6bvk0041c2xl9qn1uwdf","tag_id":"cix2l6bvc003lc2xlj5v9rb9j","_id":"cix2l6bvn0043c2xlfwx6qy3b"},{"post_id":"cix2l6bvk0041c2xl9qn1uwdf","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6bvn0044c2xljxyh63ea"},{"post_id":"cix2l6bvk0041c2xl9qn1uwdf","tag_id":"cix2l6bvh003vc2xlhv94n7t9","_id":"cix2l6bvn0045c2xle2vm1pxq"},{"post_id":"cix2l6bvk0041c2xl9qn1uwdf","tag_id":"cix2l6bvd003nc2xlzttr1jkp","_id":"cix2l6bvn0046c2xl23ckkq8g"},{"post_id":"cix2l6bvx0047c2xlb4wcbgaw","tag_id":"cix2l6bvc003lc2xlj5v9rb9j","_id":"cix2l6bw1004bc2xl69fsiz0m"},{"post_id":"cix2l6bvx0047c2xlb4wcbgaw","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6bw1004cc2xl7orjrko9"},{"post_id":"cix2l6bvx0047c2xlb4wcbgaw","tag_id":"cix2l6bvz0049c2xle6e8llpz","_id":"cix2l6bw1004dc2xlxs071pvq"},{"post_id":"cix2l6bvx0047c2xlb4wcbgaw","tag_id":"cix2l6bw0004ac2xl40e50m9d","_id":"cix2l6bw2004ec2xlcgjh23lp"},{"post_id":"cix2l6bw3004fc2xlhnehj6fi","tag_id":"cix2l6bvc003lc2xlj5v9rb9j","_id":"cix2l6bw5004ic2xl35pb4pgd"},{"post_id":"cix2l6bw3004fc2xlhnehj6fi","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6bw6004jc2xls88qo4b0"},{"post_id":"cix2l6bw3004fc2xlhnehj6fi","tag_id":"cix2l6bvz0049c2xle6e8llpz","_id":"cix2l6bw6004kc2xlwhp236zj"},{"post_id":"cix2l6bw3004fc2xlhnehj6fi","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6bw6004lc2xljaizcp4l"},{"post_id":"cix2l6bw3004fc2xlhnehj6fi","tag_id":"cix2l6bw5004hc2xliqrfp4kr","_id":"cix2l6bw6004mc2xli1k7lz0v"},{"post_id":"cix2l6bw7004nc2xlooynpv96","tag_id":"cix2l6bvc003lc2xlj5v9rb9j","_id":"cix2l6bwb004sc2xlwubjgij2"},{"post_id":"cix2l6bw7004nc2xlooynpv96","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6bwc004tc2xl2ibg8y82"},{"post_id":"cix2l6bw7004nc2xlooynpv96","tag_id":"cix2l6bwa004pc2xlfep7re8c","_id":"cix2l6bwc004uc2xl46afed6t"},{"post_id":"cix2l6bw7004nc2xlooynpv96","tag_id":"cix2l6bvz0049c2xle6e8llpz","_id":"cix2l6bwc004vc2xl00gkpsns"},{"post_id":"cix2l6bw7004nc2xlooynpv96","tag_id":"cix2l6bvd003nc2xlzttr1jkp","_id":"cix2l6bwc004wc2xlh06exwho"},{"post_id":"cix2l6bw7004nc2xlooynpv96","tag_id":"cix2l6bwa004qc2xlqnw3w3ri","_id":"cix2l6bwc004xc2xlabiqwuzr"},{"post_id":"cix2l6bw7004nc2xlooynpv96","tag_id":"cix2l6bwb004rc2xl2ocoadp0","_id":"cix2l6bwc004yc2xl8sc6zx2r"},{"post_id":"cix2l6bwd004zc2xlezvta4ib","tag_id":"cix2l6bvc003lc2xlj5v9rb9j","_id":"cix2l6bwf0052c2xlqybvdw2p"},{"post_id":"cix2l6bwd004zc2xlezvta4ib","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6bwg0053c2xlbe1ht13w"},{"post_id":"cix2l6bwd004zc2xlezvta4ib","tag_id":"cix2l6bvz0049c2xle6e8llpz","_id":"cix2l6bwg0054c2xlod390wtj"},{"post_id":"cix2l6bwd004zc2xlezvta4ib","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6bwg0055c2xlri3gb3wm"},{"post_id":"cix2l6bwd004zc2xlezvta4ib","tag_id":"cix2l6bwe0051c2xllpdw4hf2","_id":"cix2l6bwg0056c2xlr691j7i6"},{"post_id":"cix2l6bwg0057c2xlf1vl8ful","tag_id":"cix2l6bvc003lc2xlj5v9rb9j","_id":"cix2l6bwj005ac2xls2nsp7lv"},{"post_id":"cix2l6bwg0057c2xlf1vl8ful","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6bwk005bc2xlghqbxj62"},{"post_id":"cix2l6bwg0057c2xlf1vl8ful","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6bwk005cc2xl8fqfsq4g"},{"post_id":"cix2l6bwg0057c2xlf1vl8ful","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6bwk005dc2xlbrpdt1m8"},{"post_id":"cix2l6bwg0057c2xlf1vl8ful","tag_id":"cix2l6bwj0059c2xlp2z4w5xl","_id":"cix2l6bwk005ec2xlv1tm5lud"},{"post_id":"cix2l6bwl005fc2xl4445crj9","tag_id":"cix2l6bvc003lc2xlj5v9rb9j","_id":"cix2l6bwp005kc2xlp3avkriq"},{"post_id":"cix2l6bwl005fc2xl4445crj9","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6bwp005lc2xlfrzxjncm"},{"post_id":"cix2l6bwl005fc2xl4445crj9","tag_id":"cix2l6bvz0049c2xle6e8llpz","_id":"cix2l6bwp005mc2xlotzhdy3j"},{"post_id":"cix2l6bwl005fc2xl4445crj9","tag_id":"cix2l6bvd003nc2xlzttr1jkp","_id":"cix2l6bwq005nc2xlg3qb5rti"},{"post_id":"cix2l6bwl005fc2xl4445crj9","tag_id":"cix2l6bwn005hc2xl3hpoko78","_id":"cix2l6bwq005oc2xl02rjtdbp"},{"post_id":"cix2l6bwl005fc2xl4445crj9","tag_id":"cix2l6bwo005ic2xl8p6ir184","_id":"cix2l6bwq005pc2xluhej6r39"},{"post_id":"cix2l6bwl005fc2xl4445crj9","tag_id":"cix2l6bwo005jc2xlf9qo92q5","_id":"cix2l6bwq005qc2xli2ejxyx9"},{"post_id":"cix2l6bws005rc2xlo2896nrc","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6bww005wc2xl57anwl4o"},{"post_id":"cix2l6bws005rc2xlo2896nrc","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6bww005xc2xleuk09f67"},{"post_id":"cix2l6bws005rc2xlo2896nrc","tag_id":"cix2l6bwv005uc2xlcab5p7ag","_id":"cix2l6bww005yc2xlfjbr69dc"},{"post_id":"cix2l6bws005rc2xlo2896nrc","tag_id":"cix2l6bwv005vc2xl62lmb5wk","_id":"cix2l6bww005zc2xlojjscygx"},{"post_id":"cix2l6bwx0060c2xlw6q2naa2","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6bwz0064c2xld5j6pnyq"},{"post_id":"cix2l6bwx0060c2xlw6q2naa2","tag_id":"cix2l6bwy0062c2xlihgiezyj","_id":"cix2l6bwz0065c2xlousyxvkm"},{"post_id":"cix2l6bwx0060c2xlw6q2naa2","tag_id":"cix2l6bwz0063c2xlh8ly3fo3","_id":"cix2l6bwz0066c2xlj37easkt"},{"post_id":"cix2l6bwx0060c2xlw6q2naa2","tag_id":"cix2l6bub002yc2xlx0vn80a9","_id":"cix2l6bx00067c2xlaca5zwg7"},{"post_id":"cix2l6bx10068c2xl0hniccz4","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6bx4006cc2xlzv3wcmq2"},{"post_id":"cix2l6bx10068c2xl0hniccz4","tag_id":"cix2l6bwy0062c2xlihgiezyj","_id":"cix2l6bx4006dc2xlo1mdtfne"},{"post_id":"cix2l6bx10068c2xl0hniccz4","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6bx4006ec2xl9psz804j"},{"post_id":"cix2l6bx10068c2xl0hniccz4","tag_id":"cix2l6bx3006bc2xlhxm1aa0p","_id":"cix2l6bx4006fc2xlq49hb9y5"},{"post_id":"cix2l6bx5006gc2xlw3kpv4jw","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6bxa006lc2xlji2ub6a7"},{"post_id":"cix2l6bx5006gc2xlw3kpv4jw","tag_id":"cix2l6bwy0062c2xlihgiezyj","_id":"cix2l6bxa006mc2xlq1ef5e9r"},{"post_id":"cix2l6bx5006gc2xlw3kpv4jw","tag_id":"cix2l6bx8006ic2xlanfcs0th","_id":"cix2l6bxa006nc2xlj07eimby"},{"post_id":"cix2l6bx5006gc2xlw3kpv4jw","tag_id":"cix2l6bx9006jc2xl21zjnyx6","_id":"cix2l6bxa006oc2xlb6v8d1jc"},{"post_id":"cix2l6bx5006gc2xlw3kpv4jw","tag_id":"cix2l6bx9006kc2xl8ligd8yv","_id":"cix2l6bxa006pc2xlkvt5rn43"},{"post_id":"cix2l6bxb006qc2xl3n527i9r","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6bxe006wc2xluiary6ez"},{"post_id":"cix2l6bxb006qc2xl3n527i9r","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6bxf006xc2xlqnqdn9zl"},{"post_id":"cix2l6bxb006qc2xl3n527i9r","tag_id":"cix2l6bxe006uc2xlqk5geg3s","_id":"cix2l6bxf006yc2xl3dhokrsl"},{"post_id":"cix2l6bxb006qc2xl3n527i9r","tag_id":"cix2l6btx002ac2xls5nn914i","_id":"cix2l6bxf006zc2xlsn3n1u3x"},{"post_id":"cix2l6bxb006qc2xl3n527i9r","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6bxf0070c2xlago8foq2"},{"post_id":"cix2l6bxg0071c2xlyuso9bu9","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6bxi0074c2xl6p0rsvvj"},{"post_id":"cix2l6bxg0071c2xlyuso9bu9","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6bxj0075c2xlmc45mg3w"},{"post_id":"cix2l6bxg0071c2xlyuso9bu9","tag_id":"cix2l6bxh0073c2xlzrgyofi2","_id":"cix2l6bxj0076c2xl5d3t2y6h"},{"post_id":"cix2l6bxg0071c2xlyuso9bu9","tag_id":"cix2l6btx002ac2xls5nn914i","_id":"cix2l6bxj0077c2xlx5nwolwp"},{"post_id":"cix2l6bxg0071c2xlyuso9bu9","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6bxj0078c2xlrxuw2rlq"},{"post_id":"cix2l6bxj0079c2xlkqk26ysx","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6bxl007cc2xlew2523j1"},{"post_id":"cix2l6bxj0079c2xlkqk26ysx","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6bxm007dc2xlv6tp7gyu"},{"post_id":"cix2l6bxj0079c2xlkqk26ysx","tag_id":"cix2l6bxl007bc2xlnhqu19fi","_id":"cix2l6bxm007ec2xld3xktdz0"},{"post_id":"cix2l6bxj0079c2xlkqk26ysx","tag_id":"cix2l6bu6002qc2xl8k4xwvuw","_id":"cix2l6bxm007fc2xlpftuholc"},{"post_id":"cix2l6bxj0079c2xlkqk26ysx","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6bxm007gc2xlxmldfdxp"},{"post_id":"cix2l6bxn007hc2xlvkjf70g7","tag_id":"cix2l6bxo007jc2xlkcrgnf1u","_id":"cix2l6bxp007lc2xlhx8susme"},{"post_id":"cix2l6bxn007hc2xlvkjf70g7","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6bxq007mc2xllb2p1esj"},{"post_id":"cix2l6bxn007hc2xlvkjf70g7","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6bxq007nc2xltcbcjexy"},{"post_id":"cix2l6bxn007hc2xlvkjf70g7","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6bxq007oc2xll0qsk9lb"},{"post_id":"cix2l6bxn007hc2xlvkjf70g7","tag_id":"cix2l6bxp007kc2xl8rge6ieh","_id":"cix2l6bxq007pc2xltv5opz0g"},{"post_id":"cix2l6bxr007qc2xl5tc05r1b","tag_id":"cix2l6bxt007sc2xlghh13692","_id":"cix2l6bxv007uc2xlrlx55q4p"},{"post_id":"cix2l6bxr007qc2xl5tc05r1b","tag_id":"cix2l6bxt007tc2xlta9yvqhe","_id":"cix2l6bxw007vc2xl56sn4pyy"},{"post_id":"cix2l6bxy007wc2xlbfr6msqp","tag_id":"cix2l6bxz007yc2xloq7888ej","_id":"cix2l6by0007zc2xl1ao0t4g6"},{"post_id":"cix2l6bxy007wc2xlbfr6msqp","tag_id":"cix2l6bxo007jc2xlkcrgnf1u","_id":"cix2l6by00080c2xlxxyjb699"},{"post_id":"cix2l6bxy007wc2xlbfr6msqp","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6by00081c2xlobc270ru"},{"post_id":"cix2l6by10082c2xlwm1twirx","tag_id":"cix2l6bx9006jc2xl21zjnyx6","_id":"cix2l6by30084c2xlx4yeufc9"},{"post_id":"cix2l6by10082c2xlwm1twirx","tag_id":"cix2l6bry0006c2xlm8gllv7h","_id":"cix2l6by40085c2xlmxr4th7z"},{"post_id":"cix2l6by10082c2xlwm1twirx","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6by40086c2xlqybgwq6o"},{"post_id":"cix2l6by10082c2xlwm1twirx","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6by40087c2xlp5hgvevw"},{"post_id":"cix2l6byh0088c2xl22ay970e","tag_id":"cix2l6bx9006jc2xl21zjnyx6","_id":"cix2l6byk008ac2xli8j6lp5y"},{"post_id":"cix2l6byh0088c2xl22ay970e","tag_id":"cix2l6bry0006c2xlm8gllv7h","_id":"cix2l6byl008bc2xljcyb7oeq"},{"post_id":"cix2l6byh0088c2xl22ay970e","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6byl008cc2xlyzqr0qq1"},{"post_id":"cix2l6byh0088c2xl22ay970e","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6bym008dc2xl4unxrdnv"},{"post_id":"cix2l6byn008ec2xlcm86l0z4","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6byo008gc2xlsyrg5ve1"},{"post_id":"cix2l6byn008ec2xlcm86l0z4","tag_id":"cix2l6bx9006jc2xl21zjnyx6","_id":"cix2l6byp008hc2xlix66v94w"},{"post_id":"cix2l6byn008ec2xlcm86l0z4","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6byp008ic2xlzpycc9vq"},{"post_id":"cix2l6byn008ec2xlcm86l0z4","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6byp008jc2xlhfie5f5y"},{"post_id":"cix2l6byn008ec2xlcm86l0z4","tag_id":"cix2l6bry0006c2xlm8gllv7h","_id":"cix2l6byp008kc2xljqqhyjwp"},{"post_id":"cix2l6byq008lc2xlii69cjiz","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6bys008nc2xl0wx2omcw"},{"post_id":"cix2l6byq008lc2xlii69cjiz","tag_id":"cix2l6bx9006jc2xl21zjnyx6","_id":"cix2l6byt008oc2xl1txbzd62"},{"post_id":"cix2l6byq008lc2xlii69cjiz","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6byt008pc2xlqvbg44ts"},{"post_id":"cix2l6byq008lc2xlii69cjiz","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6byt008qc2xl5tnvwf9d"},{"post_id":"cix2l6byq008lc2xlii69cjiz","tag_id":"cix2l6bry0006c2xlm8gllv7h","_id":"cix2l6byt008rc2xltkxmxk2v"},{"post_id":"cix2l6byw008sc2xlihfle7ic","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6byz008vc2xlsp136427"},{"post_id":"cix2l6byw008sc2xlihfle7ic","tag_id":"cix2l6byy008uc2xlhu86f9mq","_id":"cix2l6byz008wc2xl4khd0h21"},{"post_id":"cix2l6byw008sc2xlihfle7ic","tag_id":"cix2l6bry0004c2xlbo1rvuu2","_id":"cix2l6byz008xc2xlcgmz9trn"},{"post_id":"cix2l6bz0008yc2xl5ned3wmd","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6bz20091c2xlomuu1jde"},{"post_id":"cix2l6bz0008yc2xl5ned3wmd","tag_id":"cix2l6byy008uc2xlhu86f9mq","_id":"cix2l6bz30092c2xlowo6ahhz"},{"post_id":"cix2l6bz0008yc2xl5ned3wmd","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6bz30093c2xl8fgi0cc3"},{"post_id":"cix2l6bz0008yc2xl5ned3wmd","tag_id":"cix2l6bz10090c2xlbwvetl3j","_id":"cix2l6bz30094c2xlzxnqo4m4"},{"post_id":"cix2l6bz30095c2xlfqney5g0","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6bz50097c2xlg0zh7s3z"},{"post_id":"cix2l6bz30095c2xlfqney5g0","tag_id":"cix2l6byy008uc2xlhu86f9mq","_id":"cix2l6bz60098c2xltgvy0bj8"},{"post_id":"cix2l6bz30095c2xlfqney5g0","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6bz60099c2xl06chgl30"},{"post_id":"cix2l6bz7009ac2xlytb1inkm","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6bz8009cc2xljsxzc2ko"},{"post_id":"cix2l6bz7009ac2xlytb1inkm","tag_id":"cix2l6byy008uc2xlhu86f9mq","_id":"cix2l6bz9009dc2xll877tlbx"},{"post_id":"cix2l6bz7009ac2xlytb1inkm","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6bz9009ec2xl1upgkzg7"},{"post_id":"cix2l6bza009fc2xlq7y3j4dd","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6bzd009ic2xlt39ck70g"},{"post_id":"cix2l6bza009fc2xlq7y3j4dd","tag_id":"cix2l6byy008uc2xlhu86f9mq","_id":"cix2l6bzd009jc2xl7hx8dp9o"},{"post_id":"cix2l6bza009fc2xlq7y3j4dd","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6bze009kc2xlova8py7c"},{"post_id":"cix2l6bza009fc2xlq7y3j4dd","tag_id":"cix2l6bzc009hc2xlus0k8tgu","_id":"cix2l6bze009lc2xlp8mvle6a"},{"post_id":"cix2l6bza009fc2xlq7y3j4dd","tag_id":"cix2l6btx002ac2xls5nn914i","_id":"cix2l6bze009mc2xlr4tq3nkj"},{"post_id":"cix2l6bzf009nc2xl1qv01htn","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6bzh009pc2xlqk9eab5l"},{"post_id":"cix2l6bzf009nc2xl1qv01htn","tag_id":"cix2l6byy008uc2xlhu86f9mq","_id":"cix2l6bzi009qc2xljt8xe5z2"},{"post_id":"cix2l6bzf009nc2xl1qv01htn","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6bzi009rc2xlhw2r2v9u"},{"post_id":"cix2l6bzf009nc2xl1qv01htn","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6bzi009sc2xl2e94xidm"},{"post_id":"cix2l6bzf009nc2xl1qv01htn","tag_id":"cix2l6bt20014c2xlf6zchc9m","_id":"cix2l6bzi009tc2xlmgd3hn5c"},{"post_id":"cix2l6bzj009uc2xlzsl9e2y3","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6bzm009yc2xlqsgibw1p"},{"post_id":"cix2l6bzj009uc2xlzsl9e2y3","tag_id":"cix2l6byy008uc2xlhu86f9mq","_id":"cix2l6bzm009zc2xl56cd6jdm"},{"post_id":"cix2l6bzj009uc2xlzsl9e2y3","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6bzn00a0c2xlk6cjdrhz"},{"post_id":"cix2l6bzj009uc2xlzsl9e2y3","tag_id":"cix2l6bzl009wc2xlvxagmmjn","_id":"cix2l6bzn00a1c2xl86tv5ys9"},{"post_id":"cix2l6bzj009uc2xlzsl9e2y3","tag_id":"cix2l6bx9006kc2xl8ligd8yv","_id":"cix2l6bzn00a2c2xlm5qzrwnz"},{"post_id":"cix2l6bzj009uc2xlzsl9e2y3","tag_id":"cix2l6bzl009xc2xleyxetgjg","_id":"cix2l6bzn00a3c2xlrwpmjz4u"},{"post_id":"cix2l6bzn00a4c2xl7y3lfduh","tag_id":"cix2l6bzp00a6c2xlunj1vv5y","_id":"cix2l6bzs00aac2xlmlmkog9y"},{"post_id":"cix2l6bzn00a4c2xl7y3lfduh","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6bzs00abc2xlc14jvp8d"},{"post_id":"cix2l6bzn00a4c2xl7y3lfduh","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6bzs00acc2xl1qacx62h"},{"post_id":"cix2l6bzn00a4c2xl7y3lfduh","tag_id":"cix2l6bzq00a7c2xl0plzunvi","_id":"cix2l6bzs00adc2xlogx0id89"},{"post_id":"cix2l6bzn00a4c2xl7y3lfduh","tag_id":"cix2l6bzr00a8c2xl9tmid8wv","_id":"cix2l6bzs00aec2xlwntauy9t"},{"post_id":"cix2l6bzn00a4c2xl7y3lfduh","tag_id":"cix2l6bzr00a9c2xluebmxms0","_id":"cix2l6bzs00afc2xlo7u2m8w1"},{"post_id":"cix2l6bzx00ajc2xlml35kc7l","tag_id":"cix2l6bzp00a6c2xlunj1vv5y","_id":"cix2l6c0200amc2xlj0spnu33"},{"post_id":"cix2l6bzx00ajc2xlml35kc7l","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6c0300anc2xlvn47p3ot"},{"post_id":"cix2l6bzx00ajc2xlml35kc7l","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c0300aoc2xl21de88rq"},{"post_id":"cix2l6bzx00ajc2xlml35kc7l","tag_id":"cix2l6bvh003vc2xlhv94n7t9","_id":"cix2l6c0300apc2xl9xr8yazr"},{"post_id":"cix2l6bzx00ajc2xlml35kc7l","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6c0300aqc2xlazjm75yo"},{"post_id":"cix2l6bzx00ajc2xlml35kc7l","tag_id":"cix2l6c0000alc2xl6bt8foyz","_id":"cix2l6c0300arc2xloafyhwcu"},{"post_id":"cix2l6bzx00ajc2xlml35kc7l","tag_id":"cix2l6bwn005hc2xl3hpoko78","_id":"cix2l6c0300asc2xlah25ldpb"},{"post_id":"cix2l6c0400atc2xlxateai4p","tag_id":"cix2l6bzp00a6c2xlunj1vv5y","_id":"cix2l6c0800ayc2xlecu54qw2"},{"post_id":"cix2l6c0400atc2xlxateai4p","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6c0900azc2xlty7c3fc5"},{"post_id":"cix2l6c0400atc2xlxateai4p","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c0900b0c2xl7j9nxxio"},{"post_id":"cix2l6c0400atc2xlxateai4p","tag_id":"cix2l6bst000vc2xl1kukczvd","_id":"cix2l6c0900b1c2xluqobtdc7"},{"post_id":"cix2l6c0400atc2xlxateai4p","tag_id":"cix2l6bwa004pc2xlfep7re8c","_id":"cix2l6c0900b2c2xlflcfggac"},{"post_id":"cix2l6c0400atc2xlxateai4p","tag_id":"cix2l6c0500avc2xlnjpnaec3","_id":"cix2l6c0900b3c2xlma04ufyq"},{"post_id":"cix2l6c0400atc2xlxateai4p","tag_id":"cix2l6c0600awc2xlaldzn55u","_id":"cix2l6c0900b4c2xlb22dc0sh"},{"post_id":"cix2l6c0400atc2xlxateai4p","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6c0900b5c2xlgg74kjyz"},{"post_id":"cix2l6c0400atc2xlxateai4p","tag_id":"cix2l6bsr000uc2xlhetrx95o","_id":"cix2l6c0900b6c2xl9aqcf67b"},{"post_id":"cix2l6c0400atc2xlxateai4p","tag_id":"cix2l6c0700axc2xlgxp3vaf5","_id":"cix2l6c0900b7c2xl2p9imbgf"},{"post_id":"cix2l6c0b00b8c2xlr2vz42nv","tag_id":"cix2l6bzp00a6c2xlunj1vv5y","_id":"cix2l6c0d00bac2xlctu6d1he"},{"post_id":"cix2l6c0b00b8c2xlr2vz42nv","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6c0e00bbc2xlavimhklx"},{"post_id":"cix2l6c0b00b8c2xlr2vz42nv","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c0e00bcc2xlpk1ho6pl"},{"post_id":"cix2l6c0b00b8c2xlr2vz42nv","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6c0e00bdc2xlnn5gen5q"},{"post_id":"cix2l6c0b00b8c2xlr2vz42nv","tag_id":"cix2l6btq001zc2xl1xyp27mz","_id":"cix2l6c0e00bec2xlqf7w87vp"},{"post_id":"cix2l6c0b00b8c2xlr2vz42nv","tag_id":"cix2l6btq0020c2xlllnmvl4u","_id":"cix2l6c0e00bfc2xlisgn4qiz"},{"post_id":"cix2l6c0f00bgc2xlirfamzo8","tag_id":"cix2l6bzp00a6c2xlunj1vv5y","_id":"cix2l6c0i00bjc2xl28cvq9kj"},{"post_id":"cix2l6c0f00bgc2xlirfamzo8","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6c0j00bkc2xl5uz39du7"},{"post_id":"cix2l6c0f00bgc2xlirfamzo8","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c0j00blc2xl3qlqxxzj"},{"post_id":"cix2l6c0f00bgc2xlirfamzo8","tag_id":"cix2l6bxo007jc2xlkcrgnf1u","_id":"cix2l6c0j00bmc2xlvlpumdwz"},{"post_id":"cix2l6c0f00bgc2xlirfamzo8","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6c0j00bnc2xllx04dy7n"},{"post_id":"cix2l6c0f00bgc2xlirfamzo8","tag_id":"cix2l6c0h00bic2xlug85j0rs","_id":"cix2l6c0j00boc2xljnpx6bcs"},{"post_id":"cix2l6c0k00bpc2xl1fk96gdo","tag_id":"cix2l6bzp00a6c2xlunj1vv5y","_id":"cix2l6c0m00bsc2xlccghpdr0"},{"post_id":"cix2l6c0k00bpc2xl1fk96gdo","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6c0n00btc2xlz5fwy62a"},{"post_id":"cix2l6c0k00bpc2xl1fk96gdo","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c0n00buc2xl20rffzdr"},{"post_id":"cix2l6c0k00bpc2xl1fk96gdo","tag_id":"cix2l6brx0003c2xl4mq6xsp7","_id":"cix2l6c0n00bvc2xldhgpnfyn"},{"post_id":"cix2l6c0k00bpc2xl1fk96gdo","tag_id":"cix2l6bry0004c2xlbo1rvuu2","_id":"cix2l6c0n00bwc2xl3nyhcre9"},{"post_id":"cix2l6c0k00bpc2xl1fk96gdo","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6c0n00bxc2xl01zkek5t"},{"post_id":"cix2l6c0k00bpc2xl1fk96gdo","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6c0n00byc2xlpvkrzno7"},{"post_id":"cix2l6c0k00bpc2xl1fk96gdo","tag_id":"cix2l6c0l00brc2xlrz9vwge8","_id":"cix2l6c0o00bzc2xlcpdtw7rj"},{"post_id":"cix2l6c0t00c0c2xl4nsx8oc0","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c0v00c3c2xlohawjdvx"},{"post_id":"cix2l6c0t00c0c2xl4nsx8oc0","tag_id":"cix2l6bzp00a6c2xlunj1vv5y","_id":"cix2l6c0w00c4c2xlppnm2a92"},{"post_id":"cix2l6c0t00c0c2xl4nsx8oc0","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6c0x00c5c2xl6qygtkbe"},{"post_id":"cix2l6c0t00c0c2xl4nsx8oc0","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6c0x00c6c2xl0mpwbfoo"},{"post_id":"cix2l6c0t00c0c2xl4nsx8oc0","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6c0x00c7c2xlxsl02mca"},{"post_id":"cix2l6c0t00c0c2xl4nsx8oc0","tag_id":"cix2l6c0700axc2xlgxp3vaf5","_id":"cix2l6c0x00c8c2xlruf9rad0"},{"post_id":"cix2l6c0t00c0c2xl4nsx8oc0","tag_id":"cix2l6c0v00c2c2xl8pxn33ts","_id":"cix2l6c0x00c9c2xlm8xtjiz0"},{"post_id":"cix2l6c0x00cac2xle8ywib7a","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c1200cgc2xlyyuyqdnh"},{"post_id":"cix2l6c0x00cac2xle8ywib7a","tag_id":"cix2l6bzp00a6c2xlunj1vv5y","_id":"cix2l6c1300chc2xlu34f26ka"},{"post_id":"cix2l6c0x00cac2xle8ywib7a","tag_id":"cix2l6bsh000kc2xlm1grmv1m","_id":"cix2l6c1300cic2xle12u6d1q"},{"post_id":"cix2l6c0x00cac2xle8ywib7a","tag_id":"cix2l6c1000ccc2xl32nvuu2i","_id":"cix2l6c1400cjc2xlbcsp1bza"},{"post_id":"cix2l6c0x00cac2xle8ywib7a","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6c1400ckc2xlfyd8yp72"},{"post_id":"cix2l6c0x00cac2xle8ywib7a","tag_id":"cix2l6c1100cdc2xlzs83aivv","_id":"cix2l6c1400clc2xlvuf3yjza"},{"post_id":"cix2l6c0x00cac2xle8ywib7a","tag_id":"cix2l6c1100cec2xln5pdkz26","_id":"cix2l6c1400cmc2xl0puu266x"},{"post_id":"cix2l6c0x00cac2xle8ywib7a","tag_id":"cix2l6c1100cfc2xlukvyrt3z","_id":"cix2l6c1400cnc2xlhwz6ugga"},{"post_id":"cix2l6c1500coc2xlua0rrkkv","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c1800cqc2xlq7dpuzeh"},{"post_id":"cix2l6c1500coc2xlua0rrkkv","tag_id":"cix2l6bzp00a6c2xlunj1vv5y","_id":"cix2l6c1900crc2xlbd2enju3"},{"post_id":"cix2l6c1500coc2xlua0rrkkv","tag_id":"cix2l6brx0003c2xl4mq6xsp7","_id":"cix2l6c1900csc2xlhjd9grau"},{"post_id":"cix2l6c1500coc2xlua0rrkkv","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6c1900ctc2xlk33hnj1o"},{"post_id":"cix2l6c1a00cuc2xlsd79jq5o","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c1m00czc2xlu5984re5"},{"post_id":"cix2l6c1a00cuc2xlsd79jq5o","tag_id":"cix2l6bzp00a6c2xlunj1vv5y","_id":"cix2l6c1n00d0c2xl22v9gakc"},{"post_id":"cix2l6c1a00cuc2xlsd79jq5o","tag_id":"cix2l6c1k00cwc2xltzt3umv8","_id":"cix2l6c1n00d1c2xllw63dpqg"},{"post_id":"cix2l6c1a00cuc2xlsd79jq5o","tag_id":"cix2l6c1l00cxc2xljmq6rska","_id":"cix2l6c1n00d2c2xli67h1b0j"},{"post_id":"cix2l6c1a00cuc2xlsd79jq5o","tag_id":"cix2l6c1l00cyc2xly6uvavyj","_id":"cix2l6c1n00d3c2xl9a0ps8r2"},{"post_id":"cix2l6c1a00cuc2xlsd79jq5o","tag_id":"cix2l6c0l00brc2xlrz9vwge8","_id":"cix2l6c1n00d4c2xlf3c86t93"},{"post_id":"cix2l6c1o00d5c2xl0hilvwi2","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c1r00d9c2xlr8lqdoo8"},{"post_id":"cix2l6c1o00d5c2xl0hilvwi2","tag_id":"cix2l6bzp00a6c2xlunj1vv5y","_id":"cix2l6c1s00dac2xltf5q0pcg"},{"post_id":"cix2l6c1o00d5c2xl0hilvwi2","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6c1s00dbc2xl15ulqud6"},{"post_id":"cix2l6c1o00d5c2xl0hilvwi2","tag_id":"cix2l6c1p00d7c2xlkwengzke","_id":"cix2l6c1s00dcc2xl357yy0ir"},{"post_id":"cix2l6c1o00d5c2xl0hilvwi2","tag_id":"cix2l6c1100cec2xln5pdkz26","_id":"cix2l6c1s00ddc2xlymbo3qen"},{"post_id":"cix2l6c1o00d5c2xl0hilvwi2","tag_id":"cix2l6c1q00d8c2xlptdx3gp2","_id":"cix2l6c1s00dec2xl5cun8814"},{"post_id":"cix2l6c1t00dfc2xlczjqoznc","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c1v00dhc2xlnof1qke5"},{"post_id":"cix2l6c1t00dfc2xlczjqoznc","tag_id":"cix2l6bzp00a6c2xlunj1vv5y","_id":"cix2l6c1x00dic2xlq7bmgsvn"},{"post_id":"cix2l6c1t00dfc2xlczjqoznc","tag_id":"cix2l6bst000vc2xl1kukczvd","_id":"cix2l6c1x00djc2xlc3drgl9v"},{"post_id":"cix2l6c1t00dfc2xlczjqoznc","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6c1x00dkc2xlct8tok44"},{"post_id":"cix2l6c1t00dfc2xlczjqoznc","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6c1x00dlc2xls4lzsbzc"},{"post_id":"cix2l6c1t00dfc2xlczjqoznc","tag_id":"cix2l6bsr000uc2xlhetrx95o","_id":"cix2l6c1x00dmc2xlh609iwl8"},{"post_id":"cix2l6c1y00dnc2xlepo0bnx5","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c2000dpc2xlf6qc3v3z"},{"post_id":"cix2l6c1y00dnc2xlepo0bnx5","tag_id":"cix2l6bzp00a6c2xlunj1vv5y","_id":"cix2l6c2000dqc2xl9bobn8vn"},{"post_id":"cix2l6c1y00dnc2xlepo0bnx5","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6c2000drc2xl070olt6v"},{"post_id":"cix2l6c2100dsc2xl2mo6co45","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c2300duc2xlt5k7rxtt"},{"post_id":"cix2l6c2100dsc2xl2mo6co45","tag_id":"cix2l6bzp00a6c2xlunj1vv5y","_id":"cix2l6c2400dvc2xls5qlqk2l"},{"post_id":"cix2l6c2100dsc2xl2mo6co45","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6c2400dwc2xlueoeqos7"},{"post_id":"cix2l6c2100dsc2xl2mo6co45","tag_id":"cix2l6bsr000uc2xlhetrx95o","_id":"cix2l6c2500dxc2xlbmsj3o6v"},{"post_id":"cix2l6c2100dsc2xl2mo6co45","tag_id":"cix2l6bst000vc2xl1kukczvd","_id":"cix2l6c2500dyc2xlqh8i5dot"},{"post_id":"cix2l6c2500dzc2xlygy30xcd","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c2800e1c2xl7om2g5oj"},{"post_id":"cix2l6c2500dzc2xlygy30xcd","tag_id":"cix2l6bzp00a6c2xlunj1vv5y","_id":"cix2l6c2900e2c2xl4tfu59qf"},{"post_id":"cix2l6c2500dzc2xlygy30xcd","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6c2900e3c2xldpfo6doy"},{"post_id":"cix2l6c2500dzc2xlygy30xcd","tag_id":"cix2l6bry0004c2xlbo1rvuu2","_id":"cix2l6c2900e4c2xlhl29jabl"},{"post_id":"cix2l6c2a00e5c2xlm66wx5rj","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c2d00e9c2xl1vc4wm0t"},{"post_id":"cix2l6c2a00e5c2xlm66wx5rj","tag_id":"cix2l6bzp00a6c2xlunj1vv5y","_id":"cix2l6c2e00eac2xlqg4fy1rs"},{"post_id":"cix2l6c2a00e5c2xlm66wx5rj","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6c2e00ebc2xl8bykplqn"},{"post_id":"cix2l6c2a00e5c2xlm66wx5rj","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6c2e00ecc2xlq71mrvux"},{"post_id":"cix2l6c2a00e5c2xlm66wx5rj","tag_id":"cix2l6bry0006c2xlm8gllv7h","_id":"cix2l6c2e00edc2xl3wmy0o6y"},{"post_id":"cix2l6c2a00e5c2xlm66wx5rj","tag_id":"cix2l6c2b00e7c2xlodn8a4nq","_id":"cix2l6c2e00eec2xld1h0h9ve"},{"post_id":"cix2l6c2a00e5c2xlm66wx5rj","tag_id":"cix2l6c2c00e8c2xl7n4dn713","_id":"cix2l6c2e00efc2xlrwbey53h"},{"post_id":"cix2l6c2f00egc2xl0ksuclev","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c2i00elc2xldkyiilk6"},{"post_id":"cix2l6c2f00egc2xl0ksuclev","tag_id":"cix2l6c2g00eic2xl83nrf9in","_id":"cix2l6c2j00emc2xl27satee7"},{"post_id":"cix2l6c2f00egc2xl0ksuclev","tag_id":"cix2l6brs0002c2xlkjhralkg","_id":"cix2l6c2j00enc2xl1ysysx73"},{"post_id":"cix2l6c2f00egc2xl0ksuclev","tag_id":"cix2l6c2h00ejc2xltczoe27q","_id":"cix2l6c2j00eoc2xll0hbu2f9"},{"post_id":"cix2l6c2f00egc2xl0ksuclev","tag_id":"cix2l6c2h00ekc2xlifaivm0i","_id":"cix2l6c2j00epc2xlc71l2sbz"},{"post_id":"cix2l6c2j00eqc2xln0f47hrk","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c2l00esc2xlfbst5hdn"},{"post_id":"cix2l6c2j00eqc2xln0f47hrk","tag_id":"cix2l6c2g00eic2xl83nrf9in","_id":"cix2l6c2n00etc2xljx88sg9j"},{"post_id":"cix2l6c2j00eqc2xln0f47hrk","tag_id":"cix2l6brs0002c2xlkjhralkg","_id":"cix2l6c2n00euc2xl1zxbe89u"},{"post_id":"cix2l6c2j00eqc2xln0f47hrk","tag_id":"cix2l6bx8006ic2xlanfcs0th","_id":"cix2l6c2n00evc2xlrevrymyl"},{"post_id":"cix2l6c2j00eqc2xln0f47hrk","tag_id":"cix2l6c2c00e8c2xl7n4dn713","_id":"cix2l6c2n00ewc2xl6ladj8cl"},{"post_id":"cix2l6c2j00eqc2xln0f47hrk","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6c2n00exc2xllljxautp"},{"post_id":"cix2l6c2j00eqc2xln0f47hrk","tag_id":"cix2l6bry0006c2xlm8gllv7h","_id":"cix2l6c2n00eyc2xljt1618nq"},{"post_id":"cix2l6c2o00ezc2xlkuv05dqx","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c2u00f2c2xlbo5drq3d"},{"post_id":"cix2l6c2o00ezc2xlkuv05dqx","tag_id":"cix2l6c2g00eic2xl83nrf9in","_id":"cix2l6c2v00f3c2xl3am50sez"},{"post_id":"cix2l6c2o00ezc2xlkuv05dqx","tag_id":"cix2l6brs0002c2xlkjhralkg","_id":"cix2l6c2v00f4c2xlwsjrddhs"},{"post_id":"cix2l6c2o00ezc2xlkuv05dqx","tag_id":"cix2l6c0700axc2xlgxp3vaf5","_id":"cix2l6c2v00f5c2xlnxssrtek"},{"post_id":"cix2l6c2o00ezc2xlkuv05dqx","tag_id":"cix2l6c2t00f1c2xlpcqtvvg8","_id":"cix2l6c2v00f6c2xlng79mg7a"},{"post_id":"cix2l6c2o00ezc2xlkuv05dqx","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6c2v00f7c2xla6mzsl3t"},{"post_id":"cix2l6c2o00ezc2xlkuv05dqx","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6c2v00f8c2xlvshdkfxw"},{"post_id":"cix2l6c2x00f9c2xl6rd90nt6","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c3000fcc2xl6tpvkb4y"},{"post_id":"cix2l6c2x00f9c2xl6rd90nt6","tag_id":"cix2l6c2g00eic2xl83nrf9in","_id":"cix2l6c3100fdc2xld3z1hbf5"},{"post_id":"cix2l6c2x00f9c2xl6rd90nt6","tag_id":"cix2l6brs0002c2xlkjhralkg","_id":"cix2l6c3100fec2xlg8p6nmn2"},{"post_id":"cix2l6c2x00f9c2xl6rd90nt6","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6c3100ffc2xlsur5iajh"},{"post_id":"cix2l6c2x00f9c2xl6rd90nt6","tag_id":"cix2l6c2z00fbc2xl6mvehv6g","_id":"cix2l6c3100fgc2xl5eu8fmd3"},{"post_id":"cix2l6c3200fhc2xlie3l1pnf","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c3400fkc2xlmh9qbdo2"},{"post_id":"cix2l6c3200fhc2xlie3l1pnf","tag_id":"cix2l6c2g00eic2xl83nrf9in","_id":"cix2l6c3500flc2xl9ecuqrkl"},{"post_id":"cix2l6c3200fhc2xlie3l1pnf","tag_id":"cix2l6brs0002c2xlkjhralkg","_id":"cix2l6c3500fmc2xl8fdj9dfh"},{"post_id":"cix2l6c3200fhc2xlie3l1pnf","tag_id":"cix2l6bte001ic2xld1gajghb","_id":"cix2l6c3500fnc2xl40jcajq7"},{"post_id":"cix2l6c3200fhc2xlie3l1pnf","tag_id":"cix2l6c3300fjc2xllz8yew7g","_id":"cix2l6c3600foc2xlhi6d3rpv"},{"post_id":"cix2l6c3700fpc2xllyop1drz","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c3a00frc2xlgxxft5rz"},{"post_id":"cix2l6c3700fpc2xllyop1drz","tag_id":"cix2l6c2g00eic2xl83nrf9in","_id":"cix2l6c3b00fsc2xll9gwhq9a"},{"post_id":"cix2l6c3700fpc2xllyop1drz","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6c3b00ftc2xl6uq5co70"},{"post_id":"cix2l6c3700fpc2xllyop1drz","tag_id":"cix2l6bx3006bc2xlhxm1aa0p","_id":"cix2l6c3b00fuc2xlddethkbt"},{"post_id":"cix2l6c3c00fvc2xleuwccy1p","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c3f00fyc2xlumhv7bav"},{"post_id":"cix2l6c3c00fvc2xleuwccy1p","tag_id":"cix2l6c2g00eic2xl83nrf9in","_id":"cix2l6c3h00fzc2xl0krgg2u7"},{"post_id":"cix2l6c3c00fvc2xleuwccy1p","tag_id":"cix2l6bxe006uc2xlqk5geg3s","_id":"cix2l6c3h00g0c2xl7y7eheej"},{"post_id":"cix2l6c3c00fvc2xleuwccy1p","tag_id":"cix2l6btx002ac2xls5nn914i","_id":"cix2l6c3h00g1c2xlctqtotln"},{"post_id":"cix2l6c3c00fvc2xleuwccy1p","tag_id":"cix2l6btx002bc2xlii39i8qq","_id":"cix2l6c3h00g2c2xlilm5ucjx"},{"post_id":"cix2l6c3c00fvc2xleuwccy1p","tag_id":"cix2l6c3e00fxc2xlm2nhl5xr","_id":"cix2l6c3h00g3c2xlnfhigt6b"},{"post_id":"cix2l6c3c00fvc2xleuwccy1p","tag_id":"cix2l6bxl007bc2xlnhqu19fi","_id":"cix2l6c3h00g4c2xlr5ohlqqe"},{"post_id":"cix2l6c3i00g5c2xlx7ymxp67","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c3l00g9c2xluzgs3b7u"},{"post_id":"cix2l6c3i00g5c2xlx7ymxp67","tag_id":"cix2l6c2g00eic2xl83nrf9in","_id":"cix2l6c3m00gac2xlf1mmxs08"},{"post_id":"cix2l6c3i00g5c2xlx7ymxp67","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6c3m00gbc2xlncc8xvi4"},{"post_id":"cix2l6c3i00g5c2xlx7ymxp67","tag_id":"cix2l6c2t00f1c2xlpcqtvvg8","_id":"cix2l6c3m00gcc2xlvg83gogd"},{"post_id":"cix2l6c3i00g5c2xlx7ymxp67","tag_id":"cix2l6c3k00g7c2xluaqlxpmp","_id":"cix2l6c3m00gdc2xl9yw01yh4"},{"post_id":"cix2l6c3i00g5c2xlx7ymxp67","tag_id":"cix2l6c3k00g8c2xlsdw5jbor","_id":"cix2l6c3m00gec2xlvt6qv2wk"},{"post_id":"cix2l6c3n00gfc2xlur06igll","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c3o00ghc2xlwwal5xzg"},{"post_id":"cix2l6c3n00gfc2xlur06igll","tag_id":"cix2l6c2g00eic2xl83nrf9in","_id":"cix2l6c3p00gic2xls685lvh9"},{"post_id":"cix2l6c3n00gfc2xlur06igll","tag_id":"cix2l6bw5004hc2xliqrfp4kr","_id":"cix2l6c3p00gjc2xlea9pdmy5"},{"post_id":"cix2l6c3n00gfc2xlur06igll","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6c3p00gkc2xl7xbzdtn9"},{"post_id":"cix2l6c3q00glc2xlxho77mpr","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c3s00gnc2xlbtz3w3xw"},{"post_id":"cix2l6c3q00glc2xlxho77mpr","tag_id":"cix2l6c2g00eic2xl83nrf9in","_id":"cix2l6c3t00goc2xlcbeuaims"},{"post_id":"cix2l6c3q00glc2xlxho77mpr","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6c3t00gpc2xlasgz4bxz"},{"post_id":"cix2l6c3q00glc2xlxho77mpr","tag_id":"cix2l6bwe0051c2xllpdw4hf2","_id":"cix2l6c3t00gqc2xl6c408i6l"},{"post_id":"cix2l6c3t00grc2xljphzz9oq","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c3w00guc2xl0sevtp3r"},{"post_id":"cix2l6c3t00grc2xljphzz9oq","tag_id":"cix2l6c2g00eic2xl83nrf9in","_id":"cix2l6c3x00gvc2xlapnitkqk"},{"post_id":"cix2l6c3t00grc2xljphzz9oq","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6c3x00gwc2xll9wnap20"},{"post_id":"cix2l6c3t00grc2xljphzz9oq","tag_id":"cix2l6c3v00gtc2xl3nyi6ovi","_id":"cix2l6c3x00gxc2xlhmshy5ye"},{"post_id":"cix2l6c3t00grc2xljphzz9oq","tag_id":"cix2l6bwe0051c2xllpdw4hf2","_id":"cix2l6c3x00gyc2xl9zjlhfek"},{"post_id":"cix2l6c3t00grc2xljphzz9oq","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6c3x00gzc2xl0jw80w07"},{"post_id":"cix2l6c3y00h0c2xl2sz697zb","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c4200h4c2xlkp0kzwmj"},{"post_id":"cix2l6c3y00h0c2xl2sz697zb","tag_id":"cix2l6c2g00eic2xl83nrf9in","_id":"cix2l6c4200h5c2xla9nvrdj7"},{"post_id":"cix2l6c3y00h0c2xl2sz697zb","tag_id":"cix2l6c4000h2c2xl0ymvmkpr","_id":"cix2l6c4200h6c2xlilfhdsbs"},{"post_id":"cix2l6c3y00h0c2xl2sz697zb","tag_id":"cix2l6c4100h3c2xlojzbrv1p","_id":"cix2l6c4200h7c2xlm8rd3h9q"},{"post_id":"cix2l6c4400h8c2xlvdbx87ds","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c4700hac2xlyqz7c18j"},{"post_id":"cix2l6c4400h8c2xlvdbx87ds","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6c4800hbc2xll6wdr3dg"},{"post_id":"cix2l6c4400h8c2xlvdbx87ds","tag_id":"cix2l6c2g00eic2xl83nrf9in","_id":"cix2l6c4800hcc2xlwx0mku93"},{"post_id":"cix2l6c4400h8c2xlvdbx87ds","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6c4800hdc2xl6ys8xqx4"},{"post_id":"cix2l6c4400h8c2xlvdbx87ds","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6c4800hec2xln4epetb3"},{"post_id":"cix2l6c4400h8c2xlvdbx87ds","tag_id":"cix2l6bsr000uc2xlhetrx95o","_id":"cix2l6c4800hfc2xly4s1cw99"},{"post_id":"cix2l6c4400h8c2xlvdbx87ds","tag_id":"cix2l6bst000vc2xl1kukczvd","_id":"cix2l6c4800hgc2xlp3hrwzka"},{"post_id":"cix2l6c4900hhc2xlz1u499la","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c4b00hjc2xlrtdznl66"},{"post_id":"cix2l6c4900hhc2xlz1u499la","tag_id":"cix2l6c2g00eic2xl83nrf9in","_id":"cix2l6c4c00hkc2xlyc0p6crz"},{"post_id":"cix2l6c4900hhc2xlz1u499la","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6c4c00hlc2xla9wajqmn"},{"post_id":"cix2l6c4900hhc2xlz1u499la","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6c4c00hmc2xlnh4ikptr"},{"post_id":"cix2l6c4d00hnc2xlu1hlazam","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c4f00hpc2xlznohm1eo"},{"post_id":"cix2l6c4d00hnc2xlu1hlazam","tag_id":"cix2l6c2g00eic2xl83nrf9in","_id":"cix2l6c4g00hqc2xlncvr83i4"},{"post_id":"cix2l6c4d00hnc2xlu1hlazam","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6c4g00hrc2xlrs34r3kp"},{"post_id":"cix2l6c4d00hnc2xlu1hlazam","tag_id":"cix2l6bvc003mc2xlzsn1jrh3","_id":"cix2l6c4g00hsc2xlq8vvv4wq"},{"post_id":"cix2l6c4h00htc2xlqm9a4iz0","tag_id":"cix2l6c4j00hvc2xlt9thv2lh","_id":"cix2l6c4l00hxc2xl3gd50sou"},{"post_id":"cix2l6c4h00htc2xlqm9a4iz0","tag_id":"cix2l6c4k00hwc2xlg2jpx39j","_id":"cix2l6c4m00hyc2xlkk8as8m6"},{"post_id":"cix2l6c4h00htc2xlqm9a4iz0","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6c4m00hzc2xltew5jkxs"},{"post_id":"cix2l6c4h00htc2xlqm9a4iz0","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6c4m00i0c2xlzr27rx6b"},{"post_id":"cix2l6c4m00i1c2xlblomrgol","tag_id":"cix2l6c4j00hvc2xlt9thv2lh","_id":"cix2l6c4s00i6c2xlaf4iesm1"},{"post_id":"cix2l6c4m00i1c2xlblomrgol","tag_id":"cix2l6c4p00i3c2xlxkmyp1eu","_id":"cix2l6c4t00i7c2xlzm962ste"},{"post_id":"cix2l6c4m00i1c2xlblomrgol","tag_id":"cix2l6c4q00i4c2xlchz98yon","_id":"cix2l6c4t00i8c2xl9x0381eb"},{"post_id":"cix2l6c4m00i1c2xlblomrgol","tag_id":"cix2l6c0700axc2xlgxp3vaf5","_id":"cix2l6c4t00i9c2xl386bjbwt"},{"post_id":"cix2l6c4m00i1c2xlblomrgol","tag_id":"cix2l6c0v00c2c2xl8pxn33ts","_id":"cix2l6c4t00iac2xlautenl3i"},{"post_id":"cix2l6c4m00i1c2xlblomrgol","tag_id":"cix2l6c4r00i5c2xl2e2bf7pp","_id":"cix2l6c4t00ibc2xli5o4wkat"},{"post_id":"cix2l6c4u00icc2xl4cdjx76c","tag_id":"cix2l6c4j00hvc2xlt9thv2lh","_id":"cix2l6c4w00iec2xlyfnr05ou"},{"post_id":"cix2l6c4u00icc2xl4cdjx76c","tag_id":"cix2l6bvz0049c2xle6e8llpz","_id":"cix2l6c4y00ifc2xlyyuav6hc"},{"post_id":"cix2l6c4u00icc2xl4cdjx76c","tag_id":"cix2l6bw0004ac2xl40e50m9d","_id":"cix2l6c4y00igc2xl19uo5i7h"},{"post_id":"cix2l6c4u00icc2xl4cdjx76c","tag_id":"cix2l6bwn005hc2xl3hpoko78","_id":"cix2l6c4y00ihc2xl13m1tgwq"},{"post_id":"cix2l6c4u00icc2xl4cdjx76c","tag_id":"cix2l6bvd003nc2xlzttr1jkp","_id":"cix2l6c4y00iic2xlb6ka8vhm"},{"post_id":"cix2l6c4u00icc2xl4cdjx76c","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6c4y00ijc2xlzrv73zrt"},{"post_id":"cix2l6c4z00ikc2xlg02derhw","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c5100inc2xlahbyq7s9"},{"post_id":"cix2l6c4z00ikc2xlg02derhw","tag_id":"cix2l6c5000imc2xltidgbutl","_id":"cix2l6c5200ioc2xl3wk18kwd"},{"post_id":"cix2l6c4z00ikc2xlg02derhw","tag_id":"cix2l6btx002ac2xls5nn914i","_id":"cix2l6c5200ipc2xlsxurjxe9"},{"post_id":"cix2l6c4z00ikc2xlg02derhw","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6c5200iqc2xlyzum1y6m"},{"post_id":"cix2l6c4z00ikc2xlg02derhw","tag_id":"cix2l6bxh0073c2xlzrgyofi2","_id":"cix2l6c5200irc2xl6mplkmm1"},{"post_id":"cix2l6c5300isc2xlbxq2fkht","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c5700iuc2xltcrcrpqc"},{"post_id":"cix2l6c5300isc2xlbxq2fkht","tag_id":"cix2l6c5000imc2xltidgbutl","_id":"cix2l6c5800ivc2xlg41xvii6"},{"post_id":"cix2l6c5300isc2xlbxq2fkht","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6c5800iwc2xlycv695hb"},{"post_id":"cix2l6c5300isc2xlbxq2fkht","tag_id":"cix2l6bsr000uc2xlhetrx95o","_id":"cix2l6c5800ixc2xli1aoou2h"},{"post_id":"cix2l6c5300isc2xlbxq2fkht","tag_id":"cix2l6bst000vc2xl1kukczvd","_id":"cix2l6c5800iyc2xlkiwlan28"},{"post_id":"cix2l6c5900izc2xlfffxuvd0","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c5c00j1c2xltmuk6udc"},{"post_id":"cix2l6c5900izc2xlfffxuvd0","tag_id":"cix2l6c5000imc2xltidgbutl","_id":"cix2l6c5d00j2c2xlkhmzbrg5"},{"post_id":"cix2l6c5900izc2xlfffxuvd0","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6c5d00j3c2xlpcy9mhnw"},{"post_id":"cix2l6c5900izc2xlfffxuvd0","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6c5d00j4c2xloc6jybov"},{"post_id":"cix2l6c5900izc2xlfffxuvd0","tag_id":"cix2l6c0700axc2xlgxp3vaf5","_id":"cix2l6c5d00j5c2xlhm3agxwk"},{"post_id":"cix2l6c5e00j6c2xlx83fmb1t","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c5g00j8c2xlcf8qu566"},{"post_id":"cix2l6c5e00j6c2xlx83fmb1t","tag_id":"cix2l6c5000imc2xltidgbutl","_id":"cix2l6c5h00j9c2xl2stffhou"},{"post_id":"cix2l6c5e00j6c2xlx83fmb1t","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6c5i00jac2xl5eq1tyh0"},{"post_id":"cix2l6c5e00j6c2xlx83fmb1t","tag_id":"cix2l6bx3006bc2xlhxm1aa0p","_id":"cix2l6c5i00jbc2xlwwx6jhxh"},{"post_id":"cix2l6c5e00j6c2xlx83fmb1t","tag_id":"cix2l6c3e00fxc2xlm2nhl5xr","_id":"cix2l6c5i00jcc2xlen63bgnu"},{"post_id":"cix2l6c5j00jdc2xlk4a4ott5","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6c5l00jfc2xl1uicm03r"},{"post_id":"cix2l6c5j00jdc2xlk4a4ott5","tag_id":"cix2l6bwa004pc2xlfep7re8c","_id":"cix2l6c5m00jgc2xl9uirwvdg"},{"post_id":"cix2l6c5j00jdc2xlk4a4ott5","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6c5m00jhc2xlg7nbckbn"},{"post_id":"cix2l6c5j00jdc2xlk4a4ott5","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6c5m00jic2xld7ak5gmf"},{"post_id":"cix2l6c6500jjc2xl9q7yy1u2","tag_id":"cix2l6bxt007tc2xlta9yvqhe","_id":"cix2l6c6c00jlc2xl85ptfdzn"},{"post_id":"cix2l6c6500jjc2xl9q7yy1u2","tag_id":"cix2l6c4100h3c2xlojzbrv1p","_id":"cix2l6c6e00jmc2xlay2c1a71"},{"post_id":"cix2l6c6500jjc2xl9q7yy1u2","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6c6e00jnc2xlit4pld1m"},{"post_id":"cix2l6c6500jjc2xl9q7yy1u2","tag_id":"cix2l6btx002ac2xls5nn914i","_id":"cix2l6c6e00joc2xl0ovz7v9q"},{"post_id":"cix2l6c6500jjc2xl9q7yy1u2","tag_id":"cix2l6bxe006uc2xlqk5geg3s","_id":"cix2l6c6e00jpc2xlcccg9k8r"},{"post_id":"cix2l6c6500jjc2xl9q7yy1u2","tag_id":"cix2l6brx0003c2xl4mq6xsp7","_id":"cix2l6c6e00jqc2xlhbvojrua"},{"post_id":"cix2l6c6h00jtc2xlylaght2n","tag_id":"cix2l6c6j00jvc2xld8v1mwdo","_id":"cix2l6c6k00jwc2xl3jjfi1kc"},{"post_id":"cix2l6c6h00jtc2xlylaght2n","tag_id":"cix2l6btk001pc2xlq2nvh5we","_id":"cix2l6c6k00jxc2xlxls1qe7p"},{"post_id":"cix2l6c6l00jyc2xlw2fnj5q9","tag_id":"cix2l6c6j00jvc2xld8v1mwdo","_id":"cix2l6c6o00k1c2xl05zy6nry"},{"post_id":"cix2l6c6l00jyc2xlw2fnj5q9","tag_id":"cix2l6c6n00k0c2xlbnfyz1hv","_id":"cix2l6c6o00k2c2xlbzpk1gxr"},{"post_id":"cix2l6c6l00jyc2xlw2fnj5q9","tag_id":"cix2l6brx0003c2xl4mq6xsp7","_id":"cix2l6c6o00k3c2xl0b3uq72o"},{"post_id":"cix2l6c6u00k4c2xlc9y0x3gz","tag_id":"cix2l6c6j00jvc2xld8v1mwdo","_id":"cix2l6c6w00k6c2xl7ul4zdeq"},{"post_id":"cix2l6c6u00k4c2xlc9y0x3gz","tag_id":"cix2l6c6n00k0c2xlbnfyz1hv","_id":"cix2l6c6x00k7c2xlsizwi7lh"},{"post_id":"cix2l6c6u00k4c2xlc9y0x3gz","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6c6x00k8c2xlm6d2qdof"},{"post_id":"cix2l6c6u00k4c2xlc9y0x3gz","tag_id":"cix2l6bwn005hc2xl3hpoko78","_id":"cix2l6c6x00k9c2xlxtdlukn8"},{"post_id":"cix2l6c6y00kac2xlsvcveua9","tag_id":"cix2l6c6j00jvc2xld8v1mwdo","_id":"cix2l6c7000kdc2xll1y3x66w"},{"post_id":"cix2l6c6y00kac2xlsvcveua9","tag_id":"cix2l6c6z00kcc2xljwdacnnm","_id":"cix2l6c7100kec2xlk510l8rl"},{"post_id":"cix2l6c7100kfc2xlshvblmw1","tag_id":"cix2l6c6j00jvc2xld8v1mwdo","_id":"cix2l6c7700kic2xlxu4a3aoi"},{"post_id":"cix2l6c7100kfc2xlshvblmw1","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6c7800kjc2xlteeayygs"},{"post_id":"cix2l6c7100kfc2xlshvblmw1","tag_id":"cix2l6c7600khc2xllu0wv0rd","_id":"cix2l6c7800kkc2xljddd43ja"},{"post_id":"cix2l6c7100kfc2xlshvblmw1","tag_id":"cix2l6bwj0059c2xlp2z4w5xl","_id":"cix2l6c7800klc2xlzm6i208t"},{"post_id":"cix2l6c7900kmc2xlata0f22v","tag_id":"cix2l6c6j00jvc2xld8v1mwdo","_id":"cix2l6c7c00kqc2xlhosk0zb6"},{"post_id":"cix2l6c7900kmc2xlata0f22v","tag_id":"cix2l6c7a00koc2xls3c7nuq6","_id":"cix2l6c7d00krc2xlpzeg52bo"},{"post_id":"cix2l6c7900kmc2xlata0f22v","tag_id":"cix2l6c4000h2c2xl0ymvmkpr","_id":"cix2l6c7d00ksc2xl5l7ig8jm"},{"post_id":"cix2l6c7900kmc2xlata0f22v","tag_id":"cix2l6c7b00kpc2xll5wlx8bz","_id":"cix2l6c7d00ktc2xl5c38mqsc"},{"post_id":"cix2l6c7e00kuc2xl2i7m7a1c","tag_id":"cix2l6c6j00jvc2xld8v1mwdo","_id":"cix2l6c7g00kwc2xlvdkzykbl"},{"post_id":"cix2l6c7e00kuc2xl2i7m7a1c","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c7h00kxc2xl6m65qs9o"},{"post_id":"cix2l6c7e00kuc2xl2i7m7a1c","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6c7h00kyc2xln16um8bl"},{"post_id":"cix2l6c7e00kuc2xl2i7m7a1c","tag_id":"cix2l6c0l00brc2xlrz9vwge8","_id":"cix2l6c7h00kzc2xlkp837zsd"},{"post_id":"cix2l6c7h00l0c2xl01ii0mf9","tag_id":"cix2l6c6j00jvc2xld8v1mwdo","_id":"cix2l6c7j00l2c2xleeyfqact"},{"post_id":"cix2l6c7h00l0c2xl01ii0mf9","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6c7k00l3c2xlh88mo8zf"},{"post_id":"cix2l6c7h00l0c2xl01ii0mf9","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6c7k00l4c2xlk7v5dpta"},{"post_id":"cix2l6c7l00l5c2xlia9o9uzg","tag_id":"cix2l6c6j00jvc2xld8v1mwdo","_id":"cix2l6c7n00l7c2xlhse2si70"},{"post_id":"cix2l6c7l00l5c2xlia9o9uzg","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6c7o00l8c2xl59btqyyn"},{"post_id":"cix2l6c7l00l5c2xlia9o9uzg","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c7o00l9c2xl1639ivvm"},{"post_id":"cix2l6c7l00l5c2xlia9o9uzg","tag_id":"cix2l6c4000h2c2xl0ymvmkpr","_id":"cix2l6c7o00lac2xlflo0wd56"},{"post_id":"cix2l6c7p00lbc2xl2fmd6frl","tag_id":"cix2l6c6j00jvc2xld8v1mwdo","_id":"cix2l6c7r00lec2xl08h0xiqj"},{"post_id":"cix2l6c7p00lbc2xl2fmd6frl","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6c7s00lfc2xlei2e0btc"},{"post_id":"cix2l6c7p00lbc2xl2fmd6frl","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6c7t00lgc2xl2wg6x19o"},{"post_id":"cix2l6c7p00lbc2xl2fmd6frl","tag_id":"cix2l6c7q00ldc2xlltyylx9y","_id":"cix2l6c7t00lhc2xl45m27ajb"},{"post_id":"cix2l6c7p00lbc2xl2fmd6frl","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6c7t00lic2xl6e9kvnhb"},{"post_id":"cix2l6c7u00ljc2xlqe4ely8k","tag_id":"cix2l6c6j00jvc2xld8v1mwdo","_id":"cix2l6c7w00llc2xlcmbtkpwr"},{"post_id":"cix2l6c7u00ljc2xlqe4ely8k","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6c7y00lmc2xlxbctktqg"},{"post_id":"cix2l6c7u00ljc2xlqe4ely8k","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6c7y00lnc2xljoyg7uhn"},{"post_id":"cix2l6c7u00ljc2xlqe4ely8k","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6c7y00loc2xli15q9l9l"},{"post_id":"cix2l6c7u00ljc2xlqe4ely8k","tag_id":"cix2l6bwe0051c2xllpdw4hf2","_id":"cix2l6c7y00lpc2xlzfz4vysn"},{"post_id":"cix2l6c7y00lqc2xl0ywbc2ig","tag_id":"cix2l6c6j00jvc2xld8v1mwdo","_id":"cix2l6c8100ltc2xl62jqvtl4"},{"post_id":"cix2l6c7y00lqc2xl0ywbc2ig","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6c8300luc2xlhhajaer5"},{"post_id":"cix2l6c7y00lqc2xl0ywbc2ig","tag_id":"cix2l6c4000h2c2xl0ymvmkpr","_id":"cix2l6c8300lvc2xlnuxcz6mv"},{"post_id":"cix2l6c7y00lqc2xl0ywbc2ig","tag_id":"cix2l6bu6002qc2xl8k4xwvuw","_id":"cix2l6c8300lwc2xlnv15xj5n"},{"post_id":"cix2l6c7y00lqc2xl0ywbc2ig","tag_id":"cix2l6c8000lsc2xl1rukwqob","_id":"cix2l6c8300lxc2xl1qtqimv2"},{"post_id":"cix2l6c7y00lqc2xl0ywbc2ig","tag_id":"cix2l6c7b00kpc2xll5wlx8bz","_id":"cix2l6c8300lyc2xlnk3qlbdo"},{"post_id":"cix2l6c8300lzc2xll9nv803j","tag_id":"cix2l6c6j00jvc2xld8v1mwdo","_id":"cix2l6c8600m2c2xld4fob8i5"},{"post_id":"cix2l6c8300lzc2xll9nv803j","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6c8700m3c2xlvd3kr6mv"},{"post_id":"cix2l6c8300lzc2xll9nv803j","tag_id":"cix2l6c8500m1c2xlrq6onoip","_id":"cix2l6c8700m4c2xl12uidm88"},{"post_id":"cix2l6c8300lzc2xll9nv803j","tag_id":"cix2l6bx9006kc2xl8ligd8yv","_id":"cix2l6c8700m5c2xlimkeenv6"},{"post_id":"cix2l6c8800m6c2xlonsw0kmd","tag_id":"cix2l6c6j00jvc2xld8v1mwdo","_id":"cix2l6c8a00m8c2xllmahbsfx"},{"post_id":"cix2l6c8800m6c2xlonsw0kmd","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6c8b00m9c2xlxjpjzh9z"},{"post_id":"cix2l6c8800m6c2xlonsw0kmd","tag_id":"cix2l6bte001ic2xld1gajghb","_id":"cix2l6c8b00mac2xlgm9hepcl"},{"post_id":"cix2l6c8c00mbc2xl8o61il2q","tag_id":"cix2l6c6j00jvc2xld8v1mwdo","_id":"cix2l6c8e00mdc2xl135dzcye"},{"post_id":"cix2l6c8c00mbc2xl8o61il2q","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6c8g00mec2xl1fpzf3qa"},{"post_id":"cix2l6c8c00mbc2xl8o61il2q","tag_id":"cix2l6bwv005uc2xlcab5p7ag","_id":"cix2l6c8g00mfc2xl6o4r4mr1"},{"post_id":"cix2l6c8c00mbc2xl8o61il2q","tag_id":"cix2l6bwa004pc2xlfep7re8c","_id":"cix2l6c8g00mgc2xl9a9l2i33"},{"post_id":"cix2l6c8c00mbc2xl8o61il2q","tag_id":"cix2l6c1p00d7c2xlkwengzke","_id":"cix2l6c8g00mhc2xl9mzqfklq"},{"post_id":"cix2l6c8c00mbc2xl8o61il2q","tag_id":"cix2l6bwa004qc2xlqnw3w3ri","_id":"cix2l6c8g00mic2xlx3uicbgr"},{"post_id":"cix2l6c8h00mjc2xl5a0hda7m","tag_id":"cix2l6c6j00jvc2xld8v1mwdo","_id":"cix2l6c8j00mlc2xlisikgb79"},{"post_id":"cix2l6c8h00mjc2xl5a0hda7m","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6c8k00mmc2xlxu319xr5"},{"post_id":"cix2l6c8h00mjc2xl5a0hda7m","tag_id":"cix2l6c3300fjc2xllz8yew7g","_id":"cix2l6c8k00mnc2xl3gh4iqkb"},{"post_id":"cix2l6c8l00moc2xlujgm0ar7","tag_id":"cix2l6c6j00jvc2xld8v1mwdo","_id":"cix2l6c8o00msc2xlj0h00xgr"},{"post_id":"cix2l6c8l00moc2xlujgm0ar7","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6c8q00mtc2xlrq4jfk7v"},{"post_id":"cix2l6c8l00moc2xlujgm0ar7","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6c8q00muc2xlfvb2aya3"},{"post_id":"cix2l6c8l00moc2xlujgm0ar7","tag_id":"cix2l6c8n00mqc2xlphdzc6hg","_id":"cix2l6c8q00mvc2xlyqdkay0g"},{"post_id":"cix2l6c8l00moc2xlujgm0ar7","tag_id":"cix2l6bry0004c2xlbo1rvuu2","_id":"cix2l6c8q00mwc2xlv121jw7m"},{"post_id":"cix2l6c8l00moc2xlujgm0ar7","tag_id":"cix2l6c8n00mrc2xlz3wjn4mj","_id":"cix2l6c8q00mxc2xlqff9vwgt"},{"post_id":"cix2l6c8r00myc2xl3qc96ysa","tag_id":"cix2l6c6j00jvc2xld8v1mwdo","_id":"cix2l6c8t00n0c2xlsbk09po5"},{"post_id":"cix2l6c8r00myc2xl3qc96ysa","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6c8u00n1c2xlh9chl8l6"},{"post_id":"cix2l6c8r00myc2xl3qc96ysa","tag_id":"cix2l6c8n00mqc2xlphdzc6hg","_id":"cix2l6c8u00n2c2xl1e64ks6m"},{"post_id":"cix2l6c8r00myc2xl3qc96ysa","tag_id":"cix2l6c3300fjc2xllz8yew7g","_id":"cix2l6c8u00n3c2xlsrupola1"},{"post_id":"cix2l6c8r00myc2xl3qc96ysa","tag_id":"cix2l6bte001ic2xld1gajghb","_id":"cix2l6c8u00n4c2xldcb77jyq"},{"post_id":"cix2l6c8v00n5c2xlsmh6mqzd","tag_id":"cix2l6c6j00jvc2xld8v1mwdo","_id":"cix2l6c9100nac2xljwasn7xa"},{"post_id":"cix2l6c8v00n5c2xlsmh6mqzd","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6c9300nbc2xlej9s44eu"},{"post_id":"cix2l6c8v00n5c2xlsmh6mqzd","tag_id":"cix2l6c8x00n7c2xlapjxljjh","_id":"cix2l6c9300ncc2xljxk2guwv"},{"post_id":"cix2l6c8v00n5c2xlsmh6mqzd","tag_id":"cix2l6c8y00n8c2xljlhqh411","_id":"cix2l6c9300ndc2xlqd4hvpmn"},{"post_id":"cix2l6c8v00n5c2xlsmh6mqzd","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6c9300nec2xlm4zoltwe"},{"post_id":"cix2l6c8v00n5c2xlsmh6mqzd","tag_id":"cix2l6c0700axc2xlgxp3vaf5","_id":"cix2l6c9400nfc2xl4b5bmv5m"},{"post_id":"cix2l6c8v00n5c2xlsmh6mqzd","tag_id":"cix2l6c8y00n9c2xlm421go5n","_id":"cix2l6c9400ngc2xle6r4hyz8"},{"post_id":"cix2l6c9500nhc2xl568izctq","tag_id":"cix2l6c6j00jvc2xld8v1mwdo","_id":"cix2l6c9800nkc2xlegpguotq"},{"post_id":"cix2l6c9500nhc2xl568izctq","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6c9900nlc2xlaw3d9qvk"},{"post_id":"cix2l6c9500nhc2xl568izctq","tag_id":"cix2l6c7b00kpc2xll5wlx8bz","_id":"cix2l6c9900nmc2xl68fxy969"},{"post_id":"cix2l6c9500nhc2xl568izctq","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6c9900nnc2xl7qs22amz"},{"post_id":"cix2l6c9500nhc2xl568izctq","tag_id":"cix2l6c9700njc2xlqaed2y8c","_id":"cix2l6c9900noc2xludiuv0ad"},{"post_id":"cix2l6c9a00npc2xlq3jhcl52","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6c9e00nrc2xlxkn5rr49"},{"post_id":"cix2l6c9a00npc2xlq3jhcl52","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6c9f00nsc2xlwbcdcsbr"},{"post_id":"cix2l6c9a00npc2xlq3jhcl52","tag_id":"cix2l6c6j00jvc2xld8v1mwdo","_id":"cix2l6c9g00ntc2xlzvkof7gx"},{"post_id":"cix2l6c9a00npc2xlq3jhcl52","tag_id":"cix2l6bwv005uc2xlcab5p7ag","_id":"cix2l6c9g00nuc2xl37ll0857"},{"post_id":"cix2l6c9a00npc2xlq3jhcl52","tag_id":"cix2l6bvc003mc2xlzsn1jrh3","_id":"cix2l6c9g00nvc2xl0ki6uqn4"},{"post_id":"cix2l6c9j00nwc2xlb0vtong6","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6c9m00nyc2xlbnalh9nz"},{"post_id":"cix2l6c9j00nwc2xlb0vtong6","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6c9o00nzc2xlpskxntqm"},{"post_id":"cix2l6c9j00nwc2xlb0vtong6","tag_id":"cix2l6bwv005uc2xlcab5p7ag","_id":"cix2l6c9o00o0c2xlnarzvwxd"},{"post_id":"cix2l6c9j00nwc2xlb0vtong6","tag_id":"cix2l6c8x00n7c2xlapjxljjh","_id":"cix2l6c9o00o1c2xljr1g7e0u"},{"post_id":"cix2l6c9j00nwc2xlb0vtong6","tag_id":"cix2l6c2z00fbc2xl6mvehv6g","_id":"cix2l6c9o00o2c2xlipw7iknz"},{"post_id":"cix2l6c9j00nwc2xlb0vtong6","tag_id":"cix2l6c8y00n8c2xljlhqh411","_id":"cix2l6c9o00o3c2xlejgy8sw1"},{"post_id":"cix2l6c9j00nwc2xlb0vtong6","tag_id":"cix2l6bwe0051c2xllpdw4hf2","_id":"cix2l6c9o00o4c2xl8iuj9dta"},{"post_id":"cix2l6c9p00o5c2xljftollwe","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6c9s00o7c2xlqrm7wlxo"},{"post_id":"cix2l6c9p00o5c2xljftollwe","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6c9t00o8c2xl6m6dykfx"},{"post_id":"cix2l6c9p00o5c2xljftollwe","tag_id":"cix2l6c6j00jvc2xld8v1mwdo","_id":"cix2l6c9t00o9c2xllszedxxm"},{"post_id":"cix2l6c9p00o5c2xljftollwe","tag_id":"cix2l6bwv005vc2xl62lmb5wk","_id":"cix2l6c9u00oac2xla9vrjuis"},{"post_id":"cix2l6c9p00o5c2xljftollwe","tag_id":"cix2l6c8y00n8c2xljlhqh411","_id":"cix2l6c9u00obc2xl14moybnu"},{"post_id":"cix2l6c9p00o5c2xljftollwe","tag_id":"cix2l6bwv005uc2xlcab5p7ag","_id":"cix2l6c9u00occ2xlrk78ah3q"},{"post_id":"cix2l6c9v00odc2xlc5u61jl9","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6c9x00ofc2xlqqlicu5l"},{"post_id":"cix2l6c9v00odc2xlc5u61jl9","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6c9z00ogc2xlwsrxsahb"},{"post_id":"cix2l6c9v00odc2xlc5u61jl9","tag_id":"cix2l6c6j00jvc2xld8v1mwdo","_id":"cix2l6c9z00ohc2xltgr6etf3"},{"post_id":"cix2l6c9v00odc2xlc5u61jl9","tag_id":"cix2l6bwv005vc2xl62lmb5wk","_id":"cix2l6c9z00oic2xl7msci76t"},{"post_id":"cix2l6ca000ojc2xlpt1gw5qo","tag_id":"cix2l6ca200olc2xl0hipr5lo","_id":"cix2l6ca300omc2xlq2wcfca2"},{"post_id":"cix2l6ca000ojc2xlpt1gw5qo","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6ca400onc2xle51a2g6a"},{"post_id":"cix2l6ca000ojc2xlpt1gw5qo","tag_id":"cix2l6bry0004c2xlbo1rvuu2","_id":"cix2l6ca400ooc2xly7jkyllv"},{"post_id":"cix2l6ca500opc2xlm4k8cd1c","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6ca700orc2xl2uixb8th"},{"post_id":"cix2l6ca500opc2xlm4k8cd1c","tag_id":"cix2l6ca200olc2xl0hipr5lo","_id":"cix2l6ca900osc2xlkes16tjd"},{"post_id":"cix2l6ca500opc2xlm4k8cd1c","tag_id":"cix2l6btx002ac2xls5nn914i","_id":"cix2l6ca900otc2xlhc8ah0uz"},{"post_id":"cix2l6ca500opc2xlm4k8cd1c","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6ca900ouc2xlracuvj33"},{"post_id":"cix2l6ca500opc2xlm4k8cd1c","tag_id":"cix2l6bxh0073c2xlzrgyofi2","_id":"cix2l6ca900ovc2xlhkp1h255"},{"post_id":"cix2l6caa00owc2xl0wb51qrs","tag_id":"cix2l6ca200olc2xl0hipr5lo","_id":"cix2l6cad00oyc2xlidk40gah"},{"post_id":"cix2l6caa00owc2xl0wb51qrs","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6caf00ozc2xl6sqbqd1y"},{"post_id":"cix2l6caa00owc2xl0wb51qrs","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6caf00p0c2xllm5m9ece"},{"post_id":"cix2l6caa00owc2xl0wb51qrs","tag_id":"cix2l6c7q00ldc2xlltyylx9y","_id":"cix2l6caf00p1c2xlnw73g5py"},{"post_id":"cix2l6cag00p2c2xlewpaymrt","tag_id":"cix2l6ca200olc2xl0hipr5lo","_id":"cix2l6cao00p4c2xl0m17guti"},{"post_id":"cix2l6cag00p2c2xlewpaymrt","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6caq00p5c2xl8mwt63z3"},{"post_id":"cix2l6cag00p2c2xlewpaymrt","tag_id":"cix2l6bxo007jc2xlkcrgnf1u","_id":"cix2l6caq00p6c2xlpva4n3iw"},{"post_id":"cix2l6cag00p2c2xlewpaymrt","tag_id":"cix2l6c1k00cwc2xltzt3umv8","_id":"cix2l6caq00p7c2xl7b6nv8m4"},{"post_id":"cix2l6cag00p2c2xlewpaymrt","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6caq00p8c2xlhrev2c2f"},{"post_id":"cix2l6car00p9c2xlcfkmm59g","tag_id":"cix2l6ca200olc2xl0hipr5lo","_id":"cix2l6cay00pec2xlhbu0b4og"},{"post_id":"cix2l6car00p9c2xlcfkmm59g","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cb100pfc2xl1qaa4qhm"},{"post_id":"cix2l6car00p9c2xlcfkmm59g","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6cb100pgc2xlmlxzuvf0"},{"post_id":"cix2l6car00p9c2xlcfkmm59g","tag_id":"cix2l6cat00pbc2xlrgesoa0t","_id":"cix2l6cb100phc2xlpvmb0up5"},{"post_id":"cix2l6car00p9c2xlcfkmm59g","tag_id":"cix2l6c1k00cwc2xltzt3umv8","_id":"cix2l6cb100pic2xl12ekme7s"},{"post_id":"cix2l6car00p9c2xlcfkmm59g","tag_id":"cix2l6caw00pcc2xlv0e4fef1","_id":"cix2l6cb100pjc2xlc50ghffn"},{"post_id":"cix2l6car00p9c2xlcfkmm59g","tag_id":"cix2l6cax00pdc2xlcci3d4bu","_id":"cix2l6cb100pkc2xlqez2q8yu"},{"post_id":"cix2l6cb200plc2xl5b9caggl","tag_id":"cix2l6ca200olc2xl0hipr5lo","_id":"cix2l6cb500pnc2xlebjs3e5a"},{"post_id":"cix2l6cb200plc2xl5b9caggl","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6cb700poc2xlukvouu18"},{"post_id":"cix2l6cb200plc2xl5b9caggl","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cb700ppc2xl87qtkiph"},{"post_id":"cix2l6cb200plc2xl5b9caggl","tag_id":"cix2l6brx0003c2xl4mq6xsp7","_id":"cix2l6cb700pqc2xl1y1m449h"},{"post_id":"cix2l6cb200plc2xl5b9caggl","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6cb700prc2xlxn9lqj9z"},{"post_id":"cix2l6cb200plc2xl5b9caggl","tag_id":"cix2l6bry0006c2xlm8gllv7h","_id":"cix2l6cb700psc2xl6knnjwgo"},{"post_id":"cix2l6cb900ptc2xlqa5g371x","tag_id":"cix2l6ca200olc2xl0hipr5lo","_id":"cix2l6cbc00pwc2xl80ng030q"},{"post_id":"cix2l6cb900ptc2xlqa5g371x","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cbe00pxc2xlttyzjxql"},{"post_id":"cix2l6cb900ptc2xlqa5g371x","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6cbe00pyc2xlv0w4kyka"},{"post_id":"cix2l6cb900ptc2xlqa5g371x","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6cbe00pzc2xl93ksu2r9"},{"post_id":"cix2l6cb900ptc2xlqa5g371x","tag_id":"cix2l6cbb00pvc2xlcxypt001","_id":"cix2l6cbe00q0c2xlwhibjm25"},{"post_id":"cix2l6cb900ptc2xlqa5g371x","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6cbe00q1c2xle5629sd8"},{"post_id":"cix2l6cbg00q2c2xlfl2zijy5","tag_id":"cix2l6ca200olc2xl0hipr5lo","_id":"cix2l6cbk00q6c2xldy6m2hjk"},{"post_id":"cix2l6cbg00q2c2xlfl2zijy5","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cbm00q7c2xlaj7xsbwf"},{"post_id":"cix2l6cbg00q2c2xlfl2zijy5","tag_id":"cix2l6cbi00q4c2xln0k6n9xo","_id":"cix2l6cbm00q8c2xlnj3gvdqm"},{"post_id":"cix2l6cbg00q2c2xlfl2zijy5","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6cbm00q9c2xls2tzi0bp"},{"post_id":"cix2l6cbg00q2c2xlfl2zijy5","tag_id":"cix2l6cbj00q5c2xl1du7z26p","_id":"cix2l6cbm00qac2xlzy7h7a7b"},{"post_id":"cix2l6cbn00qbc2xl7v5sx37n","tag_id":"cix2l6ca200olc2xl0hipr5lo","_id":"cix2l6cbq00qdc2xljk6wkr6f"},{"post_id":"cix2l6cbn00qbc2xl7v5sx37n","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cbs00qec2xl770ae3nv"},{"post_id":"cix2l6cbn00qbc2xl7v5sx37n","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6cbs00qfc2xlwoc7jco2"},{"post_id":"cix2l6cbn00qbc2xl7v5sx37n","tag_id":"cix2l6bwz0063c2xlh8ly3fo3","_id":"cix2l6cbs00qgc2xlr2q9v19o"},{"post_id":"cix2l6cbn00qbc2xl7v5sx37n","tag_id":"cix2l6bwe0051c2xllpdw4hf2","_id":"cix2l6cbs00qhc2xl676zvyh1"},{"post_id":"cix2l6cbt00qic2xlhyboh5bi","tag_id":"cix2l6ca200olc2xl0hipr5lo","_id":"cix2l6cbv00qkc2xl5vgphrfr"},{"post_id":"cix2l6cbt00qic2xlhyboh5bi","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cbx00qlc2xl6vxoctjj"},{"post_id":"cix2l6cbt00qic2xlhyboh5bi","tag_id":"cix2l6c4k00hwc2xlg2jpx39j","_id":"cix2l6cbx00qmc2xll0ehnxqk"},{"post_id":"cix2l6cbt00qic2xlhyboh5bi","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6cbx00qnc2xlwlumrobj"},{"post_id":"cix2l6cby00qoc2xlwc42qho2","tag_id":"cix2l6ca200olc2xl0hipr5lo","_id":"cix2l6cc000qqc2xlttwelvs6"},{"post_id":"cix2l6cby00qoc2xlwc42qho2","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cc200qrc2xluz4cdzl9"},{"post_id":"cix2l6cby00qoc2xlwc42qho2","tag_id":"cix2l6bzr00a9c2xluebmxms0","_id":"cix2l6cc200qsc2xlk7eqz7qc"},{"post_id":"cix2l6cby00qoc2xlwc42qho2","tag_id":"cix2l6bte001ic2xld1gajghb","_id":"cix2l6cc200qtc2xloe80m2cb"},{"post_id":"cix2l6cc300quc2xliza3k2sd","tag_id":"cix2l6ca200olc2xl0hipr5lo","_id":"cix2l6cc600qxc2xl6mxfas4y"},{"post_id":"cix2l6cc300quc2xliza3k2sd","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cc800qyc2xl5rb7bjkc"},{"post_id":"cix2l6cc300quc2xliza3k2sd","tag_id":"cix2l6cc500qwc2xlckxpvh8b","_id":"cix2l6cc800qzc2xltuj3hzx3"},{"post_id":"cix2l6cc300quc2xliza3k2sd","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6cc800r0c2xlzdigy4id"},{"post_id":"cix2l6cc900r1c2xl5prwgqg9","tag_id":"cix2l6ca200olc2xl0hipr5lo","_id":"cix2l6ccb00r3c2xl7707np5z"},{"post_id":"cix2l6cc900r1c2xl5prwgqg9","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6ccd00r4c2xlz14xvo7a"},{"post_id":"cix2l6cc900r1c2xl5prwgqg9","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6ccd00r5c2xlfq69is4i"},{"post_id":"cix2l6cc900r1c2xl5prwgqg9","tag_id":"cix2l6bub002yc2xlx0vn80a9","_id":"cix2l6ccd00r6c2xlmby5fja1"},{"post_id":"cix2l6cce00r7c2xl14zkxu1u","tag_id":"cix2l6ca200olc2xl0hipr5lo","_id":"cix2l6cch00r9c2xlgdwmtmvb"},{"post_id":"cix2l6cce00r7c2xl14zkxu1u","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6ccj00rac2xl6vs56eiz"},{"post_id":"cix2l6cce00r7c2xl14zkxu1u","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6ccj00rbc2xlzxnvshu5"},{"post_id":"cix2l6cce00r7c2xl14zkxu1u","tag_id":"cix2l6bx3006bc2xlhxm1aa0p","_id":"cix2l6ccj00rcc2xl9z8ikyhp"},{"post_id":"cix2l6cck00rdc2xlc04v9w81","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6ccp00rhc2xlvq0fx9xs"},{"post_id":"cix2l6cck00rdc2xlc04v9w81","tag_id":"cix2l6ca200olc2xl0hipr5lo","_id":"cix2l6ccr00ric2xl70hb8t9f"},{"post_id":"cix2l6cck00rdc2xlc04v9w81","tag_id":"cix2l6ccm00rfc2xlj9no12qt","_id":"cix2l6ccr00rjc2xlfatg74f4"},{"post_id":"cix2l6cck00rdc2xlc04v9w81","tag_id":"cix2l6bx9006kc2xl8ligd8yv","_id":"cix2l6ccr00rkc2xl65oo625f"},{"post_id":"cix2l6cck00rdc2xlc04v9w81","tag_id":"cix2l6cco00rgc2xlkarmc1gx","_id":"cix2l6ccr00rlc2xl7w840stt"},{"post_id":"cix2l6cdh00rmc2xl7v3m0v3k","tag_id":"cix2l6ca200olc2xl0hipr5lo","_id":"cix2l6cdl00rpc2xlplsh4kg5"},{"post_id":"cix2l6cdh00rmc2xl7v3m0v3k","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cdo00rqc2xlbh58po3z"},{"post_id":"cix2l6cdh00rmc2xl7v3m0v3k","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6cdo00rrc2xlu02lnmma"},{"post_id":"cix2l6cdh00rmc2xl7v3m0v3k","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6cdp00rsc2xlkwpvmv7v"},{"post_id":"cix2l6cdh00rmc2xl7v3m0v3k","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6cdp00rtc2xljfv1ec3h"},{"post_id":"cix2l6cdh00rmc2xl7v3m0v3k","tag_id":"cix2l6bt20014c2xlf6zchc9m","_id":"cix2l6cdp00ruc2xle32ak7p6"},{"post_id":"cix2l6cdh00rmc2xl7v3m0v3k","tag_id":"cix2l6cdk00roc2xl0mop3e11","_id":"cix2l6cdp00rvc2xl5plw3040"},{"post_id":"cix2l6cdh00rmc2xl7v3m0v3k","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6cdp00rwc2xldedzvj1m"},{"post_id":"cix2l6cdq00rxc2xlay02lzkk","tag_id":"cix2l6ca200olc2xl0hipr5lo","_id":"cix2l6cdt00rzc2xl01947wfb"},{"post_id":"cix2l6cdq00rxc2xlay02lzkk","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cdw00s0c2xlmgjw17s3"},{"post_id":"cix2l6cdq00rxc2xlay02lzkk","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6cdw00s1c2xlfpe3v0a4"},{"post_id":"cix2l6cdq00rxc2xlay02lzkk","tag_id":"cix2l6bx9006jc2xl21zjnyx6","_id":"cix2l6cdw00s2c2xll7h6vll8"},{"post_id":"cix2l6cdq00rxc2xlay02lzkk","tag_id":"cix2l6bry0006c2xlm8gllv7h","_id":"cix2l6cdw00s3c2xlqa9770oj"},{"post_id":"cix2l6cdq00rxc2xlay02lzkk","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6cdw00s4c2xlebs3iuku"},{"post_id":"cix2l6cdx00s5c2xl39w35ogs","tag_id":"cix2l6ca200olc2xl0hipr5lo","_id":"cix2l6ce000s7c2xlfroafkn6"},{"post_id":"cix2l6cdx00s5c2xl39w35ogs","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6ce200s8c2xlft4f1nhm"},{"post_id":"cix2l6cdx00s5c2xl39w35ogs","tag_id":"cix2l6bx9006jc2xl21zjnyx6","_id":"cix2l6ce300s9c2xlyqqftgls"},{"post_id":"cix2l6cdx00s5c2xl39w35ogs","tag_id":"cix2l6bry0006c2xlm8gllv7h","_id":"cix2l6ce300sac2xl1r6d8o1b"},{"post_id":"cix2l6cdx00s5c2xl39w35ogs","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6ce300sbc2xl60m0axqf"},{"post_id":"cix2l6ce300scc2xla2jph1yg","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6ce700sec2xlb5wv2rkx"},{"post_id":"cix2l6ce300scc2xla2jph1yg","tag_id":"cix2l6ca200olc2xl0hipr5lo","_id":"cix2l6ce800sfc2xldk0t68pj"},{"post_id":"cix2l6ce300scc2xla2jph1yg","tag_id":"cix2l6c1k00cwc2xltzt3umv8","_id":"cix2l6ce800sgc2xlsp6homx5"},{"post_id":"cix2l6cea00shc2xlzm3j55me","tag_id":"cix2l6ced00sjc2xludjl9rln","_id":"cix2l6cef00skc2xlrxhtlmii"},{"post_id":"cix2l6cea00shc2xlzm3j55me","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6ceh00slc2xlewncefdt"},{"post_id":"cix2l6cea00shc2xlzm3j55me","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6ceh00smc2xl5vtexdcx"},{"post_id":"cix2l6cea00shc2xlzm3j55me","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6ceh00snc2xlhdqn22v6"},{"post_id":"cix2l6cem00soc2xls64g54ho","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6ceo00sqc2xl0kfs3p2o"},{"post_id":"cix2l6cem00soc2xls64g54ho","tag_id":"cix2l6bwa004pc2xlfep7re8c","_id":"cix2l6ceq00src2xlrkxu73xa"},{"post_id":"cix2l6cem00soc2xls64g54ho","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6ceq00ssc2xl32mzhe6s"},{"post_id":"cix2l6cem00soc2xls64g54ho","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6ceq00stc2xlwwdclc03"},{"post_id":"cix2l6cem00soc2xls64g54ho","tag_id":"cix2l6bwa004qc2xlqnw3w3ri","_id":"cix2l6ceq00suc2xl305y8gdb"},{"post_id":"cix2l6cer00svc2xln823gqim","tag_id":"cix2l6btq0020c2xlllnmvl4u","_id":"cix2l6cev00sxc2xlk3lbfk3e"},{"post_id":"cix2l6cer00svc2xln823gqim","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6cex00syc2xlab0fbz8w"},{"post_id":"cix2l6cer00svc2xln823gqim","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6cex00szc2xliz4cwonr"},{"post_id":"cix2l6cer00svc2xln823gqim","tag_id":"cix2l6bry0006c2xlm8gllv7h","_id":"cix2l6cex00t0c2xll0kpnrth"},{"post_id":"cix2l6cer00svc2xln823gqim","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6cex00t1c2xlicqqs7hz"},{"post_id":"cix2l6cey00t2c2xl1uqvp0r4","tag_id":"cix2l6cf300t4c2xlm4mno1ve","_id":"cix2l6cf500t5c2xl4iana7sc"},{"post_id":"cix2l6cey00t2c2xl1uqvp0r4","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6cf600t6c2xlidz4amp2"},{"post_id":"cix2l6cey00t2c2xl1uqvp0r4","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6cf600t7c2xlome43tt7"},{"post_id":"cix2l6cf800t8c2xlmfscwldu","tag_id":"cix2l6cfb00tac2xlhx2talym","_id":"cix2l6cfh00tcc2xlai25i4z4"},{"post_id":"cix2l6cf800t8c2xlmfscwldu","tag_id":"cix2l6c4j00hvc2xlt9thv2lh","_id":"cix2l6cfm00tdc2xl74kmu0km"},{"post_id":"cix2l6cf800t8c2xlmfscwldu","tag_id":"cix2l6c4p00i3c2xlxkmyp1eu","_id":"cix2l6cfm00tec2xlog56otg7"},{"post_id":"cix2l6cf800t8c2xlmfscwldu","tag_id":"cix2l6c3300fjc2xllz8yew7g","_id":"cix2l6cfm00tfc2xlheozdi61"},{"post_id":"cix2l6cf800t8c2xlmfscwldu","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6cfm00tgc2xlttrsnrw2"},{"post_id":"cix2l6cf800t8c2xlmfscwldu","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6cfm00thc2xlakvabzes"},{"post_id":"cix2l6cf800t8c2xlmfscwldu","tag_id":"cix2l6c1k00cwc2xltzt3umv8","_id":"cix2l6cfn00tic2xl95mmb83r"},{"post_id":"cix2l6cf800t8c2xlmfscwldu","tag_id":"cix2l6cfd00tbc2xliu07hzyl","_id":"cix2l6cfn00tjc2xllvsfaj38"},{"post_id":"cix2l6cf800t8c2xlmfscwldu","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6cfn00tkc2xlx47xg304"},{"post_id":"cix2l6cfu00tnc2xlvjxdiny8","tag_id":"cix2l6c2c00e8c2xl7n4dn713","_id":"cix2l6cfy00tpc2xl78tx6xy7"},{"post_id":"cix2l6cfu00tnc2xlvjxdiny8","tag_id":"cix2l6c2b00e7c2xlodn8a4nq","_id":"cix2l6cg100tqc2xliazux38u"},{"post_id":"cix2l6cfu00tnc2xlvjxdiny8","tag_id":"cix2l6bx9006jc2xl21zjnyx6","_id":"cix2l6cg100trc2xlhwgcs1w6"},{"post_id":"cix2l6cfu00tnc2xlvjxdiny8","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6cg100tsc2xlgr74va8v"},{"post_id":"cix2l6cfu00tnc2xlvjxdiny8","tag_id":"cix2l6bry0006c2xlm8gllv7h","_id":"cix2l6cg100ttc2xlidhmcxf5"},{"post_id":"cix2l6cfu00tnc2xlvjxdiny8","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6cg100tuc2xlcukp3sey"},{"post_id":"cix2l6cg200tvc2xldrn3l8co","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6cg600txc2xlwq55y6an"},{"post_id":"cix2l6cg200tvc2xldrn3l8co","tag_id":"cix2l6c4k00hwc2xlg2jpx39j","_id":"cix2l6cg800tyc2xlyqcp46sh"},{"post_id":"cix2l6cg200tvc2xldrn3l8co","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6cg800tzc2xl1gj06za0"},{"post_id":"cix2l6cg200tvc2xldrn3l8co","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6cg800u0c2xlv4j9xdjr"},{"post_id":"cix2l6cg200tvc2xldrn3l8co","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6cg800u1c2xl95idqiyu"},{"post_id":"cix2l6cg900u2c2xl5k11bdgb","tag_id":"cix2l6cgc00u4c2xls6kc7fm1","_id":"cix2l6cgg00u6c2xlkktfahgh"},{"post_id":"cix2l6cg900u2c2xl5k11bdgb","tag_id":"cix2l6cgf00u5c2xl3wledtm7","_id":"cix2l6cgi00u7c2xl63fatsoc"},{"post_id":"cix2l6cg900u2c2xl5k11bdgb","tag_id":"cix2l6c2h00ekc2xlifaivm0i","_id":"cix2l6cgi00u8c2xl326xklj1"},{"post_id":"cix2l6cg900u2c2xl5k11bdgb","tag_id":"cix2l6c0h00bic2xlug85j0rs","_id":"cix2l6cgj00u9c2xlumuarbto"},{"post_id":"cix2l6cgk00uac2xloq8g88ro","tag_id":"cix2l6cgc00u4c2xls6kc7fm1","_id":"cix2l6cgo00ucc2xl2873cq2e"},{"post_id":"cix2l6cgk00uac2xloq8g88ro","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6cgq00udc2xl31peh2be"},{"post_id":"cix2l6cgk00uac2xloq8g88ro","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6cgq00uec2xlkml7cil4"},{"post_id":"cix2l6cgk00uac2xloq8g88ro","tag_id":"cix2l6bu6002qc2xl8k4xwvuw","_id":"cix2l6cgq00ufc2xl98dnhgck"},{"post_id":"cix2l6cgk00uac2xloq8g88ro","tag_id":"cix2l6c7600khc2xllu0wv0rd","_id":"cix2l6cgr00ugc2xlq2xd5235"},{"post_id":"cix2l6cgs00uhc2xlltiuxm68","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cgx00ukc2xli3f1qq90"},{"post_id":"cix2l6cgs00uhc2xlltiuxm68","tag_id":"cix2l6cgc00u4c2xls6kc7fm1","_id":"cix2l6ch000ulc2xlqm83f2pp"},{"post_id":"cix2l6cgs00uhc2xlltiuxm68","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6ch000umc2xlbifjhn3z"},{"post_id":"cix2l6cgs00uhc2xlltiuxm68","tag_id":"cix2l6bx3006bc2xlhxm1aa0p","_id":"cix2l6ch000unc2xlx5mxn54v"},{"post_id":"cix2l6cgs00uhc2xlltiuxm68","tag_id":"cix2l6bwj0059c2xlp2z4w5xl","_id":"cix2l6ch000uoc2xl0irxy304"},{"post_id":"cix2l6cgs00uhc2xlltiuxm68","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6ch000upc2xlhpc23xxu"},{"post_id":"cix2l6cgs00uhc2xlltiuxm68","tag_id":"cix2l6cgv00ujc2xlr86rk7qt","_id":"cix2l6ch000uqc2xlh1f0wj2m"},{"post_id":"cix2l6ch100urc2xlvr7fw9x4","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6ch700uuc2xlc12guyx6"},{"post_id":"cix2l6ch100urc2xlvr7fw9x4","tag_id":"cix2l6cgc00u4c2xls6kc7fm1","_id":"cix2l6cha00uvc2xlmhxevbxn"},{"post_id":"cix2l6ch100urc2xlvr7fw9x4","tag_id":"cix2l6ch500utc2xlr3bp525f","_id":"cix2l6cha00uwc2xlrsmq2643"},{"post_id":"cix2l6ch100urc2xlvr7fw9x4","tag_id":"cix2l6c2t00f1c2xlpcqtvvg8","_id":"cix2l6cha00uxc2xl7a1b2q7z"},{"post_id":"cix2l6ch100urc2xlvr7fw9x4","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6cha00uyc2xlnqtuqrmk"},{"post_id":"cix2l6ch100urc2xlvr7fw9x4","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6cha00uzc2xlqgi8f0ba"},{"post_id":"cix2l6chb00v0c2xl0ekuj2ko","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6chf00v2c2xlzsr4a245"},{"post_id":"cix2l6chb00v0c2xl0ekuj2ko","tag_id":"cix2l6cgc00u4c2xls6kc7fm1","_id":"cix2l6chh00v3c2xlxntotc90"},{"post_id":"cix2l6chb00v0c2xl0ekuj2ko","tag_id":"cix2l6c1k00cwc2xltzt3umv8","_id":"cix2l6chh00v4c2xl19botdrl"},{"post_id":"cix2l6chb00v0c2xl0ekuj2ko","tag_id":"cix2l6bx8006ic2xlanfcs0th","_id":"cix2l6chi00v5c2xlxnd5tb0r"},{"post_id":"cix2l6chj00v6c2xlqpdg3ocj","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cho00v8c2xl0ukqucro"},{"post_id":"cix2l6chj00v6c2xlqpdg3ocj","tag_id":"cix2l6cgc00u4c2xls6kc7fm1","_id":"cix2l6chr00v9c2xlpu5vv38b"},{"post_id":"cix2l6chj00v6c2xlqpdg3ocj","tag_id":"cix2l6bx9006jc2xl21zjnyx6","_id":"cix2l6chr00vac2xleewt1sue"},{"post_id":"cix2l6chj00v6c2xlqpdg3ocj","tag_id":"cix2l6c7q00ldc2xlltyylx9y","_id":"cix2l6chr00vbc2xl1f5wo75p"},{"post_id":"cix2l6chj00v6c2xlqpdg3ocj","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6chr00vcc2xla6jwwgja"},{"post_id":"cix2l6chs00vdc2xlb6u1m4b9","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6chw00vfc2xlbd8j8anx"},{"post_id":"cix2l6chs00vdc2xlb6u1m4b9","tag_id":"cix2l6cgc00u4c2xls6kc7fm1","_id":"cix2l6chy00vgc2xl6hxjm086"},{"post_id":"cix2l6chs00vdc2xlb6u1m4b9","tag_id":"cix2l6bx9006jc2xl21zjnyx6","_id":"cix2l6chy00vhc2xlo0efd4fs"},{"post_id":"cix2l6chs00vdc2xlb6u1m4b9","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6chy00vic2xlmdd0fdjg"},{"post_id":"cix2l6chs00vdc2xlb6u1m4b9","tag_id":"cix2l6bry0006c2xlm8gllv7h","_id":"cix2l6chy00vjc2xlkk67tza3"},{"post_id":"cix2l6chz00vkc2xlhma496vk","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6ci300vmc2xlw7t4mc0z"},{"post_id":"cix2l6chz00vkc2xlhma496vk","tag_id":"cix2l6cgc00u4c2xls6kc7fm1","_id":"cix2l6ci500vnc2xlrl3jus40"},{"post_id":"cix2l6chz00vkc2xlhma496vk","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6ci500voc2xln8gtw6tz"},{"post_id":"cix2l6chz00vkc2xlhma496vk","tag_id":"cix2l6bwe0051c2xllpdw4hf2","_id":"cix2l6ci500vpc2xlxjg2xgr8"},{"post_id":"cix2l6ci600vqc2xlsfb6onqi","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cia00vsc2xliyxahed1"},{"post_id":"cix2l6ci600vqc2xlsfb6onqi","tag_id":"cix2l6cgc00u4c2xls6kc7fm1","_id":"cix2l6cic00vtc2xlsx2o5667"},{"post_id":"cix2l6ci600vqc2xlsfb6onqi","tag_id":"cix2l6cfd00tbc2xliu07hzyl","_id":"cix2l6cic00vuc2xl6v5fgo4c"},{"post_id":"cix2l6ci600vqc2xlsfb6onqi","tag_id":"cix2l6c4000h2c2xl0ymvmkpr","_id":"cix2l6cic00vvc2xlh3aip27z"},{"post_id":"cix2l6cid00vwc2xllxfci3g6","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cih00vyc2xlxd4vkk4l"},{"post_id":"cix2l6cid00vwc2xllxfci3g6","tag_id":"cix2l6cgc00u4c2xls6kc7fm1","_id":"cix2l6cii00vzc2xlnp8wgv8f"},{"post_id":"cix2l6cid00vwc2xllxfci3g6","tag_id":"cix2l6bte001ic2xld1gajghb","_id":"cix2l6cii00w0c2xlc2c7l1n0"},{"post_id":"cix2l6cij00w1c2xldyt70jjs","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cio00w4c2xlnnvftwsu"},{"post_id":"cix2l6cij00w1c2xldyt70jjs","tag_id":"cix2l6cgc00u4c2xls6kc7fm1","_id":"cix2l6cir00w5c2xlak8puqtn"},{"post_id":"cix2l6cij00w1c2xldyt70jjs","tag_id":"cix2l6cim00w3c2xl564hvwhm","_id":"cix2l6cir00w6c2xlwq8bial9"},{"post_id":"cix2l6cij00w1c2xldyt70jjs","tag_id":"cix2l6bte001ic2xld1gajghb","_id":"cix2l6cir00w7c2xlta14kj7m"},{"post_id":"cix2l6cit00w8c2xlh1zqq49r","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cix00wac2xlqf9f5tlz"},{"post_id":"cix2l6cit00w8c2xlh1zqq49r","tag_id":"cix2l6cgc00u4c2xls6kc7fm1","_id":"cix2l6cj000wbc2xlq2tjjv85"},{"post_id":"cix2l6cit00w8c2xlh1zqq49r","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6cj000wcc2xlnjyozvpw"},{"post_id":"cix2l6cit00w8c2xlh1zqq49r","tag_id":"cix2l6bx3006bc2xlhxm1aa0p","_id":"cix2l6cj000wdc2xlkquz8yu4"},{"post_id":"cix2l6cit00w8c2xlh1zqq49r","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6cj000wec2xl6j754dun"},{"post_id":"cix2l6cj100wfc2xlu4w1h8ti","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cj600whc2xls9w9x2ge"},{"post_id":"cix2l6cj100wfc2xlu4w1h8ti","tag_id":"cix2l6cgc00u4c2xls6kc7fm1","_id":"cix2l6cj800wic2xl5ylf7g51"},{"post_id":"cix2l6cj100wfc2xlu4w1h8ti","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6cj800wjc2xl8njnnnoz"},{"post_id":"cix2l6cj100wfc2xlu4w1h8ti","tag_id":"cix2l6bxo007jc2xlkcrgnf1u","_id":"cix2l6cj800wkc2xl9tcvdrjg"},{"post_id":"cix2l6cj900wlc2xl1sj7zor5","tag_id":"cix2l6cjc00wnc2xl02ddxhyj","_id":"cix2l6cjf00woc2xlcl7tcy2x"},{"post_id":"cix2l6cj900wlc2xl1sj7zor5","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cjh00wpc2xlav5jzu63"},{"post_id":"cix2l6cj900wlc2xl1sj7zor5","tag_id":"cix2l6ced00sjc2xludjl9rln","_id":"cix2l6cjh00wqc2xlunggw9dg"},{"post_id":"cix2l6cj900wlc2xl1sj7zor5","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6cjh00wrc2xl7d7yqgg5"},{"post_id":"cix2l6cji00wsc2xlwhl44dm1","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cjo00wvc2xlqxw4j1dv"},{"post_id":"cix2l6cji00wsc2xlwhl44dm1","tag_id":"cix2l6byy008uc2xlhu86f9mq","_id":"cix2l6cjr00wwc2xlzjzc9hcl"},{"post_id":"cix2l6cji00wsc2xlwhl44dm1","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6cjr00wxc2xli4al7qey"},{"post_id":"cix2l6cji00wsc2xlwhl44dm1","tag_id":"cix2l6cjm00wuc2xl1zipz2jh","_id":"cix2l6cjs00wyc2xljpwcebqi"},{"post_id":"cix2l6cji00wsc2xlwhl44dm1","tag_id":"cix2l6btx002ac2xls5nn914i","_id":"cix2l6cjs00wzc2xldp5upc1s"},{"post_id":"cix2l6cjt00x0c2xly13ge6ou","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cjz00x3c2xlww54tbjk"},{"post_id":"cix2l6cjt00x0c2xly13ge6ou","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6ck300x4c2xlymq5f2g8"},{"post_id":"cix2l6cjt00x0c2xly13ge6ou","tag_id":"cix2l6cjw00x2c2xl4bxhlmuf","_id":"cix2l6ck300x5c2xl01kvn709"},{"post_id":"cix2l6cjt00x0c2xly13ge6ou","tag_id":"cix2l6brx0003c2xl4mq6xsp7","_id":"cix2l6ck300x6c2xlzbnk0bnu"},{"post_id":"cix2l6cjt00x0c2xly13ge6ou","tag_id":"cix2l6c1l00cxc2xljmq6rska","_id":"cix2l6ck300x7c2xlmcfp4usn"},{"post_id":"cix2l6cjt00x0c2xly13ge6ou","tag_id":"cix2l6c0l00brc2xlrz9vwge8","_id":"cix2l6ck300x8c2xl4ww2l8oy"},{"post_id":"cix2l6ck400x9c2xlitwh7tcv","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6ck900xbc2xl5qlgmc5j"},{"post_id":"cix2l6ck400x9c2xlitwh7tcv","tag_id":"cix2l6cjw00x2c2xl4bxhlmuf","_id":"cix2l6ckc00xcc2xl2qcemn62"},{"post_id":"cix2l6ck400x9c2xlitwh7tcv","tag_id":"cix2l6cf300t4c2xlm4mno1ve","_id":"cix2l6ckc00xdc2xlfmjpwfdn"},{"post_id":"cix2l6ck400x9c2xlitwh7tcv","tag_id":"cix2l6c0h00bic2xlug85j0rs","_id":"cix2l6ckc00xec2xl27krbe6x"},{"post_id":"cix2l6ckd00xfc2xlcm2srjss","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cki00xic2xl1mqch437"},{"post_id":"cix2l6ckd00xfc2xlcm2srjss","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6ckl00xjc2xla5kpfngl"},{"post_id":"cix2l6ckd00xfc2xlcm2srjss","tag_id":"cix2l6cjw00x2c2xl4bxhlmuf","_id":"cix2l6ckl00xkc2xl3pgwk7lk"},{"post_id":"cix2l6ckd00xfc2xlcm2srjss","tag_id":"cix2l6brx0003c2xl4mq6xsp7","_id":"cix2l6ckl00xlc2xlavom5aud"},{"post_id":"cix2l6ckd00xfc2xlcm2srjss","tag_id":"cix2l6ckh00xhc2xls3xatgc5","_id":"cix2l6ckl00xmc2xluubt6do6"},{"post_id":"cix2l6ckm00xnc2xl09mej7dn","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6ckr00xpc2xlgys3b0p2"},{"post_id":"cix2l6ckm00xnc2xl09mej7dn","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6ckx00xqc2xloqwl2odj"},{"post_id":"cix2l6ckm00xnc2xl09mej7dn","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6ckx00xrc2xljabnmk1m"},{"post_id":"cix2l6ckm00xnc2xl09mej7dn","tag_id":"cix2l6cjw00x2c2xl4bxhlmuf","_id":"cix2l6ckx00xsc2xldclw16kq"},{"post_id":"cix2l6ckm00xnc2xl09mej7dn","tag_id":"cix2l6cgf00u5c2xl3wledtm7","_id":"cix2l6ckx00xtc2xla9965qot"},{"post_id":"cix2l6ckm00xnc2xl09mej7dn","tag_id":"cix2l6c1k00cwc2xltzt3umv8","_id":"cix2l6ckx00xuc2xll4h9bia5"},{"post_id":"cix2l6ckz00xvc2xl4owzq48v","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cl400xxc2xl6bwf3kak"},{"post_id":"cix2l6ckz00xvc2xl4owzq48v","tag_id":"cix2l6cjw00x2c2xl4bxhlmuf","_id":"cix2l6cl700xyc2xlhu4nam41"},{"post_id":"cix2l6ckz00xvc2xl4owzq48v","tag_id":"cix2l6btx002ac2xls5nn914i","_id":"cix2l6cl700xzc2xlncundkkv"},{"post_id":"cix2l6ckz00xvc2xl4owzq48v","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6cl700y0c2xlwb5rr5ti"},{"post_id":"cix2l6ckz00xvc2xl4owzq48v","tag_id":"cix2l6bxh0073c2xlzrgyofi2","_id":"cix2l6cl800y1c2xljnrtqzz6"},{"post_id":"cix2l6cl800y2c2xlfkyejj2n","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cld00y4c2xl4te5mxrz"},{"post_id":"cix2l6cl800y2c2xlfkyejj2n","tag_id":"cix2l6cjw00x2c2xl4bxhlmuf","_id":"cix2l6clf00y5c2xl689v6bk9"},{"post_id":"cix2l6cl800y2c2xlfkyejj2n","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6clf00y6c2xlrgr0zky5"},{"post_id":"cix2l6cl800y2c2xlfkyejj2n","tag_id":"cix2l6bvc003mc2xlzsn1jrh3","_id":"cix2l6clf00y7c2xltes4b0ig"},{"post_id":"cix2l6clh00y8c2xl0vbm2av4","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6clo00ybc2xl5p5t3xl9"},{"post_id":"cix2l6clh00y8c2xl0vbm2av4","tag_id":"cix2l6cjw00x2c2xl4bxhlmuf","_id":"cix2l6clx00ycc2xlerj5e5cn"},{"post_id":"cix2l6clh00y8c2xl0vbm2av4","tag_id":"cix2l6clm00yac2xli8haq2fp","_id":"cix2l6clx00ydc2xlixp2lr22"},{"post_id":"cix2l6clh00y8c2xl0vbm2av4","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6clx00yec2xlqu4u7sos"},{"post_id":"cix2l6clh00y8c2xl0vbm2av4","tag_id":"cix2l6bw0004ac2xl40e50m9d","_id":"cix2l6clx00yfc2xltrvsq2ey"},{"post_id":"cix2l6cly00ygc2xlcboq51r6","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cm200yic2xljkuu87h2"},{"post_id":"cix2l6cly00ygc2xlcboq51r6","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6cm500yjc2xlpd2d79h8"},{"post_id":"cix2l6cly00ygc2xlcboq51r6","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6cm500ykc2xlu4pmiwcc"},{"post_id":"cix2l6cly00ygc2xlcboq51r6","tag_id":"cix2l6cjw00x2c2xl4bxhlmuf","_id":"cix2l6cm500ylc2xlt63ilhll"},{"post_id":"cix2l6cly00ygc2xlcboq51r6","tag_id":"cix2l6btq001zc2xl1xyp27mz","_id":"cix2l6cm500ymc2xlfgxmoyzw"},{"post_id":"cix2l6cly00ygc2xlcboq51r6","tag_id":"cix2l6btq0020c2xlllnmvl4u","_id":"cix2l6cm500ync2xla3wz6mqb"},{"post_id":"cix2l6cly00ygc2xlcboq51r6","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6cm500yoc2xl97isf8t6"},{"post_id":"cix2l6cm600ypc2xlixlhq2v8","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cmf00ytc2xlce9slfm2"},{"post_id":"cix2l6cm600ypc2xlixlhq2v8","tag_id":"cix2l6cjw00x2c2xl4bxhlmuf","_id":"cix2l6cmi00yuc2xl8gsa5ez3"},{"post_id":"cix2l6cm600ypc2xlixlhq2v8","tag_id":"cix2l6cmb00yrc2xlayel59p2","_id":"cix2l6cmi00yvc2xleqqcecbc"},{"post_id":"cix2l6cm600ypc2xlixlhq2v8","tag_id":"cix2l6cmd00ysc2xl95xjgm34","_id":"cix2l6cmi00ywc2xlq17qcm8j"},{"post_id":"cix2l6cmj00yxc2xlx6xxhlrm","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cmp00yzc2xlekozbad1"},{"post_id":"cix2l6cmj00yxc2xlx6xxhlrm","tag_id":"cix2l6cjw00x2c2xl4bxhlmuf","_id":"cix2l6cmt00z0c2xlmdp9uw6p"},{"post_id":"cix2l6cmj00yxc2xlx6xxhlrm","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6cmt00z1c2xl11u0949z"},{"post_id":"cix2l6cmj00yxc2xlx6xxhlrm","tag_id":"cix2l6c4k00hwc2xlg2jpx39j","_id":"cix2l6cmt00z2c2xla5epb3y3"},{"post_id":"cix2l6cmj00yxc2xlx6xxhlrm","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6cmt00z3c2xl30na90o7"},{"post_id":"cix2l6cmj00yxc2xlx6xxhlrm","tag_id":"cix2l6bub002yc2xlx0vn80a9","_id":"cix2l6cmt00z4c2xlnydaxk97"},{"post_id":"cix2l6cmj00yxc2xlx6xxhlrm","tag_id":"cix2l6c1100cec2xln5pdkz26","_id":"cix2l6cmt00z5c2xl0hr4zq2y"},{"post_id":"cix2l6cmu00z6c2xls3xstv2v","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cmz00z9c2xl3uqbxv91"},{"post_id":"cix2l6cmu00z6c2xls3xstv2v","tag_id":"cix2l6cjw00x2c2xl4bxhlmuf","_id":"cix2l6cn100zac2xl1vm7eizn"},{"post_id":"cix2l6cmu00z6c2xls3xstv2v","tag_id":"cix2l6cmy00z8c2xlmjs0f8du","_id":"cix2l6cn100zbc2xlgsaejuv1"},{"post_id":"cix2l6cmu00z6c2xls3xstv2v","tag_id":"cix2l6c3v00gtc2xl3nyi6ovi","_id":"cix2l6cn100zcc2xldlrdp6ea"},{"post_id":"cix2l6cmu00z6c2xls3xstv2v","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6cn100zdc2xlnamjatxw"},{"post_id":"cix2l6cn200zec2xlr7qp5cyz","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cn500zgc2xl7p5p1c68"},{"post_id":"cix2l6cn200zec2xlr7qp5cyz","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6cn700zhc2xlmbm0253v"},{"post_id":"cix2l6cn200zec2xlr7qp5cyz","tag_id":"cix2l6cjw00x2c2xl4bxhlmuf","_id":"cix2l6cn700zic2xlg9mtyxge"},{"post_id":"cix2l6cn200zec2xlr7qp5cyz","tag_id":"cix2l6c2h00ejc2xltczoe27q","_id":"cix2l6cn700zjc2xlwgpioar1"},{"post_id":"cix2l6cn200zec2xlr7qp5cyz","tag_id":"cix2l6bxt007tc2xlta9yvqhe","_id":"cix2l6cn700zkc2xlbbis9ehr"},{"post_id":"cix2l6cn800zlc2xlepdlk3wo","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cnb00zoc2xlzzehuej8"},{"post_id":"cix2l6cn800zlc2xlepdlk3wo","tag_id":"cix2l6cjw00x2c2xl4bxhlmuf","_id":"cix2l6cnd00zpc2xlz1thlh5z"},{"post_id":"cix2l6cn800zlc2xlepdlk3wo","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6cnd00zqc2xlxvcjr2uu"},{"post_id":"cix2l6cn800zlc2xlepdlk3wo","tag_id":"cix2l6cna00znc2xlbe2v7kt6","_id":"cix2l6cnd00zrc2xlwkxls0pg"},{"post_id":"cix2l6cne00zsc2xlvj3qizzw","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cnh00zvc2xl82zy3g8h"},{"post_id":"cix2l6cne00zsc2xlvj3qizzw","tag_id":"cix2l6cng00zuc2xlo4lvp1qd","_id":"cix2l6cnj00zwc2xl8nno3tbn"},{"post_id":"cix2l6cne00zsc2xlvj3qizzw","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6cnj00zxc2xlipjbogv3"},{"post_id":"cix2l6cne00zsc2xlvj3qizzw","tag_id":"cix2l6bwe0051c2xllpdw4hf2","_id":"cix2l6cnj00zyc2xl2ygszn0y"},{"post_id":"cix2l6cnk00zzc2xlnwjx8ega","tag_id":"cix2l6cnm0101c2xlw1asdo5m","_id":"cix2l6cno0103c2xl9l44gbmo"},{"post_id":"cix2l6cnk00zzc2xlnwjx8ega","tag_id":"cix2l6cnn0102c2xlm3qrvcmj","_id":"cix2l6cnr0104c2xl1y46pcmk"},{"post_id":"cix2l6cnk00zzc2xlnwjx8ega","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6cnr0105c2xlefw3jgmc"},{"post_id":"cix2l6cnk00zzc2xlnwjx8ega","tag_id":"cix2l6bxo007jc2xlkcrgnf1u","_id":"cix2l6cnr0106c2xlco9eung0"},{"post_id":"cix2l6cnk00zzc2xlnwjx8ega","tag_id":"cix2l6c1k00cwc2xltzt3umv8","_id":"cix2l6cnr0107c2xliqbu9esk"},{"post_id":"cix2l6cnk00zzc2xlnwjx8ega","tag_id":"cix2l6bx8006ic2xlanfcs0th","_id":"cix2l6cnr0108c2xlc5s4jpjg"},{"post_id":"cix2l6cnk00zzc2xlnwjx8ega","tag_id":"cix2l6bx9006kc2xl8ligd8yv","_id":"cix2l6cnr0109c2xlzpynyqqr"},{"post_id":"cix2l6cns010ac2xl973cjb8b","tag_id":"cix2l6cnm0101c2xlw1asdo5m","_id":"cix2l6cnw010dc2xl411fyeh0"},{"post_id":"cix2l6cns010ac2xl973cjb8b","tag_id":"cix2l6cnu010cc2xlq7tmwtf1","_id":"cix2l6cnx010ec2xlknuwx84j"},{"post_id":"cix2l6cns010ac2xl973cjb8b","tag_id":"cix2l6bw5004hc2xliqrfp4kr","_id":"cix2l6cnx010fc2xleqfsp02a"},{"post_id":"cix2l6cns010ac2xl973cjb8b","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6cnx010gc2xlobqzpubz"},{"post_id":"cix2l6cny010hc2xlcnsxg74l","tag_id":"cix2l6cnm0101c2xlw1asdo5m","_id":"cix2l6co1010jc2xlo2ugushv"},{"post_id":"cix2l6cny010hc2xlcnsxg74l","tag_id":"cix2l6bw5004hc2xliqrfp4kr","_id":"cix2l6co2010kc2xluow9qvmg"},{"post_id":"cix2l6cny010hc2xlcnsxg74l","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6co2010lc2xl2j2hv0ud"},{"post_id":"cix2l6co3010mc2xlaoa85tvp","tag_id":"cix2l6cnm0101c2xlw1asdo5m","_id":"cix2l6co5010oc2xl8p4zw072"},{"post_id":"cix2l6co3010mc2xlaoa85tvp","tag_id":"cix2l6bw5004hc2xliqrfp4kr","_id":"cix2l6co6010pc2xlgaimh6po"},{"post_id":"cix2l6co3010mc2xlaoa85tvp","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6co6010qc2xl4cibcykl"},{"post_id":"cix2l6co7010rc2xlf2ck7v97","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cob010uc2xlmk84u56d"},{"post_id":"cix2l6co7010rc2xlf2ck7v97","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6cod010vc2xly8qdbvle"},{"post_id":"cix2l6co7010rc2xlf2ck7v97","tag_id":"cix2l6co9010tc2xljfmesvht","_id":"cix2l6cod010wc2xla8jwnyf6"},{"post_id":"cix2l6co7010rc2xlf2ck7v97","tag_id":"cix2l6c3e00fxc2xlm2nhl5xr","_id":"cix2l6cod010xc2xlwwh5gakq"},{"post_id":"cix2l6co7010rc2xlf2ck7v97","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6cod010yc2xl4rmo20q7"},{"post_id":"cix2l6coe010zc2xlo3rb9c3n","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6coh0111c2xldhdf6ycf"},{"post_id":"cix2l6coe010zc2xlo3rb9c3n","tag_id":"cix2l6co9010tc2xljfmesvht","_id":"cix2l6coj0112c2xls1e8x56e"},{"post_id":"cix2l6coe010zc2xlo3rb9c3n","tag_id":"cix2l6brx0003c2xl4mq6xsp7","_id":"cix2l6coj0113c2xlg7hlbls6"},{"post_id":"cix2l6coe010zc2xlo3rb9c3n","tag_id":"cix2l6bry0004c2xlbo1rvuu2","_id":"cix2l6coj0114c2xlm5471mb5"},{"post_id":"cix2l6coe010zc2xlo3rb9c3n","tag_id":"cix2l6ckh00xhc2xls3xatgc5","_id":"cix2l6coj0115c2xlcmahkgq9"},{"post_id":"cix2l6cok0116c2xl16ozicb9","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6coo0119c2xlg4n6vjwh"},{"post_id":"cix2l6cok0116c2xl16ozicb9","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6cor011ac2xl0vtb7gnu"},{"post_id":"cix2l6cok0116c2xl16ozicb9","tag_id":"cix2l6co9010tc2xljfmesvht","_id":"cix2l6cor011bc2xly9n1f4z6"},{"post_id":"cix2l6cok0116c2xl16ozicb9","tag_id":"cix2l6con0118c2xlp3um23qw","_id":"cix2l6cor011cc2xlh6sznztq"},{"post_id":"cix2l6cok0116c2xl16ozicb9","tag_id":"cix2l6bwa004pc2xlfep7re8c","_id":"cix2l6cor011dc2xl5ny3chgl"},{"post_id":"cix2l6cok0116c2xl16ozicb9","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6cor011ec2xlfmus0yw2"},{"post_id":"cix2l6cok0116c2xl16ozicb9","tag_id":"cix2l6c0600awc2xlaldzn55u","_id":"cix2l6cor011fc2xlm6egj5fp"},{"post_id":"cix2l6cos011gc2xl4xw2ftu1","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cov011ic2xlvbt6aypk"},{"post_id":"cix2l6cos011gc2xl4xw2ftu1","tag_id":"cix2l6co9010tc2xljfmesvht","_id":"cix2l6cow011jc2xld5llr66q"},{"post_id":"cix2l6cos011gc2xl4xw2ftu1","tag_id":"cix2l6c8n00mqc2xlphdzc6hg","_id":"cix2l6cow011kc2xlp0jajogi"},{"post_id":"cix2l6cos011gc2xl4xw2ftu1","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6cow011lc2xl4ayar3cu"},{"post_id":"cix2l6cox011mc2xlvejxcxpg","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cp0011oc2xlnbo4ybst"},{"post_id":"cix2l6cox011mc2xlvejxcxpg","tag_id":"cix2l6co9010tc2xljfmesvht","_id":"cix2l6cp2011pc2xlndyqeu80"},{"post_id":"cix2l6cox011mc2xlvejxcxpg","tag_id":"cix2l6cax00pdc2xlcci3d4bu","_id":"cix2l6cp2011qc2xlmh752jt9"},{"post_id":"cix2l6cox011mc2xlvejxcxpg","tag_id":"cix2l6bx9006jc2xl21zjnyx6","_id":"cix2l6cp2011rc2xlzuyohdot"},{"post_id":"cix2l6cox011mc2xlvejxcxpg","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6cp2011sc2xlw2mk02zy"},{"post_id":"cix2l6cp3011tc2xlff8p9t24","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cp6011vc2xlsmhzayte"},{"post_id":"cix2l6cp3011tc2xlff8p9t24","tag_id":"cix2l6co9010tc2xljfmesvht","_id":"cix2l6cp8011wc2xlbm6z3ayl"},{"post_id":"cix2l6cp3011tc2xlff8p9t24","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6cp8011xc2xlco51ppxx"},{"post_id":"cix2l6cp3011tc2xlff8p9t24","tag_id":"cix2l6bvc003mc2xlzsn1jrh3","_id":"cix2l6cp8011yc2xlvrys6yuw"},{"post_id":"cix2l6cp8011zc2xlhd4h0stw","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cpb0121c2xlkjaht39l"},{"post_id":"cix2l6cp8011zc2xlhd4h0stw","tag_id":"cix2l6co9010tc2xljfmesvht","_id":"cix2l6cpd0122c2xlhuhc3e1g"},{"post_id":"cix2l6cp8011zc2xlhd4h0stw","tag_id":"cix2l6c7a00koc2xls3c7nuq6","_id":"cix2l6cpd0123c2xlkzwrfb79"},{"post_id":"cix2l6cp8011zc2xlhd4h0stw","tag_id":"cix2l6c7b00kpc2xll5wlx8bz","_id":"cix2l6cpd0124c2xl9aoma58j"},{"post_id":"cix2l6cpe0125c2xl8n6yz5ql","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cph0127c2xl964mcwyw"},{"post_id":"cix2l6cpe0125c2xl8n6yz5ql","tag_id":"cix2l6co9010tc2xljfmesvht","_id":"cix2l6cpk0128c2xlmqjhy47n"},{"post_id":"cix2l6cpe0125c2xl8n6yz5ql","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6cpk0129c2xl1yym0rqm"},{"post_id":"cix2l6cpe0125c2xl8n6yz5ql","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6cpk012ac2xlx0ybnw5d"},{"post_id":"cix2l6cpe0125c2xl8n6yz5ql","tag_id":"cix2l6bwe0051c2xllpdw4hf2","_id":"cix2l6cpk012bc2xla8fu3zbd"},{"post_id":"cix2l6cpe0125c2xl8n6yz5ql","tag_id":"cix2l6bvi003wc2xl9jvtord9","_id":"cix2l6cpk012cc2xlwio90rw7"},{"post_id":"cix2l6cpl012dc2xl1wt67ql5","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cpn012fc2xlaclo6g4w"},{"post_id":"cix2l6cpl012dc2xl1wt67ql5","tag_id":"cix2l6co9010tc2xljfmesvht","_id":"cix2l6cpp012gc2xlbymhscwu"},{"post_id":"cix2l6cpl012dc2xl1wt67ql5","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6cpp012hc2xlkx2t3whn"},{"post_id":"cix2l6cpp012ic2xlrnikueyi","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cpu012kc2xlxp9iddzp"},{"post_id":"cix2l6cpp012ic2xlrnikueyi","tag_id":"cix2l6co9010tc2xljfmesvht","_id":"cix2l6cpv012lc2xlkzdfbavr"},{"post_id":"cix2l6cpp012ic2xlrnikueyi","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6cpv012mc2xl5bpomysw"},{"post_id":"cix2l6cpw012nc2xltzkkizpe","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cpy012pc2xl3vnl5x8o"},{"post_id":"cix2l6cpw012nc2xltzkkizpe","tag_id":"cix2l6co9010tc2xljfmesvht","_id":"cix2l6cq0012qc2xlhdsgni06"},{"post_id":"cix2l6cpw012nc2xltzkkizpe","tag_id":"cix2l6btq0020c2xlllnmvl4u","_id":"cix2l6cq0012rc2xlfseoc1ax"},{"post_id":"cix2l6cq1012sc2xlrr6wbnho","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cq3012uc2xltn5j8c1e"},{"post_id":"cix2l6cq1012sc2xlrr6wbnho","tag_id":"cix2l6co9010tc2xljfmesvht","_id":"cix2l6cq5012vc2xleia9onfi"},{"post_id":"cix2l6cq1012sc2xlrr6wbnho","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6cq6012wc2xltmsyjh23"},{"post_id":"cix2l6cq1012sc2xlrr6wbnho","tag_id":"cix2l6c4000h2c2xl0ymvmkpr","_id":"cix2l6cq6012xc2xl3lroj8bp"},{"post_id":"cix2l6cq1012sc2xlrr6wbnho","tag_id":"cix2l6c4100h3c2xlojzbrv1p","_id":"cix2l6cq6012yc2xlh2e47ym4"},{"post_id":"cix2l6cq6012zc2xl9xz9zejh","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cq90131c2xlztc5hkal"},{"post_id":"cix2l6cq6012zc2xl9xz9zejh","tag_id":"cix2l6co9010tc2xljfmesvht","_id":"cix2l6cqb0132c2xln397s84x"},{"post_id":"cix2l6cq6012zc2xl9xz9zejh","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6cqb0133c2xl0y1qrcpy"},{"post_id":"cix2l6cq6012zc2xl9xz9zejh","tag_id":"cix2l6bte001ic2xld1gajghb","_id":"cix2l6cqb0134c2xln20hyuyx"},{"post_id":"cix2l6cqc0135c2xl7dqjqzy1","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cqf0137c2xlt7b9arao"},{"post_id":"cix2l6cqc0135c2xl7dqjqzy1","tag_id":"cix2l6co9010tc2xljfmesvht","_id":"cix2l6cqh0138c2xl361gpc10"},{"post_id":"cix2l6cqc0135c2xl7dqjqzy1","tag_id":"cix2l6c0700axc2xlgxp3vaf5","_id":"cix2l6cqh0139c2xlyf0lmth0"},{"post_id":"cix2l6cqc0135c2xl7dqjqzy1","tag_id":"cix2l6cim00w3c2xl564hvwhm","_id":"cix2l6cqh013ac2xlg2cwwm6g"},{"post_id":"cix2l6cqi013bc2xl858kef5z","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cql013dc2xlw37h3kxe"},{"post_id":"cix2l6cqi013bc2xl858kef5z","tag_id":"cix2l6co9010tc2xljfmesvht","_id":"cix2l6cqm013ec2xl8k2ixsjy"},{"post_id":"cix2l6cqi013bc2xl858kef5z","tag_id":"cix2l6c4000h2c2xl0ymvmkpr","_id":"cix2l6cqm013fc2xliu5dgrr5"},{"post_id":"cix2l6cqi013bc2xl858kef5z","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6cqn013gc2xlqxxmsh24"},{"post_id":"cix2l6cqn013hc2xlvdz4s7k4","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cqq013jc2xlsrtgtnee"},{"post_id":"cix2l6cqn013hc2xlvdz4s7k4","tag_id":"cix2l6co9010tc2xljfmesvht","_id":"cix2l6cqr013kc2xlvr4g224w"},{"post_id":"cix2l6cqn013hc2xlvdz4s7k4","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6cqs013lc2xlapl1cl18"},{"post_id":"cix2l6cqx013mc2xlnvvv4hr8","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cqz013oc2xlm24oun1m"},{"post_id":"cix2l6cqx013mc2xlnvvv4hr8","tag_id":"cix2l6co9010tc2xljfmesvht","_id":"cix2l6cr2013pc2xl8tfo3e6v"},{"post_id":"cix2l6cqx013mc2xlnvvv4hr8","tag_id":"cix2l6bxe006uc2xlqk5geg3s","_id":"cix2l6cr2013qc2xlrhb70b24"},{"post_id":"cix2l6cqx013mc2xlnvvv4hr8","tag_id":"cix2l6btx002ac2xls5nn914i","_id":"cix2l6cr2013rc2xl8b0xstjy"},{"post_id":"cix2l6cqx013mc2xlnvvv4hr8","tag_id":"cix2l6btx002bc2xlii39i8qq","_id":"cix2l6cr2013sc2xldw8pdd8i"},{"post_id":"cix2l6cr3013tc2xlgml7050a","tag_id":"cix2l6cr5013vc2xlx4c8h7q8","_id":"cix2l6cr7013xc2xlizcde1pf"},{"post_id":"cix2l6cr3013tc2xlgml7050a","tag_id":"cix2l6cr6013wc2xlhj5p97sd","_id":"cix2l6cr9013yc2xld5o2lk5u"},{"post_id":"cix2l6cr3013tc2xlgml7050a","tag_id":"cix2l6bxt007sc2xlghh13692","_id":"cix2l6cr9013zc2xln7vvuguq"},{"post_id":"cix2l6cr90140c2xl3gt869k0","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6crd0143c2xlvi8ovphg"},{"post_id":"cix2l6cr90140c2xl3gt869k0","tag_id":"cix2l6crb0142c2xlekgfcoo1","_id":"cix2l6crf0144c2xlh28jxo6p"},{"post_id":"cix2l6cr90140c2xl3gt869k0","tag_id":"cix2l6bw0004ac2xl40e50m9d","_id":"cix2l6crf0145c2xlywusue47"},{"post_id":"cix2l6crf0146c2xlscbb7cvw","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6crj0149c2xlel4eee0v"},{"post_id":"cix2l6crf0146c2xlscbb7cvw","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6crm014ac2xl6oumhn2u"},{"post_id":"cix2l6crf0146c2xlscbb7cvw","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6crm014bc2xltzbveb56"},{"post_id":"cix2l6crf0146c2xlscbb7cvw","tag_id":"cix2l6cri0148c2xl8dewe3uk","_id":"cix2l6crm014cc2xlrvsq190h"},{"post_id":"cix2l6crf0146c2xlscbb7cvw","tag_id":"cix2l6bwa004pc2xlfep7re8c","_id":"cix2l6crm014dc2xlada47dqs"},{"post_id":"cix2l6crf0146c2xlscbb7cvw","tag_id":"cix2l6c1100cfc2xlukvyrt3z","_id":"cix2l6crm014ec2xlcze6o730"},{"post_id":"cix2l6crn014fc2xl5q3vdtrh","tag_id":"cix2l6bsh000kc2xlm1grmv1m","_id":"cix2l6crq014hc2xlk7553ye9"},{"post_id":"cix2l6crn014fc2xl5q3vdtrh","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6crt014ic2xln4n09k1v"},{"post_id":"cix2l6crn014fc2xl5q3vdtrh","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6crt014jc2xl0vnb8d7d"},{"post_id":"cix2l6crn014fc2xl5q3vdtrh","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6crt014kc2xls8sy6m42"},{"post_id":"cix2l6crn014fc2xl5q3vdtrh","tag_id":"cix2l6cri0148c2xl8dewe3uk","_id":"cix2l6crt014lc2xl1t1yqc2y"},{"post_id":"cix2l6crt014mc2xl4olmhzgw","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6crw014oc2xlftzj3kvl"},{"post_id":"cix2l6crt014mc2xl4olmhzgw","tag_id":"cix2l6bwa004pc2xlfep7re8c","_id":"cix2l6crz014pc2xlynd5tn1h"},{"post_id":"cix2l6crt014mc2xl4olmhzgw","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6crz014qc2xls0osnsbm"},{"post_id":"cix2l6crt014mc2xl4olmhzgw","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6crz014rc2xl2e9hmrsx"},{"post_id":"cix2l6crt014mc2xl4olmhzgw","tag_id":"cix2l6c0600awc2xlaldzn55u","_id":"cix2l6crz014sc2xlallfu1j9"},{"post_id":"cix2l6cs0014tc2xlbdr5e22e","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6cs3014vc2xlvykbf0u0"},{"post_id":"cix2l6cs0014tc2xlbdr5e22e","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6cs6014wc2xlt4v4jvf6"},{"post_id":"cix2l6cs0014tc2xlbdr5e22e","tag_id":"cix2l6bsr000uc2xlhetrx95o","_id":"cix2l6cs6014xc2xlrqhvgmpz"},{"post_id":"cix2l6cs0014tc2xlbdr5e22e","tag_id":"cix2l6bst000vc2xl1kukczvd","_id":"cix2l6cs6014yc2xlx00hu7q5"},{"post_id":"cix2l6cs0014tc2xlbdr5e22e","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6cs6014zc2xl804qvgdy"},{"post_id":"cix2l6cs0014tc2xlbdr5e22e","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6cs60150c2xlzve4stb1"},{"post_id":"cix2l6cs70151c2xles9j0qa2","tag_id":"cix2l6cs90153c2xlm3390uc6","_id":"cix2l6csb0155c2xltcbkt40e"},{"post_id":"cix2l6cs70151c2xles9j0qa2","tag_id":"cix2l6csa0154c2xlrkw7c4z0","_id":"cix2l6csc0156c2xloya2rko6"},{"post_id":"cix2l6cse0157c2xlubh2j54s","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6csh0159c2xla114v1fu"},{"post_id":"cix2l6cse0157c2xlubh2j54s","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6csk015ac2xljuoyzouy"},{"post_id":"cix2l6cse0157c2xlubh2j54s","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6csk015bc2xlawe433d7"},{"post_id":"cix2l6cse0157c2xlubh2j54s","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6csk015cc2xlur642qwy"},{"post_id":"cix2l6cse0157c2xlubh2j54s","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6csk015dc2xl4twd91me"},{"post_id":"cix2l6csk015ec2xlkjzbnick","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6cso015gc2xlnpb4x2xe"},{"post_id":"cix2l6csk015ec2xlkjzbnick","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6csp015hc2xlueazha4e"},{"post_id":"cix2l6csk015ec2xlkjzbnick","tag_id":"cix2l6c0000alc2xl6bt8foyz","_id":"cix2l6csp015ic2xl1eary7mu"},{"post_id":"cix2l6csz015rc2xls7mzmm9b","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6ct4015vc2xlzv53ebvc"},{"post_id":"cix2l6csz015rc2xls7mzmm9b","tag_id":"cix2l6ct2015tc2xlldttpyg8","_id":"cix2l6ct8015wc2xlh3p79eo1"},{"post_id":"cix2l6csz015rc2xls7mzmm9b","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6ct8015xc2xlotjoz2k9"},{"post_id":"cix2l6csz015rc2xls7mzmm9b","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6cta015yc2xlibjm6jed"},{"post_id":"cix2l6csz015rc2xls7mzmm9b","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6cta015zc2xlnuw29924"},{"post_id":"cix2l6csz015rc2xls7mzmm9b","tag_id":"cix2l6ct3015uc2xlt50zcpkw","_id":"cix2l6cta0160c2xl68s82yc6"},{"post_id":"cix2l6csz015rc2xls7mzmm9b","tag_id":"cix2l6c3k00g8c2xlsdw5jbor","_id":"cix2l6cta0161c2xlzwz7ti87"},{"post_id":"cix2l6ctb0162c2xlkgdjun96","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6cte0164c2xlj5hc65fx"},{"post_id":"cix2l6ctb0162c2xlkgdjun96","tag_id":"cix2l6ct2015tc2xlldttpyg8","_id":"cix2l6ctg0165c2xlnfxgjqyj"},{"post_id":"cix2l6ctb0162c2xlkgdjun96","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6ctg0166c2xlkzw8okai"},{"post_id":"cix2l6ctb0162c2xlkgdjun96","tag_id":"cix2l6c2z00fbc2xl6mvehv6g","_id":"cix2l6ctg0167c2xlmem8fe2i"},{"post_id":"cix2l6ctk016ac2xlkmlipq5s","tag_id":"cix2l6ctn016cc2xldpemx1d5","_id":"cix2l6ctp016dc2xlca2ta7ub"},{"post_id":"cix2l6ctk016ac2xlkmlipq5s","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6ctq016ec2xlq1yrd0oh"},{"post_id":"cix2l6ctk016ac2xlkmlipq5s","tag_id":"cix2l6bw5004hc2xliqrfp4kr","_id":"cix2l6ctq016fc2xltbcjw9nx"},{"post_id":"cix2l6ctk016ac2xlkmlipq5s","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6ctq016gc2xlgt50lgua"},{"post_id":"cix2l6ctr016hc2xldh2b6iv3","tag_id":"cix2l6ctn016cc2xldpemx1d5","_id":"cix2l6ctv016jc2xlamba1cbt"},{"post_id":"cix2l6ctr016hc2xldh2b6iv3","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6ctx016kc2xlfetrrsp8"},{"post_id":"cix2l6ctr016hc2xldh2b6iv3","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6ctx016lc2xlitmzrhe0"},{"post_id":"cix2l6ctr016hc2xldh2b6iv3","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6ctx016mc2xlt38dc5u8"},{"post_id":"cix2l6ctr016hc2xldh2b6iv3","tag_id":"cix2l6bzl009xc2xleyxetgjg","_id":"cix2l6ctx016nc2xlhil9d1li"},{"post_id":"cix2l6cty016oc2xlpke52uts","tag_id":"cix2l6ctn016cc2xldpemx1d5","_id":"cix2l6cu1016qc2xl0mz8cqb9"},{"post_id":"cix2l6cty016oc2xlpke52uts","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cu4016rc2xlonrbm7qg"},{"post_id":"cix2l6cty016oc2xlpke52uts","tag_id":"cix2l6bzl009wc2xlvxagmmjn","_id":"cix2l6cu4016sc2xl03wrfp1w"},{"post_id":"cix2l6cty016oc2xlpke52uts","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6cu4016tc2xllcplkuvq"},{"post_id":"cix2l6cty016oc2xlpke52uts","tag_id":"cix2l6bx9006kc2xl8ligd8yv","_id":"cix2l6cu4016uc2xld553qjij"},{"post_id":"cix2l6cty016oc2xlpke52uts","tag_id":"cix2l6bzl009xc2xleyxetgjg","_id":"cix2l6cu4016vc2xl16tpsf52"},{"post_id":"cix2l6cu5016wc2xlumk55knn","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6cu8016yc2xlwbt2ib34"},{"post_id":"cix2l6cu5016wc2xlumk55knn","tag_id":"cix2l6bvh003vc2xlhv94n7t9","_id":"cix2l6cua016zc2xlnmjxh8bc"},{"post_id":"cix2l6cu5016wc2xlumk55knn","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6cua0170c2xlmmasam37"},{"post_id":"cix2l6cu5016wc2xlumk55knn","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6cua0171c2xly9h14pvl"},{"post_id":"cix2l6cub0172c2xlvt6c4qr5","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6cuf0175c2xlevh3m4x3"},{"post_id":"cix2l6cub0172c2xlvt6c4qr5","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6cui0176c2xl1sx5ydkk"},{"post_id":"cix2l6cub0172c2xlvt6c4qr5","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6cui0177c2xlyvp7yoa3"},{"post_id":"cix2l6cub0172c2xlvt6c4qr5","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6cui0178c2xlu3465vnc"},{"post_id":"cix2l6cub0172c2xlvt6c4qr5","tag_id":"cix2l6ct3015uc2xlt50zcpkw","_id":"cix2l6cui0179c2xl8miirijf"},{"post_id":"cix2l6cub0172c2xlvt6c4qr5","tag_id":"cix2l6cud0174c2xlqr5wpjmy","_id":"cix2l6cui017ac2xlgnb4d60h"},{"post_id":"cix2l6cuj017bc2xlky1mii1p","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6cum017dc2xloe1nqdkq"},{"post_id":"cix2l6cuj017bc2xlky1mii1p","tag_id":"cix2l6bst000vc2xl1kukczvd","_id":"cix2l6cup017ec2xlntbks5nb"},{"post_id":"cix2l6cuj017bc2xlky1mii1p","tag_id":"cix2l6ct3015uc2xlt50zcpkw","_id":"cix2l6cup017fc2xlwvgpixrr"},{"post_id":"cix2l6cuj017bc2xlky1mii1p","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6cup017gc2xlzbia884h"},{"post_id":"cix2l6cuj017bc2xlky1mii1p","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6cup017hc2xlzl7m92jj"},{"post_id":"cix2l6cuj017bc2xlky1mii1p","tag_id":"cix2l6bsr000uc2xlhetrx95o","_id":"cix2l6cup017ic2xlxp49400p"},{"post_id":"cix2l6cuq017jc2xlcfbch6uh","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6cut017lc2xl7l2zzrd0"},{"post_id":"cix2l6cuq017jc2xlcfbch6uh","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6cuw017mc2xlgqb0z88g"},{"post_id":"cix2l6cuq017jc2xlcfbch6uh","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6cuw017nc2xl04rlr6v9"},{"post_id":"cix2l6cuq017jc2xlcfbch6uh","tag_id":"cix2l6ct3015uc2xlt50zcpkw","_id":"cix2l6cuw017oc2xljl7taxh8"},{"post_id":"cix2l6cuq017jc2xlcfbch6uh","tag_id":"cix2l6bst000vc2xl1kukczvd","_id":"cix2l6cuw017pc2xlql6f0rio"},{"post_id":"cix2l6cuq017jc2xlcfbch6uh","tag_id":"cix2l6bsr000uc2xlhetrx95o","_id":"cix2l6cuw017qc2xlcjwlg5im"},{"post_id":"cix2l6cux017rc2xln2220k5d","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6cv0017tc2xl8egpcf6j"},{"post_id":"cix2l6cux017rc2xln2220k5d","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6cv4017uc2xl6lticc6n"},{"post_id":"cix2l6cux017rc2xln2220k5d","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6cv4017vc2xlveilao1l"},{"post_id":"cix2l6cux017rc2xln2220k5d","tag_id":"cix2l6ct3015uc2xlt50zcpkw","_id":"cix2l6cv4017wc2xlolrh0b7l"},{"post_id":"cix2l6cux017rc2xln2220k5d","tag_id":"cix2l6bst000vc2xl1kukczvd","_id":"cix2l6cv4017xc2xlfkwdhkrt"},{"post_id":"cix2l6cux017rc2xln2220k5d","tag_id":"cix2l6bsr000uc2xlhetrx95o","_id":"cix2l6cv4017yc2xl1y0b3cvl"},{"post_id":"cix2l6cux017rc2xln2220k5d","tag_id":"cix2l6c2t00f1c2xlpcqtvvg8","_id":"cix2l6cv4017zc2xlefysg0k8"},{"post_id":"cix2l6cv50180c2xl5hotor5q","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6cv80182c2xlun0imkss"},{"post_id":"cix2l6cv50180c2xl5hotor5q","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6cvb0183c2xlnhpp6nwi"},{"post_id":"cix2l6cv50180c2xl5hotor5q","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6cvb0184c2xlmebcl7lo"},{"post_id":"cix2l6cv50180c2xl5hotor5q","tag_id":"cix2l6bsr000uc2xlhetrx95o","_id":"cix2l6cvb0185c2xl5xzuwqkf"},{"post_id":"cix2l6cv50180c2xl5hotor5q","tag_id":"cix2l6bst000vc2xl1kukczvd","_id":"cix2l6cvb0186c2xlqv12q3c8"},{"post_id":"cix2l6cv50180c2xl5hotor5q","tag_id":"cix2l6ct3015uc2xlt50zcpkw","_id":"cix2l6cvb0187c2xlanl9pdoo"},{"post_id":"cix2l6cvc0188c2xl2o3l0h16","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6cvf018ac2xlz5j431zt"},{"post_id":"cix2l6cvc0188c2xl2o3l0h16","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6cvi018bc2xlya9t8egk"},{"post_id":"cix2l6cvc0188c2xl2o3l0h16","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6cvi018cc2xl459lrbe4"},{"post_id":"cix2l6cvc0188c2xl2o3l0h16","tag_id":"cix2l6bsr000uc2xlhetrx95o","_id":"cix2l6cvi018dc2xl2xi7mh5p"},{"post_id":"cix2l6cvc0188c2xl2o3l0h16","tag_id":"cix2l6bst000vc2xl1kukczvd","_id":"cix2l6cvi018ec2xly9gw7fr5"},{"post_id":"cix2l6cvc0188c2xl2o3l0h16","tag_id":"cix2l6ct3015uc2xlt50zcpkw","_id":"cix2l6cvi018fc2xlwzmnvox6"},{"post_id":"cix2l6cvj018gc2xl8sc8taqf","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6cvm018ic2xlypnhcz6y"},{"post_id":"cix2l6cvj018gc2xl8sc8taqf","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6cvp018jc2xlto8o7zuj"},{"post_id":"cix2l6cvj018gc2xl8sc8taqf","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6cvp018kc2xl2sfp3oue"},{"post_id":"cix2l6cvj018gc2xl8sc8taqf","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6cvp018lc2xl91auz3qo"},{"post_id":"cix2l6cvj018gc2xl8sc8taqf","tag_id":"cix2l6ct3015uc2xlt50zcpkw","_id":"cix2l6cvp018mc2xl5g7fs9p0"},{"post_id":"cix2l6cvj018gc2xl8sc8taqf","tag_id":"cix2l6cud0174c2xlqr5wpjmy","_id":"cix2l6cvp018nc2xl8cy0xshw"},{"post_id":"cix2l6cvq018oc2xluiysn7mv","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6cvt018qc2xlktjhikg5"},{"post_id":"cix2l6cvq018oc2xluiysn7mv","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6cvw018rc2xlm6rdaxzi"},{"post_id":"cix2l6cvq018oc2xluiysn7mv","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6cvw018sc2xl5d93edry"},{"post_id":"cix2l6cvq018oc2xluiysn7mv","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6cvw018tc2xle5qrr5nz"},{"post_id":"cix2l6cvq018oc2xluiysn7mv","tag_id":"cix2l6ct3015uc2xlt50zcpkw","_id":"cix2l6cvw018uc2xli646qh0e"},{"post_id":"cix2l6cvx018vc2xlo3qz61yo","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6cw0018xc2xli2u60skz"},{"post_id":"cix2l6cvx018vc2xlo3qz61yo","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6cw3018yc2xl77l94px4"},{"post_id":"cix2l6cvx018vc2xlo3qz61yo","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6cw3018zc2xlyk90zzfm"},{"post_id":"cix2l6cvx018vc2xlo3qz61yo","tag_id":"cix2l6ct3015uc2xlt50zcpkw","_id":"cix2l6cw30190c2xlck38jfbb"},{"post_id":"cix2l6cvx018vc2xlo3qz61yo","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6cw30191c2xlr6441q73"},{"post_id":"cix2l6cw30192c2xlhihsc9gg","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6cw70194c2xlxzt9oe04"},{"post_id":"cix2l6cw30192c2xlhihsc9gg","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6cwa0195c2xlxny72iuq"},{"post_id":"cix2l6cw30192c2xlhihsc9gg","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6cwa0196c2xljl354ghp"},{"post_id":"cix2l6cw30192c2xlhihsc9gg","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6cwa0197c2xli95txiq2"},{"post_id":"cix2l6cw30192c2xlhihsc9gg","tag_id":"cix2l6c2t00f1c2xlpcqtvvg8","_id":"cix2l6cwa0198c2xlkiyf46gv"},{"post_id":"cix2l6cw30192c2xlhihsc9gg","tag_id":"cix2l6ct3015uc2xlt50zcpkw","_id":"cix2l6cwa0199c2xlua9cz97d"},{"post_id":"cix2l6cwb019ac2xll827ieda","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6cwf019cc2xlki1jz3oj"},{"post_id":"cix2l6cwb019ac2xll827ieda","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6cwi019dc2xl6dka98lq"},{"post_id":"cix2l6cwb019ac2xll827ieda","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6cwi019ec2xlb64td4xt"},{"post_id":"cix2l6cwb019ac2xll827ieda","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6cwi019fc2xlyj6nisjy"},{"post_id":"cix2l6cwb019ac2xll827ieda","tag_id":"cix2l6ct3015uc2xlt50zcpkw","_id":"cix2l6cwi019gc2xlmobm21ou"},{"post_id":"cix2l6cwb019ac2xll827ieda","tag_id":"cix2l6cdk00roc2xl0mop3e11","_id":"cix2l6cwi019hc2xl9pckng80"},{"post_id":"cix2l6cwj019ic2xla8jsi931","tag_id":"cix2l6c4000h2c2xl0ymvmkpr","_id":"cix2l6cwp019lc2xlc17bfw7h"},{"post_id":"cix2l6cwj019ic2xla8jsi931","tag_id":"cix2l6cwn019kc2xlj3h9uckl","_id":"cix2l6cws019mc2xle8nxrl2r"},{"post_id":"cix2l6cwj019ic2xla8jsi931","tag_id":"cix2l6bzr00a9c2xluebmxms0","_id":"cix2l6cws019nc2xlitqp99to"},{"post_id":"cix2l6cwj019ic2xla8jsi931","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6cws019oc2xlpc277ppj"},{"post_id":"cix2l6cwj019ic2xla8jsi931","tag_id":"cix2l6ct3015uc2xlt50zcpkw","_id":"cix2l6cws019pc2xl03wr15e2"},{"post_id":"cix2l6cwj019ic2xla8jsi931","tag_id":"cix2l6cax00pdc2xlcci3d4bu","_id":"cix2l6cws019qc2xlys1gze5m"},{"post_id":"cix2l6cwt019rc2xlb0u387nq","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6cww019tc2xl4ekr58m4"},{"post_id":"cix2l6cwt019rc2xlb0u387nq","tag_id":"cix2l6bte001ic2xld1gajghb","_id":"cix2l6cwy019uc2xl6n3olwls"},{"post_id":"cix2l6cwt019rc2xlb0u387nq","tag_id":"cix2l6ct3015uc2xlt50zcpkw","_id":"cix2l6cwy019vc2xll5xs6wwx"},{"post_id":"cix2l6cwy019wc2xls4ucr3xb","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6cx2019yc2xlyvx7clgp"},{"post_id":"cix2l6cwy019wc2xls4ucr3xb","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6cx5019zc2xlcefk6il6"},{"post_id":"cix2l6cwy019wc2xls4ucr3xb","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6cx501a0c2xlo67x65m5"},{"post_id":"cix2l6cwy019wc2xls4ucr3xb","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6cx501a1c2xlquphlkfk"},{"post_id":"cix2l6cwy019wc2xls4ucr3xb","tag_id":"cix2l6c2t00f1c2xlpcqtvvg8","_id":"cix2l6cx501a2c2xlunhbvugo"},{"post_id":"cix2l6cwy019wc2xls4ucr3xb","tag_id":"cix2l6ct3015uc2xlt50zcpkw","_id":"cix2l6cx501a3c2xl4kro71k4"},{"post_id":"cix2l6cx601a4c2xlyrt4c2en","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6cx901a6c2xls5rzqzfs"},{"post_id":"cix2l6cx601a4c2xlyrt4c2en","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6cxb01a7c2xl68izhv5d"},{"post_id":"cix2l6cx601a4c2xlyrt4c2en","tag_id":"cix2l6bwe0051c2xllpdw4hf2","_id":"cix2l6cxb01a8c2xlofap9ydi"},{"post_id":"cix2l6cxc01a9c2xl2h3i18hx","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6cxf01abc2xlrord0f4j"},{"post_id":"cix2l6cxc01a9c2xl2h3i18hx","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6cxh01acc2xlguwosvtj"},{"post_id":"cix2l6cxc01a9c2xl2h3i18hx","tag_id":"cix2l6btq0020c2xlllnmvl4u","_id":"cix2l6cxh01adc2xl5vmnj3sw"},{"post_id":"cix2l6cxc01a9c2xl2h3i18hx","tag_id":"cix2l6bwe0051c2xllpdw4hf2","_id":"cix2l6cxh01aec2xlm1z861ep"},{"post_id":"cix2l6cxi01afc2xlcm2f8ysy","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6cxl01ahc2xly5g8nx03"},{"post_id":"cix2l6cxi01afc2xlcm2f8ysy","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6cxo01aic2xlajpqo5rr"},{"post_id":"cix2l6cxi01afc2xlcm2f8ysy","tag_id":"cix2l6c0700axc2xlgxp3vaf5","_id":"cix2l6cxo01ajc2xlqxy5dfa7"},{"post_id":"cix2l6cxi01afc2xlcm2f8ysy","tag_id":"cix2l6bwv005vc2xl62lmb5wk","_id":"cix2l6cxo01akc2xl5uzzto9f"},{"post_id":"cix2l6cxi01afc2xlcm2f8ysy","tag_id":"cix2l6bte001ic2xld1gajghb","_id":"cix2l6cxo01alc2xlr0gsk7gh"},{"post_id":"cix2l6cxp01amc2xlo2dpurq8","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6cxs01aoc2xl3r5v4kjv"},{"post_id":"cix2l6cxp01amc2xlo2dpurq8","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6cxv01apc2xlgqrrkjis"},{"post_id":"cix2l6cxp01amc2xlo2dpurq8","tag_id":"cix2l6btx002ac2xls5nn914i","_id":"cix2l6cxv01aqc2xlfon5jmtl"},{"post_id":"cix2l6cxp01amc2xlo2dpurq8","tag_id":"cix2l6bxe006uc2xlqk5geg3s","_id":"cix2l6cxv01arc2xl2g2fjc55"},{"post_id":"cix2l6cxp01amc2xlo2dpurq8","tag_id":"cix2l6btx002bc2xlii39i8qq","_id":"cix2l6cxv01asc2xlehscabuw"},{"post_id":"cix2l6cxw01atc2xlmtjmku4s","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6cxz01avc2xlf21mi85x"},{"post_id":"cix2l6cxw01atc2xlmtjmku4s","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6cy101awc2xls84v0gb0"},{"post_id":"cix2l6cxw01atc2xlmtjmku4s","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6cy101axc2xl872hvub2"},{"post_id":"cix2l6cxw01atc2xlmtjmku4s","tag_id":"cix2l6c9700njc2xlqaed2y8c","_id":"cix2l6cy101ayc2xl7irlc40f"},{"post_id":"cix2l6cy201azc2xlks3fmfmk","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6cy601b2c2xlc08bv3ji"},{"post_id":"cix2l6cy201azc2xlks3fmfmk","tag_id":"cix2l6cy401b1c2xlirimv0hc","_id":"cix2l6cy901b3c2xlpk09z6wq"},{"post_id":"cix2l6cy201azc2xlks3fmfmk","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6cy901b4c2xlqsbnvuxj"},{"post_id":"cix2l6cy201azc2xlks3fmfmk","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6cy901b5c2xlsyqkfa54"},{"post_id":"cix2l6cy201azc2xlks3fmfmk","tag_id":"cix2l6bxd006tc2xlwt0cqgkb","_id":"cix2l6cy901b6c2xly0r9lw1t"},{"post_id":"cix2l6cy901b7c2xljqpcfsx5","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6cyd01b9c2xlcqcw5zbs"},{"post_id":"cix2l6cy901b7c2xljqpcfsx5","tag_id":"cix2l6cy401b1c2xlirimv0hc","_id":"cix2l6cyf01bac2xl946qfgnb"},{"post_id":"cix2l6cy901b7c2xljqpcfsx5","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6cyf01bbc2xlz4mduqkr"},{"post_id":"cix2l6cy901b7c2xljqpcfsx5","tag_id":"cix2l6c9700njc2xlqaed2y8c","_id":"cix2l6cyf01bcc2xl73wmo9ah"},{"post_id":"cix2l6cyg01bdc2xluekyf0f3","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6cyl01bhc2xlmmrs77mi"},{"post_id":"cix2l6cyg01bdc2xluekyf0f3","tag_id":"cix2l6cyi01bfc2xliv6zf2wj","_id":"cix2l6cyp01bic2xlytzknr0s"},{"post_id":"cix2l6cyg01bdc2xluekyf0f3","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6cyp01bjc2xln6ocvm8h"},{"post_id":"cix2l6cyg01bdc2xluekyf0f3","tag_id":"cix2l6bx3006bc2xlhxm1aa0p","_id":"cix2l6cyp01bkc2xl4ib075nu"},{"post_id":"cix2l6cyg01bdc2xluekyf0f3","tag_id":"cix2l6brx0003c2xl4mq6xsp7","_id":"cix2l6cyp01blc2xl1m215w0q"},{"post_id":"cix2l6cyg01bdc2xluekyf0f3","tag_id":"cix2l6cyk01bgc2xlhq5xgs57","_id":"cix2l6cyp01bmc2xlv9vg1zq5"},{"post_id":"cix2l6cyq01bnc2xl0a9o9024","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6cyu01bpc2xlzllem5hb"},{"post_id":"cix2l6cyq01bnc2xl0a9o9024","tag_id":"cix2l6c1l00cxc2xljmq6rska","_id":"cix2l6cyw01bqc2xleaaufkka"},{"post_id":"cix2l6cyq01bnc2xl0a9o9024","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6cyw01brc2xlbse8lhm5"},{"post_id":"cix2l6cyq01bnc2xl0a9o9024","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6cyw01bsc2xlruyrkfwr"},{"post_id":"cix2l6cyx01btc2xlgexlzpn6","tag_id":"cix2l6cz001bvc2xl21k8w1hf","_id":"cix2l6cz201bwc2xle57tlzsp"},{"post_id":"cix2l6cyx01btc2xlgexlzpn6","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6cz501bxc2xlw9wqo6hq"},{"post_id":"cix2l6cyx01btc2xlgexlzpn6","tag_id":"cix2l6ced00sjc2xludjl9rln","_id":"cix2l6cz501byc2xlxrk30d63"},{"post_id":"cix2l6cyx01btc2xlgexlzpn6","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6cz501bzc2xl7b6hhdzd"},{"post_id":"cix2l6cyx01btc2xlgexlzpn6","tag_id":"cix2l6bwa004pc2xlfep7re8c","_id":"cix2l6cz501c0c2xlsuhpf5o4"},{"post_id":"cix2l6cyx01btc2xlgexlzpn6","tag_id":"cix2l6bwa004qc2xlqnw3w3ri","_id":"cix2l6cz601c1c2xld7c67es9"},{"post_id":"cix2l6cza01c2c2xl6g35bgwb","tag_id":"cix2l6cz001bvc2xl21k8w1hf","_id":"cix2l6czd01c4c2xltnr6zano"},{"post_id":"cix2l6cza01c2c2xl6g35bgwb","tag_id":"cix2l6bw5004hc2xliqrfp4kr","_id":"cix2l6cze01c5c2xlu4quqcy5"},{"post_id":"cix2l6cza01c2c2xl6g35bgwb","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6czf01c6c2xlrx14jqul"},{"post_id":"cix2l6czf01c7c2xl31nuewiw","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6czi01c9c2xl4aon9q02"},{"post_id":"cix2l6czf01c7c2xl31nuewiw","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6czk01cac2xl4urlwn2u"},{"post_id":"cix2l6czf01c7c2xl31nuewiw","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6czk01cbc2xltv2u6s1u"},{"post_id":"cix2l6czf01c7c2xl31nuewiw","tag_id":"cix2l6bt20014c2xlf6zchc9m","_id":"cix2l6czk01ccc2xl4gwu8nwq"},{"post_id":"cix2l6czl01cdc2xlczfe3g86","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6czq01cgc2xlyntlp520"},{"post_id":"cix2l6czl01cdc2xlczfe3g86","tag_id":"cix2l6czo01cfc2xlf85ymlwp","_id":"cix2l6czs01chc2xl9r4g6m6u"},{"post_id":"cix2l6czl01cdc2xlczfe3g86","tag_id":"cix2l6btq001zc2xl1xyp27mz","_id":"cix2l6czt01cic2xlxopwbbjs"},{"post_id":"cix2l6czl01cdc2xlczfe3g86","tag_id":"cix2l6btq0020c2xlllnmvl4u","_id":"cix2l6czt01cjc2xlhupotkr0"},{"post_id":"cix2l6czl01cdc2xlczfe3g86","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6czt01ckc2xlo7e6e42r"},{"post_id":"cix2l6czt01clc2xlc3rmt97a","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6czy01coc2xl5ggmqn39"},{"post_id":"cix2l6czt01clc2xlc3rmt97a","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6d0401cpc2xl4scbbvy8"},{"post_id":"cix2l6czt01clc2xlc3rmt97a","tag_id":"cix2l6bvh003vc2xlhv94n7t9","_id":"cix2l6d0401cqc2xlm1fakpzn"},{"post_id":"cix2l6czt01clc2xlc3rmt97a","tag_id":"cix2l6bwn005hc2xl3hpoko78","_id":"cix2l6d0401crc2xljzupdhtq"},{"post_id":"cix2l6czt01clc2xlc3rmt97a","tag_id":"cix2l6bwa004pc2xlfep7re8c","_id":"cix2l6d0401csc2xldkmc7rug"},{"post_id":"cix2l6czt01clc2xlc3rmt97a","tag_id":"cix2l6czw01cnc2xlbi3gkkqt","_id":"cix2l6d0401ctc2xl4dpsxr1x"},{"post_id":"cix2l6czt01clc2xlc3rmt97a","tag_id":"cix2l6bwa004qc2xlqnw3w3ri","_id":"cix2l6d0401cuc2xl9cm141v6"},{"post_id":"cix2l6d0401cvc2xle8wmyb2e","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d0801cxc2xln40w6iah"},{"post_id":"cix2l6d0401cvc2xle8wmyb2e","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6d0a01cyc2xlmjdhjsax"},{"post_id":"cix2l6d0401cvc2xle8wmyb2e","tag_id":"cix2l6bwj0059c2xlp2z4w5xl","_id":"cix2l6d0a01czc2xljhau781a"},{"post_id":"cix2l6d0401cvc2xle8wmyb2e","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6d0a01d0c2xlf8xixf4j"},{"post_id":"cix2l6d0b01d1c2xlodmx85zc","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d0e01d3c2xla09l0594"},{"post_id":"cix2l6d0b01d1c2xlodmx85zc","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6d0f01d4c2xlt7bijls0"},{"post_id":"cix2l6d0b01d1c2xlodmx85zc","tag_id":"cix2l6bwe0051c2xllpdw4hf2","_id":"cix2l6d0f01d5c2xljg61lk27"},{"post_id":"cix2l6d0g01d6c2xltmret6t5","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d0j01d8c2xlqxwecp5c"},{"post_id":"cix2l6d0g01d6c2xltmret6t5","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6d0l01d9c2xl8eafqfic"},{"post_id":"cix2l6d0g01d6c2xltmret6t5","tag_id":"cix2l6bwz0063c2xlh8ly3fo3","_id":"cix2l6d0l01dac2xl7cpg89dj"},{"post_id":"cix2l6d0m01dbc2xlvjjay1lq","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d0r01dfc2xl9t2w2qff"},{"post_id":"cix2l6d0m01dbc2xlvjjay1lq","tag_id":"cix2l6cy401b1c2xlirimv0hc","_id":"cix2l6d0v01dgc2xls43rfygv"},{"post_id":"cix2l6d0m01dbc2xlvjjay1lq","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6d0v01dhc2xl6xefcu7j"},{"post_id":"cix2l6d0m01dbc2xlvjjay1lq","tag_id":"cix2l6bx3006bc2xlhxm1aa0p","_id":"cix2l6d0v01dic2xl2nb473ec"},{"post_id":"cix2l6d0m01dbc2xlvjjay1lq","tag_id":"cix2l6d0p01ddc2xlzout3pn1","_id":"cix2l6d0v01djc2xlbz65sjck"},{"post_id":"cix2l6d0m01dbc2xlvjjay1lq","tag_id":"cix2l6d0q01dec2xlzd4vc6dr","_id":"cix2l6d0v01dkc2xlxug0gmxj"},{"post_id":"cix2l6d0w01dlc2xl0e0xhez1","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d0z01dnc2xlnibhc1j4"},{"post_id":"cix2l6d0w01dlc2xl0e0xhez1","tag_id":"cix2l6cdk00roc2xl0mop3e11","_id":"cix2l6d1101doc2xlhwf7twjv"},{"post_id":"cix2l6d0w01dlc2xl0e0xhez1","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6d1201dpc2xly2asda9h"},{"post_id":"cix2l6d0w01dlc2xl0e0xhez1","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6d1201dqc2xlm70au2ku"},{"post_id":"cix2l6d0w01dlc2xl0e0xhez1","tag_id":"cix2l6bt20014c2xlf6zchc9m","_id":"cix2l6d1201drc2xl72u4i6kp"},{"post_id":"cix2l6d1201dsc2xllj5nwbfo","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d1601duc2xl7mmwi771"},{"post_id":"cix2l6d1201dsc2xllj5nwbfo","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6d1801dvc2xlt866mse2"},{"post_id":"cix2l6d1201dsc2xllj5nwbfo","tag_id":"cix2l6bxo007jc2xlkcrgnf1u","_id":"cix2l6d1801dwc2xln67c14bb"},{"post_id":"cix2l6d1201dsc2xllj5nwbfo","tag_id":"cix2l6bx3006bc2xlhxm1aa0p","_id":"cix2l6d1801dxc2xl3vom43ve"},{"post_id":"cix2l6d1901dyc2xlmy00aokl","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d1c01e0c2xlzuf2u6sk"},{"post_id":"cix2l6d1901dyc2xlmy00aokl","tag_id":"cix2l6ced00sjc2xludjl9rln","_id":"cix2l6d1e01e1c2xl6ewh5x9i"},{"post_id":"cix2l6d1901dyc2xlmy00aokl","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6d1e01e2c2xlbiymdd90"},{"post_id":"cix2l6d1f01e3c2xlu1xl80px","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d1i01e5c2xllh2ohk1z"},{"post_id":"cix2l6d1f01e3c2xlu1xl80px","tag_id":"cix2l6brs0002c2xlkjhralkg","_id":"cix2l6d1l01e6c2xljz3rf33e"},{"post_id":"cix2l6d1f01e3c2xlu1xl80px","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6d1l01e7c2xll79q8ilq"},{"post_id":"cix2l6d1f01e3c2xlu1xl80px","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6d1l01e8c2xlvyiq0f8n"},{"post_id":"cix2l6d1f01e3c2xlu1xl80px","tag_id":"cix2l6bt20014c2xlf6zchc9m","_id":"cix2l6d1l01e9c2xl4tbw6t66"},{"post_id":"cix2l6d1m01eac2xlti16uxm8","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d1p01ecc2xl413lh3op"},{"post_id":"cix2l6d1m01eac2xlti16uxm8","tag_id":"cix2l6cdk00roc2xl0mop3e11","_id":"cix2l6d1s01edc2xlzlnucr6f"},{"post_id":"cix2l6d1m01eac2xlti16uxm8","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6d1s01eec2xldfds4n3q"},{"post_id":"cix2l6d1m01eac2xlti16uxm8","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6d1s01efc2xlztccxlwh"},{"post_id":"cix2l6d1m01eac2xlti16uxm8","tag_id":"cix2l6bt20014c2xlf6zchc9m","_id":"cix2l6d1s01egc2xl5h7qebc9"},{"post_id":"cix2l6d1t01ehc2xl1oiu6to6","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d1w01ejc2xl26n65qv7"},{"post_id":"cix2l6d1t01ehc2xl1oiu6to6","tag_id":"cix2l6ced00sjc2xludjl9rln","_id":"cix2l6d1y01ekc2xlice1okok"},{"post_id":"cix2l6d1t01ehc2xl1oiu6to6","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6d1y01elc2xl1s7n4cl0"},{"post_id":"cix2l6d1z01emc2xlddjbdlva","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d2201eoc2xlh9txq5dm"},{"post_id":"cix2l6d1z01emc2xlddjbdlva","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6d2401epc2xl2wvymhnx"},{"post_id":"cix2l6d1z01emc2xlddjbdlva","tag_id":"cix2l6bsr000uc2xlhetrx95o","_id":"cix2l6d2401eqc2xld77ka6q6"},{"post_id":"cix2l6d1z01emc2xlddjbdlva","tag_id":"cix2l6bst000vc2xl1kukczvd","_id":"cix2l6d2401erc2xl4haem79e"},{"post_id":"cix2l6d2501esc2xlsrkezl16","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d2901euc2xl7y6i12uh"},{"post_id":"cix2l6d2501esc2xlsrkezl16","tag_id":"cix2l6cz001bvc2xl21k8w1hf","_id":"cix2l6d2c01evc2xlp6eng4kc"},{"post_id":"cix2l6d2501esc2xlsrkezl16","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6d2c01ewc2xllpwg5xkz"},{"post_id":"cix2l6d2501esc2xlsrkezl16","tag_id":"cix2l6bxo007jc2xlkcrgnf1u","_id":"cix2l6d2c01exc2xl51gsgzw9"},{"post_id":"cix2l6d2501esc2xlsrkezl16","tag_id":"cix2l6c1k00cwc2xltzt3umv8","_id":"cix2l6d2c01eyc2xlyzau67g1"},{"post_id":"cix2l6d2501esc2xlsrkezl16","tag_id":"cix2l6c1l00cyc2xly6uvavyj","_id":"cix2l6d2c01ezc2xlor6tb8cm"},{"post_id":"cix2l6d2d01f0c2xlyynqa9kv","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d2h01f2c2xl7jzpo1ji"},{"post_id":"cix2l6d2d01f0c2xlyynqa9kv","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6d2k01f3c2xl5f268v5x"},{"post_id":"cix2l6d2d01f0c2xlyynqa9kv","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6d2k01f4c2xlvt2zraoj"},{"post_id":"cix2l6d2d01f0c2xlyynqa9kv","tag_id":"cix2l6bt20014c2xlf6zchc9m","_id":"cix2l6d2k01f5c2xlu43abqsl"},{"post_id":"cix2l6d2d01f0c2xlyynqa9kv","tag_id":"cix2l6c8y00n9c2xlm421go5n","_id":"cix2l6d2k01f6c2xlga32qb08"},{"post_id":"cix2l6d2l01f7c2xlnbgi70cq","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d2o01f9c2xl8ehfh76l"},{"post_id":"cix2l6d2l01f7c2xlnbgi70cq","tag_id":"cix2l6bzl009wc2xlvxagmmjn","_id":"cix2l6d2r01fac2xl1n2348pa"},{"post_id":"cix2l6d2l01f7c2xlnbgi70cq","tag_id":"cix2l6bx9006kc2xl8ligd8yv","_id":"cix2l6d2r01fbc2xl546j88gy"},{"post_id":"cix2l6d2l01f7c2xlnbgi70cq","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6d2r01fcc2xlj8ybbpkw"},{"post_id":"cix2l6d2l01f7c2xlnbgi70cq","tag_id":"cix2l6bzl009xc2xleyxetgjg","_id":"cix2l6d2r01fdc2xlsh0mdrkk"},{"post_id":"cix2l6d2s01fec2xlo6134k3k","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d2v01fgc2xld4ukvyvh"},{"post_id":"cix2l6d2s01fec2xlo6134k3k","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6d2x01fhc2xlzrhdterj"},{"post_id":"cix2l6d2s01fec2xlo6134k3k","tag_id":"cix2l6bxo007jc2xlkcrgnf1u","_id":"cix2l6d2x01fic2xlzx3konr8"},{"post_id":"cix2l6d2y01fjc2xl3eio6kpp","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d3301fmc2xlkyjhkfoc"},{"post_id":"cix2l6d2y01fjc2xl3eio6kpp","tag_id":"cix2l6bry0004c2xlbo1rvuu2","_id":"cix2l6d3601fnc2xlo49qb8u9"},{"post_id":"cix2l6d2y01fjc2xl3eio6kpp","tag_id":"cix2l6d3101flc2xly6zvvnbj","_id":"cix2l6d3601foc2xlgtwz1bn7"},{"post_id":"cix2l6d2y01fjc2xl3eio6kpp","tag_id":"cix2l6bx9006jc2xl21zjnyx6","_id":"cix2l6d3601fpc2xlmgawrpyd"},{"post_id":"cix2l6d2y01fjc2xl3eio6kpp","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6d3601fqc2xlkuysxruz"},{"post_id":"cix2l6d3601frc2xlr32why36","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d3a01ftc2xlbx1id8d7"},{"post_id":"cix2l6d3601frc2xlr32why36","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6d3e01fuc2xlrcj3hmg4"},{"post_id":"cix2l6d3601frc2xlr32why36","tag_id":"cix2l6btq0020c2xlllnmvl4u","_id":"cix2l6d3e01fvc2xlq52cq5d6"},{"post_id":"cix2l6d3601frc2xlr32why36","tag_id":"cix2l6btq001zc2xl1xyp27mz","_id":"cix2l6d3f01fwc2xlqwwu1kgi"},{"post_id":"cix2l6d3i01fxc2xlf210bu7p","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d3n01fzc2xljsbb6c90"},{"post_id":"cix2l6d3i01fxc2xlf210bu7p","tag_id":"cix2l6con0118c2xlp3um23qw","_id":"cix2l6d3q01g0c2xl67503dbv"},{"post_id":"cix2l6d3i01fxc2xlf210bu7p","tag_id":"cix2l6bwa004pc2xlfep7re8c","_id":"cix2l6d3q01g1c2xlcsugj7uk"},{"post_id":"cix2l6d3i01fxc2xlf210bu7p","tag_id":"cix2l6c0600awc2xlaldzn55u","_id":"cix2l6d3q01g2c2xl3b3l0hii"},{"post_id":"cix2l6d3i01fxc2xlf210bu7p","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6d3q01g3c2xlm8v95fm6"},{"post_id":"cix2l6d3r01g4c2xl6g233gn3","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d3v01g6c2xlw9vyj3k7"},{"post_id":"cix2l6d3r01g4c2xl6g233gn3","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6d3y01g7c2xlel3fgglm"},{"post_id":"cix2l6d3r01g4c2xl6g233gn3","tag_id":"cix2l6bzl009wc2xlvxagmmjn","_id":"cix2l6d3y01g8c2xlhp26cvka"},{"post_id":"cix2l6d3r01g4c2xl6g233gn3","tag_id":"cix2l6bx9006kc2xl8ligd8yv","_id":"cix2l6d3y01g9c2xl3zh9kkhb"},{"post_id":"cix2l6d3r01g4c2xl6g233gn3","tag_id":"cix2l6bzl009xc2xleyxetgjg","_id":"cix2l6d3y01gac2xlzjp3qjn9"},{"post_id":"cix2l6d3y01gbc2xlf2gf6nh1","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d4201gdc2xl1dmk2flz"},{"post_id":"cix2l6d3y01gbc2xlf2gf6nh1","tag_id":"cix2l6bzl009wc2xlvxagmmjn","_id":"cix2l6d4501gec2xl03g45yp6"},{"post_id":"cix2l6d3y01gbc2xlf2gf6nh1","tag_id":"cix2l6bx9006kc2xl8ligd8yv","_id":"cix2l6d4501gfc2xle2ri9aod"},{"post_id":"cix2l6d3y01gbc2xlf2gf6nh1","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6d4501ggc2xl5lspkuxh"},{"post_id":"cix2l6d3y01gbc2xlf2gf6nh1","tag_id":"cix2l6bzl009xc2xleyxetgjg","_id":"cix2l6d4501ghc2xlt2iwgxnu"},{"post_id":"cix2l6d4801gic2xlg10r6hhy","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d4c01gkc2xlp9jeoikn"},{"post_id":"cix2l6d4801gic2xlg10r6hhy","tag_id":"cix2l6cy401b1c2xlirimv0hc","_id":"cix2l6d4f01glc2xlv7v87yx8"},{"post_id":"cix2l6d4801gic2xlg10r6hhy","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6d4f01gmc2xleo2dvvbc"},{"post_id":"cix2l6d4801gic2xlg10r6hhy","tag_id":"cix2l6bx3006bc2xlhxm1aa0p","_id":"cix2l6d4f01gnc2xl55u5724a"},{"post_id":"cix2l6d4801gic2xlg10r6hhy","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6d4f01goc2xlm67igye2"},{"post_id":"cix2l6d4g01gpc2xld6lpuze4","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d4j01grc2xlc4m5ytgi"},{"post_id":"cix2l6d4g01gpc2xld6lpuze4","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6d4l01gsc2xlrvofpr9l"},{"post_id":"cix2l6d4g01gpc2xld6lpuze4","tag_id":"cix2l6bx3006bc2xlhxm1aa0p","_id":"cix2l6d4l01gtc2xl1jm8zw6m"},{"post_id":"cix2l6d4m01guc2xl6mpt9qv4","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d4p01gwc2xl2cj1trh0"},{"post_id":"cix2l6d4m01guc2xl6mpt9qv4","tag_id":"cix2l6c2h00ekc2xlifaivm0i","_id":"cix2l6d4q01gxc2xlls0b70kj"},{"post_id":"cix2l6d4r01gyc2xln2gav8z2","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d4v01h0c2xl1u7rgq3l"},{"post_id":"cix2l6d4r01gyc2xln2gav8z2","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6d4z01h1c2xlsnulmlal"},{"post_id":"cix2l6d4r01gyc2xln2gav8z2","tag_id":"cix2l6cy401b1c2xlirimv0hc","_id":"cix2l6d4z01h2c2xl8pg8r7u0"},{"post_id":"cix2l6d4r01gyc2xln2gav8z2","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6d4z01h3c2xlvta4coj5"},{"post_id":"cix2l6d4r01gyc2xln2gav8z2","tag_id":"cix2l6btq0020c2xlllnmvl4u","_id":"cix2l6d4z01h4c2xlezprigf2"},{"post_id":"cix2l6d4r01gyc2xln2gav8z2","tag_id":"cix2l6c9700njc2xlqaed2y8c","_id":"cix2l6d4z01h5c2xlax55m9jh"},{"post_id":"cix2l6d5001h6c2xls8ponbne","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d5401h8c2xlmovs2640"},{"post_id":"cix2l6d5001h6c2xls8ponbne","tag_id":"cix2l6bxe006uc2xlqk5geg3s","_id":"cix2l6d5601h9c2xlypie7d28"},{"post_id":"cix2l6d5001h6c2xls8ponbne","tag_id":"cix2l6btx002ac2xls5nn914i","_id":"cix2l6d5601hac2xlwd3ojxtl"},{"post_id":"cix2l6d5001h6c2xls8ponbne","tag_id":"cix2l6btx002bc2xlii39i8qq","_id":"cix2l6d5601hbc2xl9571vusg"},{"post_id":"cix2l6d5701hcc2xlkulsg2tk","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d5a01hec2xluroi27k6"},{"post_id":"cix2l6d5701hcc2xlkulsg2tk","tag_id":"cix2l6bwa004pc2xlfep7re8c","_id":"cix2l6d5c01hfc2xl4lvxvbna"},{"post_id":"cix2l6d5701hcc2xlkulsg2tk","tag_id":"cix2l6brs0002c2xlkjhralkg","_id":"cix2l6d5c01hgc2xly1s021in"},{"post_id":"cix2l6d5d01hhc2xlapd4rgr5","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d5g01hjc2xlbd3kxqqf"},{"post_id":"cix2l6d5d01hhc2xlapd4rgr5","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6d5i01hkc2xly9x5b9tl"},{"post_id":"cix2l6d5d01hhc2xlapd4rgr5","tag_id":"cix2l6bsh000kc2xlm1grmv1m","_id":"cix2l6d5i01hlc2xldlzccz4m"},{"post_id":"cix2l6d5j01hmc2xllrirotgb","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d5n01hoc2xl373bkg2t"},{"post_id":"cix2l6d5j01hmc2xllrirotgb","tag_id":"cix2l6ced00sjc2xludjl9rln","_id":"cix2l6d5o01hpc2xlhadokp4j"},{"post_id":"cix2l6d5j01hmc2xllrirotgb","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6d5o01hqc2xlygrklkxb"},{"post_id":"cix2l6d5p01hrc2xl55zu2uwq","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d5u01huc2xlu1jle1yb"},{"post_id":"cix2l6d5p01hrc2xl55zu2uwq","tag_id":"cix2l6bu6002qc2xl8k4xwvuw","_id":"cix2l6d5w01hvc2xl4325fn9q"},{"post_id":"cix2l6d5p01hrc2xl55zu2uwq","tag_id":"cix2l6d5s01htc2xlx3mkghfh","_id":"cix2l6d5w01hwc2xl8rsgs979"},{"post_id":"cix2l6d5p01hrc2xl55zu2uwq","tag_id":"cix2l6brs0002c2xlkjhralkg","_id":"cix2l6d5w01hxc2xlt9zy7rmp"},{"post_id":"cix2l6d5x01hyc2xl1frzaouw","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d6101i0c2xl4w95nwmk"},{"post_id":"cix2l6d5x01hyc2xl1frzaouw","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6d6301i1c2xl7urkndnt"},{"post_id":"cix2l6d5x01hyc2xl1frzaouw","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6d6301i2c2xl3k37c40s"},{"post_id":"cix2l6d5x01hyc2xl1frzaouw","tag_id":"cix2l6bt20014c2xlf6zchc9m","_id":"cix2l6d6301i3c2xl257opkge"},{"post_id":"cix2l6d6401i4c2xlza4mf0wc","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d6701i6c2xltcj0704o"},{"post_id":"cix2l6d6401i4c2xlza4mf0wc","tag_id":"cix2l6cdk00roc2xl0mop3e11","_id":"cix2l6d6a01i7c2xlqq6qop78"},{"post_id":"cix2l6d6401i4c2xlza4mf0wc","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6d6a01i8c2xlkk2v2b88"},{"post_id":"cix2l6d6401i4c2xlza4mf0wc","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6d6a01i9c2xllihb2wd0"},{"post_id":"cix2l6d6401i4c2xlza4mf0wc","tag_id":"cix2l6bt20014c2xlf6zchc9m","_id":"cix2l6d6a01iac2xl08o6gzlx"},{"post_id":"cix2l6d6b01ibc2xlaiop41hs","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d6f01idc2xldvd1tf98"},{"post_id":"cix2l6d6b01ibc2xlaiop41hs","tag_id":"cix2l6cf300t4c2xlm4mno1ve","_id":"cix2l6d6h01iec2xleh0l0ss1"},{"post_id":"cix2l6d6b01ibc2xlaiop41hs","tag_id":"cix2l6cgf00u5c2xl3wledtm7","_id":"cix2l6d6i01ifc2xlywvr4xjt"},{"post_id":"cix2l6d6b01ibc2xlaiop41hs","tag_id":"cix2l6brs0002c2xlkjhralkg","_id":"cix2l6d6i01igc2xlnqk36tsz"},{"post_id":"cix2l6d6i01ihc2xlgy6da0el","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d6m01ijc2xlfrtjq115"},{"post_id":"cix2l6d6i01ihc2xlgy6da0el","tag_id":"cix2l6bry0004c2xlbo1rvuu2","_id":"cix2l6d6p01ikc2xl5ykol0qh"},{"post_id":"cix2l6d6i01ihc2xlgy6da0el","tag_id":"cix2l6bry0006c2xlm8gllv7h","_id":"cix2l6d6p01ilc2xlorqs916f"},{"post_id":"cix2l6d6i01ihc2xlgy6da0el","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6d6p01imc2xlnc9ltaqy"},{"post_id":"cix2l6d6i01ihc2xlgy6da0el","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6d6p01inc2xlonx7ctt0"},{"post_id":"cix2l6d6q01ioc2xlm4phfqr2","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d6u01iqc2xl1n935ww6"},{"post_id":"cix2l6d6q01ioc2xlm4phfqr2","tag_id":"cix2l6cy401b1c2xlirimv0hc","_id":"cix2l6d6y01irc2xl6nfjqlyi"},{"post_id":"cix2l6d6q01ioc2xlm4phfqr2","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6d6y01isc2xlyffeiesp"},{"post_id":"cix2l6d6q01ioc2xlm4phfqr2","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6d6y01itc2xls2kpxlu5"},{"post_id":"cix2l6d6z01iuc2xl49p5bf0a","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d7301iwc2xl55dix08v"},{"post_id":"cix2l6d6z01iuc2xl49p5bf0a","tag_id":"cix2l6btk001oc2xlac0t82w8","_id":"cix2l6d7501ixc2xl41j8dwpo"},{"post_id":"cix2l6d6z01iuc2xl49p5bf0a","tag_id":"cix2l6cy401b1c2xlirimv0hc","_id":"cix2l6d7501iyc2xlxou5innb"},{"post_id":"cix2l6d6z01iuc2xl49p5bf0a","tag_id":"cix2l6bub002yc2xlx0vn80a9","_id":"cix2l6d7501izc2xlxbub0seo"},{"post_id":"cix2l6d7601j0c2xlmzabz6k6","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d7a01j2c2xl6k4nw4ki"},{"post_id":"cix2l6d7601j0c2xlmzabz6k6","tag_id":"cix2l6cy401b1c2xlirimv0hc","_id":"cix2l6d7d01j3c2xlg9egc2qs"},{"post_id":"cix2l6d7601j0c2xlmzabz6k6","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6d7d01j4c2xluu1fh6c3"},{"post_id":"cix2l6d7601j0c2xlmzabz6k6","tag_id":"cix2l6bxo007jc2xlkcrgnf1u","_id":"cix2l6d7d01j5c2xlnizocra9"},{"post_id":"cix2l6d7601j0c2xlmzabz6k6","tag_id":"cix2l6bte001ic2xld1gajghb","_id":"cix2l6d7d01j6c2xlxy2o8ee9"},{"post_id":"cix2l6d7e01j7c2xlgu6jo6vq","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d7i01j9c2xlr0k8h18i"},{"post_id":"cix2l6d7e01j7c2xlgu6jo6vq","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6d7k01jac2xlumft7n59"},{"post_id":"cix2l6d7e01j7c2xlgu6jo6vq","tag_id":"cix2l6btq0020c2xlllnmvl4u","_id":"cix2l6d7k01jbc2xlvuncde9d"},{"post_id":"cix2l6d7e01j7c2xlgu6jo6vq","tag_id":"cix2l6btq001zc2xl1xyp27mz","_id":"cix2l6d7k01jcc2xlr1wy916s"},{"post_id":"cix2l6d7l01jdc2xl017bwp1z","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d7p01jfc2xl1m6q768n"},{"post_id":"cix2l6d7l01jdc2xl017bwp1z","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6d7s01jgc2xl1vmug21b"},{"post_id":"cix2l6d7l01jdc2xl017bwp1z","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6d7s01jhc2xlxtwhby3d"},{"post_id":"cix2l6d7l01jdc2xl017bwp1z","tag_id":"cix2l6bt20014c2xlf6zchc9m","_id":"cix2l6d7s01jic2xle847g7j4"},{"post_id":"cix2l6d7l01jdc2xl017bwp1z","tag_id":"cix2l6cy401b1c2xlirimv0hc","_id":"cix2l6d7s01jjc2xlbftm1zgk"},{"post_id":"cix2l6d7t01jkc2xlucsd71jl","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d7x01jmc2xl8y7yyx81"},{"post_id":"cix2l6d7t01jkc2xlucsd71jl","tag_id":"cix2l6bwv005uc2xlcab5p7ag","_id":"cix2l6d7z01jnc2xlsfny9fmr"},{"post_id":"cix2l6d7t01jkc2xlucsd71jl","tag_id":"cix2l6c1p00d7c2xlkwengzke","_id":"cix2l6d7z01joc2xlwoiwpd45"},{"post_id":"cix2l6d7t01jkc2xlucsd71jl","tag_id":"cix2l6bwa004pc2xlfep7re8c","_id":"cix2l6d7z01jpc2xl7anpw794"},{"post_id":"cix2l6d8001jqc2xleot5r6xn","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d8301jsc2xlm2ok77wy"},{"post_id":"cix2l6d8001jqc2xleot5r6xn","tag_id":"cix2l6ced00sjc2xludjl9rln","_id":"cix2l6d8501jtc2xlqq8xjz4n"},{"post_id":"cix2l6d8001jqc2xleot5r6xn","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6d8501juc2xl3n7yyjnj"},{"post_id":"cix2l6d8601jvc2xlflpbj4e2","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d8901jxc2xlpeosm1xr"},{"post_id":"cix2l6d8601jvc2xlflpbj4e2","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6d8b01jyc2xlmi9j713d"},{"post_id":"cix2l6d8601jvc2xlflpbj4e2","tag_id":"cix2l6bwe0051c2xllpdw4hf2","_id":"cix2l6d8b01jzc2xl7qpoindw"},{"post_id":"cix2l6d8c01k0c2xltbszxjbq","tag_id":"cix2l6bx9006jc2xl21zjnyx6","_id":"cix2l6d8h01k2c2xliud09o9v"},{"post_id":"cix2l6d8c01k0c2xltbszxjbq","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d8k01k3c2xljxbtnm38"},{"post_id":"cix2l6d8c01k0c2xltbszxjbq","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix2l6d8k01k4c2xlnojx19t6"},{"post_id":"cix2l6d8c01k0c2xltbszxjbq","tag_id":"cix2l6bry0006c2xlm8gllv7h","_id":"cix2l6d8k01k5c2xla7i187ga"},{"post_id":"cix2l6d8k01k6c2xl8tee8a63","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d8o01k8c2xlfm2gpd7f"},{"post_id":"cix2l6d8k01k6c2xl8tee8a63","tag_id":"cix2l6bzl009wc2xlvxagmmjn","_id":"cix2l6d8r01k9c2xl5j4ec26p"},{"post_id":"cix2l6d8k01k6c2xl8tee8a63","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6d8s01kac2xlkcmbp1of"},{"post_id":"cix2l6d8k01k6c2xl8tee8a63","tag_id":"cix2l6bx9006kc2xl8ligd8yv","_id":"cix2l6d8s01kbc2xle40fo1fz"},{"post_id":"cix2l6d8k01k6c2xl8tee8a63","tag_id":"cix2l6bzl009xc2xleyxetgjg","_id":"cix2l6d8s01kcc2xlc1kged0q"},{"post_id":"cix2l6d8s01kdc2xlau85znt7","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d8w01kfc2xlofpwz76r"},{"post_id":"cix2l6d8s01kdc2xlau85znt7","tag_id":"cix2l6cjw00x2c2xl4bxhlmuf","_id":"cix2l6d8z01kgc2xl77bvr9x7"},{"post_id":"cix2l6d8s01kdc2xlau85znt7","tag_id":"cix2l6bvd003nc2xlzttr1jkp","_id":"cix2l6d8z01khc2xl3xa6kjqg"},{"post_id":"cix2l6d8s01kdc2xlau85znt7","tag_id":"cix2l6c1100cec2xln5pdkz26","_id":"cix2l6d8z01kic2xlu2689i8a"},{"post_id":"cix2l6d8z01kjc2xl73w1n3zy","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d9301klc2xla5g8xj6e"},{"post_id":"cix2l6d8z01kjc2xl73w1n3zy","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6d9601kmc2xl0hptht61"},{"post_id":"cix2l6d8z01kjc2xl73w1n3zy","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6d9601knc2xlwbvuxid5"},{"post_id":"cix2l6d8z01kjc2xl73w1n3zy","tag_id":"cix2l6bt20014c2xlf6zchc9m","_id":"cix2l6d9601koc2xlei18vwbw"},{"post_id":"cix2l6d9601kpc2xlbqcd2x9f","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6d9b01ksc2xljkvzq81f"},{"post_id":"cix2l6d9601kpc2xlbqcd2x9f","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6d9e01ktc2xlx2kbykp4"},{"post_id":"cix2l6d9601kpc2xlbqcd2x9f","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6d9f01kuc2xlim1su8w3"},{"post_id":"cix2l6d9601kpc2xlbqcd2x9f","tag_id":"cix2l6d9901krc2xlwgakumya","_id":"cix2l6d9f01kvc2xl4fyp8v0z"},{"post_id":"cix2l6d9601kpc2xlbqcd2x9f","tag_id":"cix2l6c1q00d8c2xlptdx3gp2","_id":"cix2l6d9f01kwc2xl59p4foja"},{"post_id":"cix2l6d9f01kxc2xls2kespyk","tag_id":"cix2l6bw0004ac2xl40e50m9d","_id":"cix2l6d9j01kzc2xl7d3be5wy"},{"post_id":"cix2l6d9f01kxc2xls2kespyk","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6d9k01l0c2xlypkg24lp"},{"post_id":"cix2l6d9s01l3c2xlqxqopyqq","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6d9y01l6c2xlu62rlqnr"},{"post_id":"cix2l6d9s01l3c2xlqxqopyqq","tag_id":"cix2l6d9w01l5c2xl57rbpy6v","_id":"cix2l6da101l7c2xlco7ygbl6"},{"post_id":"cix2l6d9s01l3c2xlqxqopyqq","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6da201l8c2xlvk1mm4wu"},{"post_id":"cix2l6d9s01l3c2xlqxqopyqq","tag_id":"cix2l6btq0020c2xlllnmvl4u","_id":"cix2l6da201l9c2xl72xkjdun"},{"post_id":"cix2l6d9s01l3c2xlqxqopyqq","tag_id":"cix2l6btq001zc2xl1xyp27mz","_id":"cix2l6da201lac2xlais5xdz2"},{"post_id":"cix2l6da201lbc2xlo3xjecw6","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6daa01lgc2xlylqzbwbv"},{"post_id":"cix2l6da201lbc2xlo3xjecw6","tag_id":"cix2l6d9w01l5c2xl57rbpy6v","_id":"cix2l6dah01lhc2xlubxj5u7x"},{"post_id":"cix2l6da201lbc2xlo3xjecw6","tag_id":"cix2l6bxe006uc2xlqk5geg3s","_id":"cix2l6dah01lic2xlhlc6bjvy"},{"post_id":"cix2l6da201lbc2xlo3xjecw6","tag_id":"cix2l6btx002ac2xls5nn914i","_id":"cix2l6dah01ljc2xlrkj1yv1b"},{"post_id":"cix2l6da201lbc2xlo3xjecw6","tag_id":"cix2l6btx002bc2xlii39i8qq","_id":"cix2l6dah01lkc2xlwzd3molj"},{"post_id":"cix2l6da201lbc2xlo3xjecw6","tag_id":"cix2l6da601ldc2xl7alau4ot","_id":"cix2l6dah01llc2xlc4qtlugi"},{"post_id":"cix2l6da201lbc2xlo3xjecw6","tag_id":"cix2l6da701lec2xlorc96gmk","_id":"cix2l6dah01lmc2xlyv2ardqi"},{"post_id":"cix2l6da201lbc2xlo3xjecw6","tag_id":"cix2l6da901lfc2xlna69p8dk","_id":"cix2l6dah01lnc2xlaftv5fpq"},{"post_id":"cix2l6dai01loc2xlnrj4he67","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6dao01lrc2xl28xw2zk4"},{"post_id":"cix2l6dai01loc2xlnrj4he67","tag_id":"cix2l6dal01lqc2xllxky811x","_id":"cix2l6dar01lsc2xlr0tlx1rb"},{"post_id":"cix2l6dai01loc2xlnrj4he67","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6dar01ltc2xlbf1ymzgg"},{"post_id":"cix2l6dai01loc2xlnrj4he67","tag_id":"cix2l6bsr000uc2xlhetrx95o","_id":"cix2l6dar01luc2xl2gvi7agn"},{"post_id":"cix2l6dai01loc2xlnrj4he67","tag_id":"cix2l6cbb00pvc2xlcxypt001","_id":"cix2l6dar01lvc2xljsli2no7"},{"post_id":"cix2l6dai01loc2xlnrj4he67","tag_id":"cix2l6bst000vc2xl1kukczvd","_id":"cix2l6dar01lwc2xlgipa3ymz"},{"post_id":"cix2l6das01lxc2xlc6w1mh62","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6dax01m0c2xl5m2m8i9e"},{"post_id":"cix2l6das01lxc2xlc6w1mh62","tag_id":"cix2l6dal01lqc2xllxky811x","_id":"cix2l6db101m1c2xluilrhaet"},{"post_id":"cix2l6das01lxc2xlc6w1mh62","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6db101m2c2xl8yesvatd"},{"post_id":"cix2l6das01lxc2xlc6w1mh62","tag_id":"cix2l6bxo007jc2xlkcrgnf1u","_id":"cix2l6db101m3c2xlys30twba"},{"post_id":"cix2l6das01lxc2xlc6w1mh62","tag_id":"cix2l6dav01lzc2xlx123gjz0","_id":"cix2l6db101m4c2xl0if353a3"},{"post_id":"cix2l6db101m5c2xl8o2hxcgz","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix2l6db601m7c2xloxnciv6y"},{"post_id":"cix2l6db101m5c2xl8o2hxcgz","tag_id":"cix2l6dal01lqc2xllxky811x","_id":"cix2l6db901m8c2xllia179d7"},{"post_id":"cix2l6db101m5c2xl8o2hxcgz","tag_id":"cix2l6c0l00brc2xlrz9vwge8","_id":"cix2l6db901m9c2xlwx59pr46"},{"post_id":"cix2l6db101m5c2xl8o2hxcgz","tag_id":"cix2l6c2h00ekc2xlifaivm0i","_id":"cix2l6db901mac2xly3uks4jl"},{"post_id":"cix2l6db101m5c2xl8o2hxcgz","tag_id":"cix2l6c3300fjc2xllz8yew7g","_id":"cix2l6db901mbc2xlmn3z6md9"},{"post_id":"cix2l6dba01mcc2xly70b6g77","tag_id":"cix2l6bx3006bc2xlhxm1aa0p","_id":"cix2l6dbe01mec2xluugx53p0"},{"post_id":"cix2l6dba01mcc2xly70b6g77","tag_id":"cix2l6bx2006ac2xlwgy8xsi3","_id":"cix2l6dbg01mfc2xl3dfw02fj"},{"post_id":"cix2l6dba01mcc2xly70b6g77","tag_id":"cix2l6bxd006sc2xl6lc5b6ny","_id":"cix2l6dbg01mgc2xlv0ht5xti"},{"post_id":"cix2l6dba01mcc2xly70b6g77","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix2l6dbg01mhc2xldicwqfrb"},{"post_id":"cix2l6dbl01mic2xl2lxtrjh7","tag_id":"cix2l6dbo01mkc2xliusk5723","_id":"cix2l6dbr01mmc2xlf73qxtty"},{"post_id":"cix2l6dbl01mic2xl2lxtrjh7","tag_id":"cix2l6cgf00u5c2xl3wledtm7","_id":"cix2l6dbu01mnc2xl46vudxq6"},{"post_id":"cix2l6dbl01mic2xl2lxtrjh7","tag_id":"cix2l6dbp01mlc2xlckdjobj0","_id":"cix2l6dbu01moc2xl9x4q6ebv"},{"post_id":"cix2l6dbl01mic2xl2lxtrjh7","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix2l6dbu01mpc2xlecnp3hr1"},{"post_id":"cix2l6dbu01mqc2xludpdiukd","tag_id":"cix2l6brs0002c2xlkjhralkg","_id":"cix2l6dc001mtc2xlsnsn6d0f"},{"post_id":"cix2l6dbu01mqc2xludpdiukd","tag_id":"cix2l6c2z00fbc2xl6mvehv6g","_id":"cix2l6dc401muc2xliw9zyku6"},{"post_id":"cix2l6dbu01mqc2xludpdiukd","tag_id":"cix2l6dby01msc2xl3lddum0p","_id":"cix2l6dc401mvc2xlly64srr3"},{"post_id":"cix2l6dbu01mqc2xludpdiukd","tag_id":"cix2l6bsp000sc2xl8viyjdh1","_id":"cix2l6dc401mwc2xl0vku69hv"},{"post_id":"cix2l6dbu01mqc2xludpdiukd","tag_id":"cix2l6bsq000tc2xl5tyr29cc","_id":"cix2l6dc401mxc2xlqcl3plv7"},{"post_id":"cix2l6dbu01mqc2xludpdiukd","tag_id":"cix2l6cdk00roc2xl0mop3e11","_id":"cix2l6dc401myc2xlizvhyr2y"},{"post_id":"cix2l6dc501mzc2xl7egw8gbw","tag_id":"cix2l6brs0002c2xlkjhralkg","_id":"cix2l6dcb01n2c2xlk2fxibyy"},{"post_id":"cix2l6dc501mzc2xl7egw8gbw","tag_id":"cix2l6bt9001cc2xle8b2zj6q","_id":"cix2l6dcd01n3c2xlobs58cdq"},{"post_id":"cix2l6dc501mzc2xl7egw8gbw","tag_id":"cix2l6dc801n1c2xlrae0qsw0","_id":"cix2l6dcd01n4c2xltjy43jbg"},{"post_id":"cix2l6dce01n5c2xlby8s0qzs","tag_id":"cix2l6brs0002c2xlkjhralkg","_id":"cix2l6dci01n7c2xliz3534mp"},{"post_id":"cix2l6dce01n5c2xlby8s0qzs","tag_id":"cix2l6bub002yc2xlx0vn80a9","_id":"cix2l6dcl01n8c2xlqk6cno66"},{"post_id":"cix2l6dce01n5c2xlby8s0qzs","tag_id":"cix2l6c1100cec2xln5pdkz26","_id":"cix2l6dcl01n9c2xlsryczn99"},{"post_id":"cix2l6dce01n5c2xlby8s0qzs","tag_id":"cix2l6bsh000lc2xlthfbg1y5","_id":"cix2l6dcl01nac2xl58mjktsx"},{"post_id":"cix2l6dcm01nbc2xlmry79v3w","tag_id":"cix2l6brs0002c2xlkjhralkg","_id":"cix2l6dcs01nec2xlonckrhw5"},{"post_id":"cix2l6dcm01nbc2xlmry79v3w","tag_id":"cix2l6dcp01ndc2xlmq888fkr","_id":"cix2l6dcw01nfc2xl2pbfg2rn"},{"post_id":"cix2l6dcm01nbc2xlmry79v3w","tag_id":"cix2l6d0p01ddc2xlzout3pn1","_id":"cix2l6dcw01ngc2xl0pbfyvqz"},{"post_id":"cix2l6dcm01nbc2xlmry79v3w","tag_id":"cix2l6bx9006kc2xl8ligd8yv","_id":"cix2l6dcw01nhc2xlmeeyi69i"},{"post_id":"cix2l6dcm01nbc2xlmry79v3w","tag_id":"cix2l6cat00pbc2xlrgesoa0t","_id":"cix2l6dcw01nic2xlh7udihve"},{"post_id":"cix8bsb1s0000wcxlej6q489r","tag_id":"cix2l6bsg000ic2xll3edrt0o","_id":"cix8bsb220002wcxl05zg1zv7"},{"post_id":"cix8bsb1s0000wcxlej6q489r","tag_id":"cix2l6bwu005tc2xlqglflnzf","_id":"cix8bsb260003wcxl2l5n287x"},{"post_id":"cix8bsb1s0000wcxlej6q489r","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cix8bsb270004wcxlw1nv0jpv"},{"post_id":"cix8bsb1s0000wcxlej6q489r","tag_id":"cix2l6brx0003c2xl4mq6xsp7","_id":"cix8bsb270005wcxlrvdfy64f"},{"post_id":"cix8bsb1s0000wcxlej6q489r","tag_id":"cix2l6bry0006c2xlm8gllv7h","_id":"cix8bsb270006wcxlxgqoqefy"},{"post_id":"cix8bsb1s0000wcxlej6q489r","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cix8bsb280007wcxlp43ch0ht"},{"post_id":"cixb433bv0000vsxl40ulnzgy","tag_id":"cix2l6c0h00bic2xlug85j0rs","_id":"cixb433c60002vsxlklpbr8vr"},{"post_id":"cixb433bv0000vsxl40ulnzgy","tag_id":"cix2l6bry0005c2xl9gbe56jn","_id":"cixb433ca0003vsxlv46ywg56"},{"post_id":"cixb433bv0000vsxl40ulnzgy","tag_id":"cix2l6bxe006vc2xlvoy75opn","_id":"cixb433ca0004vsxloazuepvz"}],"Tag":[{"name":"","_id":"cix2l6brs0002c2xlkjhralkg"},{"name":"","_id":"cix2l6brx0003c2xl4mq6xsp7"},{"name":"","_id":"cix2l6bry0004c2xlbo1rvuu2"},{"name":"","_id":"cix2l6bry0005c2xl9gbe56jn"},{"name":"","_id":"cix2l6bry0006c2xlm8gllv7h"},{"name":"BZOJ","_id":"cix2l6bsg000ic2xll3edrt0o"},{"name":"ZJOI","_id":"cix2l6bsh000jc2xl80byapp7"},{"name":"FFT","_id":"cix2l6bsh000kc2xlm1grmv1m"},{"name":"","_id":"cix2l6bsh000lc2xlthfbg1y5"},{"name":"","_id":"cix2l6bsp000sc2xl8viyjdh1"},{"name":"Dinic","_id":"cix2l6bsq000tc2xl5tyr29cc"},{"name":"","_id":"cix2l6bsr000uc2xlhetrx95o"},{"name":"Edmonds-Karp","_id":"cix2l6bst000vc2xl1kukczvd"},{"name":"","_id":"cix2l6bt20014c2xlf6zchc9m"},{"name":"DP","_id":"cix2l6bt9001cc2xle8b2zj6q"},{"name":"","_id":"cix2l6bte001ic2xld1gajghb"},{"name":"COGS","_id":"cix2l6btk001oc2xlac0t82w8"},{"name":"","_id":"cix2l6btk001pc2xlq2nvh5we"},{"name":"","_id":"cix2l6btl001qc2xlzz6m02ox"},{"name":"","_id":"cix2l6btq001zc2xl1xyp27mz"},{"name":"","_id":"cix2l6btq0020c2xlllnmvl4u"},{"name":"","_id":"cix2l6btw0029c2xlus1ynht7"},{"name":"Tarjan","_id":"cix2l6btx002ac2xls5nn914i"},{"name":"","_id":"cix2l6btx002bc2xlii39i8qq"},{"name":"","_id":"cix2l6bu1002kc2xlpyrkma70"},{"name":"","_id":"cix2l6bu6002qc2xl8k4xwvuw"},{"name":"","_id":"cix2l6bub002yc2xlx0vn80a9"},{"name":"OS X","_id":"cix2l6buf0036c2xl9e1mzymh"},{"name":"Linux","_id":"cix2l6bug0037c2xlpfgfsh0i"},{"name":"Archlinux","_id":"cix2l6bug0038c2xlqtc61ja0"},{"name":"VirtualBox","_id":"cix2l6bug0039c2xlmf6x273a"},{"name":"","_id":"cix2l6bug003ac2xlqigs1bh1"},{"name":"SSH","_id":"cix2l6buh003bc2xlaft5jc5z"},{"name":"UVa","_id":"cix2l6bvc003lc2xlj5v9rb9j"},{"name":" DP","_id":"cix2l6bvc003mc2xlzsn1jrh3"},{"name":"","_id":"cix2l6bvd003nc2xlzttr1jkp"},{"name":"","_id":"cix2l6bvh003vc2xlhv94n7t9"},{"name":"","_id":"cix2l6bvi003wc2xl9jvtord9"},{"name":"","_id":"cix2l6bvz0049c2xle6e8llpz"},{"name":"","_id":"cix2l6bw0004ac2xl40e50m9d"},{"name":" DP","_id":"cix2l6bw5004hc2xliqrfp4kr"},{"name":"","_id":"cix2l6bwa004pc2xlfep7re8c"},{"name":"","_id":"cix2l6bwa004qc2xlqnw3w3ri"},{"name":"","_id":"cix2l6bwb004rc2xl2ocoadp0"},{"name":" DP","_id":"cix2l6bwe0051c2xllpdw4hf2"},{"name":"","_id":"cix2l6bwj0059c2xlp2z4w5xl"},{"name":"","_id":"cix2l6bwn005hc2xl3hpoko78"},{"name":"","_id":"cix2l6bwo005ic2xl8p6ir184"},{"name":"","_id":"cix2l6bwo005jc2xlf9qo92q5"},{"name":"CodeVS","_id":"cix2l6bwu005tc2xlqglflnzf"},{"name":"Tyvj","_id":"cix2l6bwv005uc2xlcab5p7ag"},{"name":" DP","_id":"cix2l6bwv005vc2xl62lmb5wk"},{"name":"TJOI","_id":"cix2l6bwy0062c2xlihgiezyj"},{"name":" DP","_id":"cix2l6bwz0063c2xlh8ly3fo3"},{"name":"","_id":"cix2l6bx2006ac2xlwgy8xsi3"},{"name":"AC ","_id":"cix2l6bx3006bc2xlhxm1aa0p"},{"name":"","_id":"cix2l6bx8006ic2xlanfcs0th"},{"name":"Splay","_id":"cix2l6bx9006jc2xl21zjnyx6"},{"name":"","_id":"cix2l6bx9006kc2xl8ligd8yv"},{"name":"","_id":"cix2l6bxd006sc2xl6lc5b6ny"},{"name":"","_id":"cix2l6bxd006tc2xlwt0cqgkb"},{"name":"","_id":"cix2l6bxe006uc2xlqk5geg3s"},{"name":"","_id":"cix2l6bxe006vc2xlvoy75opn"},{"name":"","_id":"cix2l6bxh0073c2xlzrgyofi2"},{"name":"","_id":"cix2l6bxl007bc2xlnhqu19fi"},{"name":"","_id":"cix2l6bxo007jc2xlkcrgnf1u"},{"name":"","_id":"cix2l6bxp007kc2xl8rge6ieh"},{"name":"C++","_id":"cix2l6bxt007sc2xlghh13692"},{"name":"STL","_id":"cix2l6bxt007tc2xlta9yvqhe"},{"name":"SPOJ","_id":"cix2l6bxz007yc2xloq7888ej"},{"name":"SHOI","_id":"cix2l6byy008uc2xlhu86f9mq"},{"name":"","_id":"cix2l6bz10090c2xlbwvetl3j"},{"name":"","_id":"cix2l6bzc009hc2xlus0k8tgu"},{"name":"CDQ","_id":"cix2l6bzl009wc2xlvxagmmjn"},{"name":"","_id":"cix2l6bzl009xc2xleyxetgjg"},{"name":"SDOI","_id":"cix2l6bzp00a6c2xlunj1vv5y"},{"name":"","_id":"cix2l6bzq00a7c2xl0plzunvi"},{"name":"","_id":"cix2l6bzr00a8c2xl9tmid8wv"},{"name":"","_id":"cix2l6bzr00a9c2xluebmxms0"},{"name":"","_id":"cix2l6c0000alc2xl6bt8foyz"},{"name":"","_id":"cix2l6c0500avc2xlnjpnaec3"},{"name":"","_id":"cix2l6c0600awc2xlaldzn55u"},{"name":"","_id":"cix2l6c0700axc2xlgxp3vaf5"},{"name":"RMQ","_id":"cix2l6c0h00bic2xlug85j0rs"},{"name":"","_id":"cix2l6c0l00brc2xlrz9vwge8"},{"name":"","_id":"cix2l6c0v00c2c2xl8pxn33ts"},{"name":"NTT","_id":"cix2l6c1000ccc2xl32nvuu2i"},{"name":"","_id":"cix2l6c1100cdc2xlzs83aivv"},{"name":"","_id":"cix2l6c1100cec2xln5pdkz26"},{"name":"","_id":"cix2l6c1100cfc2xlukvyrt3z"},{"name":"","_id":"cix2l6c1k00cwc2xltzt3umv8"},{"name":"","_id":"cix2l6c1l00cxc2xljmq6rska"},{"name":"","_id":"cix2l6c1l00cyc2xly6uvavyj"},{"name":"EXGCD","_id":"cix2l6c1p00d7c2xlkwengzke"},{"name":"BSGS","_id":"cix2l6c1q00d8c2xlptdx3gp2"},{"name":"","_id":"cix2l6c2b00e7c2xlodn8a4nq"},{"name":"Link-Cut Tree","_id":"cix2l6c2c00e8c2xl7n4dn713"},{"name":"SCOI","_id":"cix2l6c2g00eic2xl83nrf9in"},{"name":"set","_id":"cix2l6c2h00ejc2xltczoe27q"},{"name":"","_id":"cix2l6c2h00ekc2xlifaivm0i"},{"name":"","_id":"cix2l6c2t00f1c2xlpcqtvvg8"},{"name":" DP","_id":"cix2l6c2z00fbc2xl6mvehv6g"},{"name":"","_id":"cix2l6c3300fjc2xllz8yew7g"},{"name":"","_id":"cix2l6c3e00fxc2xlm2nhl5xr"},{"name":"","_id":"cix2l6c3k00g7c2xluaqlxpmp"},{"name":"","_id":"cix2l6c3k00g8c2xlsdw5jbor"},{"name":"","_id":"cix2l6c3v00gtc2xl3nyi6ovi"},{"name":"","_id":"cix2l6c4000h2c2xl0ymvmkpr"},{"name":"DFS","_id":"cix2l6c4100h3c2xlojzbrv1p"},{"name":"POJ","_id":"cix2l6c4j00hvc2xlt9thv2lh"},{"name":"KMP","_id":"cix2l6c4k00hwc2xlg2jpx39j"},{"name":"Prim","_id":"cix2l6c4p00i3c2xlxkmyp1eu"},{"name":"","_id":"cix2l6c4q00i4c2xlchz98yon"},{"name":"","_id":"cix2l6c4r00i5c2xl2e2bf7pp"},{"name":"POI","_id":"cix2l6c5000imc2xltidgbutl"},{"name":"NOIP","_id":"cix2l6c6j00jvc2xld8v1mwdo"},{"name":"","_id":"cix2l6c6n00k0c2xlbnfyz1hv"},{"name":"","_id":"cix2l6c6z00kcc2xljwdacnnm"},{"name":"Floyd","_id":"cix2l6c7600khc2xllu0wv0rd"},{"name":"","_id":"cix2l6c7a00koc2xls3c7nuq6"},{"name":"BFS","_id":"cix2l6c7b00kpc2xll5wlx8bz"},{"name":"Hash","_id":"cix2l6c7q00ldc2xlltyylx9y"},{"name":"SPFA","_id":"cix2l6c8000lsc2xl1rukwqob"},{"name":"","_id":"cix2l6c8500m1c2xlrq6onoip"},{"name":"","_id":"cix2l6c8n00mqc2xlphdzc6hg"},{"name":"","_id":"cix2l6c8n00mrc2xlz3wjn4mj"},{"name":"Vijos","_id":"cix2l6c8x00n7c2xlapjxljjh"},{"name":"","_id":"cix2l6c8y00n8c2xljlhqh411"},{"name":"","_id":"cix2l6c8y00n9c2xlm421go5n"},{"name":" DP","_id":"cix2l6c9700njc2xlqaed2y8c"},{"name":"NOI","_id":"cix2l6ca200olc2xl0hipr5lo"},{"name":"","_id":"cix2l6cat00pbc2xlrgesoa0t"},{"name":"","_id":"cix2l6caw00pcc2xlv0e4fef1"},{"name":"map","_id":"cix2l6cax00pdc2xlcci3d4bu"},{"name":"","_id":"cix2l6cbb00pvc2xlcxypt001"},{"name":"","_id":"cix2l6cbi00q4c2xln0k6n9xo"},{"name":"","_id":"cix2l6cbj00q5c2xl1du7z26p"},{"name":"LCT","_id":"cix2l6cc500qwc2xlckxpvh8b"},{"name":"","_id":"cix2l6ccm00rfc2xlj9no12qt"},{"name":"","_id":"cix2l6cco00rgc2xlkarmc1gx"},{"name":"","_id":"cix2l6cdk00roc2xl0mop3e11"},{"name":"","_id":"cix2l6ced00sjc2xludjl9rln"},{"name":"","_id":"cix2l6cf300t4c2xlm4mno1ve"},{"name":"Kruskal","_id":"cix2l6cfb00tac2xlhx2talym"},{"name":"","_id":"cix2l6cfd00tbc2xliu07hzyl"},{"name":"JSOI","_id":"cix2l6cgc00u4c2xls6kc7fm1"},{"name":"","_id":"cix2l6cgf00u5c2xl3wledtm7"},{"name":"","_id":"cix2l6cgv00ujc2xlr86rk7qt"},{"name":"","_id":"cix2l6ch500utc2xlr3bp525f"},{"name":"","_id":"cix2l6cim00w3c2xl564hvwhm"},{"name":"IOI","_id":"cix2l6cjc00wnc2xl02ddxhyj"},{"name":"","_id":"cix2l6cjm00wuc2xl1zipz2jh"},{"name":"HNOI","_id":"cix2l6cjw00x2c2xl4bxhlmuf"},{"name":"DFS ","_id":"cix2l6ckh00xhc2xls3xatgc5"},{"name":"Prfer ","_id":"cix2l6clm00yac2xli8haq2fp"},{"name":"","_id":"cix2l6cmb00yrc2xlayel59p2"},{"name":"","_id":"cix2l6cmd00ysc2xl95xjgm34"},{"name":"Burnside ","_id":"cix2l6cmy00z8c2xlmjs0f8du"},{"name":"Trie","_id":"cix2l6cna00znc2xlbe2v7kt6"},{"name":"HEOI","_id":"cix2l6cng00zuc2xlo4lvp1qd"},{"name":"HDU","_id":"cix2l6cnm0101c2xlw1asdo5m"},{"name":"Bestcoder","_id":"cix2l6cnn0102c2xlm3qrvcmj"},{"name":"BestCoder","_id":"cix2l6cnu010cc2xlq7tmwtf1"},{"name":"HAOI","_id":"cix2l6co9010tc2xljfmesvht"},{"name":"","_id":"cix2l6con0118c2xlp3um23qw"},{"name":"GDB","_id":"cix2l6cr5013vc2xlx4c8h7q8"},{"name":"","_id":"cix2l6cr6013wc2xlhj5p97sd"},{"name":"FJOI","_id":"cix2l6crb0142c2xlekgfcoo1"},{"name":"","_id":"cix2l6cri0148c2xl8dewe3uk"},{"name":"Docker","_id":"cix2l6cs90153c2xlm3390uc6"},{"name":"","_id":"cix2l6csa0154c2xlrkw7c4z0"},{"name":"CTSC","_id":"cix2l6ct2015tc2xlldttpyg8"},{"name":" 24 ","_id":"cix2l6ct3015uc2xlt50zcpkw"},{"name":"CQOI","_id":"cix2l6ctn016cc2xldpemx1d5"},{"name":"","_id":"cix2l6cud0174c2xlqr5wpjmy"},{"name":"","_id":"cix2l6cwn019kc2xlj3h9uckl"},{"name":"USACO","_id":"cix2l6cy401b1c2xlirimv0hc"},{"name":"COCI","_id":"cix2l6cyi01bfc2xliv6zf2wj"},{"name":"","_id":"cix2l6cyk01bgc2xlhq5xgs57"},{"name":"Codeforces","_id":"cix2l6cz001bvc2xl21k8w1hf"},{"name":"CEOI","_id":"cix2l6czo01cfc2xlf85ymlwp"},{"name":"Lucas ","_id":"cix2l6czw01cnc2xlbi3gkkqt"},{"name":"","_id":"cix2l6d0p01ddc2xlzout3pn1"},{"name":"","_id":"cix2l6d0q01dec2xlzd4vc6dr"},{"name":"","_id":"cix2l6d3101flc2xly6zvvnbj"},{"name":"Dijkstra","_id":"cix2l6d5s01htc2xlx3mkghfh"},{"name":"","_id":"cix2l6d9901krc2xlwgakumya"},{"name":"APIO","_id":"cix2l6d9w01l5c2xl57rbpy6v"},{"name":"DAG","_id":"cix2l6da601ldc2xl7alau4ot"},{"name":"","_id":"cix2l6da701lec2xlorc96gmk"},{"name":"Bellman-Ford","_id":"cix2l6da901lfc2xlna69p8dk"},{"name":"AHOI","_id":"cix2l6dal01lqc2xllxky811x"},{"name":"","_id":"cix2l6dav01lzc2xlx123gjz0"},{"name":"","_id":"cix2l6dbo01mkc2xliusk5723"},{"name":"","_id":"cix2l6dbp01mlc2xlckdjobj0"},{"name":"","_id":"cix2l6dby01msc2xl3lddum0p"},{"name":"","_id":"cix2l6dc801n1c2xlrae0qsw0"},{"name":"","_id":"cix2l6dcp01ndc2xlmq888fkr"}]}}